{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/Lover/white/0@1x.png","path":"Lover/white/0@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/0@2x.png","path":"Lover/white/0@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/10@1x.png","path":"Lover/white/10@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/10@2x.png","path":"Lover/white/10@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/11@1x.png","path":"Lover/white/11@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/12@1x.png","path":"Lover/white/12@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/11@2x.png","path":"Lover/white/11@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/14@1x.png","path":"Lover/white/14@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/12@2x.png","path":"Lover/white/12@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/14@2x.png","path":"Lover/white/14@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/15@1x.png","path":"Lover/white/15@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/15@2x.png","path":"Lover/white/15@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/16@1x.png","path":"Lover/white/16@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/16@2x.png","path":"Lover/white/16@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/17@1x.png","path":"Lover/white/17@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/17@2x.png","path":"Lover/white/17@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/18@1x.png","path":"Lover/white/18@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/18@2x.png","path":"Lover/white/18@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/19@1x.png","path":"Lover/white/19@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/19@2x.png","path":"Lover/white/19@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/1@1x.png","path":"Lover/white/1@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/13@2x.png","path":"Lover/white/13@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/13@1x.png","path":"Lover/white/13@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/1@2x.png","path":"Lover/white/1@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/20@1x.png","path":"Lover/white/20@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/20@2x.png","path":"Lover/white/20@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/21@1x.png","path":"Lover/white/21@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/21@2x.png","path":"Lover/white/21@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/22@1x.png","path":"Lover/white/22@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/22@2x.png","path":"Lover/white/22@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/23@1x.png","path":"Lover/white/23@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/23@2x.png","path":"Lover/white/23@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/24@1x.png","path":"Lover/white/24@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/24@2x.png","path":"Lover/white/24@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/25@1x.png","path":"Lover/white/25@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/26@1x.png","path":"Lover/white/26@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/25@2x.png","path":"Lover/white/25@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/26@2x.png","path":"Lover/white/26@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/27@1x.png","path":"Lover/white/27@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/27@2x.png","path":"Lover/white/27@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/28@1x.png","path":"Lover/white/28@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/28@2x.png","path":"Lover/white/28@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/29@1x.png","path":"Lover/white/29@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/29@2x.png","path":"Lover/white/29@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/2@1x.png","path":"Lover/white/2@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/2@2x.png","path":"Lover/white/2@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/30@1x.png","path":"Lover/white/30@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/30@2x.png","path":"Lover/white/30@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/31@1x.png","path":"Lover/white/31@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/31@2x.png","path":"Lover/white/31@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/32@1x.png","path":"Lover/white/32@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/32@2x.png","path":"Lover/white/32@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/33@1x.png","path":"Lover/white/33@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/33@2x.png","path":"Lover/white/33@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/34@1x.png","path":"Lover/white/34@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/34@2x.png","path":"Lover/white/34@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/35@2x.png","path":"Lover/white/35@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/35@1x.png","path":"Lover/white/35@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/36@1x.png","path":"Lover/white/36@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/36@2x.png","path":"Lover/white/36@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/37@1x.png","path":"Lover/white/37@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/37@2x.png","path":"Lover/white/37@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/38@2x.png","path":"Lover/white/38@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/3@1x.png","path":"Lover/white/3@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/3@2x.png","path":"Lover/white/3@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/38@1x.png","path":"Lover/white/38@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/4@1x.png","path":"Lover/white/4@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/4@2x.png","path":"Lover/white/4@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/5@1x.png","path":"Lover/white/5@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/5@2x.png","path":"Lover/white/5@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/6@1x.png","path":"Lover/white/6@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/6@2x.png","path":"Lover/white/6@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/7@1x.png","path":"Lover/white/7@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/7@2x.png","path":"Lover/white/7@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/8@1x.png","path":"Lover/white/8@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/8@2x.png","path":"Lover/white/8@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/99@1x.png","path":"Lover/white/99@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/99@2x.png","path":"Lover/white/99@2x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/9@1x.png","path":"Lover/white/9@1x.png","modified":1,"renderable":0},{"_id":"source/Lover/white/9@2x.png","path":"Lover/white/9@2x.png","modified":1,"renderable":0},{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/iconfont.css","path":"css/iconfont.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/fish.js","path":"js/fish.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/0922.jpg","path":"img/0922.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/1.jpg","path":"img/1.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/2.jpg","path":"img/2.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/4.jpg","path":"img/4.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/CORS_banner.jpeg","path":"img/CORS_banner.jpeg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/Git.jpeg","path":"img/Git.jpeg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/3.jpg","path":"img/3.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/SOms95ABciyH3hR.gif","path":"img/SOms95ABciyH3hR.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/Vue-router.jpeg","path":"img/Vue-router.jpeg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/Vue.jpg","path":"img/Vue.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/VueBanner.jpeg","path":"img/VueBanner.jpeg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/a.jpg","path":"img/a.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/author.gif","path":"img/author.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/b.jpg","path":"img/b.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/background.jpg","path":"img/background.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/bianliang.jpg","path":"img/bianliang.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/blog_bg.webp","path":"img/blog_bg.webp","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/brand.gif","path":"img/brand.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/browser.jpg","path":"img/browser.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/c.jpg","path":"img/c.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/comment.webp","path":"img/comment.webp","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/ctext.jpg","path":"img/ctext.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/d.jpg","path":"img/d.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/debounce_banner.jpg","path":"img/debounce_banner.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/dog.jpg","path":"img/dog.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/e.jpg","path":"img/e.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/electron.jpeg","path":"img/electron.jpeg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/f.jpg","path":"img/f.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/favicon.jpg","path":"img/favicon.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/font-index.jpg","path":"img/font-index.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/fontBanner.jpg","path":"img/fontBanner.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/g.jpg","path":"img/g.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/git-banner.jpg","path":"img/git-banner.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/git-index.jpeg","path":"img/git-index.jpeg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/gulp-banner.png","path":"img/gulp-banner.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/gulp-index.jpg","path":"img/gulp-index.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/h.jpg","path":"img/h.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/hello.jpg","path":"img/hello.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/hexo.jpg","path":"img/hexo.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/html.jpg","path":"img/html.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/html2.jpg","path":"img/html2.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/index.image","path":"img/index.image","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/mianshi.jpg","path":"img/mianshi.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/music.png","path":"img/music.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/node.jpeg","path":"img/node.jpeg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/playwright.webp","path":"img/playwright.webp","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/promise.jpeg","path":"img/promise.jpeg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/python.jpg","path":"img/python.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/regex.jfif","path":"img/regex.jfif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/render-DOM.png","path":"img/render-DOM.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/sass.gif","path":"img/sass.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/sass.jpg","path":"img/sass.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/school (2).jpg","path":"img/school (2).jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/school.jpg","path":"img/school.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/server-banner.jpg","path":"img/server-banner.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/server.jpg","path":"img/server.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/spider.jpg","path":"img/spider.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/spiderman.jfif","path":"img/spiderman.jfif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/sql.jpg","path":"img/sql.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/top.jpg","path":"img/top.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/top1.jpg","path":"img/top1.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/top2.png","path":"img/top2.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/top3.jpg","path":"img/top3.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/top4.png","path":"img/top4.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/top6.jpg","path":"img/top6.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/top5.png","path":"img/top5.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/top7.jpg","path":"img/top7.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/top8.jpg","path":"img/top8.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/top9.jpg","path":"img/top9.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/v2-0186d22bc902a7021c641556e614bcd1_1440w.jpg","path":"img/v2-0186d22bc902a7021c641556e614bcd1_1440w.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/v2-9dbbbd8b4ba2742b031dfc3baba729f5_1440w.jpg","path":"img/v2-9dbbbd8b4ba2742b031dfc3baba729f5_1440w.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/v2-d4a96ee83387c1f4fec250794441014c_1440w.jpg","path":"img/v2-d4a96ee83387c1f4fec250794441014c_1440w.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/vueRouter.jpg","path":"img/vueRouter.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/wallhaven-96qo3x.png","path":"img/wallhaven-96qo3x.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/weixin.png","path":"img/weixin.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/weixinpay.png","path":"img/weixinpay.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/xiaoai.gif","path":"img/xiaoai.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/原型链.jpeg","path":"img/原型链.jpeg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/变量的本质.jpg","path":"img/变量的本质.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/回流与重绘.jpeg","path":"img/回流与重绘.jpeg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/小雪.png","path":"img/小雪.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/深浅拷贝.jpeg","path":"img/深浅拷贝.jpeg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/跨域.jpeg","path":"img/跨域.jpeg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/雨水.png","path":"img/雨水.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/post/dify.png","path":"img/post/dify.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/post/leetcode.jpg","path":"img/post/leetcode.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/Git.md","hash":"b7dd0a2bb9f2b79db32b690c2a650991c1dddf80","modified":1731851890666},{"_id":"source/about/index.md","hash":"1b9ebaa8e173471b591bb4e7489e871d9b20c88e","modified":1731851890690},{"_id":"source/_posts/Electron入门.md","hash":"8305546e361ccab14ec224f38c0227171ae74626","modified":1731851890666},{"_id":"source/Lover/index.html","hash":"230aadb91fdab6652d13cfbfdf9d959bcf071fa3","modified":1731851890659},{"_id":"source/_posts/Promise的基本知识.md","hash":"23ddfbfcd3e9a0c8f234966616b4ab1ef39649e6","modified":1731851890667},{"_id":"source/_posts/Gulp.md","hash":"50a302cca5e54f59f245fcc03a13b13dc6a3746a","modified":1731851890667},{"_id":"source/_posts/Git的一些操作.md","hash":"0d662f1ec53a6c0940f6169ec3ecf9a1c5bc426c","modified":1731851890667},{"_id":"source/_posts/Vue-路由.md","hash":"c651163ae0aa50461a7b35c4d1e2be60b2e7dbe1","modified":1731851890668},{"_id":"source/_posts/Vue的虚拟DOM.md","hash":"1b0b395ea9f8598ade32e2fabe438b6e1b500ab5","modified":1731851890669},{"_id":"source/_posts/Vue组件化.md","hash":"5ba5e42d6a5280da0419445d0e87553f5c9f8f21","modified":1731851890669},{"_id":"source/_posts/c.md","hash":"3e02a6b4132bb7f98985e7417b389eade7567354","modified":1731851890669},{"_id":"source/_posts/css.md","hash":"41bff6865a9335e83ae2af8a635c180c24024119","modified":1731851890669},{"_id":"source/_posts/database.md","hash":"30dd862e70cda0b92d7ddde4242d32e9901feeaa","modified":1731851890669},{"_id":"source/_posts/hello-world.md","hash":"d067e16ae90c3219ca1fd64c59e6fd0136200b68","modified":1731851890670},{"_id":"source/_posts/dify工作流的二次开发.md","hash":"c313a208759cc31298611390dd52999a63474340","modified":1731851890670},{"_id":"source/_posts/html.md","hash":"32def7c254a1fb259041c39225197e6ab0ba11f2","modified":1731851890670},{"_id":"source/_posts/css3.md","hash":"75121cd20a52ba4eef51aa3df470e9971c94a8f4","modified":1731851890669},{"_id":"source/_posts/music.md","hash":"4d8443011943ee74c24dbdc2a91bc6fe974d991e","modified":1731851890670},{"_id":"source/_posts/mongoDB快速指南.md","hash":"77a22e78e86be642c7c34becdb18f2cf44f9c5f2","modified":1731851890670},{"_id":"source/_posts/shuangfa.md","hash":"fa8a1f488f8f47c3537785159ea8208ac04609a0","modified":1731851890670},{"_id":"source/_posts/node实现简易爬虫.md","hash":"87d027a8e72f786280abf0c90c83896bdcd96131","modified":1731851890670},{"_id":"source/_posts/hexo.md","hash":"4ec42e5d14d3751155a6b8129a0cc6a06f336694","modified":1731851890670},{"_id":"source/_posts/SassScript.md","hash":"7430aebbafc1b36199613cfc964ea93cc565f46f","modified":1731851890668},{"_id":"source/_posts/node.md","hash":"1e15eda405e15761c7906caccf6052f995030fa1","modified":1731851890670},{"_id":"source/_posts/web.md","hash":"b64ea471a7ede5e77e61f3256467ecf0145fe46b","modified":1731851890671},{"_id":"source/_posts/前后端交互模式.md","hash":"d08483b939c1ad6f255cd07fb97e2d0d4779f6f4","modified":1731851890671},{"_id":"source/_posts/原型链.md","hash":"a1f2f0217e5ad0b82b19c10182eb66b5e29d405c","modified":1731851890673},{"_id":"source/_posts/变量提升.md","hash":"7d20ccd2e868f59f6ae2932f79c5e0832ca52b43","modified":1731851890674},{"_id":"source/_posts/有序数组中的单一元素.md","hash":"f415e79002a076a75447d9f9b9bc4e693a511172","modified":1731851890679},{"_id":"source/_posts/变量的本质和垃圾回收.md","hash":"0ea7429b5bf5f51f63d14a3e2cbc2c9ab259c90c","modified":1731851890674},{"_id":"source/_posts/平方数之和.md","hash":"2530d4a3b2f9e8e47727a85ddb077020d55cb7f3","modified":1731851890679},{"_id":"source/_posts/回流和重绘.md","hash":"1b89d9b4d5227ce8c84f8b1e1708a15cb318a137","modified":1731851890678},{"_id":"source/_posts/前端解决跨域的几种方法.md","hash":"f84e32f3e9fc81f1ef458c48b95e725e620d77a2","modified":1731851890673},{"_id":"source/_posts/检测相邻递增子数组-II.md","hash":"a3fd124ffd60bbd389330d8dd19b662dbe9b6551","modified":1731851890681},{"_id":"source/_posts/正则表达式.md","hash":"de8146aab6423e033d8c03e1209ea4530ba35d58","modified":1731851890681},{"_id":"source/_posts/深浅拷贝.md","hash":"d595c311e0566277119ccbace80a661925597894","modified":1731851890682},{"_id":"source/_posts/前端.md","hash":"06c29a2f4e44a2ea98eaf72662487d8a43659644","modified":1731851890672},{"_id":"source/_posts/服务器端.md","hash":"bbc83739be88cdb7fa39ffb469612fa05681a6b5","modified":1731851890679},{"_id":"source/_posts/渲染引擎的执行原理.md","hash":"9f27f1dec4c1e8268244cd2e0cf5286794615f13","modified":1731851890683},{"_id":"source/_posts/节流与防抖.md","hash":"4e44301e7dc7fc1f0ad2eacdc3ad6ac3f63eba5a","modified":1731851890689},{"_id":"source/_posts/统计满足-K-约束的子字符串数量-I.md","hash":"c0da1d29b39907462352040e2cdc32992b63212a","modified":1731851890689},{"_id":"source/_posts/求出胜利玩家的数目.md","hash":"9b44e059a9359c1fd635c66352bea53cebf3339c","modified":1732336598475},{"_id":"source/_posts/闭包和作用域的理解.md","hash":"58399a7c79781ed395dbe332ba70c58a1dddc645","modified":1731851890690},{"_id":"source/_posts/返回地区勾选之后的数组.md","hash":"295387543712acaf9c229a88d76d4f8c318120a0","modified":1731851890689},{"_id":"source/_posts/长度为K的子数组的能量.md","hash":"998229d1d083b9ccb6081ff17f8fd7155e1132f0","modified":1731851890690},{"_id":"source/_posts/矩阵中的蛇.md","hash":"340dd135aa23c3adff6e39ac25c5e2825e7f919e","modified":1732181154580},{"_id":"source/Lover/white/0@1x.png","hash":"8d9b8a2bb4d8fc578845d6c868be83e5b8d69352","modified":1731851890659},{"_id":"source/_posts/面试题汇总.md","hash":"084f6126d914bd82e14a19a777a761881fc1c033","modified":1731851890690},{"_id":"source/Lover/white/.DS_Store","hash":"17ea17a7d241c1aff233ec1dce5817f662fd4175","modified":1731851890659},{"_id":"source/Lover/white/10@2x.png","hash":"2a957324563c46d0ac3cd1115983fd6ca3948ef0","modified":1731851890660},{"_id":"source/Lover/white/0@2x.png","hash":"8a980aab67352df908d59b5b008c3cb80211bfce","modified":1731851890660},{"_id":"source/Lover/white/11@1x.png","hash":"dfa8d5748a8fe9d88a8258331ec979e148d3227a","modified":1731851890660},{"_id":"source/Lover/white/10@1x.png","hash":"a78a1a388ed5725b4b39a7cf76b8f3e4ec30099a","modified":1731851890660},{"_id":"source/Lover/white/12@1x.png","hash":"55048ea404a706c7a48c0cf2ebd1dd2d9fed260a","modified":1731851890660},{"_id":"source/Lover/white/14@1x.png","hash":"e262de89f8f918e8c6cbd32b4ab5d449d9e61ac8","modified":1731851890660},{"_id":"source/Lover/white/12@2x.png","hash":"e004b88de5a4335008db80414740489bc5bf22a1","modified":1731851890660},{"_id":"source/Lover/white/14@2x.png","hash":"6b0dcfcd35cbd2a962eae283e705e4bfa3d7c349","modified":1731851890660},{"_id":"source/Lover/white/15@1x.png","hash":"105b816cd748cb293c5e2fd1efc5c9b5ab899363","modified":1731851890661},{"_id":"source/Lover/white/11@2x.png","hash":"7876ab98f1ab9966b15f9c41aba61973cfe936ba","modified":1731851890660},{"_id":"source/Lover/white/15@2x.png","hash":"8937aa0c6a90478869e328444d5134d7ccbcde5b","modified":1731851890661},{"_id":"source/Lover/white/16@1x.png","hash":"f5db7c213e6b496eb24481a136a3b2b2c87468a2","modified":1731851890661},{"_id":"source/Lover/white/16@2x.png","hash":"700d2d71fb9e0a1b574f7e20f5bbb9cc153aab48","modified":1731851890661},{"_id":"source/Lover/white/17@2x.png","hash":"91f03716087a3dae03fb837b6247a808f5d96f88","modified":1731851890661},{"_id":"source/Lover/white/18@2x.png","hash":"91f03716087a3dae03fb837b6247a808f5d96f88","modified":1731851890661},{"_id":"source/Lover/white/18@1x.png","hash":"b990ca00c936a072e8167264dc711724a9f70d7b","modified":1731851890661},{"_id":"source/Lover/white/19@2x.png","hash":"c1a822fc33376f178beda871cddd689b75759db1","modified":1731851890661},{"_id":"source/Lover/white/1@1x.png","hash":"bacfbff1d9c52cb6bca8203b7526f2f17d5b4c7e","modified":1731851890661},{"_id":"source/Lover/white/13@2x.png","hash":"61c8d64eb595bcbb0ceabf79954207c8c0b04a3c","modified":1731851890660},{"_id":"source/Lover/white/17@1x.png","hash":"b990ca00c936a072e8167264dc711724a9f70d7b","modified":1731851890661},{"_id":"source/Lover/white/19@1x.png","hash":"eceb494516987af117b3736f0099b791fbed1e14","modified":1731851890661},{"_id":"source/Lover/white/13@1x.png","hash":"350e45d987c55a06df7952bbc36c483305d3ac5b","modified":1731851890660},{"_id":"source/Lover/white/20@1x.png","hash":"83c3072460c97bfc8c8cc1572c6e4bc8b8da6b0d","modified":1731851890662},{"_id":"source/Lover/white/1@2x.png","hash":"c1ce7c893c1b3c87bd7d60ee929c05ff17c2b295","modified":1731851890661},{"_id":"source/Lover/white/21@1x.png","hash":"0878b1201d111af0e913217cfa8e9da250c5c44b","modified":1731851890662},{"_id":"source/Lover/white/20@2x.png","hash":"b0443cf1327c0ee1df77230c6040350175445d4e","modified":1731851890662},{"_id":"source/Lover/white/22@1x.png","hash":"0e864c0b50f1e67b61d67aca0c71a7685ffabe0e","modified":1731851890662},{"_id":"source/Lover/white/21@2x.png","hash":"227b1ae44ee8a9271a87c4042288eb4e80542957","modified":1731851890662},{"_id":"source/Lover/white/22@2x.png","hash":"045f088eee8638312f52aff41f8d2342e9f57ec1","modified":1731851890662},{"_id":"source/Lover/white/23@1x.png","hash":"5d08adcdf33031efc07a7b4df0cd598c06877494","modified":1731851890662},{"_id":"source/Lover/white/23@2x.png","hash":"502d0c0353e935de140471df151d5fd7f7cb1e42","modified":1731851890662},{"_id":"source/Lover/white/24@1x.png","hash":"a42df674c8eec6530a3ed2857bb9e46961d53648","modified":1731851890662},{"_id":"source/Lover/white/25@1x.png","hash":"a70edd58c835fe5fe19bb428edcbf8fee2d79c7a","modified":1731851890662},{"_id":"source/Lover/white/24@2x.png","hash":"c8473ff3fe106f429934fdb55db3a49d90cac80f","modified":1731851890662},{"_id":"source/Lover/white/26@1x.png","hash":"7dd634a922c0f0f4ed3dab57f7c56e82d2c220c2","modified":1731851890662},{"_id":"source/Lover/white/25@2x.png","hash":"357b7e5762fc5e5c590d6a9cb7bff77366883a57","modified":1731851890662},{"_id":"source/Lover/white/27@1x.png","hash":"7dd634a922c0f0f4ed3dab57f7c56e82d2c220c2","modified":1731851890663},{"_id":"source/Lover/white/26@2x.png","hash":"5871814f34224f964e43cb028dad5078a2920cc8","modified":1731851890663},{"_id":"source/Lover/white/28@2x.png","hash":"75e354b7945553108a03c298cd2fab1bafb5146d","modified":1731851890663},{"_id":"source/Lover/white/27@2x.png","hash":"5871814f34224f964e43cb028dad5078a2920cc8","modified":1731851890663},{"_id":"source/Lover/white/29@2x.png","hash":"75e354b7945553108a03c298cd2fab1bafb5146d","modified":1731851890663},{"_id":"source/Lover/white/28@1x.png","hash":"0c980bf2e8278730a18377bd3669666e999a4287","modified":1731851890663},{"_id":"source/Lover/white/2@1x.png","hash":"8d9b8a2bb4d8fc578845d6c868be83e5b8d69352","modified":1731851890663},{"_id":"source/Lover/white/2@2x.png","hash":"8a980aab67352df908d59b5b008c3cb80211bfce","modified":1731851890663},{"_id":"source/Lover/white/29@1x.png","hash":"0c980bf2e8278730a18377bd3669666e999a4287","modified":1731851890663},{"_id":"source/Lover/white/30@2x.png","hash":"6379c1552fefd821f374eb0f12a9cafb8f41f9a4","modified":1731851890663},{"_id":"source/Lover/white/30@1x.png","hash":"9ff5368a53cf2a9d7ecedac3cbf6ebb597fd33f2","modified":1731851890663},{"_id":"source/Lover/white/31@1x.png","hash":"747f0806d0116dbe1d7e687acabdb5ed22d1baf2","modified":1731851890663},{"_id":"source/Lover/white/31@2x.png","hash":"a75458b94a19b87e9ac328bd703b190b3e4d01e3","modified":1731851890663},{"_id":"source/Lover/white/32@1x.png","hash":"aaaab41bebd5b31f10b9ae7eac7600c6026ede49","modified":1731851890663},{"_id":"source/Lover/white/33@2x.png","hash":"4868856833b222b494aba286a4483344ab178601","modified":1731851890664},{"_id":"source/Lover/white/33@1x.png","hash":"aaaab41bebd5b31f10b9ae7eac7600c6026ede49","modified":1731851890664},{"_id":"source/Lover/white/32@2x.png","hash":"4868856833b222b494aba286a4483344ab178601","modified":1731851890664},{"_id":"source/Lover/white/34@1x.png","hash":"725129a1fa8ba59d31c6da9b698478757882a7ff","modified":1731851890664},{"_id":"source/Lover/white/36@1x.png","hash":"1301d1253a24e58cbe9b3ba1f1f4f50e08a948e0","modified":1731851890664},{"_id":"source/Lover/white/35@2x.png","hash":"d0b0dd9f038f803248fd0fd81c0333472bc76790","modified":1731851890664},{"_id":"source/Lover/white/34@2x.png","hash":"d0b0dd9f038f803248fd0fd81c0333472bc76790","modified":1731851890664},{"_id":"source/Lover/white/35@1x.png","hash":"725129a1fa8ba59d31c6da9b698478757882a7ff","modified":1731851890664},{"_id":"source/Lover/white/36@2x.png","hash":"7eb7a8edeadf7ea18ad6131ba09b625725d9be0d","modified":1731851890665},{"_id":"source/Lover/white/37@2x.png","hash":"e351fca22bfcf3cd7229d4ec582085361be9bd88","modified":1731851890665},{"_id":"source/Lover/white/37@1x.png","hash":"cf21031ec2ad8d3a9234476e9b138644dd6c4c4b","modified":1731851890665},{"_id":"source/Lover/white/38@2x.png","hash":"8a980aab67352df908d59b5b008c3cb80211bfce","modified":1731851890665},{"_id":"source/Lover/white/3@1x.png","hash":"bacfbff1d9c52cb6bca8203b7526f2f17d5b4c7e","modified":1731851890665},{"_id":"source/Lover/white/3@2x.png","hash":"c1ce7c893c1b3c87bd7d60ee929c05ff17c2b295","modified":1731851890665},{"_id":"source/Lover/white/4@2x.png","hash":"42dd6576aec05d317ca8df8713595377314ddb90","modified":1731851890665},{"_id":"source/Lover/white/38@1x.png","hash":"8d9b8a2bb4d8fc578845d6c868be83e5b8d69352","modified":1731851890665},{"_id":"source/Lover/white/4@1x.png","hash":"166fd579bd089f5c330933c59a0a4a122c28e260","modified":1731851890665},{"_id":"source/Lover/white/5@2x.png","hash":"2486e94df5c2a6aa08acbf763d11fcafa17cfcd4","modified":1731851890665},{"_id":"source/Lover/white/6@1x.png","hash":"691788a4a39aa68145b86d78a560732cc1876dc4","modified":1731851890665},{"_id":"source/Lover/white/5@1x.png","hash":"fd1ebb3d6c3756cc94c1acb900fea2415d7f1c0d","modified":1731851890665},{"_id":"source/Lover/white/6@2x.png","hash":"9e51a2e7f432ea9ca7188d5b3d21fdc5012ff3f7","modified":1731851890665},{"_id":"source/Lover/white/7@2x.png","hash":"2486e94df5c2a6aa08acbf763d11fcafa17cfcd4","modified":1731851890666},{"_id":"source/Lover/white/7@1x.png","hash":"fd1ebb3d6c3756cc94c1acb900fea2415d7f1c0d","modified":1731851890666},{"_id":"source/Lover/white/8@2x.png","hash":"9e51a2e7f432ea9ca7188d5b3d21fdc5012ff3f7","modified":1731851890666},{"_id":"source/Lover/white/8@1x.png","hash":"691788a4a39aa68145b86d78a560732cc1876dc4","modified":1731851890666},{"_id":"source/Lover/white/99@2x.png","hash":"c4bf9b78665892ad18ea73a3c0d6e2746e9cbe23","modified":1731851890666},{"_id":"source/Lover/white/99@1x.png","hash":"733698f8ee6f709a0d4debb203dd4172a740b661","modified":1731851890666},{"_id":"source/Lover/white/9@1x.png","hash":"6502a189eb32eb68eba49c9985927250d648bd57","modified":1731851890666},{"_id":"source/Lover/white/9@2x.png","hash":"1f4580ef65dd0c2ce0e546fa6caa66bef9b59bbb","modified":1731851890666},{"_id":"source/_posts/spider/spider.png","hash":"fd23af034209ed7ef2fa4edd9ad6d1f956e55300","modified":1731851890671},{"_id":"source/_posts/Vue的虚拟DOM/render-DOM.png","hash":"4c4b9047bdc4cf0742386cbd16a7238e088d2916","modified":1731851890669},{"_id":"source/_posts/前后端交互模式/3.png","hash":"e73bd18d2236c79fdb8097dd765128a0dbd9170d","modified":1731851890672},{"_id":"source/_posts/变量的本质和垃圾回收/栈.png","hash":"ff7274b6cb89211a060ae7c33088928a807f45c9","modified":1731851890677},{"_id":"source/_posts/回流和重绘/回流.jpg","hash":"6f847bc7a5277d0ce04abc2bff602016b9175675","modified":1731851890678},{"_id":"source/_posts/回流和重绘/重绘.jpg","hash":"45c6ee052d3897f45f87c215943f83b5c26adb33","modified":1731851890679},{"_id":"source/_posts/节流与防抖/debounce.png","hash":"4a0f79b7bed13fcd09c0d006732d17eee3a566f3","modified":1731851890689},{"_id":"source/_posts/节流与防抖/throttle.png","hash":"16db612b123fbbb84a2fa60353584177546428a2","modified":1731851890689},{"_id":"source/_posts/变量的本质和垃圾回收/垃圾回收.png","hash":"8319f9f2f4f3f05b2a75fefca45493f04e44ce47","modified":1731851890677},{"_id":"source/_posts/渲染引擎的执行原理/DOM树.png","hash":"fd3e869c13986331c13c41ac4b31afe7d411a3ad","modified":1731851890683},{"_id":"source/_posts/深浅拷贝/深拷贝.png","hash":"08efcecf1c2b68849f0f193cb1d4021569bcbb19","modified":1731851890683},{"_id":"source/_posts/深浅拷贝/对象赋值.png","hash":"0d4cc9c5013c26c8162cc30416f0159468895724","modified":1731851890682},{"_id":"source/_posts/深浅拷贝/浅拷贝.png","hash":"90b4544febcba90744ad5df128a0fdcffea36fdb","modified":1731851890682},{"_id":"source/_posts/渲染引擎的执行原理/光栅化.png","hash":"5006f59e9e35b2e0e4c189d2effb24a31ba996e7","modified":1731851890686},{"_id":"source/_posts/Git/CSSOM.png","hash":"f14fdd28df21e207586fd319041e24ddc9fbe70f","modified":1731851890667},{"_id":"source/_posts/变量的本质和垃圾回收/浅拷贝.png","hash":"4d2c7adef9186574b44b3aa0cc4cb55b25eae476","modified":1731851890677},{"_id":"source/_posts/服务器端/server02.png","hash":"ea4873149b4ae36f040ed1dc3be03c882105ed3f","modified":1731851890680},{"_id":"source/_posts/渲染引擎的执行原理/CSSOM.png","hash":"f14fdd28df21e207586fd319041e24ddc9fbe70f","modified":1731851890683},{"_id":"source/_posts/渲染引擎的执行原理/布局.png","hash":"8626f352a91d0c6d28019d46a51088d42d5f9c5c","modified":1731851890688},{"_id":"source/_posts/渲染引擎的执行原理/浏览器解析原理.png","hash":"280d90ef0996a95b91e0d628d9ee58a8c67edf0c","modified":1731851890688},{"_id":"source/_posts/前后端交互模式/1.png","hash":"d159d69e7482ca5de66dd4b5e1bcf542c1a6cc32","modified":1731851890671},{"_id":"source/_posts/前后端交互模式/2.png","hash":"3c5e9cc2734945eab8f6502f6167b07ab027faa3","modified":1731851890672},{"_id":"source/_posts/服务器端/server03.png","hash":"ad8c54c977bbd97992e83b881998ccdd3e573adf","modified":1731851890680},{"_id":"source/_posts/原型链/原型链.png","hash":"29254fc1ff8186d4da522f2645b03c55fa0000bd","modified":1731851890673},{"_id":"source/_posts/Vue-路由/vueRouter.jpg","hash":"4a8985437433bc09e8667326de415474ce860d0f","modified":1731851890669},{"_id":"source/_posts/变量的本质和垃圾回收/同步和异步栈.png","hash":"735215ccb96b7b788ff40d813d894d556688b282","modified":1731851890676},{"_id":"source/_posts/服务器端/server01.png","hash":"d195311354a33ced4052775261569b92f8bf65fd","modified":1731851890679},{"_id":"source/_posts/渲染引擎的执行原理/重绘.png","hash":"2bb86484306cdbb6680a3f28dcd20109d9ee7931","modified":1731851890689},{"_id":"source/_posts/服务器端/server04.png","hash":"68e8d0befff7c800c23745a32a17429e14bd8065","modified":1731851890681},{"_id":"source/_posts/渲染引擎的执行原理/Tree.png","hash":"45eecf43e1e9784c491aa46dd9a200928f82be7b","modified":1731851890686},{"_id":"source/_posts/变量的本质和垃圾回收/任务队列.png","hash":"04cb67247e9681672d9aa06dffa5a6d726147165","modified":1731851890676},{"_id":"source/_posts/渲染引擎的执行原理/DRAW QUAD.png","hash":"86d02206a048d1fbf469b142c0ca52124251a38e","modified":1731851890685},{"_id":"source/_posts/渲染引擎的执行原理/分块.png","hash":"b93d829a6c871cbd7eead8177cfafbe15825bb78","modified":1731851890687},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1731851890700},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1731851890701},{"_id":"themes/fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1731851890691},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1731851890691},{"_id":"themes/fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":1731851890692},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1731851890690},{"_id":"themes/fluid/package.json","hash":"18f04247801549fe78600c1ee9c601fcbea4cab3","modified":1731851890696},{"_id":"themes/fluid/README.md","hash":"03cfa8e5f149514b57ef80dcb84eb7fea261370d","modified":1731851890692},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1731851890690},{"_id":"themes/fluid/_config.yml","hash":"e761edbc6e26c4698f159a9d200f63506261d296","modified":1731851890692},{"_id":"themes/fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":1731851890695},{"_id":"themes/fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":1731851890692},{"_id":"themes/fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1731851890693},{"_id":"themes/fluid/layout/categories.ejs","hash":"20c2a195a109d2a263b5fa6e79cbcc62932508ad","modified":1731851890695},{"_id":"themes/fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":1731851890695},{"_id":"themes/fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":1731851890695},{"_id":"themes/fluid/layout/index.ejs","hash":"666476260a2cead2cc2928d51977c4a7ba8de6bb","modified":1731851890695},{"_id":"themes/fluid/layout/layout.ejs","hash":"7f566edf750241e62d7c54abfbb0c504fdab850a","modified":1731851890695},{"_id":"themes/fluid/layout/links.ejs","hash":"2a7b49f0f9aecf07550b5a0b99242aab5654cf2b","modified":1731851890695},{"_id":"themes/fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":1731851890696},{"_id":"themes/fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":1731851890692},{"_id":"themes/fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":1731851890696},{"_id":"themes/fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":1731851890696},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1731851890696},{"_id":"themes/fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1731851890692},{"_id":"themes/fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":1731851890692},{"_id":"themes/fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1731851890692},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":1731851890693},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1731851890692},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":1731851890691},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":1731851890691},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1731851890691},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1731851890691},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1731851890691},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"58b4bbe36386de4305a8da5ffd7d56802df23049","modified":1731851890693},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"c363829a4b80f74fc1c565e41f6dab41c95006ea","modified":1731851890694},{"_id":"themes/fluid/layout/_partial/archive-list.ejs","hash":"53a4f6029373a40394a87aba9284696a71610f90","modified":1731851890693},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1731851890691},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"39ec395fc92e56eaf3c4f58bc2f4453ade3246b0","modified":1731851890694},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1731851890694},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"0ee838b6fcd895d21a29d9d67dbb99b752d623d1","modified":1731851890695},{"_id":"themes/fluid/layout/_partial/post-meta.ejs","hash":"32a17edadeed40da6db21d2d8031bd47d2fc9bf4","modified":1731851890695},{"_id":"themes/fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":1731851890696},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"7d0cf31f2595cfe6d5ad31d569654f21a00dfd77","modified":1731851890694},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1731851890691},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1731851890697},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"e71b3c4aa263163597d31b1f91e5a1a877084cfd","modified":1731851890694},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1731851890695},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":1731851890697},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1731851890697},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1731851890697},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"cde964c8cd3217268a231de5e018a62c53c2e047","modified":1731851890697},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1731851890697},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1731851890697},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"8e33f915028ac56258f6999d19b1ad8d800cecfe","modified":1731851890697},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1731851890698},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1731851890697},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1731851890698},{"_id":"themes/fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1731851890698},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1731851890698},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1731851890698},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1731851890698},{"_id":"themes/fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":1731851890698},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":1731851890695},{"_id":"themes/fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1731851890695},{"_id":"themes/fluid/source/js/color-schema.js","hash":"2520c6459b544a4e965b838f8095e2a84390a43c","modified":1731851890787},{"_id":"themes/fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1731851890787},{"_id":"themes/fluid/source/css/iconfont.css","hash":"7b0bfc5d025061ec730f219ad4ba9f65e3cf39a9","modified":1731851890701},{"_id":"themes/fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1731851890702},{"_id":"themes/fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1731851890787},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1731851890701},{"_id":"themes/fluid/source/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1731851890787},{"_id":"themes/fluid/source/js/fish.js","hash":"15ef10b82a200c54418287805619cb232d2594dc","modified":1731851890787},{"_id":"themes/fluid/source/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1731851890787},{"_id":"themes/fluid/source/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1731851890788},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1731851890787},{"_id":"themes/fluid/source/js/leancloud.js","hash":"4a787cfce27045aa0a92ec22e84f2ccf30cabc4c","modified":1731851890787},{"_id":"themes/fluid/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1731851890707},{"_id":"themes/fluid/source/img/Vue-router.jpeg","hash":"09c0fbaadc1a625a08e6bae77313b855052224bf","modified":1731851890709},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":1731851890698},{"_id":"themes/fluid/source/img/Git.jpeg","hash":"c615d52a252075f553d74ecfd4c0d0c7a6e467a4","modified":1731851890708},{"_id":"themes/fluid/source/img/Vue.jpg","hash":"6605d2f9b3dd2c867150816b4af5b7a0fcab3ea3","modified":1731851890710},{"_id":"themes/fluid/source/img/VueBanner.jpeg","hash":"e77a5b67bdd0163836affa353715d953a9d2865f","modified":1731851890710},{"_id":"themes/fluid/source/img/a.jpg","hash":"e8fe4a0d50ff288a0096b10f1ea37ee01bccb9e6","modified":1731851890710},{"_id":"themes/fluid/source/img/b.jpg","hash":"d316390b73ac1897bdf2afef02824b07fb74bddc","modified":1731851890711},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1731851890711},{"_id":"themes/fluid/source/img/ctext.jpg","hash":"ca0f50f7864613d2ce4c70196c64a1476b6ed1ce","modified":1731851890714},{"_id":"themes/fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1731851890715},{"_id":"themes/fluid/source/img/e.jpg","hash":"974cf0f11bcae3d030d4d9aceeb9fd51a3e63a1d","modified":1731851890716},{"_id":"themes/fluid/source/img/favicon.ico","hash":"47877628a0f0e0f06430845b0e3a75e0ba1361ce","modified":1731851890717},{"_id":"themes/fluid/source/img/electron.jpeg","hash":"656c88b7536ca0a2eb8d0b230794e615bbb666fb","modified":1731851890717},{"_id":"themes/fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1731851890717},{"_id":"themes/fluid/source/img/f.jpg","hash":"decbfd8b3a5b9f383907077f324556b30535e9f0","modified":1731851890717},{"_id":"themes/fluid/source/img/favicon.jpg","hash":"453452f4f14aff39e829781f9b136a8f818d4391","modified":1731851890717},{"_id":"themes/fluid/source/img/font-index.jpg","hash":"898e3a01cd55e360a1fbdb281189da0ad93e6548","modified":1731851890717},{"_id":"themes/fluid/source/img/git-index.jpeg","hash":"d3e7fd4b8be43d960cc784f197fa8a9bf57f343f","modified":1731851890718},{"_id":"themes/fluid/source/img/fontBanner.jpg","hash":"2052043c3e1e438edc31018af0890bdaa382a2f0","modified":1731851890717},{"_id":"themes/fluid/source/img/gulp-banner.png","hash":"bfccc21fb81a5a941e86f1ce4e11f162167e5094","modified":1731851890718},{"_id":"themes/fluid/source/img/git-banner.jpg","hash":"47749b196880e2887d7c2b6bc7fe0218e046b3e8","modified":1731851890718},{"_id":"themes/fluid/source/img/h.jpg","hash":"d03a46468c5f789879efc9690cbb46c24e1ad50e","modified":1731851890718},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"3aa5b4ea879cd34d3a32468d88da18d72cbcc8e0","modified":1731851890697},{"_id":"themes/fluid/source/img/gulp-index.jpg","hash":"0f711debf790f18a512d26d9740b48c1651eca31","modified":1731851890718},{"_id":"themes/fluid/source/img/hello.jpg","hash":"c63734feb6654c3e7aef0063c4e78d80ef01a1a6","modified":1731851890719},{"_id":"themes/fluid/source/img/html.jpg","hash":"75b4ff80de6eedc53c2d803d92bb15040e00827d","modified":1731851890719},{"_id":"themes/fluid/source/img/html2.jpg","hash":"18ca69b115c4446738ec8208dd8a4adb44773add","modified":1731851890719},{"_id":"themes/fluid/source/img/hexo.jpg","hash":"de6f12191e949cac5510b8aa99f0c540595db09e","modified":1731851890719},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1731851890719},{"_id":"themes/fluid/source/img/node.jpeg","hash":"acbf25daef17aaec6ec0417a25915326c5663d5e","modified":1731851890720},{"_id":"themes/fluid/source/img/mianshi.jpg","hash":"0b4725d1c5e88fbd8e329039c4f7b5e29f657469","modified":1731851890720},{"_id":"themes/fluid/source/img/python.jpg","hash":"700a497f3444df325fbf0b4e0499e9e6a4ffaeef","modified":1731851890722},{"_id":"themes/fluid/source/img/promise.jpeg","hash":"ab460b5230fb5fadee4d73e16d0eb94cb8beafa7","modified":1731851890722},{"_id":"themes/fluid/source/img/regex.jfif","hash":"8583acdbafece9d777cb8ae221649741c6520022","modified":1731851890722},{"_id":"themes/fluid/source/img/playwright.webp","hash":"23258ebcbb28656929ca76ee6624c812f3ebb56d","modified":1731851890720},{"_id":"themes/fluid/source/img/sass.gif","hash":"7cf0c9d91ac64db26571e323cd9a05b7763127f3","modified":1731851890723},{"_id":"themes/fluid/source/img/render-DOM.png","hash":"4c4b9047bdc4cf0742386cbd16a7238e088d2916","modified":1731851890723},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1731851890720},{"_id":"themes/fluid/source/img/server.jpg","hash":"743ef89cc9d613363b8e823d3f9b985a83e97a76","modified":1731851890730},{"_id":"themes/fluid/source/img/spiderman.jfif","hash":"10ba3693fdf3c25a8357d2a422583a0038b74a32","modified":1731851890732},{"_id":"themes/fluid/source/img/v2-0186d22bc902a7021c641556e614bcd1_1440w.jpg","hash":"06a9c968e2d7659283a98ec6f4790f26f3e23841","modified":1731851890777},{"_id":"themes/fluid/source/img/v2-9dbbbd8b4ba2742b031dfc3baba729f5_1440w.jpg","hash":"747f0942d9e544fdf631dc56aaddec982a5094e5","modified":1731851890777},{"_id":"themes/fluid/source/img/v2-d4a96ee83387c1f4fec250794441014c_1440w.jpg","hash":"4f45800cba9718423ddc324c497074c3dfa145ff","modified":1731851890777},{"_id":"themes/fluid/source/img/原型链.jpeg","hash":"1228c7d00808f4066be96180a36a42da4695f3a0","modified":1731851890783},{"_id":"themes/fluid/source/img/weixinpay.png","hash":"938d4bcb72836bf748d40f344034bb194142042f","modified":1731851890781},{"_id":"themes/fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1731851890693},{"_id":"themes/fluid/source/img/回流与重绘.jpeg","hash":"52654ea0d4d71ef5e5307f1b0bae9a740189693e","modified":1731851890783},{"_id":"themes/fluid/source/img/跨域.jpeg","hash":"06e227a99038aa7e0b775f2cf7b18e628e0cd960","modified":1731851890786},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1731851890693},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1731851890788},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1731851890693},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1731851890693},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1731851890693},{"_id":"themes/fluid/layout/_partial/comments/twikoo.ejs","hash":"1af53bc0be642610a3a4d4e7c05287854a821508","modified":1731851890694},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":1731851890694},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"4052ab2a8f78efa92f0fe17abe8f66135943390a","modified":1731851890694},{"_id":"themes/fluid/layout/_partial/comments/waline.ejs","hash":"21e00443054802e893aac1f668b69d5bb4b39b3a","modified":1731851890694},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":1731851890694},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":1731851890696},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1731851890696},{"_id":"themes/fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1731851890693},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"a7ed1d3079c32497c8955ca75f5fb6992e5ffb8b","modified":1731851890694},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"deed966f38cf0c8dee3f72e5b1f2e878510db0e1","modified":1731851890696},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":1731851890696},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":1731851890697},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1731851890696},{"_id":"themes/fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1731851890694},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"ece659572cf4e12638a1607fca512c25098bbd82","modified":1731851890695},{"_id":"themes/fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1731851890694},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1731851890698},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1731851890701},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1731851890698},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"63aedd67d90d641cc672540db20ef615f528c9f1","modified":1731851890701},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1731851890699},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1731851890699},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"cd55a2dce6b9d3e165a0a26d0b5bf7f649006bcd","modified":1731851890700},{"_id":"themes/fluid/source/img/post/leetcode.jpg","hash":"5534764d611918df47987ae1d98780a666f2e0d9","modified":1731851890722},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"32fb938d72b2d86159cb315a98b086bd17fa4415","modified":1731851890700},{"_id":"themes/fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1731851890788},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":1731851890700},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1731851890700},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"616c1f7147078c3d532dd1cfd2af09c0c3a816f0","modified":1731851890700},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1731851890700},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"7e32a3268accf3d524209c213e15e2d5d5e2e1a6","modified":1731851890700},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"3a6b4f8a29648d9d2c1e99b52a7b42df3f15cf62","modified":1731851890701},{"_id":"themes/fluid/source/css/_pages/_base/rewrite.styl","hash":"c66e0da2c0d05e76a686a77ab4e74f0d2e89777d","modified":1731851890700},{"_id":"themes/fluid/source/css/_pages/_post/tag_plugin.styl","hash":"b89b96c8a6a433a6f372b42710554b05cab85a24","modified":1731851890701},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1731851890701},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"0ce7552dc4993926426019398d73e817cfd841a1","modified":1731851890699},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":1731851890699},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":1731851890699},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1731851890699},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":1731851890699},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1731851890699},{"_id":"source/_posts/变量的本质和垃圾回收/heap.png","hash":"def9b966bf08b575305aed5e754b1524877900ff","modified":1731851890675},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":1731851890699},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1731851890699},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1731851890700},{"_id":"source/_posts/变量的本质和垃圾回收/浏览器的进程.png","hash":"4397aca464416a12a04b7c92eea12d794c5bb0cb","modified":1731851890678},{"_id":"themes/fluid/source/img/CORS_banner.jpeg","hash":"1515ca5694860558e2287b8fe9509895efcfc112","modified":1731851890708},{"_id":"themes/fluid/source/img/background.jpg","hash":"4076bee5df87063e76637248cfec6a7f8031e464","modified":1731851890711},{"_id":"themes/fluid/source/img/bianliang.jpg","hash":"6e79450c1a68a5f76b637d74ef667f1a840d00bf","modified":1731851890711},{"_id":"themes/fluid/source/img/blog_bg.webp","hash":"548456c285cc2b447589a7e9e74437c202b97a7c","modified":1731851890711},{"_id":"themes/fluid/source/img/c.jpg","hash":"f55f173b9fea16748cb5bb18e5b4ee7fbb767a31","modified":1731851890713},{"_id":"themes/fluid/source/img/debounce_banner.jpg","hash":"256ebc5172368463912ccd1cd3753e1de12da63b","modified":1731851890715},{"_id":"themes/fluid/source/img/browser.jpg","hash":"e2cd680d27834ab0f81d71a94b0a1d18bfb6f769","modified":1731851890713},{"_id":"themes/fluid/source/img/index.image","hash":"6e79450c1a68a5f76b637d74ef667f1a840d00bf","modified":1731851890719},{"_id":"themes/fluid/source/img/music.png","hash":"dbb07ed9abceb9d5153e87826933cd4bd7e45fbc","modified":1731851890720},{"_id":"themes/fluid/source/img/author.gif","hash":"cf943d19b12a8b2f385b206e15bf303a4192cb84","modified":1731851890710},{"_id":"themes/fluid/source/img/d.jpg","hash":"60734d39c35c7508b005092cda695fae4433da30","modified":1731851890715},{"_id":"themes/fluid/source/img/school (2).jpg","hash":"2ae694064ca40766bd92c77aceef5f563a9ea768","modified":1731851890724},{"_id":"themes/fluid/source/img/sql.jpg","hash":"195c203753e5ce193ef043bc84b8243062e51f68","modified":1731851890732},{"_id":"themes/fluid/source/img/weixin.png","hash":"6ea9d96da75c545cc1bb4b246c14a6993a6c6225","modified":1731851890781},{"_id":"themes/fluid/source/img/变量的本质.jpg","hash":"dd230ee24932037fe16dadde9bd098de1ca86863","modified":1731851890783},{"_id":"themes/fluid/source/img/g.jpg","hash":"318da5af9e64e26fbcb718771c8340ab730fc6f3","modified":1731851890718},{"_id":"themes/fluid/source/img/深浅拷贝.jpeg","hash":"1ed49ae324fe3913239a798bdceb01eb09394436","modified":1731851890785},{"_id":"themes/fluid/source/img/comment.webp","hash":"8fe6376cc493cf6e86cbb5dfedd4180280fab714","modified":1731851890714},{"_id":"themes/fluid/source/img/top7.jpg","hash":"f929ca03869f241831acf8ef9b5b69579ef5f2c8","modified":1731851890757},{"_id":"themes/fluid/source/img/SOms95ABciyH3hR.gif","hash":"5fcf0b887eefd7ebbba1c8d8ee1fc5cd2ac002ad","modified":1731851890709},{"_id":"themes/fluid/source/img/brand.gif","hash":"f67bf18567d79e66f59c21599763618e314812ac","modified":1731851890713},{"_id":"themes/fluid/source/img/school.jpg","hash":"2ba4d0eae692a34580f1ea8ad256855a0eff3538","modified":1731851890725},{"_id":"themes/fluid/source/img/xiaoai.gif","hash":"8a011158f4d33bcfaa1c7a00bc7bbead18f6e6f2","modified":1731851890783},{"_id":"themes/fluid/source/img/dog.jpg","hash":"8fad7e6e3b853eaecffd928153b9b05240c493de","modified":1731851890716},{"_id":"themes/fluid/source/img/3.jpg","hash":"48cf3027b6b9d84379d62cbda77f6b3da8bf37b6","modified":1731851890706},{"_id":"themes/fluid/source/img/1.jpg","hash":"088553ff0d73a22b862c248ba3a6061b06ecccae","modified":1731851890705},{"_id":"themes/fluid/source/img/2.jpg","hash":"30e26647ac4d499dc43572e5cb8e7ffed3954054","modified":1731851890706},{"_id":"themes/fluid/source/img/post/dify.png","hash":"9b08be27835f63ff6707bed3ba046cb078b8a652","modified":1731851890722},{"_id":"themes/fluid/source/img/spider.jpg","hash":"10f51663231586acc38ac0b858b8f81a52f81ac8","modified":1731851890732},{"_id":"themes/fluid/source/img/top3.jpg","hash":"a988dc0f236d233a92cd6a78ff8a45ff5b2df781","modified":1731851890741},{"_id":"themes/fluid/source/img/sass.jpg","hash":"886f0b7533c12ce12ffc49ff4c6ddc1bd2437866","modified":1731851890723},{"_id":"themes/fluid/source/img/top6.jpg","hash":"2e50b40897cbb421fff92a4e76381fcea55885d6","modified":1731851890757},{"_id":"themes/fluid/source/img/4.jpg","hash":"0127aa613daf55df8b191081b74fcfe2c1b28dbe","modified":1731851890707},{"_id":"themes/fluid/source/img/top1.jpg","hash":"cc8a6ebf949373852c698ded64e9d536b94993da","modified":1731851890735},{"_id":"themes/fluid/source/img/top.jpg","hash":"3a71d6549f617dd7fd9e7d8323514a497cfc1ebe","modified":1731851890733},{"_id":"themes/fluid/source/img/vueRouter.jpg","hash":"c358e62c9a29679db499efb10df9207bdf2b0cca","modified":1731851890778},{"_id":"themes/fluid/source/img/雨水.png","hash":"f4adbc12558b829b38bb1f4e841d92fa127cc8bf","modified":1731851890786},{"_id":"themes/fluid/source/img/top5.png","hash":"a416480cab88b35b310768d7a3a07262d1c3c533","modified":1731851890755},{"_id":"themes/fluid/source/img/0922.jpg","hash":"cf819efb2776fd3fb0f0af77e457007433fc5bba","modified":1731851890704},{"_id":"themes/fluid/source/img/小雪.png","hash":"51bba73b201c2f461bcc4c85c53d850f3a1f0764","modified":1731851890785},{"_id":"themes/fluid/source/img/top8.jpg","hash":"1b4593160542732a387ff0115c371cfc779d6210","modified":1731851890761},{"_id":"themes/fluid/source/img/wallhaven-96qo3x.png","hash":"8154a0cb73de933f6e0f4d6d1253fe469c3f2601","modified":1731851890781},{"_id":"themes/fluid/source/img/top9.jpg","hash":"70f418b9d4f5f52fad11f1ec64d3112e9dd402aa","modified":1731851890776},{"_id":"themes/fluid/source/img/top4.png","hash":"baec70222bb37db5e6fe224b3b56bde3528b56b3","modified":1731851890753},{"_id":"themes/fluid/source/img/top2.png","hash":"8ce68b62a1f68093079d84543129133835487d47","modified":1731851890739},{"_id":"themes/fluid/source/img/server-banner.jpg","hash":"191525c46e4b3a6bc87dff3e0cc3e3a92ec16d4a","modified":1731851890729},{"_id":"public/local-search.xml","hash":"89a47500cb5ae5b350d9203b395eb1ad43964b26","modified":1732353606425},{"_id":"public/Lover/index.html","hash":"0333b6d58aa114998f372f13e56aa519fc15898c","modified":1732353606425},{"_id":"public/about/index.html","hash":"4587317db288a9534de141f8e2941d253ef19770","modified":1732353606425},{"_id":"public/2024/11/23/求出胜利玩家的数目/index.html","hash":"366f0742bbc2b17c8ad32f55275990f624b18623","modified":1732353606425},{"_id":"public/2024/11/21/矩阵中的蛇/index.html","hash":"615e8c368bfd4b0e6f7a24671e05a3cfd6ec9d88","modified":1732353606425},{"_id":"public/2024/11/13/闭包和作用域的理解/index.html","hash":"8ab8be13571079a295aec28b4a3dd12aa29631fc","modified":1732353606425},{"_id":"public/2024/11/11/统计满足-K-约束的子字符串数量-I/index.html","hash":"d6bfb65ba5a6e98959f0b2ae8fd8284944f4867e","modified":1732353606425},{"_id":"public/2024/11/10/检测相邻递增子数组-II/index.html","hash":"1c07e25fa2897834eb4ce427ee339d7c67494773","modified":1732353606425},{"_id":"public/2024/11/08/返回地区勾选之后的数组/index.html","hash":"cfde9fc8d40a31e1ea85e57c3d68b63027e22634","modified":1732353606425},{"_id":"public/2024/11/10/有序数组中的单一元素/index.html","hash":"3e6904b1cac56c725c6f01e827daad6a291a24b2","modified":1732353606425},{"_id":"public/2024/11/03/平方数之和/index.html","hash":"df046571c9b13c304d0ad9d9dd223707b32f3639","modified":1732353606425},{"_id":"public/2024/11/06/长度为K的子数组的能量/index.html","hash":"191a4e150e840e04b2c33a25c91f6acead9d3599","modified":1732353606425},{"_id":"public/2024/07/24/dify工作流的二次开发/index.html","hash":"3270842a9653c0a41eb2d5397ee0c9b31cc6f19e","modified":1732353606425},{"_id":"public/2023/06/14/面试题汇总/index.html","hash":"fb9bf050a29f3ac1780db192046bf336dc23c3cb","modified":1732353606425},{"_id":"public/2023/06/07/Electron入门/index.html","hash":"b60021238324f594949b0024ac408c46b756cc8f","modified":1732353606425},{"_id":"public/2023/06/07/Vue的虚拟DOM/index.html","hash":"547ddfd53dbe20c86fe6c4a302a56655bb43a8f0","modified":1732353606425},{"_id":"public/2023/03/27/Promise的基本知识/index.html","hash":"4b206a1195c8b8d8a45982272f4f876662345986","modified":1732353606425},{"_id":"public/2023/03/01/渲染引擎的执行原理/index.html","hash":"4bc5582934824ffbbf2aaef4dcafe76a562284da","modified":1732353606425},{"_id":"public/2023/02/28/原型链/index.html","hash":"bd77d0d1a4c5a8071f973eb396c918713509f18a","modified":1732353606425},{"_id":"public/2023/02/27/变量的本质和垃圾回收/index.html","hash":"dca74655ea3685bf87d21b7023a0f0087374e31a","modified":1732353606425},{"_id":"public/2023/02/23/回流和重绘/index.html","hash":"7930e7334a3399494f9b27d4f7d740031fdaa7d8","modified":1732353606425},{"_id":"public/2023/02/22/前端/index.html","hash":"07a9e46ceb43edebdb00b2f5f310e791c8844147","modified":1732353606425},{"_id":"public/2023/02/22/深浅拷贝/index.html","hash":"a6107e5d3703907e385de77397c2c5fea0160d9e","modified":1732353606425},{"_id":"public/2023/02/20/Git的一些操作/index.html","hash":"007dd53a263a49f7edec801321a5b06079dae999","modified":1732353606425},{"_id":"public/2021/12/19/node实现简易爬虫/index.html","hash":"52e0f79483f69dadca40952bb678f2218a8150d3","modified":1732353606425},{"_id":"public/2021/12/12/mongoDB快速指南/index.html","hash":"cbb5b614c9e14ec404fb34811dad61aac9dd033c","modified":1732353606425},{"_id":"public/2021/12/07/前端解决跨域的几种方法/index.html","hash":"c4c583e2b9c534dab40e95cc98e28a01ed5d13c4","modified":1732353606425},{"_id":"public/2021/12/07/节流与防抖/index.html","hash":"9adca999178bce01eaa036957c1ef72cf36fb076","modified":1732353606425},{"_id":"public/2021/05/31/Vue-路由/index.html","hash":"1b13b26104254a8905a09043bb16dd511b30aef5","modified":1732353606425},{"_id":"public/2021/05/25/SassScript/index.html","hash":"cd82b42720dd0268f2cf1dd7ac9268a8067a30c5","modified":1732353606425},{"_id":"public/2021/05/25/Vue组件化/index.html","hash":"e92c73ed215abccd2226f2a423c55f63faa473d4","modified":1732353606425},{"_id":"public/2021/05/25/前后端交互模式/index.html","hash":"0a3a0d15281308bc764b87c587f3b1d44bab8bc1","modified":1732353606425},{"_id":"public/2021/04/24/变量提升/index.html","hash":"30232258eac33bf629ff69294e0d6eb3fed53fc9","modified":1732353606425},{"_id":"public/2021/04/11/正则表达式/index.html","hash":"bdc09d31e2d4d797935101712d377997ce3218f4","modified":1732353606425},{"_id":"public/2021/04/11/Git/index.html","hash":"23af81d869fd87a719db5871b6bf4b3cc8cfc7c6","modified":1732353606425},{"_id":"public/2021/04/11/Gulp/index.html","hash":"f5ac5fa022c6490d4b3804b840bb26a95039db6c","modified":1732353606425},{"_id":"public/2021/03/29/node/index.html","hash":"0fa944f6c253a63d941a6f3a5c9814ae6d921ce4","modified":1732353606425},{"_id":"public/2021/04/11/服务器端/index.html","hash":"2bc6ff1847532a82cd389852b72f27200dae6015","modified":1732353606425},{"_id":"public/2020/11/16/database/index.html","hash":"b8426945db0a38ca64c533ad0abe5d9ebdc3e564","modified":1732353606425},{"_id":"public/2020/09/22/css3/index.html","hash":"d90fa6b03b6c18fa8243f062fcb5789b7e24a984","modified":1732353606425},{"_id":"public/2020/09/03/music/index.html","hash":"05b591ef02fa7b6355526dcab18d67ee903d816e","modified":1732353606425},{"_id":"public/2020/08/31/shuangfa/index.html","hash":"1d4cf72b0bd5406be0a602483b5ad3eece98fc1d","modified":1732353606425},{"_id":"public/2020/08/27/css/index.html","hash":"72fded479cca07980a5ff15357ca948ecf4b50be","modified":1732353606425},{"_id":"public/2020/08/14/web/index.html","hash":"a924fd72aa64e5bc0fcfdb80558159f70c93af21","modified":1732353606425},{"_id":"public/2020/08/18/html/index.html","hash":"e5dfe290e8af58be74e5587ab595b05ea232cc2d","modified":1732353606425},{"_id":"public/2020/08/12/hexo/index.html","hash":"962a3db168f0f38ad304144668811664fa054f6d","modified":1732353606425},{"_id":"public/2020/08/02/c/index.html","hash":"5dfe48090ff2e51d36e2043f4f658e599056266d","modified":1732353606425},{"_id":"public/2020/08/02/hello-world/index.html","hash":"912ea52d3638ab16136e47ba4ae19df4f8923dc2","modified":1732353606425},{"_id":"public/archives/index.html","hash":"e04a6a3aec375f9d7adda19a1e9c65b2665a9552","modified":1732353606425},{"_id":"public/archives/page/2/index.html","hash":"7c8bb9a7efdd6e2888013768016488c78d3123a4","modified":1732353606425},{"_id":"public/archives/page/3/index.html","hash":"bf17eb5085a043c4d46244a7daa32a20f30ed973","modified":1732353606425},{"_id":"public/archives/page/4/index.html","hash":"a153cca205ead49ccb8da985f7a69e98264d8c9a","modified":1732353606425},{"_id":"public/archives/page/5/index.html","hash":"748b170dceedd21769086c5eb774481f2d990ab2","modified":1732353606425},{"_id":"public/archives/2020/index.html","hash":"f68aa2f15980e12df162828780e861a0850af84b","modified":1732353606425},{"_id":"public/archives/2020/08/index.html","hash":"832cb88cf14cfaabb2be122727d25ed6b558b97c","modified":1732353606425},{"_id":"public/archives/2020/09/index.html","hash":"4323e025ef5b943c25ddabfe4d2dd97c7229349b","modified":1732353606425},{"_id":"public/archives/2020/11/index.html","hash":"722b6e135ddbff981c2a3c584f4be55e684b2528","modified":1732353606425},{"_id":"public/archives/2021/index.html","hash":"7ae541b3c269d83dd46a40442817cdb9665ffe19","modified":1732353606425},{"_id":"public/archives/2021/page/2/index.html","hash":"4171202f7b13294835570b47f98afe4428cc4528","modified":1732353606425},{"_id":"public/archives/2021/03/index.html","hash":"f004fc191ae5e5586aa7db68188aa327d900c471","modified":1732353606425},{"_id":"public/archives/2021/04/index.html","hash":"cee8200cb03419ddb6ecbd8acc919d7fcbbc9afc","modified":1732353606425},{"_id":"public/archives/2021/12/index.html","hash":"c2c460ee74908d67f6e2478b75cffbe1fd2209ff","modified":1732353606425},{"_id":"public/archives/2021/05/index.html","hash":"196bc4cae7445c261f7d4596f5e84df62b2da7c1","modified":1732353606425},{"_id":"public/archives/2023/page/2/index.html","hash":"55065c398c606685ba135839b0bef6c7381346f5","modified":1732353606425},{"_id":"public/archives/2023/index.html","hash":"a5e267082b23fdeeba0a955a7c7e7199f987c6c1","modified":1732353606425},{"_id":"public/archives/2023/03/index.html","hash":"4143daaa1649552b87ca2f44ec458b27ad4b61db","modified":1732353606425},{"_id":"public/archives/2023/06/index.html","hash":"9842388428a6e480a8fbac06c83ee37a3ccb4d5d","modified":1732353606425},{"_id":"public/archives/2024/index.html","hash":"c1094210904d7333ecf823033d100c0eb4010f54","modified":1732353606425},{"_id":"public/archives/2023/02/index.html","hash":"ef5abff5804f1c23471e5d29b5f992ce4394f064","modified":1732353606425},{"_id":"public/archives/2024/07/index.html","hash":"308165494372909dcbd9847ed8466308c8226397","modified":1732353606425},{"_id":"public/archives/2024/11/index.html","hash":"95e3ba3ae398d2c623129bd2acc0ff79e6909a35","modified":1732353606425},{"_id":"public/categories/前端/index.html","hash":"3d9941ea354ed640f4ca84caa2a8ba4138cc8d15","modified":1732353606425},{"_id":"public/categories/前端/page/2/index.html","hash":"6fd5286496fab3ba1fe5f527fff4e992196ca627","modified":1732353606425},{"_id":"public/categories/前端/page/3/index.html","hash":"167ea7de0580f22c1145ed21e78791630132abac","modified":1732353606425},{"_id":"public/categories/后端/index.html","hash":"9669410890c577dd952df6ab0f901716f70d92e7","modified":1732353606425},{"_id":"public/categories/技术/index.html","hash":"5b9d64d16a5bd031fbef0b7621e03c0b64b1f9b9","modified":1732353606425},{"_id":"public/categories/hexo/index.html","hash":"7b7b26cedd43e31c84862bfac6ac29df02fc754e","modified":1732353606425},{"_id":"public/categories/blog/index.html","hash":"7a046dcc5c8e60a9013424d23135942c49b8424c","modified":1732353606425},{"_id":"public/categories/算法/index.html","hash":"51fb20a4937c0cfb622957a44c23aac9f15cccd8","modified":1732353606425},{"_id":"public/categories/JavaScript/index.html","hash":"763663be8b32ee20585257957e18f153f15e378d","modified":1732353606425},{"_id":"public/index.html","hash":"f20374b27372f79625f69d9b7bfee2c498508bfd","modified":1732353606425},{"_id":"public/page/2/index.html","hash":"7b271c85fe073071100d7169670222077b0d1fa1","modified":1732353606425},{"_id":"public/page/3/index.html","hash":"7770dab8d164ac98b5555fcb62fd722703a3f754","modified":1732353606425},{"_id":"public/page/4/index.html","hash":"bfc62a8a3bd344089eb56eb7bb2ad7e4a2405f2b","modified":1732353606425},{"_id":"public/page/5/index.html","hash":"97b74342b324d2d9c9205e3a59c28acb408f1d60","modified":1732353606425},{"_id":"public/tags/Electron/index.html","hash":"8c2b82b6a2a394c9fe59af59018ce16cc84a9d39","modified":1732353606425},{"_id":"public/tags/后端/index.html","hash":"1f7d93f4f7d89c7b7ec9b193a33da6f7fb013422","modified":1732353606425},{"_id":"public/tags/Git/index.html","hash":"2cc28b99c2d29b1aeda264dd31d0541aaa8e19f4","modified":1732353606425},{"_id":"public/tags/Gulp/index.html","hash":"014a10911c851f54bb8cc995bac3965e9e22b3a6","modified":1732353606425},{"_id":"public/tags/基础知识点/index.html","hash":"79a4f2bb82251b1f0757676b58bb7e7dc5629d7b","modified":1732353606425},{"_id":"public/tags/css/index.html","hash":"cfea4f681910dda8a6b2d1a0846e34b00dfb86ed","modified":1732353606425},{"_id":"public/tags/Vue/index.html","hash":"9305a90063dfee71ba0b119524c8785a53d76004","modified":1732353606425},{"_id":"public/tags/c语言/index.html","hash":"c01bf0609d3a3c3ae899c9c4902526c7880c16eb","modified":1732353606425},{"_id":"public/tags/css3/index.html","hash":"87a3826fbe262b6262e55c0c3b20218bb8326cc2","modified":1732353606425},{"_id":"public/tags/数据库/index.html","hash":"29742aa4c7e75932a3ac6282e92a0afebee710d1","modified":1732353606425},{"_id":"public/tags/hello-world/index.html","hash":"0d0a1d1a6f8b4b0e7799ba09dfa67f26fbedcb8c","modified":1732353606425},{"_id":"public/tags/hexo/index.html","hash":"da484d5968525412d2d96690da88481243407e0c","modified":1732353606425},{"_id":"public/tags/HTML/index.html","hash":"4975f4e29b10a35f7b6d625f7b4332d407f47e72","modified":1732353606425},{"_id":"public/tags/mongoDB/index.html","hash":"04af1ccb3d13f9f9f87b1ee34d34eb3e327c0809","modified":1732353606425},{"_id":"public/tags/aplyer/index.html","hash":"4aaf41a94aa6dec76cbbeb30eae5a839c0879a0b","modified":1732353606425},{"_id":"public/tags/Node/index.html","hash":"a3d8abf507b9cde408ed5e76d9cd8b8768d982d5","modified":1732353606425},{"_id":"public/tags/总结/index.html","hash":"0a875646becfa44484d67d6de05a5a4301ac02ab","modified":1732353606425},{"_id":"public/tags/哈希算法/index.html","hash":"2ccf196911801ce876c4ce4c84ed114f3ef0d6c1","modified":1732353606425},{"_id":"public/tags/前端/index.html","hash":"733ec9f3b0f6a896b0ca2e22c164b8c2e96e75d5","modified":1732353606425},{"_id":"public/tags/tips/index.html","hash":"3058c9661ca6bbb177522855f61a5f6854fd4ee3","modified":1732353606425},{"_id":"public/tags/变量提升/index.html","hash":"0d9137fa81f75ce2c5ae1013a9f34aed6bc5596d","modified":1732353606425},{"_id":"public/tags/每日一题/index.html","hash":"ffce3f7ca4319a4ffc47f7a249eb06c31dbcdb6e","modified":1732353606425},{"_id":"public/tags/服务器端/index.html","hash":"ceab3a64ac5c58e7da4f6fd0768372967d82b529","modified":1732353606425},{"_id":"public/tags/算法/index.html","hash":"f3213c2bae75895d451f75d8eb6dbe9269e591f7","modified":1732353606425},{"_id":"public/tags/正则表达式/index.html","hash":"e95198bfa03aaab0270d1dc60a644de8b725dd68","modified":1732353606425},{"_id":"public/tags/JavaScript基础/index.html","hash":"485e3fa79f8859b365f547ee83a27d5d2be11626","modified":1732353606425},{"_id":"public/tags/面试/index.html","hash":"3a8bc51c24d9ed72067e6c67927e81effaa1b3ba","modified":1732353606425},{"_id":"public/tags/index.html","hash":"1873a14e81b755607897ef1e30db0edfa9b7bfad","modified":1732353606425},{"_id":"public/categories/index.html","hash":"92d87874c14e9f23adb83016bd8756345b6db938","modified":1732353606425},{"_id":"public/404.html","hash":"f4e21e2087ea80afda4891a54f184f58eb58c229","modified":1732353606425},{"_id":"public/links/index.html","hash":"3f10bdd8f2c9d783d7fa90bb6dae53e50bed6db7","modified":1732353606425},{"_id":"public/Lover/white/0@1x.png","hash":"8d9b8a2bb4d8fc578845d6c868be83e5b8d69352","modified":1732353606425},{"_id":"public/Lover/white/10@2x.png","hash":"2a957324563c46d0ac3cd1115983fd6ca3948ef0","modified":1732353606425},{"_id":"public/Lover/white/11@1x.png","hash":"dfa8d5748a8fe9d88a8258331ec979e148d3227a","modified":1732353606425},{"_id":"public/Lover/white/14@1x.png","hash":"e262de89f8f918e8c6cbd32b4ab5d449d9e61ac8","modified":1732353606425},{"_id":"public/Lover/white/11@2x.png","hash":"7876ab98f1ab9966b15f9c41aba61973cfe936ba","modified":1732353606425},{"_id":"public/Lover/white/12@1x.png","hash":"55048ea404a706c7a48c0cf2ebd1dd2d9fed260a","modified":1732353606425},{"_id":"public/Lover/white/0@2x.png","hash":"8a980aab67352df908d59b5b008c3cb80211bfce","modified":1732353606425},{"_id":"public/Lover/white/10@1x.png","hash":"a78a1a388ed5725b4b39a7cf76b8f3e4ec30099a","modified":1732353606425},{"_id":"public/Lover/white/14@2x.png","hash":"6b0dcfcd35cbd2a962eae283e705e4bfa3d7c349","modified":1732353606425},{"_id":"public/Lover/white/12@2x.png","hash":"e004b88de5a4335008db80414740489bc5bf22a1","modified":1732353606425},{"_id":"public/Lover/white/15@2x.png","hash":"8937aa0c6a90478869e328444d5134d7ccbcde5b","modified":1732353606425},{"_id":"public/Lover/white/16@1x.png","hash":"f5db7c213e6b496eb24481a136a3b2b2c87468a2","modified":1732353606425},{"_id":"public/Lover/white/15@1x.png","hash":"105b816cd748cb293c5e2fd1efc5c9b5ab899363","modified":1732353606425},{"_id":"public/Lover/white/16@2x.png","hash":"700d2d71fb9e0a1b574f7e20f5bbb9cc153aab48","modified":1732353606425},{"_id":"public/Lover/white/17@2x.png","hash":"91f03716087a3dae03fb837b6247a808f5d96f88","modified":1732353606425},{"_id":"public/Lover/white/18@1x.png","hash":"b990ca00c936a072e8167264dc711724a9f70d7b","modified":1732353606425},{"_id":"public/Lover/white/19@2x.png","hash":"c1a822fc33376f178beda871cddd689b75759db1","modified":1732353606425},{"_id":"public/Lover/white/18@2x.png","hash":"91f03716087a3dae03fb837b6247a808f5d96f88","modified":1732353606425},{"_id":"public/Lover/white/17@1x.png","hash":"b990ca00c936a072e8167264dc711724a9f70d7b","modified":1732353606425},{"_id":"public/Lover/white/1@1x.png","hash":"bacfbff1d9c52cb6bca8203b7526f2f17d5b4c7e","modified":1732353606425},{"_id":"public/Lover/white/1@2x.png","hash":"c1ce7c893c1b3c87bd7d60ee929c05ff17c2b295","modified":1732353606425},{"_id":"public/Lover/white/19@1x.png","hash":"eceb494516987af117b3736f0099b791fbed1e14","modified":1732353606425},{"_id":"public/Lover/white/13@1x.png","hash":"350e45d987c55a06df7952bbc36c483305d3ac5b","modified":1732353606425},{"_id":"public/Lover/white/20@2x.png","hash":"b0443cf1327c0ee1df77230c6040350175445d4e","modified":1732353606425},{"_id":"public/Lover/white/13@2x.png","hash":"61c8d64eb595bcbb0ceabf79954207c8c0b04a3c","modified":1732353606425},{"_id":"public/Lover/white/20@1x.png","hash":"83c3072460c97bfc8c8cc1572c6e4bc8b8da6b0d","modified":1732353606425},{"_id":"public/Lover/white/21@2x.png","hash":"227b1ae44ee8a9271a87c4042288eb4e80542957","modified":1732353606425},{"_id":"public/Lover/white/22@2x.png","hash":"045f088eee8638312f52aff41f8d2342e9f57ec1","modified":1732353606425},{"_id":"public/Lover/white/21@1x.png","hash":"0878b1201d111af0e913217cfa8e9da250c5c44b","modified":1732353606425},{"_id":"public/Lover/white/22@1x.png","hash":"0e864c0b50f1e67b61d67aca0c71a7685ffabe0e","modified":1732353606425},{"_id":"public/Lover/white/23@1x.png","hash":"5d08adcdf33031efc07a7b4df0cd598c06877494","modified":1732353606425},{"_id":"public/Lover/white/24@2x.png","hash":"c8473ff3fe106f429934fdb55db3a49d90cac80f","modified":1732353606425},{"_id":"public/Lover/white/24@1x.png","hash":"a42df674c8eec6530a3ed2857bb9e46961d53648","modified":1732353606425},{"_id":"public/Lover/white/25@1x.png","hash":"a70edd58c835fe5fe19bb428edcbf8fee2d79c7a","modified":1732353606425},{"_id":"public/Lover/white/25@2x.png","hash":"357b7e5762fc5e5c590d6a9cb7bff77366883a57","modified":1732353606425},{"_id":"public/Lover/white/26@1x.png","hash":"7dd634a922c0f0f4ed3dab57f7c56e82d2c220c2","modified":1732353606425},{"_id":"public/Lover/white/26@2x.png","hash":"5871814f34224f964e43cb028dad5078a2920cc8","modified":1732353606425},{"_id":"public/Lover/white/23@2x.png","hash":"502d0c0353e935de140471df151d5fd7f7cb1e42","modified":1732353606425},{"_id":"public/Lover/white/27@1x.png","hash":"7dd634a922c0f0f4ed3dab57f7c56e82d2c220c2","modified":1732353606425},{"_id":"public/Lover/white/28@1x.png","hash":"0c980bf2e8278730a18377bd3669666e999a4287","modified":1732353606425},{"_id":"public/Lover/white/27@2x.png","hash":"5871814f34224f964e43cb028dad5078a2920cc8","modified":1732353606425},{"_id":"public/Lover/white/28@2x.png","hash":"75e354b7945553108a03c298cd2fab1bafb5146d","modified":1732353606425},{"_id":"public/Lover/white/29@1x.png","hash":"0c980bf2e8278730a18377bd3669666e999a4287","modified":1732353606425},{"_id":"public/Lover/white/29@2x.png","hash":"75e354b7945553108a03c298cd2fab1bafb5146d","modified":1732353606425},{"_id":"public/Lover/white/2@1x.png","hash":"8d9b8a2bb4d8fc578845d6c868be83e5b8d69352","modified":1732353606425},{"_id":"public/Lover/white/2@2x.png","hash":"8a980aab67352df908d59b5b008c3cb80211bfce","modified":1732353606425},{"_id":"public/Lover/white/30@1x.png","hash":"9ff5368a53cf2a9d7ecedac3cbf6ebb597fd33f2","modified":1732353606425},{"_id":"public/Lover/white/31@2x.png","hash":"a75458b94a19b87e9ac328bd703b190b3e4d01e3","modified":1732353606425},{"_id":"public/Lover/white/30@2x.png","hash":"6379c1552fefd821f374eb0f12a9cafb8f41f9a4","modified":1732353606425},{"_id":"public/Lover/white/31@1x.png","hash":"747f0806d0116dbe1d7e687acabdb5ed22d1baf2","modified":1732353606425},{"_id":"public/Lover/white/32@1x.png","hash":"aaaab41bebd5b31f10b9ae7eac7600c6026ede49","modified":1732353606425},{"_id":"public/Lover/white/33@2x.png","hash":"4868856833b222b494aba286a4483344ab178601","modified":1732353606425},{"_id":"public/Lover/white/33@1x.png","hash":"aaaab41bebd5b31f10b9ae7eac7600c6026ede49","modified":1732353606425},{"_id":"public/Lover/white/32@2x.png","hash":"4868856833b222b494aba286a4483344ab178601","modified":1732353606425},{"_id":"public/Lover/white/34@1x.png","hash":"725129a1fa8ba59d31c6da9b698478757882a7ff","modified":1732353606425},{"_id":"public/Lover/white/35@2x.png","hash":"d0b0dd9f038f803248fd0fd81c0333472bc76790","modified":1732353606425},{"_id":"public/Lover/white/35@1x.png","hash":"725129a1fa8ba59d31c6da9b698478757882a7ff","modified":1732353606425},{"_id":"public/Lover/white/37@1x.png","hash":"cf21031ec2ad8d3a9234476e9b138644dd6c4c4b","modified":1732353606425},{"_id":"public/Lover/white/34@2x.png","hash":"d0b0dd9f038f803248fd0fd81c0333472bc76790","modified":1732353606425},{"_id":"public/Lover/white/36@1x.png","hash":"1301d1253a24e58cbe9b3ba1f1f4f50e08a948e0","modified":1732353606425},{"_id":"public/Lover/white/36@2x.png","hash":"7eb7a8edeadf7ea18ad6131ba09b625725d9be0d","modified":1732353606425},{"_id":"public/Lover/white/37@2x.png","hash":"e351fca22bfcf3cd7229d4ec582085361be9bd88","modified":1732353606425},{"_id":"public/Lover/white/3@1x.png","hash":"bacfbff1d9c52cb6bca8203b7526f2f17d5b4c7e","modified":1732353606425},{"_id":"public/Lover/white/38@1x.png","hash":"8d9b8a2bb4d8fc578845d6c868be83e5b8d69352","modified":1732353606425},{"_id":"public/Lover/white/38@2x.png","hash":"8a980aab67352df908d59b5b008c3cb80211bfce","modified":1732353606425},{"_id":"public/Lover/white/3@2x.png","hash":"c1ce7c893c1b3c87bd7d60ee929c05ff17c2b295","modified":1732353606425},{"_id":"public/Lover/white/4@1x.png","hash":"166fd579bd089f5c330933c59a0a4a122c28e260","modified":1732353606425},{"_id":"public/Lover/white/4@2x.png","hash":"42dd6576aec05d317ca8df8713595377314ddb90","modified":1732353606425},{"_id":"public/Lover/white/5@1x.png","hash":"fd1ebb3d6c3756cc94c1acb900fea2415d7f1c0d","modified":1732353606425},{"_id":"public/Lover/white/6@1x.png","hash":"691788a4a39aa68145b86d78a560732cc1876dc4","modified":1732353606425},{"_id":"public/Lover/white/5@2x.png","hash":"2486e94df5c2a6aa08acbf763d11fcafa17cfcd4","modified":1732353606425},{"_id":"public/Lover/white/6@2x.png","hash":"9e51a2e7f432ea9ca7188d5b3d21fdc5012ff3f7","modified":1732353606425},{"_id":"public/Lover/white/7@2x.png","hash":"2486e94df5c2a6aa08acbf763d11fcafa17cfcd4","modified":1732353606425},{"_id":"public/Lover/white/7@1x.png","hash":"fd1ebb3d6c3756cc94c1acb900fea2415d7f1c0d","modified":1732353606425},{"_id":"public/Lover/white/8@1x.png","hash":"691788a4a39aa68145b86d78a560732cc1876dc4","modified":1732353606425},{"_id":"public/Lover/white/8@2x.png","hash":"9e51a2e7f432ea9ca7188d5b3d21fdc5012ff3f7","modified":1732353606425},{"_id":"public/Lover/white/99@2x.png","hash":"c4bf9b78665892ad18ea73a3c0d6e2746e9cbe23","modified":1732353606425},{"_id":"public/Lover/white/99@1x.png","hash":"733698f8ee6f709a0d4debb203dd4172a740b661","modified":1732353606425},{"_id":"public/Lover/white/9@1x.png","hash":"6502a189eb32eb68eba49c9985927250d648bd57","modified":1732353606425},{"_id":"public/Lover/white/9@2x.png","hash":"1f4580ef65dd0c2ce0e546fa6caa66bef9b59bbb","modified":1732353606425},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1732353606425},{"_id":"public/img/Git.jpeg","hash":"c615d52a252075f553d74ecfd4c0d0c7a6e467a4","modified":1732353606425},{"_id":"public/img/Vue-router.jpeg","hash":"09c0fbaadc1a625a08e6bae77313b855052224bf","modified":1732353606425},{"_id":"public/img/Vue.jpg","hash":"6605d2f9b3dd2c867150816b4af5b7a0fcab3ea3","modified":1732353606425},{"_id":"public/img/VueBanner.jpeg","hash":"e77a5b67bdd0163836affa353715d953a9d2865f","modified":1732353606425},{"_id":"public/img/a.jpg","hash":"e8fe4a0d50ff288a0096b10f1ea37ee01bccb9e6","modified":1732353606425},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1732353606425},{"_id":"public/img/b.jpg","hash":"d316390b73ac1897bdf2afef02824b07fb74bddc","modified":1732353606425},{"_id":"public/img/ctext.jpg","hash":"ca0f50f7864613d2ce4c70196c64a1476b6ed1ce","modified":1732353606425},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1732353606425},{"_id":"public/img/e.jpg","hash":"974cf0f11bcae3d030d4d9aceeb9fd51a3e63a1d","modified":1732353606425},{"_id":"public/img/electron.jpeg","hash":"656c88b7536ca0a2eb8d0b230794e615bbb666fb","modified":1732353606425},{"_id":"public/img/f.jpg","hash":"decbfd8b3a5b9f383907077f324556b30535e9f0","modified":1732353606425},{"_id":"public/img/favicon.ico","hash":"47877628a0f0e0f06430845b0e3a75e0ba1361ce","modified":1732353606425},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1732353606425},{"_id":"public/img/favicon.jpg","hash":"453452f4f14aff39e829781f9b136a8f818d4391","modified":1732353606425},{"_id":"public/img/font-index.jpg","hash":"898e3a01cd55e360a1fbdb281189da0ad93e6548","modified":1732353606425},{"_id":"public/img/fontBanner.jpg","hash":"2052043c3e1e438edc31018af0890bdaa382a2f0","modified":1732353606425},{"_id":"public/img/git-banner.jpg","hash":"47749b196880e2887d7c2b6bc7fe0218e046b3e8","modified":1732353606425},{"_id":"public/img/gulp-banner.png","hash":"bfccc21fb81a5a941e86f1ce4e11f162167e5094","modified":1732353606425},{"_id":"public/img/git-index.jpeg","hash":"d3e7fd4b8be43d960cc784f197fa8a9bf57f343f","modified":1732353606425},{"_id":"public/img/gulp-index.jpg","hash":"0f711debf790f18a512d26d9740b48c1651eca31","modified":1732353606425},{"_id":"public/img/hello.jpg","hash":"c63734feb6654c3e7aef0063c4e78d80ef01a1a6","modified":1732353606425},{"_id":"public/img/h.jpg","hash":"d03a46468c5f789879efc9690cbb46c24e1ad50e","modified":1732353606425},{"_id":"public/img/hexo.jpg","hash":"de6f12191e949cac5510b8aa99f0c540595db09e","modified":1732353606425},{"_id":"public/img/html.jpg","hash":"75b4ff80de6eedc53c2d803d92bb15040e00827d","modified":1732353606425},{"_id":"public/img/html2.jpg","hash":"18ca69b115c4446738ec8208dd8a4adb44773add","modified":1732353606425},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1732353606425},{"_id":"public/img/mianshi.jpg","hash":"0b4725d1c5e88fbd8e329039c4f7b5e29f657469","modified":1732353606425},{"_id":"public/img/node.jpeg","hash":"acbf25daef17aaec6ec0417a25915326c5663d5e","modified":1732353606425},{"_id":"public/img/playwright.webp","hash":"23258ebcbb28656929ca76ee6624c812f3ebb56d","modified":1732353606425},{"_id":"public/img/promise.jpeg","hash":"ab460b5230fb5fadee4d73e16d0eb94cb8beafa7","modified":1732353606425},{"_id":"public/img/regex.jfif","hash":"8583acdbafece9d777cb8ae221649741c6520022","modified":1732353606425},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1732353606425},{"_id":"public/img/python.jpg","hash":"700a497f3444df325fbf0b4e0499e9e6a4ffaeef","modified":1732353606425},{"_id":"public/img/render-DOM.png","hash":"4c4b9047bdc4cf0742386cbd16a7238e088d2916","modified":1732353606425},{"_id":"public/img/sass.gif","hash":"7cf0c9d91ac64db26571e323cd9a05b7763127f3","modified":1732353606425},{"_id":"public/img/server.jpg","hash":"743ef89cc9d613363b8e823d3f9b985a83e97a76","modified":1732353606425},{"_id":"public/img/spiderman.jfif","hash":"10ba3693fdf3c25a8357d2a422583a0038b74a32","modified":1732353606425},{"_id":"public/img/v2-0186d22bc902a7021c641556e614bcd1_1440w.jpg","hash":"06a9c968e2d7659283a98ec6f4790f26f3e23841","modified":1732353606425},{"_id":"public/img/v2-9dbbbd8b4ba2742b031dfc3baba729f5_1440w.jpg","hash":"747f0942d9e544fdf631dc56aaddec982a5094e5","modified":1732353606425},{"_id":"public/img/v2-d4a96ee83387c1f4fec250794441014c_1440w.jpg","hash":"4f45800cba9718423ddc324c497074c3dfa145ff","modified":1732353606425},{"_id":"public/img/weixinpay.png","hash":"938d4bcb72836bf748d40f344034bb194142042f","modified":1732353606425},{"_id":"public/img/原型链.jpeg","hash":"1228c7d00808f4066be96180a36a42da4695f3a0","modified":1732353606425},{"_id":"public/img/回流与重绘.jpeg","hash":"52654ea0d4d71ef5e5307f1b0bae9a740189693e","modified":1732353606425},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1732353606425},{"_id":"public/img/post/leetcode.jpg","hash":"5534764d611918df47987ae1d98780a666f2e0d9","modified":1732353606425},{"_id":"public/2023/06/07/Vue的虚拟DOM/render-DOM.png","hash":"4c4b9047bdc4cf0742386cbd16a7238e088d2916","modified":1732353606425},{"_id":"public/img/跨域.jpeg","hash":"06e227a99038aa7e0b775f2cf7b18e628e0cd960","modified":1732353606425},{"_id":"public/2021/05/25/前后端交互模式/3.png","hash":"e73bd18d2236c79fdb8097dd765128a0dbd9170d","modified":1732353606425},{"_id":"public/2023/02/27/变量的本质和垃圾回收/栈.png","hash":"ff7274b6cb89211a060ae7c33088928a807f45c9","modified":1732353606425},{"_id":"public/2023/02/23/回流和重绘/回流.jpg","hash":"6f847bc7a5277d0ce04abc2bff602016b9175675","modified":1732353606425},{"_id":"public/2023/02/23/回流和重绘/重绘.jpg","hash":"45c6ee052d3897f45f87c215943f83b5c26adb33","modified":1732353606425},{"_id":"public/2021/12/07/节流与防抖/debounce.png","hash":"4a0f79b7bed13fcd09c0d006732d17eee3a566f3","modified":1732353606425},{"_id":"public/2021/12/07/节流与防抖/throttle.png","hash":"16db612b123fbbb84a2fa60353584177546428a2","modified":1732353606425},{"_id":"public/img/CORS_banner.jpeg","hash":"1515ca5694860558e2287b8fe9509895efcfc112","modified":1732353606425},{"_id":"public/img/background.jpg","hash":"4076bee5df87063e76637248cfec6a7f8031e464","modified":1732353606425},{"_id":"public/img/bianliang.jpg","hash":"6e79450c1a68a5f76b637d74ef667f1a840d00bf","modified":1732353606425},{"_id":"public/img/blog_bg.webp","hash":"548456c285cc2b447589a7e9e74437c202b97a7c","modified":1732353606425},{"_id":"public/img/c.jpg","hash":"f55f173b9fea16748cb5bb18e5b4ee7fbb767a31","modified":1732353606425},{"_id":"public/img/debounce_banner.jpg","hash":"256ebc5172368463912ccd1cd3753e1de12da63b","modified":1732353606425},{"_id":"public/img/browser.jpg","hash":"e2cd680d27834ab0f81d71a94b0a1d18bfb6f769","modified":1732353606425},{"_id":"public/img/index.image","hash":"6e79450c1a68a5f76b637d74ef667f1a840d00bf","modified":1732353606425},{"_id":"public/img/music.png","hash":"dbb07ed9abceb9d5153e87826933cd4bd7e45fbc","modified":1732353606425},{"_id":"public/css/iconfont.css","hash":"7b0bfc5d025061ec730f219ad4ba9f65e3cf39a9","modified":1732353606425},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1732353606425},{"_id":"public/js/color-schema.js","hash":"2520c6459b544a4e965b838f8095e2a84390a43c","modified":1732353606425},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1732353606425},{"_id":"public/js/fish.js","hash":"15ef10b82a200c54418287805619cb232d2594dc","modified":1732353606425},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1732353606425},{"_id":"public/css/main.css","hash":"a647cdbbe760fb85d88c9dfb76e6e2b14de578ba","modified":1732353606425},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1732353606425},{"_id":"public/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1732353606425},{"_id":"public/js/leancloud.js","hash":"4a787cfce27045aa0a92ec22e84f2ccf30cabc4c","modified":1732353606425},{"_id":"public/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1732353606425},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1732353606425},{"_id":"public/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1732353606425},{"_id":"public/2023/02/27/变量的本质和垃圾回收/垃圾回收.png","hash":"8319f9f2f4f3f05b2a75fefca45493f04e44ce47","modified":1732353606425},{"_id":"public/2023/02/22/深浅拷贝/浅拷贝.png","hash":"90b4544febcba90744ad5df128a0fdcffea36fdb","modified":1732353606425},{"_id":"public/2023/02/22/深浅拷贝/深拷贝.png","hash":"08efcecf1c2b68849f0f193cb1d4021569bcbb19","modified":1732353606425},{"_id":"public/2023/02/22/深浅拷贝/对象赋值.png","hash":"0d4cc9c5013c26c8162cc30416f0159468895724","modified":1732353606425},{"_id":"public/2023/03/01/渲染引擎的执行原理/DOM树.png","hash":"fd3e869c13986331c13c41ac4b31afe7d411a3ad","modified":1732353606425},{"_id":"public/2023/03/01/渲染引擎的执行原理/光栅化.png","hash":"5006f59e9e35b2e0e4c189d2effb24a31ba996e7","modified":1732353606425},{"_id":"public/img/author.gif","hash":"cf943d19b12a8b2f385b206e15bf303a4192cb84","modified":1732353606425},{"_id":"public/img/d.jpg","hash":"60734d39c35c7508b005092cda695fae4433da30","modified":1732353606425},{"_id":"public/img/school (2).jpg","hash":"2ae694064ca40766bd92c77aceef5f563a9ea768","modified":1732353606425},{"_id":"public/img/sql.jpg","hash":"195c203753e5ce193ef043bc84b8243062e51f68","modified":1732353606425},{"_id":"public/img/weixin.png","hash":"6ea9d96da75c545cc1bb4b246c14a6993a6c6225","modified":1732353606425},{"_id":"public/img/变量的本质.jpg","hash":"dd230ee24932037fe16dadde9bd098de1ca86863","modified":1732353606425},{"_id":"public/2021/04/11/Git/CSSOM.png","hash":"f14fdd28df21e207586fd319041e24ddc9fbe70f","modified":1732353606425},{"_id":"public/2023/02/27/变量的本质和垃圾回收/浅拷贝.png","hash":"4d2c7adef9186574b44b3aa0cc4cb55b25eae476","modified":1732353606425},{"_id":"public/2021/04/11/服务器端/server02.png","hash":"ea4873149b4ae36f040ed1dc3be03c882105ed3f","modified":1732353606425},{"_id":"public/2023/03/01/渲染引擎的执行原理/CSSOM.png","hash":"f14fdd28df21e207586fd319041e24ddc9fbe70f","modified":1732353606425},{"_id":"public/2023/03/01/渲染引擎的执行原理/浏览器解析原理.png","hash":"280d90ef0996a95b91e0d628d9ee58a8c67edf0c","modified":1732353606425},{"_id":"public/2023/03/01/渲染引擎的执行原理/布局.png","hash":"8626f352a91d0c6d28019d46a51088d42d5f9c5c","modified":1732353606425},{"_id":"public/img/g.jpg","hash":"318da5af9e64e26fbcb718771c8340ab730fc6f3","modified":1732353606425},{"_id":"public/img/深浅拷贝.jpeg","hash":"1ed49ae324fe3913239a798bdceb01eb09394436","modified":1732353606425},{"_id":"public/2021/05/25/前后端交互模式/2.png","hash":"3c5e9cc2734945eab8f6502f6167b07ab027faa3","modified":1732353606425},{"_id":"public/2021/05/25/前后端交互模式/1.png","hash":"d159d69e7482ca5de66dd4b5e1bcf542c1a6cc32","modified":1732353606425},{"_id":"public/2021/04/11/服务器端/server03.png","hash":"ad8c54c977bbd97992e83b881998ccdd3e573adf","modified":1732353606425},{"_id":"public/img/comment.webp","hash":"8fe6376cc493cf6e86cbb5dfedd4180280fab714","modified":1732353606425},{"_id":"public/2021/05/31/Vue-路由/vueRouter.jpg","hash":"4a8985437433bc09e8667326de415474ce860d0f","modified":1732353606425},{"_id":"public/2023/02/28/原型链/原型链.png","hash":"29254fc1ff8186d4da522f2645b03c55fa0000bd","modified":1732353606425},{"_id":"public/2023/02/27/变量的本质和垃圾回收/同步和异步栈.png","hash":"735215ccb96b7b788ff40d813d894d556688b282","modified":1732353606425},{"_id":"public/2021/04/11/服务器端/server01.png","hash":"d195311354a33ced4052775261569b92f8bf65fd","modified":1732353606425},{"_id":"public/2023/03/01/渲染引擎的执行原理/重绘.png","hash":"2bb86484306cdbb6680a3f28dcd20109d9ee7931","modified":1732353606425},{"_id":"public/img/top7.jpg","hash":"f929ca03869f241831acf8ef9b5b69579ef5f2c8","modified":1732353606425},{"_id":"public/2021/04/11/服务器端/server04.png","hash":"68e8d0befff7c800c23745a32a17429e14bd8065","modified":1732353606425},{"_id":"public/2023/03/01/渲染引擎的执行原理/Tree.png","hash":"45eecf43e1e9784c491aa46dd9a200928f82be7b","modified":1732353606425},{"_id":"public/img/SOms95ABciyH3hR.gif","hash":"5fcf0b887eefd7ebbba1c8d8ee1fc5cd2ac002ad","modified":1732353606425},{"_id":"public/img/brand.gif","hash":"f67bf18567d79e66f59c21599763618e314812ac","modified":1732353606425},{"_id":"public/img/school.jpg","hash":"2ba4d0eae692a34580f1ea8ad256855a0eff3538","modified":1732353606425},{"_id":"public/img/xiaoai.gif","hash":"8a011158f4d33bcfaa1c7a00bc7bbead18f6e6f2","modified":1732353606425},{"_id":"public/2023/02/27/变量的本质和垃圾回收/任务队列.png","hash":"04cb67247e9681672d9aa06dffa5a6d726147165","modified":1732353606425},{"_id":"public/2023/03/01/渲染引擎的执行原理/DRAW QUAD.png","hash":"86d02206a048d1fbf469b142c0ca52124251a38e","modified":1732353606425},{"_id":"public/img/dog.jpg","hash":"8fad7e6e3b853eaecffd928153b9b05240c493de","modified":1732353606425},{"_id":"public/2023/03/01/渲染引擎的执行原理/分块.png","hash":"b93d829a6c871cbd7eead8177cfafbe15825bb78","modified":1732353606425},{"_id":"public/img/3.jpg","hash":"48cf3027b6b9d84379d62cbda77f6b3da8bf37b6","modified":1732353606425},{"_id":"public/img/1.jpg","hash":"088553ff0d73a22b862c248ba3a6061b06ecccae","modified":1732353606425},{"_id":"public/img/2.jpg","hash":"30e26647ac4d499dc43572e5cb8e7ffed3954054","modified":1732353606425},{"_id":"public/img/post/dify.png","hash":"9b08be27835f63ff6707bed3ba046cb078b8a652","modified":1732353606425},{"_id":"public/img/spider.jpg","hash":"10f51663231586acc38ac0b858b8f81a52f81ac8","modified":1732353606425},{"_id":"public/img/top3.jpg","hash":"a988dc0f236d233a92cd6a78ff8a45ff5b2df781","modified":1732353606425},{"_id":"public/2023/02/27/变量的本质和垃圾回收/heap.png","hash":"def9b966bf08b575305aed5e754b1524877900ff","modified":1732353606425},{"_id":"public/2023/02/27/变量的本质和垃圾回收/浏览器的进程.png","hash":"4397aca464416a12a04b7c92eea12d794c5bb0cb","modified":1732353606425},{"_id":"public/img/sass.jpg","hash":"886f0b7533c12ce12ffc49ff4c6ddc1bd2437866","modified":1732353606425},{"_id":"public/img/top6.jpg","hash":"2e50b40897cbb421fff92a4e76381fcea55885d6","modified":1732353606425},{"_id":"public/img/4.jpg","hash":"0127aa613daf55df8b191081b74fcfe2c1b28dbe","modified":1732353606425},{"_id":"public/img/top1.jpg","hash":"cc8a6ebf949373852c698ded64e9d536b94993da","modified":1732353606425},{"_id":"public/img/top.jpg","hash":"3a71d6549f617dd7fd9e7d8323514a497cfc1ebe","modified":1732353606425},{"_id":"public/img/vueRouter.jpg","hash":"c358e62c9a29679db499efb10df9207bdf2b0cca","modified":1732353606425},{"_id":"public/img/雨水.png","hash":"f4adbc12558b829b38bb1f4e841d92fa127cc8bf","modified":1732353606425},{"_id":"public/img/top5.png","hash":"a416480cab88b35b310768d7a3a07262d1c3c533","modified":1732353606425},{"_id":"public/img/小雪.png","hash":"51bba73b201c2f461bcc4c85c53d850f3a1f0764","modified":1732353606425},{"_id":"public/img/0922.jpg","hash":"cf819efb2776fd3fb0f0af77e457007433fc5bba","modified":1732353606425},{"_id":"public/img/top8.jpg","hash":"1b4593160542732a387ff0115c371cfc779d6210","modified":1732353606425},{"_id":"public/img/wallhaven-96qo3x.png","hash":"8154a0cb73de933f6e0f4d6d1253fe469c3f2601","modified":1732353606425},{"_id":"public/img/top9.jpg","hash":"70f418b9d4f5f52fad11f1ec64d3112e9dd402aa","modified":1732353606425},{"_id":"public/img/top4.png","hash":"baec70222bb37db5e6fe224b3b56bde3528b56b3","modified":1732353606425},{"_id":"public/img/top2.png","hash":"8ce68b62a1f68093079d84543129133835487d47","modified":1732353606425},{"_id":"public/img/server-banner.jpg","hash":"191525c46e4b3a6bc87dff3e0cc3e3a92ec16d4a","modified":1732353606425}],"Category":[{"name":"前端","_id":"cm3tylxpd000473t36ezb8qv2"},{"name":"后端","_id":"cm3tylxpf000973t3avgm3fbk"},{"name":"技术","_id":"cm3tylxpj000s73t3e066hgmd"},{"name":"blog","_id":"cm3tylxpk001873t34326f5q4"},{"name":"hexo","_id":"cm3tylxpm001n73t3dse30yc3"},{"name":"算法","_id":"cm3tylxpn001w73t3464rc432"},{"name":"JavaScript","_id":"cm3tylxpo002g73t36ald492y"}],"Data":[],"Page":[{"title":"最可爱的小猪","_content":"\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n  <title>小艾</title>\n  <style>\n    .searchContainer {\n      display: flex;\n      justify-content: center;\n    }\n\n    .search {\n      display: inline-block;\n      width: 2em;\n      height: 2em;\n      text-align: center;\n      border: none;\n      border-radius: 20%;\n      margin-left: 1.5em;\n    }\n\n    .search i {\n      width: 2em;\n      height: 2em;\n      font-size: 25px;\n    }\n\n    .search:hover {\n      cursor: pointer;\n    }\n\n    .searchWeather {\n      height: 2em;\n      outline: none;\n      border: none;\n      border-bottom: 1px solid #ccc;\n    }\n\n    .searchWeather:focus {\n      border-bottom: 2px solid #4285f4;\n    }\n\n    .showInfo {\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n      /* border: 2px solid #4285f4; */\n      margin-top: 3em;\n    }\n\n    .showInfo .temperature {\n      border: 2px solid #ccc;\n      border-radius: 6px;\n      font-size: 85px;\n      font-family: KaiTi, FZShuTi;\n      opacity: 0.5;\n      text-shadow: 4px 6px 2px #ccc;\n    }\n\n    .showInfo .city {\n      font-size: 30px;\n      font-family: \"Lucida Console\";\n      margin-bottom: 12px;\n    }\n\n    .showInfo .weather {\n      margin-top: 12px;\n    }\n\n    .countDown {\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n      font-size: 18px;\n      margin-top: 20px;\n    }\n\n    .countDown .container {\n      display: flex;\n      justify-content: center;\n      align-items: center;\n    }\n\n    .countDown span {\n      font-size: 40px;\n    }\n\n    .lovelyPic {\n      display: inline-block;\n      position: absolute;\n      right: -48px;\n      bottom: -15px;\n      width: 250px;\n      height: 140px;\n      background-image: url(/img/comment.webp);\n    }\n\n    @media screen and (max-width: 900px) {\n      .countDown {\n        height: 160px;\n        background-image: url(/img/comment.webp);\n        background-repeat: no-repeat;\n        background-position: 34% 0;\n      }\n\n      .lovelyPic {\n        width: 0;\n        height: 0;\n      }\n    }\n  </style>\n</head>\n\n<body>\n  <div class=\"searchContainer\">\n    <input type=\"text\" placeholder=\"输入你的城市...\" class=\"searchWeather\" autocomplete=\"off\" />\n    <span class=\"search\">\n      <i class=\"iconfont icon-search\"></i>\n    </span>\n  </div>\n  <div class=\"showInfo\">\n    <div class=\"city\"></div>\n    <div class=\"temperature\"></div>\n    <div class=\"weather\">当前的天气为：</div>\n  </div>\n  <div class=\"countDown\">\n    <div class=\"container\">\n      和我的<span style=\"font-size: 20px; color: rgb(156, 48, 48)\">小艾猪猪</span>在一起\n    </div>\n    <div class=\"timeBox\">\n      <span class=\"day\"></span>天 <span class=\"hour\"></span>时\n      <span class=\"minute\"></span>分 <span class=\"second\"></span>秒\n    </div>\n  </div>\n  <span class=\"lovelyPic\"></span>\n</body>\n<!-- 把汉字转换为拼音 -->\n<script src=\"https://cdn.jsdelivr.net/gh/zh-lx/pinyin-pro@latest/dist/pinyin-pro.js\"></script>\n<!-- 获取IP地址 -->\n<!-- <script src=\"https://pv.sohu.com/cityjson?ie=utf-8\"></script> -->\n<script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js\"></script>\n\n<script type=\"module\">\n  let input = document.querySelector(\".searchWeather\");\n    let search = document.querySelector(\".search\");\n    let weather = document.querySelector(\".weather\");\n    let temperature = document.querySelector(\".temperature\");\n    let city = document.querySelector(\".city\");\n    let countDown = document.querySelector(\".countDown\");\n    const day = document.querySelector(\".day\");\n    const hour = document.querySelector(\".hour\");\n    const minute = document.querySelector(\".minute\");\n    const second = document.querySelector(\".second\");\n\n    // 节流，防止点击多次\n    function throttle(func, wait) {\n      var previous = 0;\n      return function () {\n        let now = Date.now();\n        let context = this;\n        let args = arguments;\n        if (now - previous > wait) {\n          func.apply(context, args);\n          previous = now;\n        }\n      };\n    }\n    let address = \"\";\n    //获取ip地址\n    async function getIp(){\n      const {data} = await axios({\n        method:\"get\",\n        url:\"https://www.mxnzp.com/api/ip/self?app_id=qkojmgehinljmiur&app_secret=aU5BcjZsQStqWWNxMEtxN0w5ZlB1QT09\"\n      })\n\n      console.log(data.data.ip);\n      const ip = data.data.ip;\n      address = await axios({\n        method:\"get\",\n        url:`https://v2.alapi.cn/api/ip?ip=${ip}&token=eETQpxcYEcdBOV4Y`\n      })\n      // console.log(address.data.data.ad_info.city);\n      getInfo(address.data.data.ad_info.city)\n    }\n    // 根据ip地址先显示当前地址的天气\n    getIp();\n \n    // 获取天气信息\n    async function getInfo(chengshi = \"新余\") {\n      try {\n        var { pinyin } = pinyinPro;\n        const { data } = await axios({\n          method: \"GET\",\n          url: `https://api.seniverse.com/v3/weather/now.json?key=S8iUfojW28_QulLmE&location=${chengshi}&language=zh-Hans&unit=c`,\n        });\n        const getData = data.results[0];\n        const weatherInfo = getData.now;\n        const locationInfo = getData.location;\n        // 为页面添加数据\n        city.innerHTML = pinyin(locationInfo.name) + locationInfo.name;\n        weather.innerHTML = weather.innerHTML.substr(0, 7) + weatherInfo.text;\n        temperature.innerHTML = weatherInfo.temperature + \"℃\";\n      } catch (err) {\n        if (err.response.status === 404) {\n          alert(\"sorry,找不到所在的城市\");\n        } else if (err.response.status === 403) {\n          alert(\"欸嘿，一分钟内点太多次了\");\n        } else {\n          alert(\"啊哦，404\");\n        }\n      }\n    }\n    // 搜索特定城市天气\n    function searchInfo() {\n      let residence = input.value.trim();\n      getInfo(residence);\n    }\n    search.addEventListener(\n      \"click\",\n      throttle(function () {\n        // 判断输入框是否有内容\n        if (input.value.trim() !== \"\") {\n          searchInfo();\n          console.log(1);\n        } else alert(\"欸嘿，你忘记输入城市啦!\");\n      }, 3000)\n    );\n\n    input.addEventListener(\"keyup\", function (event) {\n      if (event.keyCode === 13) {\n        // 判断输入框是否有内容\n        if (input.value.trim() !== \"\") {\n          searchInfo();\n        } else alert(\"欸嘿，你忘记输入城市啦!\");\n      }\n    });\n\n    setInterval(() => {\n      formatDateTime();\n    }, 1000);\n    formatDateTime();\n\n    // 在一起时间的倒计时\n    function formatDateTime() {\n      let passTime = \"2019/3/17\";\n      let newDate = new Date();\n      let x = newDate.valueOf() - new Date(passTime).valueOf();\n      var d = parseInt(x / 1000 / 60 / 60 / 24);\n      d = d < 10 ? \"0\" + d : d;\n      var h = parseInt((x / 1000 / 60 / 60) % 24);\n      h = h < 10 ? \"0\" + h : h;\n      var m = parseInt((x / 1000 / 60) % 60);\n      m = m < 10 ? \"0\" + m : m;\n      var s = parseInt((x / 1000) % 60);\n      s = s < 10 ? \"0\" + s : s;\n\n      day.innerHTML = d;\n      hour.innerHTML = h;\n      minute.innerHTML = m;\n      second.innerHTML = s;\n    }\n  </script>\n\n</html>","source":"Lover/index.html","raw":"---\ntitle: 最可爱的小猪\n---\n\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n  <title>小艾</title>\n  <style>\n    .searchContainer {\n      display: flex;\n      justify-content: center;\n    }\n\n    .search {\n      display: inline-block;\n      width: 2em;\n      height: 2em;\n      text-align: center;\n      border: none;\n      border-radius: 20%;\n      margin-left: 1.5em;\n    }\n\n    .search i {\n      width: 2em;\n      height: 2em;\n      font-size: 25px;\n    }\n\n    .search:hover {\n      cursor: pointer;\n    }\n\n    .searchWeather {\n      height: 2em;\n      outline: none;\n      border: none;\n      border-bottom: 1px solid #ccc;\n    }\n\n    .searchWeather:focus {\n      border-bottom: 2px solid #4285f4;\n    }\n\n    .showInfo {\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n      /* border: 2px solid #4285f4; */\n      margin-top: 3em;\n    }\n\n    .showInfo .temperature {\n      border: 2px solid #ccc;\n      border-radius: 6px;\n      font-size: 85px;\n      font-family: KaiTi, FZShuTi;\n      opacity: 0.5;\n      text-shadow: 4px 6px 2px #ccc;\n    }\n\n    .showInfo .city {\n      font-size: 30px;\n      font-family: \"Lucida Console\";\n      margin-bottom: 12px;\n    }\n\n    .showInfo .weather {\n      margin-top: 12px;\n    }\n\n    .countDown {\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n      font-size: 18px;\n      margin-top: 20px;\n    }\n\n    .countDown .container {\n      display: flex;\n      justify-content: center;\n      align-items: center;\n    }\n\n    .countDown span {\n      font-size: 40px;\n    }\n\n    .lovelyPic {\n      display: inline-block;\n      position: absolute;\n      right: -48px;\n      bottom: -15px;\n      width: 250px;\n      height: 140px;\n      background-image: url(/img/comment.webp);\n    }\n\n    @media screen and (max-width: 900px) {\n      .countDown {\n        height: 160px;\n        background-image: url(/img/comment.webp);\n        background-repeat: no-repeat;\n        background-position: 34% 0;\n      }\n\n      .lovelyPic {\n        width: 0;\n        height: 0;\n      }\n    }\n  </style>\n</head>\n\n<body>\n  <div class=\"searchContainer\">\n    <input type=\"text\" placeholder=\"输入你的城市...\" class=\"searchWeather\" autocomplete=\"off\" />\n    <span class=\"search\">\n      <i class=\"iconfont icon-search\"></i>\n    </span>\n  </div>\n  <div class=\"showInfo\">\n    <div class=\"city\"></div>\n    <div class=\"temperature\"></div>\n    <div class=\"weather\">当前的天气为：</div>\n  </div>\n  <div class=\"countDown\">\n    <div class=\"container\">\n      和我的<span style=\"font-size: 20px; color: rgb(156, 48, 48)\">小艾猪猪</span>在一起\n    </div>\n    <div class=\"timeBox\">\n      <span class=\"day\"></span>天 <span class=\"hour\"></span>时\n      <span class=\"minute\"></span>分 <span class=\"second\"></span>秒\n    </div>\n  </div>\n  <span class=\"lovelyPic\"></span>\n</body>\n<!-- 把汉字转换为拼音 -->\n<script src=\"https://cdn.jsdelivr.net/gh/zh-lx/pinyin-pro@latest/dist/pinyin-pro.js\"></script>\n<!-- 获取IP地址 -->\n<!-- <script src=\"https://pv.sohu.com/cityjson?ie=utf-8\"></script> -->\n<script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js\"></script>\n\n<script type=\"module\">\n  let input = document.querySelector(\".searchWeather\");\n    let search = document.querySelector(\".search\");\n    let weather = document.querySelector(\".weather\");\n    let temperature = document.querySelector(\".temperature\");\n    let city = document.querySelector(\".city\");\n    let countDown = document.querySelector(\".countDown\");\n    const day = document.querySelector(\".day\");\n    const hour = document.querySelector(\".hour\");\n    const minute = document.querySelector(\".minute\");\n    const second = document.querySelector(\".second\");\n\n    // 节流，防止点击多次\n    function throttle(func, wait) {\n      var previous = 0;\n      return function () {\n        let now = Date.now();\n        let context = this;\n        let args = arguments;\n        if (now - previous > wait) {\n          func.apply(context, args);\n          previous = now;\n        }\n      };\n    }\n    let address = \"\";\n    //获取ip地址\n    async function getIp(){\n      const {data} = await axios({\n        method:\"get\",\n        url:\"https://www.mxnzp.com/api/ip/self?app_id=qkojmgehinljmiur&app_secret=aU5BcjZsQStqWWNxMEtxN0w5ZlB1QT09\"\n      })\n\n      console.log(data.data.ip);\n      const ip = data.data.ip;\n      address = await axios({\n        method:\"get\",\n        url:`https://v2.alapi.cn/api/ip?ip=${ip}&token=eETQpxcYEcdBOV4Y`\n      })\n      // console.log(address.data.data.ad_info.city);\n      getInfo(address.data.data.ad_info.city)\n    }\n    // 根据ip地址先显示当前地址的天气\n    getIp();\n \n    // 获取天气信息\n    async function getInfo(chengshi = \"新余\") {\n      try {\n        var { pinyin } = pinyinPro;\n        const { data } = await axios({\n          method: \"GET\",\n          url: `https://api.seniverse.com/v3/weather/now.json?key=S8iUfojW28_QulLmE&location=${chengshi}&language=zh-Hans&unit=c`,\n        });\n        const getData = data.results[0];\n        const weatherInfo = getData.now;\n        const locationInfo = getData.location;\n        // 为页面添加数据\n        city.innerHTML = pinyin(locationInfo.name) + locationInfo.name;\n        weather.innerHTML = weather.innerHTML.substr(0, 7) + weatherInfo.text;\n        temperature.innerHTML = weatherInfo.temperature + \"℃\";\n      } catch (err) {\n        if (err.response.status === 404) {\n          alert(\"sorry,找不到所在的城市\");\n        } else if (err.response.status === 403) {\n          alert(\"欸嘿，一分钟内点太多次了\");\n        } else {\n          alert(\"啊哦，404\");\n        }\n      }\n    }\n    // 搜索特定城市天气\n    function searchInfo() {\n      let residence = input.value.trim();\n      getInfo(residence);\n    }\n    search.addEventListener(\n      \"click\",\n      throttle(function () {\n        // 判断输入框是否有内容\n        if (input.value.trim() !== \"\") {\n          searchInfo();\n          console.log(1);\n        } else alert(\"欸嘿，你忘记输入城市啦!\");\n      }, 3000)\n    );\n\n    input.addEventListener(\"keyup\", function (event) {\n      if (event.keyCode === 13) {\n        // 判断输入框是否有内容\n        if (input.value.trim() !== \"\") {\n          searchInfo();\n        } else alert(\"欸嘿，你忘记输入城市啦!\");\n      }\n    });\n\n    setInterval(() => {\n      formatDateTime();\n    }, 1000);\n    formatDateTime();\n\n    // 在一起时间的倒计时\n    function formatDateTime() {\n      let passTime = \"2019/3/17\";\n      let newDate = new Date();\n      let x = newDate.valueOf() - new Date(passTime).valueOf();\n      var d = parseInt(x / 1000 / 60 / 60 / 24);\n      d = d < 10 ? \"0\" + d : d;\n      var h = parseInt((x / 1000 / 60 / 60) % 24);\n      h = h < 10 ? \"0\" + h : h;\n      var m = parseInt((x / 1000 / 60) % 60);\n      m = m < 10 ? \"0\" + m : m;\n      var s = parseInt((x / 1000) % 60);\n      s = s < 10 ? \"0\" + s : s;\n\n      day.innerHTML = d;\n      hour.innerHTML = h;\n      minute.innerHTML = m;\n      second.innerHTML = s;\n    }\n  </script>\n\n</html>","date":"2024-11-17T13:58:10.659Z","updated":"2024-11-17T13:58:10.659Z","path":"Lover/index.html","comments":1,"layout":"page","_id":"cm3tylxp7000073t3g7143jqi","content":"\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>小艾</title>\n  <style>\n    .searchContainer {\n      display: flex;\n      justify-content: center;\n    }\n\n    .search {\n      display: inline-block;\n      width: 2em;\n      height: 2em;\n      text-align: center;\n      border: none;\n      border-radius: 20%;\n      margin-left: 1.5em;\n    }\n\n    .search i {\n      width: 2em;\n      height: 2em;\n      font-size: 25px;\n    }\n\n    .search:hover {\n      cursor: pointer;\n    }\n\n    .searchWeather {\n      height: 2em;\n      outline: none;\n      border: none;\n      border-bottom: 1px solid #ccc;\n    }\n\n    .searchWeather:focus {\n      border-bottom: 2px solid #4285f4;\n    }\n\n    .showInfo {\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n      /* border: 2px solid #4285f4; */\n      margin-top: 3em;\n    }\n\n    .showInfo .temperature {\n      border: 2px solid #ccc;\n      border-radius: 6px;\n      font-size: 85px;\n      font-family: KaiTi, FZShuTi;\n      opacity: 0.5;\n      text-shadow: 4px 6px 2px #ccc;\n    }\n\n    .showInfo .city {\n      font-size: 30px;\n      font-family: \"Lucida Console\";\n      margin-bottom: 12px;\n    }\n\n    .showInfo .weather {\n      margin-top: 12px;\n    }\n\n    .countDown {\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n      font-size: 18px;\n      margin-top: 20px;\n    }\n\n    .countDown .container {\n      display: flex;\n      justify-content: center;\n      align-items: center;\n    }\n\n    .countDown span {\n      font-size: 40px;\n    }\n\n    .lovelyPic {\n      display: inline-block;\n      position: absolute;\n      right: -48px;\n      bottom: -15px;\n      width: 250px;\n      height: 140px;\n      background-image: url(/img/comment.webp);\n    }\n\n    @media screen and (max-width: 900px) {\n      .countDown {\n        height: 160px;\n        background-image: url(/img/comment.webp);\n        background-repeat: no-repeat;\n        background-position: 34% 0;\n      }\n\n      .lovelyPic {\n        width: 0;\n        height: 0;\n      }\n    }\n  </style>\n</head>\n\n<body>\n  <div class=\"searchContainer\">\n    <input type=\"text\" placeholder=\"输入你的城市...\" class=\"searchWeather\" autocomplete=\"off\">\n    <span class=\"search\">\n      <i class=\"iconfont icon-search\"></i>\n    </span>\n  </div>\n  <div class=\"showInfo\">\n    <div class=\"city\"></div>\n    <div class=\"temperature\"></div>\n    <div class=\"weather\">当前的天气为：</div>\n  </div>\n  <div class=\"countDown\">\n    <div class=\"container\">\n      和我的<span style=\"font-size: 20px; color: rgb(156, 48, 48)\">小艾猪猪</span>在一起\n    </div>\n    <div class=\"timeBox\">\n      <span class=\"day\"></span>天 <span class=\"hour\"></span>时\n      <span class=\"minute\"></span>分 <span class=\"second\"></span>秒\n    </div>\n  </div>\n  <span class=\"lovelyPic\"></span>\n</body>\n<!-- 把汉字转换为拼音 -->\n<script src=\"https://cdn.jsdelivr.net/gh/zh-lx/pinyin-pro@latest/dist/pinyin-pro.js\"></script>\n<!-- 获取IP地址 -->\n<!-- <script src=\"https://pv.sohu.com/cityjson?ie=utf-8\"></script> -->\n<script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js\"></script>\n\n<script type=\"module\">\n  let input = document.querySelector(\".searchWeather\");\n    let search = document.querySelector(\".search\");\n    let weather = document.querySelector(\".weather\");\n    let temperature = document.querySelector(\".temperature\");\n    let city = document.querySelector(\".city\");\n    let countDown = document.querySelector(\".countDown\");\n    const day = document.querySelector(\".day\");\n    const hour = document.querySelector(\".hour\");\n    const minute = document.querySelector(\".minute\");\n    const second = document.querySelector(\".second\");\n\n    // 节流，防止点击多次\n    function throttle(func, wait) {\n      var previous = 0;\n      return function () {\n        let now = Date.now();\n        let context = this;\n        let args = arguments;\n        if (now - previous > wait) {\n          func.apply(context, args);\n          previous = now;\n        }\n      };\n    }\n    let address = \"\";\n    //获取ip地址\n    async function getIp(){\n      const {data} = await axios({\n        method:\"get\",\n        url:\"https://www.mxnzp.com/api/ip/self?app_id=qkojmgehinljmiur&app_secret=aU5BcjZsQStqWWNxMEtxN0w5ZlB1QT09\"\n      })\n\n      console.log(data.data.ip);\n      const ip = data.data.ip;\n      address = await axios({\n        method:\"get\",\n        url:`https://v2.alapi.cn/api/ip?ip=${ip}&token=eETQpxcYEcdBOV4Y`\n      })\n      // console.log(address.data.data.ad_info.city);\n      getInfo(address.data.data.ad_info.city)\n    }\n    // 根据ip地址先显示当前地址的天气\n    getIp();\n \n    // 获取天气信息\n    async function getInfo(chengshi = \"新余\") {\n      try {\n        var { pinyin } = pinyinPro;\n        const { data } = await axios({\n          method: \"GET\",\n          url: `https://api.seniverse.com/v3/weather/now.json?key=S8iUfojW28_QulLmE&location=${chengshi}&language=zh-Hans&unit=c`,\n        });\n        const getData = data.results[0];\n        const weatherInfo = getData.now;\n        const locationInfo = getData.location;\n        // 为页面添加数据\n        city.innerHTML = pinyin(locationInfo.name) + locationInfo.name;\n        weather.innerHTML = weather.innerHTML.substr(0, 7) + weatherInfo.text;\n        temperature.innerHTML = weatherInfo.temperature + \"℃\";\n      } catch (err) {\n        if (err.response.status === 404) {\n          alert(\"sorry,找不到所在的城市\");\n        } else if (err.response.status === 403) {\n          alert(\"欸嘿，一分钟内点太多次了\");\n        } else {\n          alert(\"啊哦，404\");\n        }\n      }\n    }\n    // 搜索特定城市天气\n    function searchInfo() {\n      let residence = input.value.trim();\n      getInfo(residence);\n    }\n    search.addEventListener(\n      \"click\",\n      throttle(function () {\n        // 判断输入框是否有内容\n        if (input.value.trim() !== \"\") {\n          searchInfo();\n          console.log(1);\n        } else alert(\"欸嘿，你忘记输入城市啦!\");\n      }, 3000)\n    );\n\n    input.addEventListener(\"keyup\", function (event) {\n      if (event.keyCode === 13) {\n        // 判断输入框是否有内容\n        if (input.value.trim() !== \"\") {\n          searchInfo();\n        } else alert(\"欸嘿，你忘记输入城市啦!\");\n      }\n    });\n\n    setInterval(() => {\n      formatDateTime();\n    }, 1000);\n    formatDateTime();\n\n    // 在一起时间的倒计时\n    function formatDateTime() {\n      let passTime = \"2019/3/17\";\n      let newDate = new Date();\n      let x = newDate.valueOf() - new Date(passTime).valueOf();\n      var d = parseInt(x / 1000 / 60 / 60 / 24);\n      d = d < 10 ? \"0\" + d : d;\n      var h = parseInt((x / 1000 / 60 / 60) % 24);\n      h = h < 10 ? \"0\" + h : h;\n      var m = parseInt((x / 1000 / 60) % 60);\n      m = m < 10 ? \"0\" + m : m;\n      var s = parseInt((x / 1000) % 60);\n      s = s < 10 ? \"0\" + s : s;\n\n      day.innerHTML = d;\n      hour.innerHTML = h;\n      minute.innerHTML = m;\n      second.innerHTML = s;\n    }\n  </script>\n\n</html>","site":{"data":{}},"wordcount":3915,"excerpt":"","more":"\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>小艾</title>\n  <style>\n    .searchContainer {\n      display: flex;\n      justify-content: center;\n    }\n\n    .search {\n      display: inline-block;\n      width: 2em;\n      height: 2em;\n      text-align: center;\n      border: none;\n      border-radius: 20%;\n      margin-left: 1.5em;\n    }\n\n    .search i {\n      width: 2em;\n      height: 2em;\n      font-size: 25px;\n    }\n\n    .search:hover {\n      cursor: pointer;\n    }\n\n    .searchWeather {\n      height: 2em;\n      outline: none;\n      border: none;\n      border-bottom: 1px solid #ccc;\n    }\n\n    .searchWeather:focus {\n      border-bottom: 2px solid #4285f4;\n    }\n\n    .showInfo {\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n      /* border: 2px solid #4285f4; */\n      margin-top: 3em;\n    }\n\n    .showInfo .temperature {\n      border: 2px solid #ccc;\n      border-radius: 6px;\n      font-size: 85px;\n      font-family: KaiTi, FZShuTi;\n      opacity: 0.5;\n      text-shadow: 4px 6px 2px #ccc;\n    }\n\n    .showInfo .city {\n      font-size: 30px;\n      font-family: \"Lucida Console\";\n      margin-bottom: 12px;\n    }\n\n    .showInfo .weather {\n      margin-top: 12px;\n    }\n\n    .countDown {\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n      font-size: 18px;\n      margin-top: 20px;\n    }\n\n    .countDown .container {\n      display: flex;\n      justify-content: center;\n      align-items: center;\n    }\n\n    .countDown span {\n      font-size: 40px;\n    }\n\n    .lovelyPic {\n      display: inline-block;\n      position: absolute;\n      right: -48px;\n      bottom: -15px;\n      width: 250px;\n      height: 140px;\n      background-image: url(/img/comment.webp);\n    }\n\n    @media screen and (max-width: 900px) {\n      .countDown {\n        height: 160px;\n        background-image: url(/img/comment.webp);\n        background-repeat: no-repeat;\n        background-position: 34% 0;\n      }\n\n      .lovelyPic {\n        width: 0;\n        height: 0;\n      }\n    }\n  </style>\n</head>\n\n<body>\n  <div class=\"searchContainer\">\n    <input type=\"text\" placeholder=\"输入你的城市...\" class=\"searchWeather\" autocomplete=\"off\">\n    <span class=\"search\">\n      <i class=\"iconfont icon-search\"></i>\n    </span>\n  </div>\n  <div class=\"showInfo\">\n    <div class=\"city\"></div>\n    <div class=\"temperature\"></div>\n    <div class=\"weather\">当前的天气为：</div>\n  </div>\n  <div class=\"countDown\">\n    <div class=\"container\">\n      和我的<span style=\"font-size: 20px; color: rgb(156, 48, 48)\">小艾猪猪</span>在一起\n    </div>\n    <div class=\"timeBox\">\n      <span class=\"day\"></span>天 <span class=\"hour\"></span>时\n      <span class=\"minute\"></span>分 <span class=\"second\"></span>秒\n    </div>\n  </div>\n  <span class=\"lovelyPic\"></span>\n</body>\n<!-- 把汉字转换为拼音 -->\n<script src=\"https://cdn.jsdelivr.net/gh/zh-lx/pinyin-pro@latest/dist/pinyin-pro.js\"></script>\n<!-- 获取IP地址 -->\n<!-- <script src=\"https://pv.sohu.com/cityjson?ie=utf-8\"></script> -->\n<script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js\"></script>\n\n<script type=\"module\">\n  let input = document.querySelector(\".searchWeather\");\n    let search = document.querySelector(\".search\");\n    let weather = document.querySelector(\".weather\");\n    let temperature = document.querySelector(\".temperature\");\n    let city = document.querySelector(\".city\");\n    let countDown = document.querySelector(\".countDown\");\n    const day = document.querySelector(\".day\");\n    const hour = document.querySelector(\".hour\");\n    const minute = document.querySelector(\".minute\");\n    const second = document.querySelector(\".second\");\n\n    // 节流，防止点击多次\n    function throttle(func, wait) {\n      var previous = 0;\n      return function () {\n        let now = Date.now();\n        let context = this;\n        let args = arguments;\n        if (now - previous > wait) {\n          func.apply(context, args);\n          previous = now;\n        }\n      };\n    }\n    let address = \"\";\n    //获取ip地址\n    async function getIp(){\n      const {data} = await axios({\n        method:\"get\",\n        url:\"https://www.mxnzp.com/api/ip/self?app_id=qkojmgehinljmiur&app_secret=aU5BcjZsQStqWWNxMEtxN0w5ZlB1QT09\"\n      })\n\n      console.log(data.data.ip);\n      const ip = data.data.ip;\n      address = await axios({\n        method:\"get\",\n        url:`https://v2.alapi.cn/api/ip?ip=${ip}&token=eETQpxcYEcdBOV4Y`\n      })\n      // console.log(address.data.data.ad_info.city);\n      getInfo(address.data.data.ad_info.city)\n    }\n    // 根据ip地址先显示当前地址的天气\n    getIp();\n \n    // 获取天气信息\n    async function getInfo(chengshi = \"新余\") {\n      try {\n        var { pinyin } = pinyinPro;\n        const { data } = await axios({\n          method: \"GET\",\n          url: `https://api.seniverse.com/v3/weather/now.json?key=S8iUfojW28_QulLmE&location=${chengshi}&language=zh-Hans&unit=c`,\n        });\n        const getData = data.results[0];\n        const weatherInfo = getData.now;\n        const locationInfo = getData.location;\n        // 为页面添加数据\n        city.innerHTML = pinyin(locationInfo.name) + locationInfo.name;\n        weather.innerHTML = weather.innerHTML.substr(0, 7) + weatherInfo.text;\n        temperature.innerHTML = weatherInfo.temperature + \"℃\";\n      } catch (err) {\n        if (err.response.status === 404) {\n          alert(\"sorry,找不到所在的城市\");\n        } else if (err.response.status === 403) {\n          alert(\"欸嘿，一分钟内点太多次了\");\n        } else {\n          alert(\"啊哦，404\");\n        }\n      }\n    }\n    // 搜索特定城市天气\n    function searchInfo() {\n      let residence = input.value.trim();\n      getInfo(residence);\n    }\n    search.addEventListener(\n      \"click\",\n      throttle(function () {\n        // 判断输入框是否有内容\n        if (input.value.trim() !== \"\") {\n          searchInfo();\n          console.log(1);\n        } else alert(\"欸嘿，你忘记输入城市啦!\");\n      }, 3000)\n    );\n\n    input.addEventListener(\"keyup\", function (event) {\n      if (event.keyCode === 13) {\n        // 判断输入框是否有内容\n        if (input.value.trim() !== \"\") {\n          searchInfo();\n        } else alert(\"欸嘿，你忘记输入城市啦!\");\n      }\n    });\n\n    setInterval(() => {\n      formatDateTime();\n    }, 1000);\n    formatDateTime();\n\n    // 在一起时间的倒计时\n    function formatDateTime() {\n      let passTime = \"2019/3/17\";\n      let newDate = new Date();\n      let x = newDate.valueOf() - new Date(passTime).valueOf();\n      var d = parseInt(x / 1000 / 60 / 60 / 24);\n      d = d < 10 ? \"0\" + d : d;\n      var h = parseInt((x / 1000 / 60 / 60) % 24);\n      h = h < 10 ? \"0\" + h : h;\n      var m = parseInt((x / 1000 / 60) % 60);\n      m = m < 10 ? \"0\" + m : m;\n      var s = parseInt((x / 1000) % 60);\n      s = s < 10 ? \"0\" + s : s;\n\n      day.innerHTML = d;\n      hour.innerHTML = h;\n      minute.innerHTML = m;\n      second.innerHTML = s;\n    }\n  </script>\n\n</html>"},{"title":"about","date":"2020-02-23T11:20:33.000Z","layout":"about","_content":"\n**关于我**\n\n> <strong>享受生活，不断成长</strong>\n\n<div style=\"font-size: 2em;border-bottom:1px solid #ccc;margin-top:2em;margin-bottom:.75em\"> 🎉 联系方式</div>\n\n- Emil：1742969779@qq.com\n- GitHub: [https://github.com/badspider7](https://github.com/badspider7)\n\n<!-- <div style=\"font-size: 2em;border-bottom:1px solid #ccc;margin-top:2em;margin-bottom:.75em\"> 🎄 我的兴趣</div>\n\n- 🦹Electron\\Rust\\Tauri\n- 🎮 炉石\\lol\n- 📖 阅读\n- 👂 网易云 -->\n\n<div style=\"font-size: 2em;border-bottom:1px solid #ccc;margin-top:2em;margin-bottom:.75em\"> 🏆关于博客</div>\n\n萌生这个想法还是在我大一的时候，那个时候喜欢捣鼓东西，觉着程序员怎么能没有自己的博客，各种花里胡哨的功能都往博客上面加，也因此积累了很多 hexo 的经验，第一次通过自己的技能赚钱，但是写文章这个事情却没有坚持下来；发现随着年龄的增大，对一些新奇事物的动手欲望没有以前那么强了，很多事情都变的功利性，很急躁。\n\n现在把这当成记录自己成长的地方，记录一些自己觉得有意思的东西，不论是技术文章还是生活，希望能够**坚持初心，不断成长**。\n要多问为什么，以及多去尝试，多去实践，多去思考，多去总结，多去沉淀，多去分享。\n\n</div>\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-02-23 19:20:33\nlayout: about\n---\n\n**关于我**\n\n> <strong>享受生活，不断成长</strong>\n\n<div style=\"font-size: 2em;border-bottom:1px solid #ccc;margin-top:2em;margin-bottom:.75em\"> 🎉 联系方式</div>\n\n- Emil：1742969779@qq.com\n- GitHub: [https://github.com/badspider7](https://github.com/badspider7)\n\n<!-- <div style=\"font-size: 2em;border-bottom:1px solid #ccc;margin-top:2em;margin-bottom:.75em\"> 🎄 我的兴趣</div>\n\n- 🦹Electron\\Rust\\Tauri\n- 🎮 炉石\\lol\n- 📖 阅读\n- 👂 网易云 -->\n\n<div style=\"font-size: 2em;border-bottom:1px solid #ccc;margin-top:2em;margin-bottom:.75em\"> 🏆关于博客</div>\n\n萌生这个想法还是在我大一的时候，那个时候喜欢捣鼓东西，觉着程序员怎么能没有自己的博客，各种花里胡哨的功能都往博客上面加，也因此积累了很多 hexo 的经验，第一次通过自己的技能赚钱，但是写文章这个事情却没有坚持下来；发现随着年龄的增大，对一些新奇事物的动手欲望没有以前那么强了，很多事情都变的功利性，很急躁。\n\n现在把这当成记录自己成长的地方，记录一些自己觉得有意思的东西，不论是技术文章还是生活，希望能够**坚持初心，不断成长**。\n要多问为什么，以及多去尝试，多去实践，多去思考，多去总结，多去沉淀，多去分享。\n\n</div>\n","updated":"2024-11-17T13:58:10.690Z","path":"about/index.html","comments":1,"_id":"cm3tylxpc000273t38ds68y8s","content":"<p><strong>关于我</strong></p>\n<blockquote>\n<p><strong>享受生活，不断成长</strong></p>\n</blockquote>\n<div style=\"font-size: 2em;border-bottom:1px solid #ccc;margin-top:2em;margin-bottom:.75em\"> 🎉 联系方式</div>\n\n<ul>\n<li>Emil：<a href=\"mailto:&#x31;&#x37;&#52;&#x32;&#57;&#x36;&#x39;&#x37;&#55;&#57;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;\">&#x31;&#x37;&#52;&#x32;&#57;&#x36;&#x39;&#x37;&#55;&#57;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;</a></li>\n<li>GitHub: <a href=\"https://github.com/badspider7\">https://github.com/badspider7</a></li>\n</ul>\n<!-- <div style=\"font-size: 2em;border-bottom:1px solid #ccc;margin-top:2em;margin-bottom:.75em\"> 🎄 我的兴趣</div>\n\n- 🦹Electron\\Rust\\Tauri\n- 🎮 炉石\\lol\n- 📖 阅读\n- 👂 网易云 -->\n\n<div style=\"font-size: 2em;border-bottom:1px solid #ccc;margin-top:2em;margin-bottom:.75em\"> 🏆关于博客</div>\n\n<p>萌生这个想法还是在我大一的时候，那个时候喜欢捣鼓东西，觉着程序员怎么能没有自己的博客，各种花里胡哨的功能都往博客上面加，也因此积累了很多 hexo 的经验，第一次通过自己的技能赚钱，但是写文章这个事情却没有坚持下来；发现随着年龄的增大，对一些新奇事物的动手欲望没有以前那么强了，很多事情都变的功利性，很急躁。</p>\n<p>现在把这当成记录自己成长的地方，记录一些自己觉得有意思的东西，不论是技术文章还是生活，希望能够<strong>坚持初心，不断成长</strong>。<br>要多问为什么，以及多去尝试，多去实践，多去思考，多去总结，多去沉淀，多去分享。</p>\n\n","site":{"data":{}},"wordcount":408,"excerpt":"","more":"<p><strong>关于我</strong></p>\n<blockquote>\n<p><strong>享受生活，不断成长</strong></p>\n</blockquote>\n<div style=\"font-size: 2em;border-bottom:1px solid #ccc;margin-top:2em;margin-bottom:.75em\"> 🎉 联系方式</div>\n\n<ul>\n<li>Emil：<a href=\"mailto:&#x31;&#x37;&#52;&#x32;&#57;&#x36;&#x39;&#x37;&#55;&#57;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;\">&#x31;&#x37;&#52;&#x32;&#57;&#x36;&#x39;&#x37;&#55;&#57;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;</a></li>\n<li>GitHub: <a href=\"https://github.com/badspider7\">https://github.com/badspider7</a></li>\n</ul>\n<!-- <div style=\"font-size: 2em;border-bottom:1px solid #ccc;margin-top:2em;margin-bottom:.75em\"> 🎄 我的兴趣</div>\n\n- 🦹Electron\\Rust\\Tauri\n- 🎮 炉石\\lol\n- 📖 阅读\n- 👂 网易云 -->\n\n<div style=\"font-size: 2em;border-bottom:1px solid #ccc;margin-top:2em;margin-bottom:.75em\"> 🏆关于博客</div>\n\n<p>萌生这个想法还是在我大一的时候，那个时候喜欢捣鼓东西，觉着程序员怎么能没有自己的博客，各种花里胡哨的功能都往博客上面加，也因此积累了很多 hexo 的经验，第一次通过自己的技能赚钱，但是写文章这个事情却没有坚持下来；发现随着年龄的增大，对一些新奇事物的动手欲望没有以前那么强了，很多事情都变的功利性，很急躁。</p>\n<p>现在把这当成记录自己成长的地方，记录一些自己觉得有意思的东西，不论是技术文章还是生活，希望能够<strong>坚持初心，不断成长</strong>。<br>要多问为什么，以及多去尝试，多去实践，多去思考，多去总结，多去沉淀，多去分享。</p>\n\n"}],"Post":[{"title":"Electron入门","date":"2023-06-07T15:37:11.000Z","index_img":"/img/electron.jpeg","banner_img":"/img/electron.jpeg","_content":"//ready:app 初始化完成\n\ndom-ready:一个窗口中的文本加载完成\n\ndid-finish-load:导航完成时触发\n\nwindow-all-closed:所有窗口都被关闭时触发\n\nbefore-quit:在关闭窗口之前出发\n\nwill-quit:在窗口关闭并且应用退出时触发\n\nquit:当所有窗口被关闭时触发\n\nclosed：当窗口关闭时触发，此时应删除窗口引用\n\n\n\n```js\nconst { app, BrowserWindow } = require('electron')\n\n//当app启动之后，执行窗口创建等操作\napp.whenReady().then(() => {\n    const mainWin = new BrowserWindow({\n        width: 600,\n        height:400\n    })\n\n    //在当前窗口页面加载指定内容\n    mainWin.loadFile('index.html')\n\n    //监听当前窗口的关闭\n    mainWin.on('close', () => {\n        console.log('close')\n    })\n})\n\n//当所有窗口都关闭的时候\napp.on('window-all-closed', () => {\n    console.log('all window is closed')\n    app.quit()\n})\n```\n\n### 主进程和渲染进程通信\n\n利用   **IPCMain和IPCRenderer** ，其中分为以下几种：\n\n一. 主进程给所有渲染进程发消息\n\n\n\n```js\n//主进程\nIPCMain.send('message','some message');\n\n//渲染进程\nIPCRenderer.on('message',(event,data)=>{\n\tconsole.log('get mesaage:',data)\n})\n```\n\n二. 渲染进程给主进程发消息(双向)\n\n通过将 [`ipcRenderer.invoke`](https://www.electronjs.org/zh/docs/latest/api/ipc-renderer#ipcrendererinvokechannel-args) 与 [`ipcMain.handle`](https://www.electronjs.org/zh/docs/latest/api/ipc-main#ipcmainhandlechannel-listener) 搭配使用来完成。\n\n```js\n//preload\nconst { contextBridge, ipcRenderer } = require('electron')\n\ncontextBridge.exposeInMainWorld('electronAPI', {\n  openFile: () => ipcRenderer.invoke('dialog:openFile')\n})\n```\n\n```js\n//主进程\nIPCMain.handle('dialog:openFile',HandleOpenFile)\n\n//渲染进程\nconst filePath = await window.electronAPI.openFile()\n```\n\n\n\n三. 渲染进程给主进程发消息(单向)\n\n通过**IPCRenderer.send** API 给主进程发送消息,主进程通过 **IPCMain.on**来接收渲染进程发送的消息\n\n```js\n//主进程中\nIPCMain.on('message',(event,data)=>{\n    //渲染进程\n\tconst webContents = event.sender\n    //主页面\n   const win = BrowserWindow.fromWebContents(webContents)\n    win.setTitle(title)\n})\n```\n\n```js\n//preload\nconst { contextBridge, ipcRenderer } = require('electron')\n\ncontextBridge.exposeInMainWorld('electronAPI', {\n  sendMessage: (title) => ipcRenderer.send('message', title)\n})\n```\n\n```js\n//render.js\nwindow.electronAPI.sendMessage(title)\n```\n\n四. 主进程给渲染进程\n\n将消息从主进程发送到渲染器进程时，需要指定是哪一个渲染器接收消息。 消息需要通过其 [`WebContents`](https://www.electronjs.org/zh/docs/latest/api/web-contents) 实例发送到渲染器进程。 此 WebContents 实例包含一个 [`send`](https://www.electronjs.org/zh/docs/latest/api/web-contents#contentssendchannel-args) 方法，其使用方式与 `ipcRenderer.send` 相同。\n\n使用 `webContents.send` API 将 IPC 消息从主进程发送到目标渲染器\n\n```js\n//render.js\nwindow.electronAPI.handleCounter((event, value) => {\n  const oldValue = Number(counter.innerText)\n  const newValue = oldValue + value\n  counter.innerText = newValue\n  event.sender.send('counter-value', newValue)\n})\n\n//preload\nconst { contextBridge, ipcRenderer } = require('electron')\n\ncontextBridge.exposeInMainWorld('electronAPI', {\n  handleCounter: (callback) => ipcRenderer.on('update-counter', callback)\n})\n\n\n//MainProcess\nmainWindow.webContents.send('update-counter', 1)\n```\n\n五. 渲染进程给渲染进程\n\n没有直接的方法可以使用 `ipcMain` 和 `ipcRenderer` 模块在 Electron 中的渲染器进程之间发送消息。 为此，您有两种选择：\n\n- 将主进程作为渲染器之间的消息代理。 这需要将消息从一个渲染器发送到主进程，然后主进程将消息转发到另一个渲染器。\n\n","source":"_posts/Electron入门.md","raw":"---\ntitle: Electron入门\ndate: 2023-06-07 23:37:11\ntags: Electron\ncategories: 前端\nindex_img: /img/electron.jpeg\nbanner_img: /img/electron.jpeg\n---\n//ready:app 初始化完成\n\ndom-ready:一个窗口中的文本加载完成\n\ndid-finish-load:导航完成时触发\n\nwindow-all-closed:所有窗口都被关闭时触发\n\nbefore-quit:在关闭窗口之前出发\n\nwill-quit:在窗口关闭并且应用退出时触发\n\nquit:当所有窗口被关闭时触发\n\nclosed：当窗口关闭时触发，此时应删除窗口引用\n\n\n\n```js\nconst { app, BrowserWindow } = require('electron')\n\n//当app启动之后，执行窗口创建等操作\napp.whenReady().then(() => {\n    const mainWin = new BrowserWindow({\n        width: 600,\n        height:400\n    })\n\n    //在当前窗口页面加载指定内容\n    mainWin.loadFile('index.html')\n\n    //监听当前窗口的关闭\n    mainWin.on('close', () => {\n        console.log('close')\n    })\n})\n\n//当所有窗口都关闭的时候\napp.on('window-all-closed', () => {\n    console.log('all window is closed')\n    app.quit()\n})\n```\n\n### 主进程和渲染进程通信\n\n利用   **IPCMain和IPCRenderer** ，其中分为以下几种：\n\n一. 主进程给所有渲染进程发消息\n\n\n\n```js\n//主进程\nIPCMain.send('message','some message');\n\n//渲染进程\nIPCRenderer.on('message',(event,data)=>{\n\tconsole.log('get mesaage:',data)\n})\n```\n\n二. 渲染进程给主进程发消息(双向)\n\n通过将 [`ipcRenderer.invoke`](https://www.electronjs.org/zh/docs/latest/api/ipc-renderer#ipcrendererinvokechannel-args) 与 [`ipcMain.handle`](https://www.electronjs.org/zh/docs/latest/api/ipc-main#ipcmainhandlechannel-listener) 搭配使用来完成。\n\n```js\n//preload\nconst { contextBridge, ipcRenderer } = require('electron')\n\ncontextBridge.exposeInMainWorld('electronAPI', {\n  openFile: () => ipcRenderer.invoke('dialog:openFile')\n})\n```\n\n```js\n//主进程\nIPCMain.handle('dialog:openFile',HandleOpenFile)\n\n//渲染进程\nconst filePath = await window.electronAPI.openFile()\n```\n\n\n\n三. 渲染进程给主进程发消息(单向)\n\n通过**IPCRenderer.send** API 给主进程发送消息,主进程通过 **IPCMain.on**来接收渲染进程发送的消息\n\n```js\n//主进程中\nIPCMain.on('message',(event,data)=>{\n    //渲染进程\n\tconst webContents = event.sender\n    //主页面\n   const win = BrowserWindow.fromWebContents(webContents)\n    win.setTitle(title)\n})\n```\n\n```js\n//preload\nconst { contextBridge, ipcRenderer } = require('electron')\n\ncontextBridge.exposeInMainWorld('electronAPI', {\n  sendMessage: (title) => ipcRenderer.send('message', title)\n})\n```\n\n```js\n//render.js\nwindow.electronAPI.sendMessage(title)\n```\n\n四. 主进程给渲染进程\n\n将消息从主进程发送到渲染器进程时，需要指定是哪一个渲染器接收消息。 消息需要通过其 [`WebContents`](https://www.electronjs.org/zh/docs/latest/api/web-contents) 实例发送到渲染器进程。 此 WebContents 实例包含一个 [`send`](https://www.electronjs.org/zh/docs/latest/api/web-contents#contentssendchannel-args) 方法，其使用方式与 `ipcRenderer.send` 相同。\n\n使用 `webContents.send` API 将 IPC 消息从主进程发送到目标渲染器\n\n```js\n//render.js\nwindow.electronAPI.handleCounter((event, value) => {\n  const oldValue = Number(counter.innerText)\n  const newValue = oldValue + value\n  counter.innerText = newValue\n  event.sender.send('counter-value', newValue)\n})\n\n//preload\nconst { contextBridge, ipcRenderer } = require('electron')\n\ncontextBridge.exposeInMainWorld('electronAPI', {\n  handleCounter: (callback) => ipcRenderer.on('update-counter', callback)\n})\n\n\n//MainProcess\nmainWindow.webContents.send('update-counter', 1)\n```\n\n五. 渲染进程给渲染进程\n\n没有直接的方法可以使用 `ipcMain` 和 `ipcRenderer` 模块在 Electron 中的渲染器进程之间发送消息。 为此，您有两种选择：\n\n- 将主进程作为渲染器之间的消息代理。 这需要将消息从一个渲染器发送到主进程，然后主进程将消息转发到另一个渲染器。\n\n","slug":"Electron入门","published":1,"updated":"2024-11-17T13:58:10.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpa000173t3cdqtfgxu","content":"<p>//ready:app 初始化完成</p>\n<p>dom-ready:一个窗口中的文本加载完成</p>\n<p>did-finish-load:导航完成时触发</p>\n<p>window-all-closed:所有窗口都被关闭时触发</p>\n<p>before-quit:在关闭窗口之前出发</p>\n<p>will-quit:在窗口关闭并且应用退出时触发</p>\n<p>quit:当所有窗口被关闭时触发</p>\n<p>closed：当窗口关闭时触发，此时应删除窗口引用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> &#123; app, <span class=\"hljs-title class_\">BrowserWindow</span> &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>)<br><br><span class=\"hljs-comment\">//当app启动之后，执行窗口创建等操作</span><br>app.<span class=\"hljs-title function_\">whenReady</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> mainWin = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BrowserWindow</span>(&#123;<br>        <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">600</span>,<br>        <span class=\"hljs-attr\">height</span>:<span class=\"hljs-number\">400</span><br>    &#125;)<br><br>    <span class=\"hljs-comment\">//在当前窗口页面加载指定内容</span><br>    mainWin.<span class=\"hljs-title function_\">loadFile</span>(<span class=\"hljs-string\">&#x27;index.html&#x27;</span>)<br><br>    <span class=\"hljs-comment\">//监听当前窗口的关闭</span><br>    mainWin.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>)<br>    &#125;)<br>&#125;)<br><br><span class=\"hljs-comment\">//当所有窗口都关闭的时候</span><br>app.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;window-all-closed&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;all window is closed&#x27;</span>)<br>    app.<span class=\"hljs-title function_\">quit</span>()<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"主进程和渲染进程通信\"><a href=\"#主进程和渲染进程通信\" class=\"headerlink\" title=\"主进程和渲染进程通信\"></a>主进程和渲染进程通信</h3><p>利用   <strong>IPCMain和IPCRenderer</strong> ，其中分为以下几种：</p>\n<p>一. 主进程给所有渲染进程发消息</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//主进程</span><br><span class=\"hljs-title class_\">IPCMain</span>.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>,<span class=\"hljs-string\">&#x27;some message&#x27;</span>);<br><br><span class=\"hljs-comment\">//渲染进程</span><br><span class=\"hljs-title class_\">IPCRenderer</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>,<span class=\"hljs-function\">(<span class=\"hljs-params\">event,data</span>)=&gt;</span>&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;get mesaage:&#x27;</span>,data)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>二. 渲染进程给主进程发消息(双向)</p>\n<p>通过将 <a href=\"https://www.electronjs.org/zh/docs/latest/api/ipc-renderer#ipcrendererinvokechannel-args\"><code>ipcRenderer.invoke</code></a> 与 <a href=\"https://www.electronjs.org/zh/docs/latest/api/ipc-main#ipcmainhandlechannel-listener\"><code>ipcMain.handle</code></a> 搭配使用来完成。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//preload</span><br><span class=\"hljs-keyword\">const</span> &#123; contextBridge, ipcRenderer &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>)<br><br>contextBridge.<span class=\"hljs-title function_\">exposeInMainWorld</span>(<span class=\"hljs-string\">&#x27;electronAPI&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">openFile</span>: <span class=\"hljs-function\">() =&gt;</span> ipcRenderer.<span class=\"hljs-title function_\">invoke</span>(<span class=\"hljs-string\">&#x27;dialog:openFile&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//主进程</span><br><span class=\"hljs-title class_\">IPCMain</span>.<span class=\"hljs-title function_\">handle</span>(<span class=\"hljs-string\">&#x27;dialog:openFile&#x27;</span>,<span class=\"hljs-title class_\">HandleOpenFile</span>)<br><br><span class=\"hljs-comment\">//渲染进程</span><br><span class=\"hljs-keyword\">const</span> filePath = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">electronAPI</span>.<span class=\"hljs-title function_\">openFile</span>()<br></code></pre></td></tr></table></figure>\n\n\n\n<p>三. 渲染进程给主进程发消息(单向)</p>\n<p>通过<strong>IPCRenderer.send</strong> API 给主进程发送消息,主进程通过 <strong>IPCMain.on</strong>来接收渲染进程发送的消息</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//主进程中</span><br><span class=\"hljs-title class_\">IPCMain</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>,<span class=\"hljs-function\">(<span class=\"hljs-params\">event,data</span>)=&gt;</span>&#123;<br>    <span class=\"hljs-comment\">//渲染进程</span><br>\t<span class=\"hljs-keyword\">const</span> webContents = event.<span class=\"hljs-property\">sender</span><br>    <span class=\"hljs-comment\">//主页面</span><br>   <span class=\"hljs-keyword\">const</span> win = <span class=\"hljs-title class_\">BrowserWindow</span>.<span class=\"hljs-title function_\">fromWebContents</span>(webContents)<br>    win.<span class=\"hljs-title function_\">setTitle</span>(title)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//preload</span><br><span class=\"hljs-keyword\">const</span> &#123; contextBridge, ipcRenderer &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>)<br><br>contextBridge.<span class=\"hljs-title function_\">exposeInMainWorld</span>(<span class=\"hljs-string\">&#x27;electronAPI&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">sendMessage</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">title</span>) =&gt;</span> ipcRenderer.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>, title)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//render.js</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">electronAPI</span>.<span class=\"hljs-title function_\">sendMessage</span>(title)<br></code></pre></td></tr></table></figure>\n\n<p>四. 主进程给渲染进程</p>\n<p>将消息从主进程发送到渲染器进程时，需要指定是哪一个渲染器接收消息。 消息需要通过其 <a href=\"https://www.electronjs.org/zh/docs/latest/api/web-contents\"><code>WebContents</code></a> 实例发送到渲染器进程。 此 WebContents 实例包含一个 <a href=\"https://www.electronjs.org/zh/docs/latest/api/web-contents#contentssendchannel-args\"><code>send</code></a> 方法，其使用方式与 <code>ipcRenderer.send</code> 相同。</p>\n<p>使用 <code>webContents.send</code> API 将 IPC 消息从主进程发送到目标渲染器</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//render.js</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">electronAPI</span>.<span class=\"hljs-title function_\">handleCounter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">event, value</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> oldValue = <span class=\"hljs-title class_\">Number</span>(counter.<span class=\"hljs-property\">innerText</span>)<br>  <span class=\"hljs-keyword\">const</span> newValue = oldValue + value<br>  counter.<span class=\"hljs-property\">innerText</span> = newValue<br>  event.<span class=\"hljs-property\">sender</span>.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&#x27;counter-value&#x27;</span>, newValue)<br>&#125;)<br><br><span class=\"hljs-comment\">//preload</span><br><span class=\"hljs-keyword\">const</span> &#123; contextBridge, ipcRenderer &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>)<br><br>contextBridge.<span class=\"hljs-title function_\">exposeInMainWorld</span>(<span class=\"hljs-string\">&#x27;electronAPI&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">handleCounter</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">callback</span>) =&gt;</span> ipcRenderer.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;update-counter&#x27;</span>, callback)<br>&#125;)<br><br><br><span class=\"hljs-comment\">//MainProcess</span><br>mainWindow.<span class=\"hljs-property\">webContents</span>.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&#x27;update-counter&#x27;</span>, <span class=\"hljs-number\">1</span>)<br></code></pre></td></tr></table></figure>\n\n<p>五. 渲染进程给渲染进程</p>\n<p>没有直接的方法可以使用 <code>ipcMain</code> 和 <code>ipcRenderer</code> 模块在 Electron 中的渲染器进程之间发送消息。 为此，您有两种选择：</p>\n<ul>\n<li>将主进程作为渲染器之间的消息代理。 这需要将消息从一个渲染器发送到主进程，然后主进程将消息转发到另一个渲染器。</li>\n</ul>\n","site":{"data":{}},"wordcount":2679,"excerpt":"","more":"<p>//ready:app 初始化完成</p>\n<p>dom-ready:一个窗口中的文本加载完成</p>\n<p>did-finish-load:导航完成时触发</p>\n<p>window-all-closed:所有窗口都被关闭时触发</p>\n<p>before-quit:在关闭窗口之前出发</p>\n<p>will-quit:在窗口关闭并且应用退出时触发</p>\n<p>quit:当所有窗口被关闭时触发</p>\n<p>closed：当窗口关闭时触发，此时应删除窗口引用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> &#123; app, <span class=\"hljs-title class_\">BrowserWindow</span> &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>)<br><br><span class=\"hljs-comment\">//当app启动之后，执行窗口创建等操作</span><br>app.<span class=\"hljs-title function_\">whenReady</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> mainWin = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BrowserWindow</span>(&#123;<br>        <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">600</span>,<br>        <span class=\"hljs-attr\">height</span>:<span class=\"hljs-number\">400</span><br>    &#125;)<br><br>    <span class=\"hljs-comment\">//在当前窗口页面加载指定内容</span><br>    mainWin.<span class=\"hljs-title function_\">loadFile</span>(<span class=\"hljs-string\">&#x27;index.html&#x27;</span>)<br><br>    <span class=\"hljs-comment\">//监听当前窗口的关闭</span><br>    mainWin.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>)<br>    &#125;)<br>&#125;)<br><br><span class=\"hljs-comment\">//当所有窗口都关闭的时候</span><br>app.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;window-all-closed&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;all window is closed&#x27;</span>)<br>    app.<span class=\"hljs-title function_\">quit</span>()<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"主进程和渲染进程通信\"><a href=\"#主进程和渲染进程通信\" class=\"headerlink\" title=\"主进程和渲染进程通信\"></a>主进程和渲染进程通信</h3><p>利用   <strong>IPCMain和IPCRenderer</strong> ，其中分为以下几种：</p>\n<p>一. 主进程给所有渲染进程发消息</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//主进程</span><br><span class=\"hljs-title class_\">IPCMain</span>.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>,<span class=\"hljs-string\">&#x27;some message&#x27;</span>);<br><br><span class=\"hljs-comment\">//渲染进程</span><br><span class=\"hljs-title class_\">IPCRenderer</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>,<span class=\"hljs-function\">(<span class=\"hljs-params\">event,data</span>)=&gt;</span>&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;get mesaage:&#x27;</span>,data)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>二. 渲染进程给主进程发消息(双向)</p>\n<p>通过将 <a href=\"https://www.electronjs.org/zh/docs/latest/api/ipc-renderer#ipcrendererinvokechannel-args\"><code>ipcRenderer.invoke</code></a> 与 <a href=\"https://www.electronjs.org/zh/docs/latest/api/ipc-main#ipcmainhandlechannel-listener\"><code>ipcMain.handle</code></a> 搭配使用来完成。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//preload</span><br><span class=\"hljs-keyword\">const</span> &#123; contextBridge, ipcRenderer &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>)<br><br>contextBridge.<span class=\"hljs-title function_\">exposeInMainWorld</span>(<span class=\"hljs-string\">&#x27;electronAPI&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">openFile</span>: <span class=\"hljs-function\">() =&gt;</span> ipcRenderer.<span class=\"hljs-title function_\">invoke</span>(<span class=\"hljs-string\">&#x27;dialog:openFile&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//主进程</span><br><span class=\"hljs-title class_\">IPCMain</span>.<span class=\"hljs-title function_\">handle</span>(<span class=\"hljs-string\">&#x27;dialog:openFile&#x27;</span>,<span class=\"hljs-title class_\">HandleOpenFile</span>)<br><br><span class=\"hljs-comment\">//渲染进程</span><br><span class=\"hljs-keyword\">const</span> filePath = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">electronAPI</span>.<span class=\"hljs-title function_\">openFile</span>()<br></code></pre></td></tr></table></figure>\n\n\n\n<p>三. 渲染进程给主进程发消息(单向)</p>\n<p>通过<strong>IPCRenderer.send</strong> API 给主进程发送消息,主进程通过 <strong>IPCMain.on</strong>来接收渲染进程发送的消息</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//主进程中</span><br><span class=\"hljs-title class_\">IPCMain</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>,<span class=\"hljs-function\">(<span class=\"hljs-params\">event,data</span>)=&gt;</span>&#123;<br>    <span class=\"hljs-comment\">//渲染进程</span><br>\t<span class=\"hljs-keyword\">const</span> webContents = event.<span class=\"hljs-property\">sender</span><br>    <span class=\"hljs-comment\">//主页面</span><br>   <span class=\"hljs-keyword\">const</span> win = <span class=\"hljs-title class_\">BrowserWindow</span>.<span class=\"hljs-title function_\">fromWebContents</span>(webContents)<br>    win.<span class=\"hljs-title function_\">setTitle</span>(title)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//preload</span><br><span class=\"hljs-keyword\">const</span> &#123; contextBridge, ipcRenderer &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>)<br><br>contextBridge.<span class=\"hljs-title function_\">exposeInMainWorld</span>(<span class=\"hljs-string\">&#x27;electronAPI&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">sendMessage</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">title</span>) =&gt;</span> ipcRenderer.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>, title)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//render.js</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">electronAPI</span>.<span class=\"hljs-title function_\">sendMessage</span>(title)<br></code></pre></td></tr></table></figure>\n\n<p>四. 主进程给渲染进程</p>\n<p>将消息从主进程发送到渲染器进程时，需要指定是哪一个渲染器接收消息。 消息需要通过其 <a href=\"https://www.electronjs.org/zh/docs/latest/api/web-contents\"><code>WebContents</code></a> 实例发送到渲染器进程。 此 WebContents 实例包含一个 <a href=\"https://www.electronjs.org/zh/docs/latest/api/web-contents#contentssendchannel-args\"><code>send</code></a> 方法，其使用方式与 <code>ipcRenderer.send</code> 相同。</p>\n<p>使用 <code>webContents.send</code> API 将 IPC 消息从主进程发送到目标渲染器</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//render.js</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">electronAPI</span>.<span class=\"hljs-title function_\">handleCounter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">event, value</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> oldValue = <span class=\"hljs-title class_\">Number</span>(counter.<span class=\"hljs-property\">innerText</span>)<br>  <span class=\"hljs-keyword\">const</span> newValue = oldValue + value<br>  counter.<span class=\"hljs-property\">innerText</span> = newValue<br>  event.<span class=\"hljs-property\">sender</span>.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&#x27;counter-value&#x27;</span>, newValue)<br>&#125;)<br><br><span class=\"hljs-comment\">//preload</span><br><span class=\"hljs-keyword\">const</span> &#123; contextBridge, ipcRenderer &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>)<br><br>contextBridge.<span class=\"hljs-title function_\">exposeInMainWorld</span>(<span class=\"hljs-string\">&#x27;electronAPI&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">handleCounter</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">callback</span>) =&gt;</span> ipcRenderer.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;update-counter&#x27;</span>, callback)<br>&#125;)<br><br><br><span class=\"hljs-comment\">//MainProcess</span><br>mainWindow.<span class=\"hljs-property\">webContents</span>.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&#x27;update-counter&#x27;</span>, <span class=\"hljs-number\">1</span>)<br></code></pre></td></tr></table></figure>\n\n<p>五. 渲染进程给渲染进程</p>\n<p>没有直接的方法可以使用 <code>ipcMain</code> 和 <code>ipcRenderer</code> 模块在 Electron 中的渲染器进程之间发送消息。 为此，您有两种选择：</p>\n<ul>\n<li>将主进程作为渲染器之间的消息代理。 这需要将消息从一个渲染器发送到主进程，然后主进程将消息转发到另一个渲染器。</li>\n</ul>\n"},{"title":"Git","date":"2021-04-11T06:45:09.000Z","index_img":"/img/git-index.jpeg","banner_img":"/img/git-banner.jpg","_content":"###  1.提交步骤\n\n1. ``git init``初始化git仓库\n2. ``git status`` 查看文件状态\n3. ``git add 文件列表``  追踪文件\n4. ``git commit -m`` 提交信息 向仓库提交代码\n5. ``git log`` 查看提交记录\n\n\n\n#### 1.1 恢复记录\n\n``git reset --hard commitID`` 将gi仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录 \n\n### 2.撤销\n\n* 用暂存区中的文件覆盖工作目录中的文件： ``git checkout 文件``\n* 将文件从暂存区中删除： ``git rm --cached 文件``\n* 将git仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：``git rest --hard commitID``\n\n> 撤销的意思就是 用之前保存在暂存区的文件去覆盖目前工作区的文件\n\n### 3.git 分支\n\n为了便于理解，大家暂时可以认为分支就是当前工作目录中代码的一份副本\n\n使用分支，可以让我们从开发主线上分离出来，以免影响开发主线 \n\n#### 3.1 主分支（master): 第一次向git仓库中提交更新记录时直动产生的一个分支\n\n#### 3.2 开发分支(develop): 作为开发的分支，基于master分支创建的\n\n#### 3.3 功能分支（feature）: 作为开发具体功能的分支，基于开发分支创建\n\n<span style=\" text-decoration:underline; text-decoration-color:red;text-decoration-style: wavy\">功能开发->开发分支->主分支 </span>\n\n\n### 4.分支命令\n\n* ``git branch`` 查看分支\n* ``git branch 分支名称`` 创建分支\n* `git checkout 分支名称` 切换分支\n* `git merge 来源分支`  合并分支\n* `git branch -d 分支名称` 删除分支（分支被合并后才允许被删除)(-D 强制删除)\n\n#### 4.1 暂时保存更改\n\n在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作\n\n使用场景：分支临时切换\n\n* 存储临时改动： `git stash`\n* 恢复改动：`git stash pop`\n\n#### 4.2把代码push到GitHub里面\n\n可以使用`git push 仓库地址 分支名称`就可以了\n\n> 因为仓库地址的名称太长了不方便，我们就采用别名来命名仓库\n\n`git remote add othername`\n\n**这样子就可以使用othername来使用这个仓库了**\n\n当你上次提交代码到仓库的时候使用了\n\n`git push -u othername master`时，\n\n下次提交代码就只要使用`git push`就可以了\n\n#### 5.克隆代码到本地\n\n克隆远端数据仓库到本地 `git clone 仓库地址`\n\n##### 5.1拉取（pull）最新的仓库到本地\n\n拉取远程仓库中的最新版本到本地`git pull 远程仓库地址 分支名称`\n\n==git clone 命令是在本地没有远程仓库进行的，是完全克隆远程仓库的，基本上是第一次才会使用，而 git pull 命令是在本地之前存在过远程仓库进行的，是拉取最新的仓库==\n\n#### 6.跨团队合作\n\n1. 程序员 C fork 仓库\n2. 程序员 C 将仓库克隆在本地进行修改\n3. 程序员 C 将仓库推送到远程\n4. 程序员 C 发起 pull reqest\n5. 原仓库作者审核\n6. 原仓库作者合并代码\n\n#### ssh 免登录\n\n1. 生成密钥：`ssh-keygen`\n2. 秘钥存储目录：C:\\Users\\用户\\.ssh\n3. 公匙名称： id_rsa.pub\n4. 私钥名称： id_rsa","source":"_posts/Git.md","raw":"---\ntitle: Git\ndate: 2021-04-11 14:45:09\ntags: Git\ncategories: 后端\nindex_img: /img/git-index.jpeg\nbanner_img: /img/git-banner.jpg\n---\n###  1.提交步骤\n\n1. ``git init``初始化git仓库\n2. ``git status`` 查看文件状态\n3. ``git add 文件列表``  追踪文件\n4. ``git commit -m`` 提交信息 向仓库提交代码\n5. ``git log`` 查看提交记录\n\n\n\n#### 1.1 恢复记录\n\n``git reset --hard commitID`` 将gi仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录 \n\n### 2.撤销\n\n* 用暂存区中的文件覆盖工作目录中的文件： ``git checkout 文件``\n* 将文件从暂存区中删除： ``git rm --cached 文件``\n* 将git仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：``git rest --hard commitID``\n\n> 撤销的意思就是 用之前保存在暂存区的文件去覆盖目前工作区的文件\n\n### 3.git 分支\n\n为了便于理解，大家暂时可以认为分支就是当前工作目录中代码的一份副本\n\n使用分支，可以让我们从开发主线上分离出来，以免影响开发主线 \n\n#### 3.1 主分支（master): 第一次向git仓库中提交更新记录时直动产生的一个分支\n\n#### 3.2 开发分支(develop): 作为开发的分支，基于master分支创建的\n\n#### 3.3 功能分支（feature）: 作为开发具体功能的分支，基于开发分支创建\n\n<span style=\" text-decoration:underline; text-decoration-color:red;text-decoration-style: wavy\">功能开发->开发分支->主分支 </span>\n\n\n### 4.分支命令\n\n* ``git branch`` 查看分支\n* ``git branch 分支名称`` 创建分支\n* `git checkout 分支名称` 切换分支\n* `git merge 来源分支`  合并分支\n* `git branch -d 分支名称` 删除分支（分支被合并后才允许被删除)(-D 强制删除)\n\n#### 4.1 暂时保存更改\n\n在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作\n\n使用场景：分支临时切换\n\n* 存储临时改动： `git stash`\n* 恢复改动：`git stash pop`\n\n#### 4.2把代码push到GitHub里面\n\n可以使用`git push 仓库地址 分支名称`就可以了\n\n> 因为仓库地址的名称太长了不方便，我们就采用别名来命名仓库\n\n`git remote add othername`\n\n**这样子就可以使用othername来使用这个仓库了**\n\n当你上次提交代码到仓库的时候使用了\n\n`git push -u othername master`时，\n\n下次提交代码就只要使用`git push`就可以了\n\n#### 5.克隆代码到本地\n\n克隆远端数据仓库到本地 `git clone 仓库地址`\n\n##### 5.1拉取（pull）最新的仓库到本地\n\n拉取远程仓库中的最新版本到本地`git pull 远程仓库地址 分支名称`\n\n==git clone 命令是在本地没有远程仓库进行的，是完全克隆远程仓库的，基本上是第一次才会使用，而 git pull 命令是在本地之前存在过远程仓库进行的，是拉取最新的仓库==\n\n#### 6.跨团队合作\n\n1. 程序员 C fork 仓库\n2. 程序员 C 将仓库克隆在本地进行修改\n3. 程序员 C 将仓库推送到远程\n4. 程序员 C 发起 pull reqest\n5. 原仓库作者审核\n6. 原仓库作者合并代码\n\n#### ssh 免登录\n\n1. 生成密钥：`ssh-keygen`\n2. 秘钥存储目录：C:\\Users\\用户\\.ssh\n3. 公匙名称： id_rsa.pub\n4. 私钥名称： id_rsa","slug":"Git","published":1,"updated":"2024-11-17T13:58:10.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpc000373t34e5te62z","content":"<h3 id=\"1-提交步骤\"><a href=\"#1-提交步骤\" class=\"headerlink\" title=\"1.提交步骤\"></a>1.提交步骤</h3><ol>\n<li><code>git init</code>初始化git仓库</li>\n<li><code>git status</code> 查看文件状态</li>\n<li><code>git add 文件列表</code>  追踪文件</li>\n<li><code>git commit -m</code> 提交信息 向仓库提交代码</li>\n<li><code>git log</code> 查看提交记录</li>\n</ol>\n<h4 id=\"1-1-恢复记录\"><a href=\"#1-1-恢复记录\" class=\"headerlink\" title=\"1.1 恢复记录\"></a>1.1 恢复记录</h4><p><code>git reset --hard commitID</code> 将gi仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录 </p>\n<h3 id=\"2-撤销\"><a href=\"#2-撤销\" class=\"headerlink\" title=\"2.撤销\"></a>2.撤销</h3><ul>\n<li>用暂存区中的文件覆盖工作目录中的文件： <code>git checkout 文件</code></li>\n<li>将文件从暂存区中删除： <code>git rm --cached 文件</code></li>\n<li>将git仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：<code>git rest --hard commitID</code></li>\n</ul>\n<blockquote>\n<p>撤销的意思就是 用之前保存在暂存区的文件去覆盖目前工作区的文件</p>\n</blockquote>\n<h3 id=\"3-git-分支\"><a href=\"#3-git-分支\" class=\"headerlink\" title=\"3.git 分支\"></a>3.git 分支</h3><p>为了便于理解，大家暂时可以认为分支就是当前工作目录中代码的一份副本</p>\n<p>使用分支，可以让我们从开发主线上分离出来，以免影响开发主线 </p>\n<h4 id=\"3-1-主分支（master-第一次向git仓库中提交更新记录时直动产生的一个分支\"><a href=\"#3-1-主分支（master-第一次向git仓库中提交更新记录时直动产生的一个分支\" class=\"headerlink\" title=\"3.1 主分支（master): 第一次向git仓库中提交更新记录时直动产生的一个分支\"></a>3.1 主分支（master): 第一次向git仓库中提交更新记录时直动产生的一个分支</h4><h4 id=\"3-2-开发分支-develop-作为开发的分支，基于master分支创建的\"><a href=\"#3-2-开发分支-develop-作为开发的分支，基于master分支创建的\" class=\"headerlink\" title=\"3.2 开发分支(develop): 作为开发的分支，基于master分支创建的\"></a>3.2 开发分支(develop): 作为开发的分支，基于master分支创建的</h4><h4 id=\"3-3-功能分支（feature）-作为开发具体功能的分支，基于开发分支创建\"><a href=\"#3-3-功能分支（feature）-作为开发具体功能的分支，基于开发分支创建\" class=\"headerlink\" title=\"3.3 功能分支（feature）: 作为开发具体功能的分支，基于开发分支创建\"></a>3.3 功能分支（feature）: 作为开发具体功能的分支，基于开发分支创建</h4><p><span style=\" text-decoration:underline; text-decoration-color:red;text-decoration-style: wavy\">功能开发-&gt;开发分支-&gt;主分支 </span></p>\n<h3 id=\"4-分支命令\"><a href=\"#4-分支命令\" class=\"headerlink\" title=\"4.分支命令\"></a>4.分支命令</h3><ul>\n<li><code>git branch</code> 查看分支</li>\n<li><code>git branch 分支名称</code> 创建分支</li>\n<li><code>git checkout 分支名称</code> 切换分支</li>\n<li><code>git merge 来源分支</code>  合并分支</li>\n<li><code>git branch -d 分支名称</code> 删除分支（分支被合并后才允许被删除)(-D 强制删除)</li>\n</ul>\n<h4 id=\"4-1-暂时保存更改\"><a href=\"#4-1-暂时保存更改\" class=\"headerlink\" title=\"4.1 暂时保存更改\"></a>4.1 暂时保存更改</h4><p>在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作</p>\n<p>使用场景：分支临时切换</p>\n<ul>\n<li>存储临时改动： <code>git stash</code></li>\n<li>恢复改动：<code>git stash pop</code></li>\n</ul>\n<h4 id=\"4-2把代码push到GitHub里面\"><a href=\"#4-2把代码push到GitHub里面\" class=\"headerlink\" title=\"4.2把代码push到GitHub里面\"></a>4.2把代码push到GitHub里面</h4><p>可以使用<code>git push 仓库地址 分支名称</code>就可以了</p>\n<blockquote>\n<p>因为仓库地址的名称太长了不方便，我们就采用别名来命名仓库</p>\n</blockquote>\n<p><code>git remote add othername</code></p>\n<p><strong>这样子就可以使用othername来使用这个仓库了</strong></p>\n<p>当你上次提交代码到仓库的时候使用了</p>\n<p><code>git push -u othername master</code>时，</p>\n<p>下次提交代码就只要使用<code>git push</code>就可以了</p>\n<h4 id=\"5-克隆代码到本地\"><a href=\"#5-克隆代码到本地\" class=\"headerlink\" title=\"5.克隆代码到本地\"></a>5.克隆代码到本地</h4><p>克隆远端数据仓库到本地 <code>git clone 仓库地址</code></p>\n<h5 id=\"5-1拉取（pull）最新的仓库到本地\"><a href=\"#5-1拉取（pull）最新的仓库到本地\" class=\"headerlink\" title=\"5.1拉取（pull）最新的仓库到本地\"></a>5.1拉取（pull）最新的仓库到本地</h5><p>拉取远程仓库中的最新版本到本地<code>git pull 远程仓库地址 分支名称</code></p>\n<p>==git clone 命令是在本地没有远程仓库进行的，是完全克隆远程仓库的，基本上是第一次才会使用，而 git pull 命令是在本地之前存在过远程仓库进行的，是拉取最新的仓库==</p>\n<h4 id=\"6-跨团队合作\"><a href=\"#6-跨团队合作\" class=\"headerlink\" title=\"6.跨团队合作\"></a>6.跨团队合作</h4><ol>\n<li>程序员 C fork 仓库</li>\n<li>程序员 C 将仓库克隆在本地进行修改</li>\n<li>程序员 C 将仓库推送到远程</li>\n<li>程序员 C 发起 pull reqest</li>\n<li>原仓库作者审核</li>\n<li>原仓库作者合并代码</li>\n</ol>\n<h4 id=\"ssh-免登录\"><a href=\"#ssh-免登录\" class=\"headerlink\" title=\"ssh 免登录\"></a>ssh 免登录</h4><ol>\n<li>生成密钥：<code>ssh-keygen</code></li>\n<li>秘钥存储目录：C:\\Users\\用户.ssh</li>\n<li>公匙名称： id_rsa.pub</li>\n<li>私钥名称： id_rsa</li>\n</ol>\n","site":{"data":{}},"wordcount":1202,"excerpt":"","more":"<h3 id=\"1-提交步骤\"><a href=\"#1-提交步骤\" class=\"headerlink\" title=\"1.提交步骤\"></a>1.提交步骤</h3><ol>\n<li><code>git init</code>初始化git仓库</li>\n<li><code>git status</code> 查看文件状态</li>\n<li><code>git add 文件列表</code>  追踪文件</li>\n<li><code>git commit -m</code> 提交信息 向仓库提交代码</li>\n<li><code>git log</code> 查看提交记录</li>\n</ol>\n<h4 id=\"1-1-恢复记录\"><a href=\"#1-1-恢复记录\" class=\"headerlink\" title=\"1.1 恢复记录\"></a>1.1 恢复记录</h4><p><code>git reset --hard commitID</code> 将gi仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录 </p>\n<h3 id=\"2-撤销\"><a href=\"#2-撤销\" class=\"headerlink\" title=\"2.撤销\"></a>2.撤销</h3><ul>\n<li>用暂存区中的文件覆盖工作目录中的文件： <code>git checkout 文件</code></li>\n<li>将文件从暂存区中删除： <code>git rm --cached 文件</code></li>\n<li>将git仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：<code>git rest --hard commitID</code></li>\n</ul>\n<blockquote>\n<p>撤销的意思就是 用之前保存在暂存区的文件去覆盖目前工作区的文件</p>\n</blockquote>\n<h3 id=\"3-git-分支\"><a href=\"#3-git-分支\" class=\"headerlink\" title=\"3.git 分支\"></a>3.git 分支</h3><p>为了便于理解，大家暂时可以认为分支就是当前工作目录中代码的一份副本</p>\n<p>使用分支，可以让我们从开发主线上分离出来，以免影响开发主线 </p>\n<h4 id=\"3-1-主分支（master-第一次向git仓库中提交更新记录时直动产生的一个分支\"><a href=\"#3-1-主分支（master-第一次向git仓库中提交更新记录时直动产生的一个分支\" class=\"headerlink\" title=\"3.1 主分支（master): 第一次向git仓库中提交更新记录时直动产生的一个分支\"></a>3.1 主分支（master): 第一次向git仓库中提交更新记录时直动产生的一个分支</h4><h4 id=\"3-2-开发分支-develop-作为开发的分支，基于master分支创建的\"><a href=\"#3-2-开发分支-develop-作为开发的分支，基于master分支创建的\" class=\"headerlink\" title=\"3.2 开发分支(develop): 作为开发的分支，基于master分支创建的\"></a>3.2 开发分支(develop): 作为开发的分支，基于master分支创建的</h4><h4 id=\"3-3-功能分支（feature）-作为开发具体功能的分支，基于开发分支创建\"><a href=\"#3-3-功能分支（feature）-作为开发具体功能的分支，基于开发分支创建\" class=\"headerlink\" title=\"3.3 功能分支（feature）: 作为开发具体功能的分支，基于开发分支创建\"></a>3.3 功能分支（feature）: 作为开发具体功能的分支，基于开发分支创建</h4><p><span style=\" text-decoration:underline; text-decoration-color:red;text-decoration-style: wavy\">功能开发-&gt;开发分支-&gt;主分支 </span></p>\n<h3 id=\"4-分支命令\"><a href=\"#4-分支命令\" class=\"headerlink\" title=\"4.分支命令\"></a>4.分支命令</h3><ul>\n<li><code>git branch</code> 查看分支</li>\n<li><code>git branch 分支名称</code> 创建分支</li>\n<li><code>git checkout 分支名称</code> 切换分支</li>\n<li><code>git merge 来源分支</code>  合并分支</li>\n<li><code>git branch -d 分支名称</code> 删除分支（分支被合并后才允许被删除)(-D 强制删除)</li>\n</ul>\n<h4 id=\"4-1-暂时保存更改\"><a href=\"#4-1-暂时保存更改\" class=\"headerlink\" title=\"4.1 暂时保存更改\"></a>4.1 暂时保存更改</h4><p>在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作</p>\n<p>使用场景：分支临时切换</p>\n<ul>\n<li>存储临时改动： <code>git stash</code></li>\n<li>恢复改动：<code>git stash pop</code></li>\n</ul>\n<h4 id=\"4-2把代码push到GitHub里面\"><a href=\"#4-2把代码push到GitHub里面\" class=\"headerlink\" title=\"4.2把代码push到GitHub里面\"></a>4.2把代码push到GitHub里面</h4><p>可以使用<code>git push 仓库地址 分支名称</code>就可以了</p>\n<blockquote>\n<p>因为仓库地址的名称太长了不方便，我们就采用别名来命名仓库</p>\n</blockquote>\n<p><code>git remote add othername</code></p>\n<p><strong>这样子就可以使用othername来使用这个仓库了</strong></p>\n<p>当你上次提交代码到仓库的时候使用了</p>\n<p><code>git push -u othername master</code>时，</p>\n<p>下次提交代码就只要使用<code>git push</code>就可以了</p>\n<h4 id=\"5-克隆代码到本地\"><a href=\"#5-克隆代码到本地\" class=\"headerlink\" title=\"5.克隆代码到本地\"></a>5.克隆代码到本地</h4><p>克隆远端数据仓库到本地 <code>git clone 仓库地址</code></p>\n<h5 id=\"5-1拉取（pull）最新的仓库到本地\"><a href=\"#5-1拉取（pull）最新的仓库到本地\" class=\"headerlink\" title=\"5.1拉取（pull）最新的仓库到本地\"></a>5.1拉取（pull）最新的仓库到本地</h5><p>拉取远程仓库中的最新版本到本地<code>git pull 远程仓库地址 分支名称</code></p>\n<p>==git clone 命令是在本地没有远程仓库进行的，是完全克隆远程仓库的，基本上是第一次才会使用，而 git pull 命令是在本地之前存在过远程仓库进行的，是拉取最新的仓库==</p>\n<h4 id=\"6-跨团队合作\"><a href=\"#6-跨团队合作\" class=\"headerlink\" title=\"6.跨团队合作\"></a>6.跨团队合作</h4><ol>\n<li>程序员 C fork 仓库</li>\n<li>程序员 C 将仓库克隆在本地进行修改</li>\n<li>程序员 C 将仓库推送到远程</li>\n<li>程序员 C 发起 pull reqest</li>\n<li>原仓库作者审核</li>\n<li>原仓库作者合并代码</li>\n</ol>\n<h4 id=\"ssh-免登录\"><a href=\"#ssh-免登录\" class=\"headerlink\" title=\"ssh 免登录\"></a>ssh 免登录</h4><ol>\n<li>生成密钥：<code>ssh-keygen</code></li>\n<li>秘钥存储目录：C:\\Users\\用户.ssh</li>\n<li>公匙名称： id_rsa.pub</li>\n<li>私钥名称： id_rsa</li>\n</ol>\n"},{"title":"Git的一些操作","date":"2023-02-20T14:29:35.000Z","index_img":"/img/Git.jpeg","banner_img":null,"_content":"\n>git status\n>\n>git add file\n>\n>git add .\n>\n>git commit -m \n>\n>git push\n>\n>git clone\n>\n>git branch\n>\n>git checkout\n>\n>git log\n>\n>git reflog\n>\n>git merge\n>\n>git stash\n","source":"_posts/Git的一些操作.md","raw":"---\ntitle: Git的一些操作\ndate: 2023-2-20 22:29:35\ntags: 后端\nindex_img: /img/Git.jpeg\nbanner_img:\n---\n\n>git status\n>\n>git add file\n>\n>git add .\n>\n>git commit -m \n>\n>git push\n>\n>git clone\n>\n>git branch\n>\n>git checkout\n>\n>git log\n>\n>git reflog\n>\n>git merge\n>\n>git stash\n","slug":"Git的一些操作","published":1,"updated":"2024-11-17T13:58:10.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpe000673t3goo10pmd","content":"<blockquote>\n<p>git status</p>\n<p>git add file</p>\n<p>git add .</p>\n<p>git commit -m </p>\n<p>git push</p>\n<p>git clone</p>\n<p>git branch</p>\n<p>git checkout</p>\n<p>git log</p>\n<p>git reflog</p>\n<p>git merge</p>\n<p>git stash</p>\n</blockquote>\n","site":{"data":{}},"wordcount":103,"excerpt":"","more":"<blockquote>\n<p>git status</p>\n<p>git add file</p>\n<p>git add .</p>\n<p>git commit -m </p>\n<p>git push</p>\n<p>git clone</p>\n<p>git branch</p>\n<p>git checkout</p>\n<p>git log</p>\n<p>git reflog</p>\n<p>git merge</p>\n<p>git stash</p>\n</blockquote>\n"},{"title":"Gulp","date":"2021-04-11T06:35:55.000Z","index_img":"/img/gulp-index.jpg","banner_img":"/img/gulp-banner.png","_content":"## 1.第三方模块Gulp\n\n基于node平台开发的前端构建工具\n\n将机械化操作编写成任务，想要执行机械化操作时执行一个命令行命令任务就能自动执行了\n\n#### 1.1Gulp能做什么\n\n* 项目上线，HTML，css，js文件压缩\n* 语法转换(es6,less,scss)\n* 公共文件抽离\n* 修改文件浏览器自动刷新\n\n#### 1.2.Gulp中提供的方法\n\n* gulp.src():获取任务要处理的文件\n* gulp.dest()：输出文件\n* gulp.task():建立gulp任务\n* gulp.watch():监控文件的变化\n\n```javascript\nconst gulp = require('gulp')\n//使用gulp.task()方法建立任务\ngulp.task('first',()=>{\n    //获取要处理的文件\n    gulp.src('./src/css/base.css')\n    //将处理后的文件输出到dist目录\n    .pipe(gulp.dest('./dist/css'))\n})\n```\n\n#### 1.3Gulp插件\n\n* gulp-htmlmin：html文件压缩\n* gulp-csso：压缩css\n* gulp-babel：JavaScript语法转化\n* gulp-less：less语法转化\n* gulp-uglify：压缩混淆JavaScript\n* gulp-file-include：公共文件包含\n* browsersync：浏览器实时同步\n\n>  gulp-htmlmin  (只会压缩html中的代码，并不会压缩css中的代码)\n>\n>  使用步骤\n>\n>  1.下载   2.引用   3.调用\n\n#### 1.4构建任务\n\n```javascript\n//复制文件夹\ngulp.task('copy',()=>{\n    gulp.src('./src/images/*')\n    \t.pipe(gulp.dest(dist/images));\n    gulp.src('./src/lib/*')\n    \t.pipe(gulp.dest('dist/lib'))\n})\n\n\n//构建任务\ngulp.task('default',['htmlmin','cssmin','copy']);\n//这样子就可以一下子执行多个任务了\n```\n\n## 2.package.json文件\n\n#### 2.1node_modules文件夹的问题\n\n1. 文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候，传输速度会很慢很慢\n2. 复制的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错\n\n#### 2.2package.json文件的作用\n\n项目描述文件，记录了当前项目信息，例如项目名称，版本，作者，github地址，当前项目依赖了哪些第三方模块等。\n\n使用`npm init -y`命令生成\n\n**第一个的解决方法**\n\n当我们把文件传输给别人的时候，是不需要传输node_modules 文件的,packages.json 这个文件里面会保存有你下载的模块的名称和版本，只需要 `npm install`就可以下载原来所需的所有模块了\n\n#### 2.3项目依赖\n\n* 在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖\n* 使用npm install 包名命令下载的文件会默认被添加多package.json 文件的dependencies字段中\n\n```javascript\n{\n\t\"dependencies\":{\n\t\t\"jquery\":\"^3.3.1\"\n\t}\n}\n```\n\n#### 2.4开发依赖\n\n* 在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖\n* 使用 npm install 包名 --save-dev 命令将包添加到 package.json 文件的 devDependencies字段中\n\n> 使用 --save-dev 命令可以把开发依赖和项目依赖区分开来\n\n#### 2.5 项目依赖和开发依赖的下载\n\n当你使用 `npm install`的时候，是下载的全部包\n\n当你使用`npm install --production`的时候，下载的是项目依赖\n\n#### 2.6 package-lock.json文件的作用\n\n当我们在下载第三方模块的时候，npm会同时产生另一个文件 package-lock.json\n\n* 锁定包的版本，确保再次下载时不会因为包版本不同而产生问题\n* 加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作\n\n## 3.Node.js中模块加载机制\n\n#### 3.1 模块查找规则-当模块拥有路径但没有后缀\n\n`require('./find.js')`\n\n`require('./find')`\n\n1. require方法根据模块路径查找模块，如果是完整路径，直接引入模块\n\n2. 如果模块后缀省略，先找同名js文件再找同名js文件夹\n3. 如果找到了同名文件夹，找文件夹中的index.js\n4. 如果文件夹中没有index.js就会去当前文件夹中的package.js文件中查找main选项的入口文件\n5. 如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到\n\n#### 3.2模块查找规则-当模块没有路径且没有后缀时\n\n`require('find')`\n\n1. Node.js 会假设它是系统模块\n2. Node.js 会去node_modules文件夹中\n3. 首先看是否有该名字的js文件\n4. 再看是否有该名字的文件夹\n5. 如果是文件夹看里面是否有index.js\n6. 如果没有index.js 查看该文件夹中的package.json中的main选项确定模块入口文件\n7. 否则找不到报错","source":"_posts/Gulp.md","raw":"---\ntitle: Gulp\ndate: 2021-04-11 14:35:55\ntags: Gulp\ncategories: 后端\nindex_img: /img/gulp-index.jpg\nbanner_img: /img/gulp-banner.png\n---\n## 1.第三方模块Gulp\n\n基于node平台开发的前端构建工具\n\n将机械化操作编写成任务，想要执行机械化操作时执行一个命令行命令任务就能自动执行了\n\n#### 1.1Gulp能做什么\n\n* 项目上线，HTML，css，js文件压缩\n* 语法转换(es6,less,scss)\n* 公共文件抽离\n* 修改文件浏览器自动刷新\n\n#### 1.2.Gulp中提供的方法\n\n* gulp.src():获取任务要处理的文件\n* gulp.dest()：输出文件\n* gulp.task():建立gulp任务\n* gulp.watch():监控文件的变化\n\n```javascript\nconst gulp = require('gulp')\n//使用gulp.task()方法建立任务\ngulp.task('first',()=>{\n    //获取要处理的文件\n    gulp.src('./src/css/base.css')\n    //将处理后的文件输出到dist目录\n    .pipe(gulp.dest('./dist/css'))\n})\n```\n\n#### 1.3Gulp插件\n\n* gulp-htmlmin：html文件压缩\n* gulp-csso：压缩css\n* gulp-babel：JavaScript语法转化\n* gulp-less：less语法转化\n* gulp-uglify：压缩混淆JavaScript\n* gulp-file-include：公共文件包含\n* browsersync：浏览器实时同步\n\n>  gulp-htmlmin  (只会压缩html中的代码，并不会压缩css中的代码)\n>\n>  使用步骤\n>\n>  1.下载   2.引用   3.调用\n\n#### 1.4构建任务\n\n```javascript\n//复制文件夹\ngulp.task('copy',()=>{\n    gulp.src('./src/images/*')\n    \t.pipe(gulp.dest(dist/images));\n    gulp.src('./src/lib/*')\n    \t.pipe(gulp.dest('dist/lib'))\n})\n\n\n//构建任务\ngulp.task('default',['htmlmin','cssmin','copy']);\n//这样子就可以一下子执行多个任务了\n```\n\n## 2.package.json文件\n\n#### 2.1node_modules文件夹的问题\n\n1. 文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候，传输速度会很慢很慢\n2. 复制的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错\n\n#### 2.2package.json文件的作用\n\n项目描述文件，记录了当前项目信息，例如项目名称，版本，作者，github地址，当前项目依赖了哪些第三方模块等。\n\n使用`npm init -y`命令生成\n\n**第一个的解决方法**\n\n当我们把文件传输给别人的时候，是不需要传输node_modules 文件的,packages.json 这个文件里面会保存有你下载的模块的名称和版本，只需要 `npm install`就可以下载原来所需的所有模块了\n\n#### 2.3项目依赖\n\n* 在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖\n* 使用npm install 包名命令下载的文件会默认被添加多package.json 文件的dependencies字段中\n\n```javascript\n{\n\t\"dependencies\":{\n\t\t\"jquery\":\"^3.3.1\"\n\t}\n}\n```\n\n#### 2.4开发依赖\n\n* 在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖\n* 使用 npm install 包名 --save-dev 命令将包添加到 package.json 文件的 devDependencies字段中\n\n> 使用 --save-dev 命令可以把开发依赖和项目依赖区分开来\n\n#### 2.5 项目依赖和开发依赖的下载\n\n当你使用 `npm install`的时候，是下载的全部包\n\n当你使用`npm install --production`的时候，下载的是项目依赖\n\n#### 2.6 package-lock.json文件的作用\n\n当我们在下载第三方模块的时候，npm会同时产生另一个文件 package-lock.json\n\n* 锁定包的版本，确保再次下载时不会因为包版本不同而产生问题\n* 加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作\n\n## 3.Node.js中模块加载机制\n\n#### 3.1 模块查找规则-当模块拥有路径但没有后缀\n\n`require('./find.js')`\n\n`require('./find')`\n\n1. require方法根据模块路径查找模块，如果是完整路径，直接引入模块\n\n2. 如果模块后缀省略，先找同名js文件再找同名js文件夹\n3. 如果找到了同名文件夹，找文件夹中的index.js\n4. 如果文件夹中没有index.js就会去当前文件夹中的package.js文件中查找main选项的入口文件\n5. 如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到\n\n#### 3.2模块查找规则-当模块没有路径且没有后缀时\n\n`require('find')`\n\n1. Node.js 会假设它是系统模块\n2. Node.js 会去node_modules文件夹中\n3. 首先看是否有该名字的js文件\n4. 再看是否有该名字的文件夹\n5. 如果是文件夹看里面是否有index.js\n6. 如果没有index.js 查看该文件夹中的package.json中的main选项确定模块入口文件\n7. 否则找不到报错","slug":"Gulp","published":1,"updated":"2024-11-17T13:58:10.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpe000773t35toe97tb","content":"<h2 id=\"1-第三方模块Gulp\"><a href=\"#1-第三方模块Gulp\" class=\"headerlink\" title=\"1.第三方模块Gulp\"></a>1.第三方模块Gulp</h2><p>基于node平台开发的前端构建工具</p>\n<p>将机械化操作编写成任务，想要执行机械化操作时执行一个命令行命令任务就能自动执行了</p>\n<h4 id=\"1-1Gulp能做什么\"><a href=\"#1-1Gulp能做什么\" class=\"headerlink\" title=\"1.1Gulp能做什么\"></a>1.1Gulp能做什么</h4><ul>\n<li>项目上线，HTML，css，js文件压缩</li>\n<li>语法转换(es6,less,scss)</li>\n<li>公共文件抽离</li>\n<li>修改文件浏览器自动刷新</li>\n</ul>\n<h4 id=\"1-2-Gulp中提供的方法\"><a href=\"#1-2-Gulp中提供的方法\" class=\"headerlink\" title=\"1.2.Gulp中提供的方法\"></a>1.2.Gulp中提供的方法</h4><ul>\n<li>gulp.src():获取任务要处理的文件</li>\n<li>gulp.dest()：输出文件</li>\n<li>gulp.task():建立gulp任务</li>\n<li>gulp.watch():监控文件的变化</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> gulp = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;gulp&#x27;</span>)<br><span class=\"hljs-comment\">//使用gulp.task()方法建立任务</span><br>gulp.<span class=\"hljs-title function_\">task</span>(<span class=\"hljs-string\">&#x27;first&#x27;</span>,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>    <span class=\"hljs-comment\">//获取要处理的文件</span><br>    gulp.<span class=\"hljs-title function_\">src</span>(<span class=\"hljs-string\">&#x27;./src/css/base.css&#x27;</span>)<br>    <span class=\"hljs-comment\">//将处理后的文件输出到dist目录</span><br>    .<span class=\"hljs-title function_\">pipe</span>(gulp.<span class=\"hljs-title function_\">dest</span>(<span class=\"hljs-string\">&#x27;./dist/css&#x27;</span>))<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-3Gulp插件\"><a href=\"#1-3Gulp插件\" class=\"headerlink\" title=\"1.3Gulp插件\"></a>1.3Gulp插件</h4><ul>\n<li>gulp-htmlmin：html文件压缩</li>\n<li>gulp-csso：压缩css</li>\n<li>gulp-babel：JavaScript语法转化</li>\n<li>gulp-less：less语法转化</li>\n<li>gulp-uglify：压缩混淆JavaScript</li>\n<li>gulp-file-include：公共文件包含</li>\n<li>browsersync：浏览器实时同步</li>\n</ul>\n<blockquote>\n<p> gulp-htmlmin  (只会压缩html中的代码，并不会压缩css中的代码)</p>\n<p> 使用步骤</p>\n<p> 1.下载   2.引用   3.调用</p>\n</blockquote>\n<h4 id=\"1-4构建任务\"><a href=\"#1-4构建任务\" class=\"headerlink\" title=\"1.4构建任务\"></a>1.4构建任务</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//复制文件夹</span><br>gulp.<span class=\"hljs-title function_\">task</span>(<span class=\"hljs-string\">&#x27;copy&#x27;</span>,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>    gulp.<span class=\"hljs-title function_\">src</span>(<span class=\"hljs-string\">&#x27;./src/images/*&#x27;</span>)<br>    \t.<span class=\"hljs-title function_\">pipe</span>(gulp.<span class=\"hljs-title function_\">dest</span>(dist/images));<br>    gulp.<span class=\"hljs-title function_\">src</span>(<span class=\"hljs-string\">&#x27;./src/lib/*&#x27;</span>)<br>    \t.<span class=\"hljs-title function_\">pipe</span>(gulp.<span class=\"hljs-title function_\">dest</span>(<span class=\"hljs-string\">&#x27;dist/lib&#x27;</span>))<br>&#125;)<br><br><br><span class=\"hljs-comment\">//构建任务</span><br>gulp.<span class=\"hljs-title function_\">task</span>(<span class=\"hljs-string\">&#x27;default&#x27;</span>,[<span class=\"hljs-string\">&#x27;htmlmin&#x27;</span>,<span class=\"hljs-string\">&#x27;cssmin&#x27;</span>,<span class=\"hljs-string\">&#x27;copy&#x27;</span>]);<br><span class=\"hljs-comment\">//这样子就可以一下子执行多个任务了</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-package-json文件\"><a href=\"#2-package-json文件\" class=\"headerlink\" title=\"2.package.json文件\"></a>2.package.json文件</h2><h4 id=\"2-1node-modules文件夹的问题\"><a href=\"#2-1node-modules文件夹的问题\" class=\"headerlink\" title=\"2.1node_modules文件夹的问题\"></a>2.1node_modules文件夹的问题</h4><ol>\n<li>文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候，传输速度会很慢很慢</li>\n<li>复制的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错</li>\n</ol>\n<h4 id=\"2-2package-json文件的作用\"><a href=\"#2-2package-json文件的作用\" class=\"headerlink\" title=\"2.2package.json文件的作用\"></a>2.2package.json文件的作用</h4><p>项目描述文件，记录了当前项目信息，例如项目名称，版本，作者，github地址，当前项目依赖了哪些第三方模块等。</p>\n<p>使用<code>npm init -y</code>命令生成</p>\n<p><strong>第一个的解决方法</strong></p>\n<p>当我们把文件传输给别人的时候，是不需要传输node_modules 文件的,packages.json 这个文件里面会保存有你下载的模块的名称和版本，只需要 <code>npm install</code>就可以下载原来所需的所有模块了</p>\n<h4 id=\"2-3项目依赖\"><a href=\"#2-3项目依赖\" class=\"headerlink\" title=\"2.3项目依赖\"></a>2.3项目依赖</h4><ul>\n<li>在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖</li>\n<li>使用npm install 包名命令下载的文件会默认被添加多package.json 文件的dependencies字段中</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>\t<span class=\"hljs-string\">&quot;dependencies&quot;</span>:&#123;<br>\t\t<span class=\"hljs-string\">&quot;jquery&quot;</span>:<span class=\"hljs-string\">&quot;^3.3.1&quot;</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-4开发依赖\"><a href=\"#2-4开发依赖\" class=\"headerlink\" title=\"2.4开发依赖\"></a>2.4开发依赖</h4><ul>\n<li>在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖</li>\n<li>使用 npm install 包名 –save-dev 命令将包添加到 package.json 文件的 devDependencies字段中</li>\n</ul>\n<blockquote>\n<p>使用 –save-dev 命令可以把开发依赖和项目依赖区分开来</p>\n</blockquote>\n<h4 id=\"2-5-项目依赖和开发依赖的下载\"><a href=\"#2-5-项目依赖和开发依赖的下载\" class=\"headerlink\" title=\"2.5 项目依赖和开发依赖的下载\"></a>2.5 项目依赖和开发依赖的下载</h4><p>当你使用 <code>npm install</code>的时候，是下载的全部包</p>\n<p>当你使用<code>npm install --production</code>的时候，下载的是项目依赖</p>\n<h4 id=\"2-6-package-lock-json文件的作用\"><a href=\"#2-6-package-lock-json文件的作用\" class=\"headerlink\" title=\"2.6 package-lock.json文件的作用\"></a>2.6 package-lock.json文件的作用</h4><p>当我们在下载第三方模块的时候，npm会同时产生另一个文件 package-lock.json</p>\n<ul>\n<li>锁定包的版本，确保再次下载时不会因为包版本不同而产生问题</li>\n<li>加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</li>\n</ul>\n<h2 id=\"3-Node-js中模块加载机制\"><a href=\"#3-Node-js中模块加载机制\" class=\"headerlink\" title=\"3.Node.js中模块加载机制\"></a>3.Node.js中模块加载机制</h2><h4 id=\"3-1-模块查找规则-当模块拥有路径但没有后缀\"><a href=\"#3-1-模块查找规则-当模块拥有路径但没有后缀\" class=\"headerlink\" title=\"3.1 模块查找规则-当模块拥有路径但没有后缀\"></a>3.1 模块查找规则-当模块拥有路径但没有后缀</h4><p><code>require(&#39;./find.js&#39;)</code></p>\n<p><code>require(&#39;./find&#39;)</code></p>\n<ol>\n<li><p>require方法根据模块路径查找模块，如果是完整路径，直接引入模块</p>\n</li>\n<li><p>如果模块后缀省略，先找同名js文件再找同名js文件夹</p>\n</li>\n<li><p>如果找到了同名文件夹，找文件夹中的index.js</p>\n</li>\n<li><p>如果文件夹中没有index.js就会去当前文件夹中的package.js文件中查找main选项的入口文件</p>\n</li>\n<li><p>如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</p>\n</li>\n</ol>\n<h4 id=\"3-2模块查找规则-当模块没有路径且没有后缀时\"><a href=\"#3-2模块查找规则-当模块没有路径且没有后缀时\" class=\"headerlink\" title=\"3.2模块查找规则-当模块没有路径且没有后缀时\"></a>3.2模块查找规则-当模块没有路径且没有后缀时</h4><p><code>require(&#39;find&#39;)</code></p>\n<ol>\n<li>Node.js 会假设它是系统模块</li>\n<li>Node.js 会去node_modules文件夹中</li>\n<li>首先看是否有该名字的js文件</li>\n<li>再看是否有该名字的文件夹</li>\n<li>如果是文件夹看里面是否有index.js</li>\n<li>如果没有index.js 查看该文件夹中的package.json中的main选项确定模块入口文件</li>\n<li>否则找不到报错</li>\n</ol>\n","site":{"data":{}},"wordcount":2313,"excerpt":"","more":"<h2 id=\"1-第三方模块Gulp\"><a href=\"#1-第三方模块Gulp\" class=\"headerlink\" title=\"1.第三方模块Gulp\"></a>1.第三方模块Gulp</h2><p>基于node平台开发的前端构建工具</p>\n<p>将机械化操作编写成任务，想要执行机械化操作时执行一个命令行命令任务就能自动执行了</p>\n<h4 id=\"1-1Gulp能做什么\"><a href=\"#1-1Gulp能做什么\" class=\"headerlink\" title=\"1.1Gulp能做什么\"></a>1.1Gulp能做什么</h4><ul>\n<li>项目上线，HTML，css，js文件压缩</li>\n<li>语法转换(es6,less,scss)</li>\n<li>公共文件抽离</li>\n<li>修改文件浏览器自动刷新</li>\n</ul>\n<h4 id=\"1-2-Gulp中提供的方法\"><a href=\"#1-2-Gulp中提供的方法\" class=\"headerlink\" title=\"1.2.Gulp中提供的方法\"></a>1.2.Gulp中提供的方法</h4><ul>\n<li>gulp.src():获取任务要处理的文件</li>\n<li>gulp.dest()：输出文件</li>\n<li>gulp.task():建立gulp任务</li>\n<li>gulp.watch():监控文件的变化</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> gulp = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;gulp&#x27;</span>)<br><span class=\"hljs-comment\">//使用gulp.task()方法建立任务</span><br>gulp.<span class=\"hljs-title function_\">task</span>(<span class=\"hljs-string\">&#x27;first&#x27;</span>,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>    <span class=\"hljs-comment\">//获取要处理的文件</span><br>    gulp.<span class=\"hljs-title function_\">src</span>(<span class=\"hljs-string\">&#x27;./src/css/base.css&#x27;</span>)<br>    <span class=\"hljs-comment\">//将处理后的文件输出到dist目录</span><br>    .<span class=\"hljs-title function_\">pipe</span>(gulp.<span class=\"hljs-title function_\">dest</span>(<span class=\"hljs-string\">&#x27;./dist/css&#x27;</span>))<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-3Gulp插件\"><a href=\"#1-3Gulp插件\" class=\"headerlink\" title=\"1.3Gulp插件\"></a>1.3Gulp插件</h4><ul>\n<li>gulp-htmlmin：html文件压缩</li>\n<li>gulp-csso：压缩css</li>\n<li>gulp-babel：JavaScript语法转化</li>\n<li>gulp-less：less语法转化</li>\n<li>gulp-uglify：压缩混淆JavaScript</li>\n<li>gulp-file-include：公共文件包含</li>\n<li>browsersync：浏览器实时同步</li>\n</ul>\n<blockquote>\n<p> gulp-htmlmin  (只会压缩html中的代码，并不会压缩css中的代码)</p>\n<p> 使用步骤</p>\n<p> 1.下载   2.引用   3.调用</p>\n</blockquote>\n<h4 id=\"1-4构建任务\"><a href=\"#1-4构建任务\" class=\"headerlink\" title=\"1.4构建任务\"></a>1.4构建任务</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//复制文件夹</span><br>gulp.<span class=\"hljs-title function_\">task</span>(<span class=\"hljs-string\">&#x27;copy&#x27;</span>,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>    gulp.<span class=\"hljs-title function_\">src</span>(<span class=\"hljs-string\">&#x27;./src/images/*&#x27;</span>)<br>    \t.<span class=\"hljs-title function_\">pipe</span>(gulp.<span class=\"hljs-title function_\">dest</span>(dist/images));<br>    gulp.<span class=\"hljs-title function_\">src</span>(<span class=\"hljs-string\">&#x27;./src/lib/*&#x27;</span>)<br>    \t.<span class=\"hljs-title function_\">pipe</span>(gulp.<span class=\"hljs-title function_\">dest</span>(<span class=\"hljs-string\">&#x27;dist/lib&#x27;</span>))<br>&#125;)<br><br><br><span class=\"hljs-comment\">//构建任务</span><br>gulp.<span class=\"hljs-title function_\">task</span>(<span class=\"hljs-string\">&#x27;default&#x27;</span>,[<span class=\"hljs-string\">&#x27;htmlmin&#x27;</span>,<span class=\"hljs-string\">&#x27;cssmin&#x27;</span>,<span class=\"hljs-string\">&#x27;copy&#x27;</span>]);<br><span class=\"hljs-comment\">//这样子就可以一下子执行多个任务了</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-package-json文件\"><a href=\"#2-package-json文件\" class=\"headerlink\" title=\"2.package.json文件\"></a>2.package.json文件</h2><h4 id=\"2-1node-modules文件夹的问题\"><a href=\"#2-1node-modules文件夹的问题\" class=\"headerlink\" title=\"2.1node_modules文件夹的问题\"></a>2.1node_modules文件夹的问题</h4><ol>\n<li>文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候，传输速度会很慢很慢</li>\n<li>复制的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错</li>\n</ol>\n<h4 id=\"2-2package-json文件的作用\"><a href=\"#2-2package-json文件的作用\" class=\"headerlink\" title=\"2.2package.json文件的作用\"></a>2.2package.json文件的作用</h4><p>项目描述文件，记录了当前项目信息，例如项目名称，版本，作者，github地址，当前项目依赖了哪些第三方模块等。</p>\n<p>使用<code>npm init -y</code>命令生成</p>\n<p><strong>第一个的解决方法</strong></p>\n<p>当我们把文件传输给别人的时候，是不需要传输node_modules 文件的,packages.json 这个文件里面会保存有你下载的模块的名称和版本，只需要 <code>npm install</code>就可以下载原来所需的所有模块了</p>\n<h4 id=\"2-3项目依赖\"><a href=\"#2-3项目依赖\" class=\"headerlink\" title=\"2.3项目依赖\"></a>2.3项目依赖</h4><ul>\n<li>在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖</li>\n<li>使用npm install 包名命令下载的文件会默认被添加多package.json 文件的dependencies字段中</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>\t<span class=\"hljs-string\">&quot;dependencies&quot;</span>:&#123;<br>\t\t<span class=\"hljs-string\">&quot;jquery&quot;</span>:<span class=\"hljs-string\">&quot;^3.3.1&quot;</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-4开发依赖\"><a href=\"#2-4开发依赖\" class=\"headerlink\" title=\"2.4开发依赖\"></a>2.4开发依赖</h4><ul>\n<li>在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖</li>\n<li>使用 npm install 包名 –save-dev 命令将包添加到 package.json 文件的 devDependencies字段中</li>\n</ul>\n<blockquote>\n<p>使用 –save-dev 命令可以把开发依赖和项目依赖区分开来</p>\n</blockquote>\n<h4 id=\"2-5-项目依赖和开发依赖的下载\"><a href=\"#2-5-项目依赖和开发依赖的下载\" class=\"headerlink\" title=\"2.5 项目依赖和开发依赖的下载\"></a>2.5 项目依赖和开发依赖的下载</h4><p>当你使用 <code>npm install</code>的时候，是下载的全部包</p>\n<p>当你使用<code>npm install --production</code>的时候，下载的是项目依赖</p>\n<h4 id=\"2-6-package-lock-json文件的作用\"><a href=\"#2-6-package-lock-json文件的作用\" class=\"headerlink\" title=\"2.6 package-lock.json文件的作用\"></a>2.6 package-lock.json文件的作用</h4><p>当我们在下载第三方模块的时候，npm会同时产生另一个文件 package-lock.json</p>\n<ul>\n<li>锁定包的版本，确保再次下载时不会因为包版本不同而产生问题</li>\n<li>加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</li>\n</ul>\n<h2 id=\"3-Node-js中模块加载机制\"><a href=\"#3-Node-js中模块加载机制\" class=\"headerlink\" title=\"3.Node.js中模块加载机制\"></a>3.Node.js中模块加载机制</h2><h4 id=\"3-1-模块查找规则-当模块拥有路径但没有后缀\"><a href=\"#3-1-模块查找规则-当模块拥有路径但没有后缀\" class=\"headerlink\" title=\"3.1 模块查找规则-当模块拥有路径但没有后缀\"></a>3.1 模块查找规则-当模块拥有路径但没有后缀</h4><p><code>require(&#39;./find.js&#39;)</code></p>\n<p><code>require(&#39;./find&#39;)</code></p>\n<ol>\n<li><p>require方法根据模块路径查找模块，如果是完整路径，直接引入模块</p>\n</li>\n<li><p>如果模块后缀省略，先找同名js文件再找同名js文件夹</p>\n</li>\n<li><p>如果找到了同名文件夹，找文件夹中的index.js</p>\n</li>\n<li><p>如果文件夹中没有index.js就会去当前文件夹中的package.js文件中查找main选项的入口文件</p>\n</li>\n<li><p>如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</p>\n</li>\n</ol>\n<h4 id=\"3-2模块查找规则-当模块没有路径且没有后缀时\"><a href=\"#3-2模块查找规则-当模块没有路径且没有后缀时\" class=\"headerlink\" title=\"3.2模块查找规则-当模块没有路径且没有后缀时\"></a>3.2模块查找规则-当模块没有路径且没有后缀时</h4><p><code>require(&#39;find&#39;)</code></p>\n<ol>\n<li>Node.js 会假设它是系统模块</li>\n<li>Node.js 会去node_modules文件夹中</li>\n<li>首先看是否有该名字的js文件</li>\n<li>再看是否有该名字的文件夹</li>\n<li>如果是文件夹看里面是否有index.js</li>\n<li>如果没有index.js 查看该文件夹中的package.json中的main选项确定模块入口文件</li>\n<li>否则找不到报错</li>\n</ol>\n"},{"title":"Promise的基本知识","date":"2023-03-27T13:45:51.000Z","index_img":"/img/promise.jpeg","_content":"\n## Promise\n\nPromise 是 ES6 新出的一个类，因为 js 是单线程的，为了加快性能，提出了异步这个方法,Promise 只接受一个函数，它由两个参数 _resolve,reject_\n\n> Promise 的一些优点： 可以链式调用，解决回调地狱\n>\n> Promise 里面是同步调用的，then 里面才是微任务\n>\n> Promise 有三个状态：Pending , resolved(fulfilled),rejected\n>\n> 一个 promise 对象只能改变一次状态，成功或者失败后都会返回结果数据。\n\n一些异步的操作:\n\n- setTimeOut\n- ajax\n- 回调函数\n- 事件监听\n- Promise\n\n普通的 ajax 请求\n\n```js\n//创建一个xhr对象\nconst xhr = new XMLHttpRequset();\nxhr.open(\"GET\", \"http://localhost:2010\");\nxhr.send();\n\n//接受响应\nxhr.onReadyStateChange = function () {\n  if (xhr.readyState == 4) {\n    if (xhr.status >= 200 && xhr.status <= 300) {\n      console.log(xhr.response);\n    } else {\n      console.log(xhr.status);\n    }\n  }\n};\n```\n\n对 ajax 的 Promise 封装\n\n```js\nlet p = new Promise((resolve, reject) => {\n  //创建一个xhr对象\n  const xhr = new XMLHttpRequset();\n  xhr.open(\"GET\", \"http://localhost:2010\");\n  xhr.send();\n\n  //接受响应\n  xhr.onReadyStateChange = function () {\n    if (xhr.readyState == 4) {\n      if (xhr.status >= 200 && xhr.status <= 300) {\n        //响应成功\n        resolve(xhr.response);\n      } else {\n        //响应失败\n        reject(xhr.status);\n      }\n    }\n  };\n});\n\np.then(\n  (value) => {\n    console.log(value);\n  },\n  (error) => {\n    console.log(error);\n  }\n);\n```\n\n## Promise 的一些 API\n\n> Promise.rejected()\n\n如果返回的是一个普通的对象，就返回一个成功的 Promise 对象\n\n如果返回的是一个 Promise 对象，则根据这个 Promise 返回的结果返回结果\n\n> Promise.all([])\n\n如果所有的都返回成功的话，则会返回成功的结果的一个数组\n\n如果有一个返回失败的话，则会返回那个失败的结果\n\n> Promise.race([])\n\n它的返回结果由最先完成的那个 promise 结果来决定，第一个返回的如果是成功就是是成功的结果，如果是失败就是失败\n\n> Promise.finally()\n\n无论成功还是失败，都会执行的回调函数\n\n> Promise.then(()=>{},()=>{})\n\n如果成功，将会执行这个回调函数的第一个函数\n\n> Promise.catch\n\n如果失败，则会执行这个回调函数\n\n## 中断 Promise 链\n\n能够中断 Promise 的执行的，只有<pending>状态下的 Promise\n\n```js\nlet p = new Promise((resolve, reject) => {\n  resolve(\"OK\");\n});\n\np.then((value) => {\n  return new Promise((res, rej) => {\n    resolve(\"1\");\n  });\n})\n  .then((val) => {\n    console.log(\"2\");\n  })\n  .then((val) => {\n    console.log(\"3\");\n  });\n\n//如果想要中断这个回调函数链的话，只有返回一个pending才能中断\np.then((value) => {\n  return new Promise((res, rej) => {}); //这样子就可以了\n})\n  .then((val) => {\n    console.log(\"2\");\n  })\n  .then((val) => {\n    console.log(\"3\");\n  });\n```\n\n## Promise.then 返回的是一个 Promise 对象\n\nPromise.then 返回了一个什么呢？\n\n```js\nlet p = new Promise((resolve, reject) => {\n  resolve(\"OK\");\n});\n\nconst res = p.then((val) => {\n  console.log(val);\n});\n\nconsole.log(res); //Promise  --> resule: [val]\n```\n\nPromise.then 返回了一个 Promise 对象\n\n返回的结果由 p.then 返回的结果来决定\n\n1. 如果回调函数的返回结果是 非 promise 类型的 属性，则 then 方法返回的 promise 对象 p1 的状态为成功 fulfilled，同时返回的结果就是 promise 对象 p1 成功的值。需要注意的是，如果你不写 return，我们知道函数内部如果不写 return 默认返回结果是 undefined，又 undefined 也是非 promise 类型，所以 p1 状态还是成功 fulfilled，返回的 promise 成功值为 undefined。\n2. 如果回调函数的返回结果是 promise 对象，则 p1 的状态就取决于 return 返回的这个 promise 对象内部的状态，内部为 resolve, 则 p1 状态为 fulfilled，内部为 reject，则 p1 状态为 rejected\n\n## 改变 Promise 状态的三种办法\n\n1.reject()\n\n2.resolve()\n\n3.throw Error('error')\n\n**Promise 指定的多个回调函数也会执行的**\n\n## async 和 await\n\nawait 只能在 async 函数中才能使用\n\nasync 函数的返回值为 Promise 对象\n\nPromise 对象的结果为 async 函数执行的结果\n","source":"_posts/Promise的基本知识.md","raw":"---\ntitle: Promise的基本知识\ndate: 2023-03-27 21:45:51\ncategory: 前端\ntags: 基础知识点\nindex_img: /img/promise.jpeg\n---\n\n## Promise\n\nPromise 是 ES6 新出的一个类，因为 js 是单线程的，为了加快性能，提出了异步这个方法,Promise 只接受一个函数，它由两个参数 _resolve,reject_\n\n> Promise 的一些优点： 可以链式调用，解决回调地狱\n>\n> Promise 里面是同步调用的，then 里面才是微任务\n>\n> Promise 有三个状态：Pending , resolved(fulfilled),rejected\n>\n> 一个 promise 对象只能改变一次状态，成功或者失败后都会返回结果数据。\n\n一些异步的操作:\n\n- setTimeOut\n- ajax\n- 回调函数\n- 事件监听\n- Promise\n\n普通的 ajax 请求\n\n```js\n//创建一个xhr对象\nconst xhr = new XMLHttpRequset();\nxhr.open(\"GET\", \"http://localhost:2010\");\nxhr.send();\n\n//接受响应\nxhr.onReadyStateChange = function () {\n  if (xhr.readyState == 4) {\n    if (xhr.status >= 200 && xhr.status <= 300) {\n      console.log(xhr.response);\n    } else {\n      console.log(xhr.status);\n    }\n  }\n};\n```\n\n对 ajax 的 Promise 封装\n\n```js\nlet p = new Promise((resolve, reject) => {\n  //创建一个xhr对象\n  const xhr = new XMLHttpRequset();\n  xhr.open(\"GET\", \"http://localhost:2010\");\n  xhr.send();\n\n  //接受响应\n  xhr.onReadyStateChange = function () {\n    if (xhr.readyState == 4) {\n      if (xhr.status >= 200 && xhr.status <= 300) {\n        //响应成功\n        resolve(xhr.response);\n      } else {\n        //响应失败\n        reject(xhr.status);\n      }\n    }\n  };\n});\n\np.then(\n  (value) => {\n    console.log(value);\n  },\n  (error) => {\n    console.log(error);\n  }\n);\n```\n\n## Promise 的一些 API\n\n> Promise.rejected()\n\n如果返回的是一个普通的对象，就返回一个成功的 Promise 对象\n\n如果返回的是一个 Promise 对象，则根据这个 Promise 返回的结果返回结果\n\n> Promise.all([])\n\n如果所有的都返回成功的话，则会返回成功的结果的一个数组\n\n如果有一个返回失败的话，则会返回那个失败的结果\n\n> Promise.race([])\n\n它的返回结果由最先完成的那个 promise 结果来决定，第一个返回的如果是成功就是是成功的结果，如果是失败就是失败\n\n> Promise.finally()\n\n无论成功还是失败，都会执行的回调函数\n\n> Promise.then(()=>{},()=>{})\n\n如果成功，将会执行这个回调函数的第一个函数\n\n> Promise.catch\n\n如果失败，则会执行这个回调函数\n\n## 中断 Promise 链\n\n能够中断 Promise 的执行的，只有<pending>状态下的 Promise\n\n```js\nlet p = new Promise((resolve, reject) => {\n  resolve(\"OK\");\n});\n\np.then((value) => {\n  return new Promise((res, rej) => {\n    resolve(\"1\");\n  });\n})\n  .then((val) => {\n    console.log(\"2\");\n  })\n  .then((val) => {\n    console.log(\"3\");\n  });\n\n//如果想要中断这个回调函数链的话，只有返回一个pending才能中断\np.then((value) => {\n  return new Promise((res, rej) => {}); //这样子就可以了\n})\n  .then((val) => {\n    console.log(\"2\");\n  })\n  .then((val) => {\n    console.log(\"3\");\n  });\n```\n\n## Promise.then 返回的是一个 Promise 对象\n\nPromise.then 返回了一个什么呢？\n\n```js\nlet p = new Promise((resolve, reject) => {\n  resolve(\"OK\");\n});\n\nconst res = p.then((val) => {\n  console.log(val);\n});\n\nconsole.log(res); //Promise  --> resule: [val]\n```\n\nPromise.then 返回了一个 Promise 对象\n\n返回的结果由 p.then 返回的结果来决定\n\n1. 如果回调函数的返回结果是 非 promise 类型的 属性，则 then 方法返回的 promise 对象 p1 的状态为成功 fulfilled，同时返回的结果就是 promise 对象 p1 成功的值。需要注意的是，如果你不写 return，我们知道函数内部如果不写 return 默认返回结果是 undefined，又 undefined 也是非 promise 类型，所以 p1 状态还是成功 fulfilled，返回的 promise 成功值为 undefined。\n2. 如果回调函数的返回结果是 promise 对象，则 p1 的状态就取决于 return 返回的这个 promise 对象内部的状态，内部为 resolve, 则 p1 状态为 fulfilled，内部为 reject，则 p1 状态为 rejected\n\n## 改变 Promise 状态的三种办法\n\n1.reject()\n\n2.resolve()\n\n3.throw Error('error')\n\n**Promise 指定的多个回调函数也会执行的**\n\n## async 和 await\n\nawait 只能在 async 函数中才能使用\n\nasync 函数的返回值为 Promise 对象\n\nPromise 对象的结果为 async 函数执行的结果\n","slug":"Promise的基本知识","published":1,"updated":"2024-11-17T13:58:10.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpe000873t35kixghny","content":"<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p>Promise 是 ES6 新出的一个类，因为 js 是单线程的，为了加快性能，提出了异步这个方法,Promise 只接受一个函数，它由两个参数 <em>resolve,reject</em></p>\n<blockquote>\n<p>Promise 的一些优点： 可以链式调用，解决回调地狱</p>\n<p>Promise 里面是同步调用的，then 里面才是微任务</p>\n<p>Promise 有三个状态：Pending , resolved(fulfilled),rejected</p>\n<p>一个 promise 对象只能改变一次状态，成功或者失败后都会返回结果数据。</p>\n</blockquote>\n<p>一些异步的操作:</p>\n<ul>\n<li>setTimeOut</li>\n<li>ajax</li>\n<li>回调函数</li>\n<li>事件监听</li>\n<li>Promise</li>\n</ul>\n<p>普通的 ajax 请求</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//创建一个xhr对象</span><br><span class=\"hljs-keyword\">const</span> xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">XMLHttpRequset</span>();<br>xhr.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:2010&quot;</span>);<br>xhr.<span class=\"hljs-title function_\">send</span>();<br><br><span class=\"hljs-comment\">//接受响应</span><br>xhr.<span class=\"hljs-property\">onReadyStateChange</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (xhr.<span class=\"hljs-property\">readyState</span> == <span class=\"hljs-number\">4</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (xhr.<span class=\"hljs-property\">status</span> &gt;= <span class=\"hljs-number\">200</span> &amp;&amp; xhr.<span class=\"hljs-property\">status</span> &lt;= <span class=\"hljs-number\">300</span>) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(xhr.<span class=\"hljs-property\">response</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(xhr.<span class=\"hljs-property\">status</span>);<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>对 ajax 的 Promise 封装</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">//创建一个xhr对象</span><br>  <span class=\"hljs-keyword\">const</span> xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">XMLHttpRequset</span>();<br>  xhr.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:2010&quot;</span>);<br>  xhr.<span class=\"hljs-title function_\">send</span>();<br><br>  <span class=\"hljs-comment\">//接受响应</span><br>  xhr.<span class=\"hljs-property\">onReadyStateChange</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (xhr.<span class=\"hljs-property\">readyState</span> == <span class=\"hljs-number\">4</span>) &#123;<br>      <span class=\"hljs-keyword\">if</span> (xhr.<span class=\"hljs-property\">status</span> &gt;= <span class=\"hljs-number\">200</span> &amp;&amp; xhr.<span class=\"hljs-property\">status</span> &lt;= <span class=\"hljs-number\">300</span>) &#123;<br>        <span class=\"hljs-comment\">//响应成功</span><br>        <span class=\"hljs-title function_\">resolve</span>(xhr.<span class=\"hljs-property\">response</span>);<br>      &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-comment\">//响应失败</span><br>        <span class=\"hljs-title function_\">reject</span>(xhr.<span class=\"hljs-property\">status</span>);<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;);<br><br>p.<span class=\"hljs-title function_\">then</span>(<br>  <span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>  &#125;,<br>  <span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-的一些-API\"><a href=\"#Promise-的一些-API\" class=\"headerlink\" title=\"Promise 的一些 API\"></a>Promise 的一些 API</h2><blockquote>\n<p>Promise.rejected()</p>\n</blockquote>\n<p>如果返回的是一个普通的对象，就返回一个成功的 Promise 对象</p>\n<p>如果返回的是一个 Promise 对象，则根据这个 Promise 返回的结果返回结果</p>\n<blockquote>\n<p>Promise.all([])</p>\n</blockquote>\n<p>如果所有的都返回成功的话，则会返回成功的结果的一个数组</p>\n<p>如果有一个返回失败的话，则会返回那个失败的结果</p>\n<blockquote>\n<p>Promise.race([])</p>\n</blockquote>\n<p>它的返回结果由最先完成的那个 promise 结果来决定，第一个返回的如果是成功就是是成功的结果，如果是失败就是失败</p>\n<blockquote>\n<p>Promise.finally()</p>\n</blockquote>\n<p>无论成功还是失败，都会执行的回调函数</p>\n<blockquote>\n<p>Promise.then(()=&gt;{},()=&gt;{})</p>\n</blockquote>\n<p>如果成功，将会执行这个回调函数的第一个函数</p>\n<blockquote>\n<p>Promise.catch</p>\n</blockquote>\n<p>如果失败，则会执行这个回调函数</p>\n<h2 id=\"中断-Promise-链\"><a href=\"#中断-Promise-链\" class=\"headerlink\" title=\"中断 Promise 链\"></a>中断 Promise 链</h2><p>能够中断 Promise 的执行的，只有<pending>状态下的 Promise</pending></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&quot;OK&quot;</span>);<br>&#125;);<br><br>p.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res, rej</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&quot;1&quot;</span>);<br>  &#125;);<br>&#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;2&quot;</span>);<br>  &#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;3&quot;</span>);<br>  &#125;);<br><br><span class=\"hljs-comment\">//如果想要中断这个回调函数链的话，只有返回一个pending才能中断</span><br>p.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res, rej</span>) =&gt;</span> &#123;&#125;); <span class=\"hljs-comment\">//这样子就可以了</span><br>&#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;2&quot;</span>);<br>  &#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;3&quot;</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-then-返回的是一个-Promise-对象\"><a href=\"#Promise-then-返回的是一个-Promise-对象\" class=\"headerlink\" title=\"Promise.then 返回的是一个 Promise 对象\"></a>Promise.then 返回的是一个 Promise 对象</h2><p>Promise.then 返回了一个什么呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&quot;OK&quot;</span>);<br>&#125;);<br><br><span class=\"hljs-keyword\">const</span> res = p.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val);<br>&#125;);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res); <span class=\"hljs-comment\">//Promise  --&gt; resule: [val]</span><br></code></pre></td></tr></table></figure>\n\n<p>Promise.then 返回了一个 Promise 对象</p>\n<p>返回的结果由 p.then 返回的结果来决定</p>\n<ol>\n<li>如果回调函数的返回结果是 非 promise 类型的 属性，则 then 方法返回的 promise 对象 p1 的状态为成功 fulfilled，同时返回的结果就是 promise 对象 p1 成功的值。需要注意的是，如果你不写 return，我们知道函数内部如果不写 return 默认返回结果是 undefined，又 undefined 也是非 promise 类型，所以 p1 状态还是成功 fulfilled，返回的 promise 成功值为 undefined。</li>\n<li>如果回调函数的返回结果是 promise 对象，则 p1 的状态就取决于 return 返回的这个 promise 对象内部的状态，内部为 resolve, 则 p1 状态为 fulfilled，内部为 reject，则 p1 状态为 rejected</li>\n</ol>\n<h2 id=\"改变-Promise-状态的三种办法\"><a href=\"#改变-Promise-状态的三种办法\" class=\"headerlink\" title=\"改变 Promise 状态的三种办法\"></a>改变 Promise 状态的三种办法</h2><p>1.reject()</p>\n<p>2.resolve()</p>\n<p>3.throw Error(‘error’)</p>\n<p><strong>Promise 指定的多个回调函数也会执行的</strong></p>\n<h2 id=\"async-和-await\"><a href=\"#async-和-await\" class=\"headerlink\" title=\"async 和 await\"></a>async 和 await</h2><p>await 只能在 async 函数中才能使用</p>\n<p>async 函数的返回值为 Promise 对象</p>\n<p>Promise 对象的结果为 async 函数执行的结果</p>\n","site":{"data":{}},"wordcount":2864,"excerpt":"","more":"<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p>Promise 是 ES6 新出的一个类，因为 js 是单线程的，为了加快性能，提出了异步这个方法,Promise 只接受一个函数，它由两个参数 <em>resolve,reject</em></p>\n<blockquote>\n<p>Promise 的一些优点： 可以链式调用，解决回调地狱</p>\n<p>Promise 里面是同步调用的，then 里面才是微任务</p>\n<p>Promise 有三个状态：Pending , resolved(fulfilled),rejected</p>\n<p>一个 promise 对象只能改变一次状态，成功或者失败后都会返回结果数据。</p>\n</blockquote>\n<p>一些异步的操作:</p>\n<ul>\n<li>setTimeOut</li>\n<li>ajax</li>\n<li>回调函数</li>\n<li>事件监听</li>\n<li>Promise</li>\n</ul>\n<p>普通的 ajax 请求</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//创建一个xhr对象</span><br><span class=\"hljs-keyword\">const</span> xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">XMLHttpRequset</span>();<br>xhr.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:2010&quot;</span>);<br>xhr.<span class=\"hljs-title function_\">send</span>();<br><br><span class=\"hljs-comment\">//接受响应</span><br>xhr.<span class=\"hljs-property\">onReadyStateChange</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (xhr.<span class=\"hljs-property\">readyState</span> == <span class=\"hljs-number\">4</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (xhr.<span class=\"hljs-property\">status</span> &gt;= <span class=\"hljs-number\">200</span> &amp;&amp; xhr.<span class=\"hljs-property\">status</span> &lt;= <span class=\"hljs-number\">300</span>) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(xhr.<span class=\"hljs-property\">response</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(xhr.<span class=\"hljs-property\">status</span>);<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>对 ajax 的 Promise 封装</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">//创建一个xhr对象</span><br>  <span class=\"hljs-keyword\">const</span> xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">XMLHttpRequset</span>();<br>  xhr.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:2010&quot;</span>);<br>  xhr.<span class=\"hljs-title function_\">send</span>();<br><br>  <span class=\"hljs-comment\">//接受响应</span><br>  xhr.<span class=\"hljs-property\">onReadyStateChange</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (xhr.<span class=\"hljs-property\">readyState</span> == <span class=\"hljs-number\">4</span>) &#123;<br>      <span class=\"hljs-keyword\">if</span> (xhr.<span class=\"hljs-property\">status</span> &gt;= <span class=\"hljs-number\">200</span> &amp;&amp; xhr.<span class=\"hljs-property\">status</span> &lt;= <span class=\"hljs-number\">300</span>) &#123;<br>        <span class=\"hljs-comment\">//响应成功</span><br>        <span class=\"hljs-title function_\">resolve</span>(xhr.<span class=\"hljs-property\">response</span>);<br>      &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-comment\">//响应失败</span><br>        <span class=\"hljs-title function_\">reject</span>(xhr.<span class=\"hljs-property\">status</span>);<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;);<br><br>p.<span class=\"hljs-title function_\">then</span>(<br>  <span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>  &#125;,<br>  <span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-的一些-API\"><a href=\"#Promise-的一些-API\" class=\"headerlink\" title=\"Promise 的一些 API\"></a>Promise 的一些 API</h2><blockquote>\n<p>Promise.rejected()</p>\n</blockquote>\n<p>如果返回的是一个普通的对象，就返回一个成功的 Promise 对象</p>\n<p>如果返回的是一个 Promise 对象，则根据这个 Promise 返回的结果返回结果</p>\n<blockquote>\n<p>Promise.all([])</p>\n</blockquote>\n<p>如果所有的都返回成功的话，则会返回成功的结果的一个数组</p>\n<p>如果有一个返回失败的话，则会返回那个失败的结果</p>\n<blockquote>\n<p>Promise.race([])</p>\n</blockquote>\n<p>它的返回结果由最先完成的那个 promise 结果来决定，第一个返回的如果是成功就是是成功的结果，如果是失败就是失败</p>\n<blockquote>\n<p>Promise.finally()</p>\n</blockquote>\n<p>无论成功还是失败，都会执行的回调函数</p>\n<blockquote>\n<p>Promise.then(()=&gt;{},()=&gt;{})</p>\n</blockquote>\n<p>如果成功，将会执行这个回调函数的第一个函数</p>\n<blockquote>\n<p>Promise.catch</p>\n</blockquote>\n<p>如果失败，则会执行这个回调函数</p>\n<h2 id=\"中断-Promise-链\"><a href=\"#中断-Promise-链\" class=\"headerlink\" title=\"中断 Promise 链\"></a>中断 Promise 链</h2><p>能够中断 Promise 的执行的，只有<pending>状态下的 Promise</pending></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&quot;OK&quot;</span>);<br>&#125;);<br><br>p.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res, rej</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&quot;1&quot;</span>);<br>  &#125;);<br>&#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;2&quot;</span>);<br>  &#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;3&quot;</span>);<br>  &#125;);<br><br><span class=\"hljs-comment\">//如果想要中断这个回调函数链的话，只有返回一个pending才能中断</span><br>p.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res, rej</span>) =&gt;</span> &#123;&#125;); <span class=\"hljs-comment\">//这样子就可以了</span><br>&#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;2&quot;</span>);<br>  &#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;3&quot;</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-then-返回的是一个-Promise-对象\"><a href=\"#Promise-then-返回的是一个-Promise-对象\" class=\"headerlink\" title=\"Promise.then 返回的是一个 Promise 对象\"></a>Promise.then 返回的是一个 Promise 对象</h2><p>Promise.then 返回了一个什么呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&quot;OK&quot;</span>);<br>&#125;);<br><br><span class=\"hljs-keyword\">const</span> res = p.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val);<br>&#125;);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res); <span class=\"hljs-comment\">//Promise  --&gt; resule: [val]</span><br></code></pre></td></tr></table></figure>\n\n<p>Promise.then 返回了一个 Promise 对象</p>\n<p>返回的结果由 p.then 返回的结果来决定</p>\n<ol>\n<li>如果回调函数的返回结果是 非 promise 类型的 属性，则 then 方法返回的 promise 对象 p1 的状态为成功 fulfilled，同时返回的结果就是 promise 对象 p1 成功的值。需要注意的是，如果你不写 return，我们知道函数内部如果不写 return 默认返回结果是 undefined，又 undefined 也是非 promise 类型，所以 p1 状态还是成功 fulfilled，返回的 promise 成功值为 undefined。</li>\n<li>如果回调函数的返回结果是 promise 对象，则 p1 的状态就取决于 return 返回的这个 promise 对象内部的状态，内部为 resolve, 则 p1 状态为 fulfilled，内部为 reject，则 p1 状态为 rejected</li>\n</ol>\n<h2 id=\"改变-Promise-状态的三种办法\"><a href=\"#改变-Promise-状态的三种办法\" class=\"headerlink\" title=\"改变 Promise 状态的三种办法\"></a>改变 Promise 状态的三种办法</h2><p>1.reject()</p>\n<p>2.resolve()</p>\n<p>3.throw Error(‘error’)</p>\n<p><strong>Promise 指定的多个回调函数也会执行的</strong></p>\n<h2 id=\"async-和-await\"><a href=\"#async-和-await\" class=\"headerlink\" title=\"async 和 await\"></a>async 和 await</h2><p>await 只能在 async 函数中才能使用</p>\n<p>async 函数的返回值为 Promise 对象</p>\n<p>Promise 对象的结果为 async 函数执行的结果</p>\n"},{"title":"SassScript","date":"2021-05-25T07:29:25.000Z","index_img":"/img/sass.gif","banner_img":"/img/sass.jpg","_content":"# SassScript\n\n\n> 在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。\n\n> 弱类型语言, 对语法要求没那么严格\n\n\n\n\n## 一、注释\n\n1. Sass 支持标准的 CSS 多行注释 `/* */`，以及单行注释 `//`，前者会被完整输出到编译后的 CSS 文件中，而后者则不会。\n\n2. 将 `!` 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。\n\n3. 插值语句 (interpolation) 也可写进多行注释中输出变量值\n\n例如：\n\n~~~scss\n/* \n\thello\n\tworld!\n*/\n\n// compile scss files to css\n// it's ready to do it.\n$pink: #f3e1e1;\nhtml{\n    background-color: $pink;\n}\n\n$author: 'gdream@126.com';\n/*!\n\tAuthor: #{$author}.\n*/\n~~~\n\n开发模式编译后:\n\n~~~css\n/* \n\thello\n\tworld!\n*/\nhtml{\n    background-color: #f3e1e1;\n}\n/*!\n\tAuthor: 'gdream@126.com'.\n*/\n~~~\n\n压缩输出模式编译后：\n\n~~~css\nhtml{\n    background-color: #f3e1e1;\n}\n/*!\n\tAuthor: 'gdream@126.com'.\n*/\n~~~\n\n\n\n\n\n\n\n------\n\n## 二、变量\n\n### 1.定义\n\n变量以美元符号开头，赋值方法与 CSS 属性的写法一样\n\n~~~scss\n$width: 1600px;\n$pen-size: 3em;\n~~~\n\n### 2.使用\n\n直接使用变量的名称即可调用变量\n\n~~~scss\n#app {\n    height: $width;\n    font-size: $pen-size;\n}\n~~~\n\n### 3.作用域\n\n变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 `!global` 声明\n\n~~~scss\n#foo {\n  $width: 5em !global;\n  width: $width;\n}\n\n#bar {\n  width: $width;\n}\n~~~\n\n编译后：\n\n~~~css\n#foo {\n  width: 5em;\n}\n\n#bar {\n  width: 5em;\n}\n~~~\n\n\n\n\n\n\n\n------\n\n## 三、数据类型\n\nSassScript 支持 7 种主要的数据类型：\n\n- 数字，`1, 2, 13, 10px，5a`\n- 字符串，有引号字符串与无引号字符串，`\"foo\", 'bar', baz`\n- 颜色，`blue, #04a3f9, rgba(255,0,0,0.5)rgba(#333,.5)`\n- 布尔型，`true, false`\n- 空值，`null`\n- 数组 (list)，用空格或逗号作分隔符，`1.5em 1em 0 2em, Helvetica, Arial, sans-serif`\n- maps, 相当于 JavaScript 的 object，`(key1: value1, key2: value2)`\n\nSassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 `!important` 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。\n\n\n\n判断数据类型的方式：`type-of($value)`\n\n\n\n### 1.字符串 (Strings)\n\nSassScript 支持 CSS 的两种字符串类型：`有引号字符串 (quoted strings)`，和`无引号字符串 (unquoted strings)`。\n\n~~~scss\n$name: 'Tom Bob';\n$container: \"top bottom\";\n$what: heart;\n\n// 注：在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 `#{}` (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名\n~~~\n\n\n\n### 2.数字(Numbers)\n\nSassScript支持两种数字类型：`带单位数字`和`不带单位数字`。（可正可负可为零，可正可浮点）\n\n~~~scss\n$my-age: 19;\n$your-age: 19.5;\n$height: 120px;\n\n// 注：单位会和数字当做一个整体，进行算数运算\n~~~\n\n\n\n### 3.空值(Null)\n\n只有一个取值`null`\n\n~~~scss\n$value: null;\n\n// 注：由于它代表空，所以不能够使用它与任何类型进行算数运算\n~~~\n\n\n\n### 4.布尔型(Booleans)\n\n只有两个取值：`true`和`false`\n\n~~~scss\n$a: true;\n$b: false;\n\n// 注：只有自身是false和null才会返回false，其他一切都将返回true\n~~~\n\n\n\n### 5.数组 (Lists)\n\n通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。索引从`1`开始\n\n~~~scss\n$list0: 1px 2px 5px 6px;\n$list1: 1px 2px, 5px 6px;\n$list2: (1px 2px) (5px 6px);\n~~~\n\n数组中可以包含子数组，比如 `1px 2px, 5px 6px` 是包含 `1px 2px` 与 `5px 6px` 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 `(1px 2px) (5px 6px)`。变化是，之前的 `1px 2px, 5px 6px` 使用逗号分割了两个子数组 (comma-separated)，而 `(1px 2px) (5px 6px)` 则使用空格分割(space-separated)。\n\n当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 `(1px 2px) (5px 6px)` 与 `1px 2px, 5px 6px` 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。\n\n用 `()` 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 `font-family: ()` Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 `1px 2px () 3px` 或 `1px 2px null 3px`。\n\n基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 `(1,)` 表示只包含 `1` 的数组，而 `(1 2 3,)` 表示包含 `1 2 3` 这个以空格分隔的数组的数组。\n\n\n\n### 6.映射(Maps)\n\nMaps必须被圆括号包围，可以映射任何类型键值对（任何类型，包括内嵌maps，不过不推荐这种内嵌方式）\n\n~~~scss\n$map: ( \n  $key1: value1, \n  $key2: value2, \n  $key3: value3 \n)\n~~~\n\n\n\n### 7.颜色 (Colors)\n\nCSS原有颜色类型，十六进制、RGB、RGBA、HSL、HSLA和色彩单词\n\nSCSS提供了内置Colors函数，从而更方便地使用颜色\n\n~~~scss\n$color0: green;\n$color1: lighten($color, 15%);\n$color2: darken($color, 15%);\n$color3: saturate($color, 15%);\n$color4: desaturate($color, 15%);\n$color5: (green + red);\n~~~\n\n\n\n\n\n\n\n\n\n------\n\n## 四、运算\n\n### 1.数字运算符\n\nSassScript 支持数字的加减乘除、取整等运算 (`+, -, *, /, %`)，如果必要会在不同单位间转换值\n\n如果要保留运算符号，则应该使用插值语法\n\n- `+`\n\n\t~~~scss\n\t// 纯数字\n\t$add1: 1 + 2;\t// 3\n\t$add2: 1 + 2px; // 3px\n\t$add3: 1px + 2; // 3px\n\t$add4: 1px + 2px;//3px\n\t\n\t// 纯字符串\n\t$add5: \"a\" + \"b\"; // \"ab\"\n\t$add6: \"a\" + b;\t  // \"ab\"\n\t$add7: a + \"b\";\t  // ab\n\t$add8: a + b;\t  // ab\n\t\n\t// 数字和字符串\n\t$add9: 1 + a;\t// 1a\n\t$adda: a + 1;\t// a1\n\t$addb: \"1\" + a; // \"1a\"\n\t$addc: 1 + \"a\"; // \"1a\"\n\t$addd: \"a\" + 1; // \"a1\"\n\t$adde: a + \"1\"; // a1\n\t$addf: 1 + \"1\"; // \"11\"\n\t~~~\n\n\t~~~scss\n\t// 总结：\n\ta.纯数字：只要有单位，结果必有单位\n\tb.纯字符串：第一个字符串有无引号决定结果是否有引号\n\tc数字和字符串：第一位有引号，结果必为引号；第一位对应数字非数字且最后一位带有引号，则结果必为引号\n\t~~~\n\n- `-`\n\n\t~~~scss\n\t$add1: 1 - 2;\t// -1\n\t$add2: 1 - 2px; // -1px\n\t$add3: 1px - 2; // -1px\n\t$add4: 1px - 2px;//-1px\n\t\n\t$sub1: a - 1;  // a-1\n\t$sub2: 1 - a;  // 1-a\n\t$sub3: \"a\" - 1;// \"a\"-1\n\t$sub4: a - \"1\";// a-\"1\"\n\t~~~\n\n\t~~~scss\n\t// 总结：\n\t每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。\n\t只要其中一个值首位不为数字的，结果就按顺序去除空格后拼接起来\n\t~~~\n\n- `*`\n\n\t~~~scss\n\t$num1: 1 * 2;    // 2\n\t$mul2: 1 * 2px;  // 2px\n\t$num3: 1px * 2;  // 2px\n\t$num4: 2px * 2px;// 编译不通过\n\t\n\t$num5: 1 * 2abc; // 2abc\n\t~~~\n\n\t~~~scss\n\t// 总结：\n\t每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。其余编译不通过\n\t~~~\n\n- `/`\n\n\t~~~scss\n\t// 总结：\n\ta.不会四舍五入，精确到小数点后5位\n\tb.每个字段必须前部分为数字，且当前者只是单纯数字无单位时，后者(除数)后部分不能有字符。其余结果就按顺序去除空格后拼接起来。\n\t(因为此时后缀被当被单位看待了)\n\t~~~\n\n- `%`\n\n\t~~~scss\n\t// 总结：\n\ta.值与\"%\"之间必须要有空格，否则会被看做字符串\n\t~~~\n\n\t\n\n### 2.关系运算符\n\n大前提：两端必须为`数字` 或 `前部分数字后部分字符`\n\n返回值：`true` or `false`\n\n\n- `>`\n\n\t~~~scss\n\t$a: 1 > 2; // false\n\t~~~\n\n- `<`\n\n\t~~~scss\n\t$a: 1 > 2; // true\n\t~~~\n\n- `>=`\n\n\t~~~scss\n\t$a: 1 >= 2; // false\n\t~~~\n\n- `<=`\n\n\t~~~scss\n\t$a: 1 <= 2; // true\n\t~~~\n\n\t\n\n### 3.相等运算符\n\n作用范围：相等运算 `==, !=` 可用于所有数据类型\n\n返回值：`true` or `false`\n\n~~~scss\n$a: 1 == 1px; // true\n$b: \"a\" == a; // true\n~~~\n\n~~~scss\n// 总结：\n前部分为不带引号数字时，对比的仅仅是数字部分；反之，忽略引号，要求字符一一对应\n~~~\n\n\n\n### 4.布尔运算符\n\nSassScript 支持布尔型的 `and` `or` 以及 `not` 运算。\n\n~~~scss\n$a: 1>0 and 0>=5; // fasle\n~~~\n\n~~~scss\n// 总结：\n值与\"and\"、\"or\"和\"not\"之间必须要有空格，否则会被看做字符串\n~~~\n\n\n\n### 5.颜色值运算\n\n颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值\n\n- `颜色值与颜色值`\n\n\t~~~scss\n\tp {\n\t  color: #010203 + #040506;\n\t}\n\t\n\t// 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为\n\t// p {\n\t  color: #050709; }\n\t~~~\n\n- `颜色值与数字`\n\n\t~~~scss\n\tp {\n\t  color: #010203 * 2;\n\t}\n\t\n\t// 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为\n\t// p {\n\t  color: #020406; }\n\t~~~\n\n- `RGB和HSL`\n\n\t~~~scss\n\t// 如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。\n\t\n\tp {\n\t  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);\n\t}\n\t\n\t// p {\n\t  color: rgba(255, 255, 0, 0.75); }\n\t~~~\n\n\n\n### 6.运算优先级\n\n0. `()`\n\n1. `*`、`/`、`%`\n2. `+`、`-`\n3. `>` 、`<`、`>=`、`<=`\n\n\n\n\n\n\n\n\n\n------\n\n## 五、嵌套语法\n\n\n\n\n\n\n\n\n\n------\n\n## 六、杂货语法\n\n### 1.`插值语法`\n\n通过 `#{}` 插值语句可以在选择器、属性名和属性值中使用变量。\n\n但大多数情况下，这样使用属性值可能还不如直接使用变量方便，但是使用 `#{}` 可以避免 Sass 运行运算表达式，直接编译 CSS。\n\n~~~scss\n$name: foo;\n$attr: border;\np.#{$name} {\n  #{$attr}-color: $name;\n}\n\n// 编译后：\np.foo {\n  border-color: foo;\n}\n~~~\n\n### 2.`& in SassScript`\n\n`&`为父选择器\n\n~~~scss\na {\n    color: yellow;\n    &:hover{\n        color: green;\n    }\n    &:active{\n        color: blank;\n    }\n}\n~~~\n\n\n\n### 3.`!default`\n\n可以在变量的结尾添加 `!default` 给一个未通过 `!default` 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。\n\n~~~scss\n$content: \"First content\";\n$content: \"Second content?\" !default;\n$new_content: \"First time reference\" !default;\n\n#main {\n  content: $content;\n  new-content: $new_content;\n}\n\n// 编译为：\n#main {\n  content: \"First content\";\n  new-content: \"First time reference\"; }\n~~~\n\n注意：变量是 null 空值时将视为未被 `!default` 赋值。\n\n\n\n### 3.`!global`\n\n将局部变量提升为全局变量\n\n\n\n### 4.`!optional`\n\n如果 `@extend` 失败会收到错误提示，比如，这样写 `a.important {@extend .notice}`，当没有 `.notice` 选择器时，将会报错，只有 `h1.notice` 包含 `.notice` 时也会报错，因为 `h1` 与 `a` 冲突，会生成新的选择器。\n\n如果要求 `@extend` 不生成新选择器，可以通过 `!optional` 声明达到这个目的.\n\n简而言之：当`@extend`相关代码出现语法错误时，编译器可能会给我们\"乱\"编译为css，我们加上这个参数可以在出现问题后不让他编译该部分代码\n\n\n\n\n\n\n\n\n\n\n\n------\n\n## 七、@-Rules与指令\n\n### 1.`@import`\n\nSass 拓展了 `@import` 的功能，允许其导入 SCSS 或 SASS 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。\n\n通常，`@import` 寻找 Sass 文件并将其导入，但在以下情况下，`@import` 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。\n\n- 文件拓展名是 `.css`；\n- 文件名以 `http://` 开头；\n- 文件名是 `url()`；\n- `@import` 包含 media queries。\n\n如果不在上述情况内，文件的拓展名是 `.scss` 或 `.sass`，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 `.scss` 或 `.sass` 的文件并将其导入。\n\n~~~scss\n@import \"foo.scss\";\n@import \"foo\";\n// 以上两种方式均可\n\n\n// 以下方式均不可行\n@import \"foo.css\";\n@import \"foo\" screen;\n@import \"http://foo.com/bar\";\n@import url(foo);\n~~~\n\nSass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：\n\n~~~scss\n@import \"rounded-corners\", \"text-shadow\";\n~~~\n\n导入文件也可以使用 `#{ }` 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 `url()` 导入方式：\n\n~~~scss\n$family: unquote(\"Droid+Sans\");\n@import url(\"http://fonts.googleapis.com/css?family=\\#{$family}\");\n\n// 编译为：\n@import url(\"http://fonts.googleapis.com/css?family=Droid+Sans\");\n~~~\n\n如果你有一个 SCSS 或 Sass 文件需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。\n\n除此之外，还支持嵌套 @import,但是不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 `@import`。\n\n\n\n### 2.`@media`\n\nSass 中 `@media` 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 `@media` 嵌套在 CSS 规则内，编译时，`@media` 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 `@media` 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。\n\n~~~scss\n.sidebar {\n  width: 300px;\n  @media screen and (orientation: landscape) {\n    width: 500px;\n  }\n}\n// 编译为\n.sidebar {\n  width: 300px;\n  @media screen and (orientation: landscape) {\n    width: 500px;\n  }\n}\n~~~\n\n`@media`的 queries 允许互相嵌套使用，编译时，Sass 自动添加 `and`\n\n~~~scss\n@media screen {\n  .sidebar {\n    @media (orientation: landscape) {\n      width: 500px;\n    }\n  }\n}\n// 编译为：\n@media screen and (orientation: landscape) {\n  .sidebar {\n    width: 500px; } }\n~~~\n\n`@media` 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值\n\n~~~scss\n$media: screen;\n$feature: -webkit-min-device-pixel-ratio;\n$value: 1.5;\n\n@media #{$media} and ($feature: $value) {\n  .sidebar {\n    width: 500px;\n  }\n}\n// 编译为：\n@media screen and (-webkit-min-device-pixel-ratio: 1.5) {\n  .sidebar {\n    width: 500px; } }\n~~~\n\n\n\n### 3.`*@extend`\n\n`@extend`即`继承`。在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。\n\n总的来看：支持层叠继承、多继承、允许延伸任何定义给单个元素的选择器（但是允许不一定好用）\n\na. `基本延伸`\n\n~~~scss\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\n// 上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。\n~~~\n\n`@extend` 的作用是将重复使用的样式 (`.error`) 延伸 (extend) 给需要包含这个样式的特殊样式（`.seriousError`）\n\n注意理解以下情况：\n\n~~~scss\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.error.intrusion {\n  background-image: url(\"/image/hacked.png\");\n}\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\n// .error, .seriousError {\n  border: 1px #f00;\n  background-color: #fdd; }\n\n.error.intrusion, .seriousError.intrusion {\n  background-image: url(\"/image/hacked.png\"); }\n\n.seriousError {\n  border-width: 3px; }\n~~~\n\n当合并选择器时，`@extend` 会很聪明地避免无谓的重复，`.seriousError.seriousError` 将编译为 `.seriousError`，不能匹配任何元素的选择器也会删除。\n\n\n\nb.  `延伸复杂的选择器`：Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 `.special.cool`，`a:hover` 或者 `a.user[href^=\"http://\"]` 等\n\n\n\nc. ` 多重延伸`：同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器\n\n\n\nd. `继续延伸`：当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个\n\n\n\ne.`*选择器列`：暂时不可以将选择器列 (Selector Sequences)，比如 `.foo .bar` 或 `.foo + .bar`，延伸给其他元素，但是，却可以将其他元素延伸给选择器列。\n\n尽量不使用`合并选择器列`，因为如果凭个人推理的话，会出现排列组合的情况，所以SASS编译器只会保留有用的组合形式，但依旧会存在排列组合的情况，有可能会留下隐患。\n\n1. 当两个列合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前\n\n\t~~~scss\n\t#admin .tabbar a {\n\t  font-weight: bold;\n\t}\n\t#demo .overview .fakelink {\n\t  @extend a;\n\t}\n\t// 编译为：\n\t#admin .tabbar a,\n\t#admin .tabbar #demo .overview .fakelink,\n\t#demo .overview #admin .tabbar .fakelink {\n\t  font-weight: bold; }\n\t~~~\n\n\t\n\n2. 如果两个列包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出\n\n\t~~~scss\n\t#admin .tabbar a {\n\t  font-weight: bold;\n\t}\n\t#admin .overview .fakelink {\n\t  @extend a;\n\t}\n\t// 编译为\n\t#admin .tabbar a,\n\t#admin .tabbar .overview .fakelink,\n\t#admin .overview .tabbar .fakelink {\n\t  font-weight: bold; }\n\t~~~\n\n\t\n\nf. `在指令中延伸`\n\n在指令中使用 `@extend` 时（比如在 `@media` 中）有一些限制：Sass 不可以将 `@media` 层外的 CSS 规则延伸给指令层内的 CSS.\n\n\n\ng.  `%placeholder`为选择器占位符，配合`@extend-Only选择器`使用。\n\n效果：只定义了样式，但不会对原有选择器匹配的元素生效\n\n~~~scss\n// example1:\n%img {\n    color: red;\n}\n.path{\n    @extend %img;\n}\n// 编译后：\n.path {\n  color: red;\n}\n~~~\n\n~~~scss\n// example2:\n#context a%extreme {\n  color: blue;\n  font-weight: bold;\n  font-size: 2em;\n}\n// 编译后：\n.notice {\n  @extend %extreme;\n}\n\n// 注：必须是\".\"和\"#\"选择器\n~~~\n\n\n\n### 4.`@at-root`\n\n> The @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector\n\n译文：@at root指令使一个或多个规则在文档的根发出，而不是嵌套在其父选择器下。它可以与单个内联选择器一起使用\n\n且@at-root 使多个规则跳出嵌套\n\n@at-root默认情况下并不能使规则或者选择器跳出指令，通过使用without和with可以解决该问题\n\n了解即可\n\n\n\n### 5.`@debug`\n\n用于调试，按标准错误输出流输出\n\n~~~scss\n$size: 9px;\n\n.file{\n  @debug $size;\n}\n~~~\n\n\n\n### 6.`@warn`\n\n用于警告，按标准错误输出流输出\n\n\n\n### 7.`@error`\n\n用于报错，按标准错误输出流输出\n\n\n\n\n\n| 序列 | @-rules  | 作用                               |\n| ---- | -------- | ---------------------------------- |\n| 1    | @import  | 导入sass或scss文件                 |\n| 2    | @media   | 用于将样式规则设置为不同的媒体类型 |\n| 3    | @extend  | 以继承的方式共享选择器             |\n| 4    | @at-root | 转到根节点                         |\n| 5    | @debug   | 用于调试，按标准错误输出流输出     |\n| 6    | @warn    | 用于警告，按标准错误输出流输出     |\n| 7    | @error   | 用于报错，按标准错误输出流输出     |\n\n\n\n\n\n\n\n\n\n------\n\n## 八、控制指令\n\n### 1.`if()`\n\n*三元运算符*\n\n表达式：`if(expression, value1, value2)`\n\n~~~scss\np {\n    color: if(1 + 1 = 2, green, yellow);\n}\n\n// compile:\np{\n    color: green;}\n~~~\n\n\n\n### 2.`@if`\n\n*条件语句*\n\n当 `@if` 的表达式返回值不是 `false` 或者 `null` 时，条件成立，输出 `{}` 内的代码\n\n`@if` 声明后面可以跟多个 `@else if` 声明，或者一个 `@else` 声明。如果 `@if` 声明失败，Sass 将逐条执行 `@else if` 声明，如果全部失败，最后执行 `@else` 声明\n\n- `单@if`\n\n\t~~~scss\n\tp {\n\t    @if 1 + 1 == 2 {\n\t        color: red;\n\t    }\n\t}\n\t\n\t// compile:\n\tp {\n\t  color: red;\n\t}\n\t~~~\n\n- `@if - @else`\n\n\t~~~scss\n\tp {\n\t    @if 1 + 1 != 2 {\n\t        color: red;\n\t    } @else {\n\t        color: blue;\n\t    }\n\t}\n\t\n\t// compile:\n\tp {\n\t  color: blue;\n\t}\n\t~~~\n\n- `@if - @else if - @else`\n\n\t~~~scss\n\t$age: 19;\n\t\n\tp {\n\t    @if $age == 18 {\n\t        color: red;\n\t    } @else if $age == 19 {\n\t        color: blue;\n\t    } @else {\n\t        color: green;\n\t    }\n\t}\n\t\n\t// compile:\n\tp {\n\t  color: blue;\n\t}\n\t~~~\n\n\n\n### 3.`@for`\n\n*循环语句*\n\n表达式：`@for $var from <start> through <end>` 或 `@for $var from <start> to <end>`\n\n\n\nthrough 和 to 的相同点与不同点：\n\n- 相同点：两者均包含<start>的值\n- 不同点：through包含<end>的值，但to不包含<end>的值\n\n\n\n~~~scss\n@for $i from 1 through 3 {\n  .item-#{$i} { width: 2em * $i; }\n}\n\n// compile:\n.item-1 {\n  width: 2em; }\n.item-2 {\n  width: 4em; }\n.item-3 {\n  width: 6em; }\n~~~\n\n\n\n\n\n### 4.`@while`\n\n*循环语句*\n\n表达式：`@while expression`\n\n\n\n`@while` 指令重复输出格式直到表达式返回结果为 `false`。这样可以实现比 `@for` 更复杂的循环，只是很少会用到\n\n\n\n~~~scss\n$i: 6;\n@while $i > 0 {\n  .item-#{$i} { width: 2em * $i; }\n  $i: $i - 2;\n}\n\n// compile:\n.item-6 {\n  width: 12em; }\n.item-4 {\n  width: 8em; }\n.item-2 {\n  width: 4em; }\n~~~\n\n\n\n\n\n### 5.`@each`\n\n*循环语句*\n\n表达式：`$var in $vars`\n\n\n\n`$var` 可以是任何变量名\n\n`$vars` 只能是`Lists`或者`Maps`\n\n\n\n- 一维列表\n\n\t~~~scss\n\t@each $animal in puma, sea-slug, egret, salamander {\n\t  .#{$animal}-icon {\n\t    background-image: url('/images/#{$animal}.png');\n\t  }\n\t}\n\t\n\t// compile:\n\t.puma-icon {\n\t  background-image: url('/images/puma.png'); }\n\t.sea-slug-icon {\n\t  background-image: url('/images/sea-slug.png'); }\n\t.egret-icon {\n\t  background-image: url('/images/egret.png'); }\n\t.salamander-icon {\n\t  background-image: url('/images/salamander.png'); }\n\t~~~\n\n- 二维列表\n\n\t~~~scss\n\t@each $animal, $color, $cursor in (puma, black, default),\n\t                                  (sea-slug, blue, pointer),\n\t                                  (egret, white, move) {\n\t  .#{$animal}-icon {\n\t    background-image: url('/images/#{$animal}.png');\n\t    border: 2px solid $color;\n\t    cursor: $cursor;\n\t  }\n\t}\n\t\n\t// compile:\n\t.puma-icon {\n\t  background-image: url('/images/puma.png');\n\t  border: 2px solid black;\n\t  cursor: default; }\n\t.sea-slug-icon {\n\t  background-image: url('/images/sea-slug.png');\n\t  border: 2px solid blue;\n\t  cursor: pointer; }\n\t.egret-icon {\n\t  background-image: url('/images/egret.png');\n\t  border: 2px solid white;\n\t  cursor: move; }\n\t~~~\n\n- maps\n\n\t~~~scss\n\t@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {\n\t  #{$header} {\n\t    font-size: $size;\n\t  }\n\t}\n\t\n\t// compile:\n\th1 {\n\t  font-size: 2em; }\n\th2 {\n\t  font-size: 1.5em; }\n\th3 {\n\t  font-size: 1.2em; }\n\t~~~\n\n\t\n\n\n\n\n\n\n\n-----\n\n## 九、混合指令\n\n> 混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 `.float-left`。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。\n\n注意：这不是函数！没有返回值！！\n\n\n\n### 1.定义混合指令\n\n混合指令的用法是在 `@mixin` 后添加名称与样式，以及需要的参数（可选）。\n\n~~~scss\n// 格式：\n@mixin name {\n    // 样式....\n}\n~~~\n\n~~~scss\n// example：\n@mixin large-text {\n  font: {\n    family: Arial;\n    size: 20px;\n    weight: bold;\n  }\n  color: #ff0000;\n}\n~~~\n\n\n\n### 2.引用混合样式\n\n使用 `@include` 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）。\n\n~~~scss\n// 格式：\n@include name;\n\n// 注：无参数或参数都有默认值时，带不带括号都可以\n~~~\n\n~~~scss\n// example：\np {\n    @include large-text;\n}\n\n// compile:\np {\n  font-family: Arial;\n  font-size: 20px;\n  font-weight: bold;\n  color: #ff0000;\n}\n~~~\n\n\n\n### 3.参数\n\n格式：按照变量的格式，通过逗号分隔，将参数写进Mixin名称后的圆括号里\n\n支持默认值；支持多参数；支持不定参数；支持位置传参和关键词传参\n\n\n\n#### a. 位置传参\n\n~~~scss\n@mixin mp($width) {\n    margin: $width;\n}\n\nbody {\n    @include mp(300px);\n}\n~~~\n\n\n\n#### b.关键词传参\n\n~~~scss\n@mixin mp($width) {\n    margin: $width;\n}\n\nbody {\n    @include mp($width: 300px);\n}\n~~~\n\n\n\n#### c.参数默认值\n\n~~~scss\n@mixin mp($width: 500px) {\n    margin: $width;\n}\n\nbody {\n    @include mp($width: 300px);\n    // or\n    @include mp(300px);\n}\n~~~\n\n\n\n#### d.不定参数\n\n> 官方：Variable Arguments\n>\n> 译文：参数变量\n>\n> \n>\n> 有时，不能确定混合指令需要使用多少个参数。这时，可以使用参数变量 `…` 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理\n\n~~~scss\n@mixin mar($value...) {\n    margin: $value;\n}\n~~~\n\n\n\n### 4.向混合样式中导入内容\n\n在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 `@content` 标志的地方\n\n可以看作参数的升级版\n\n~~~scss\n@mixin example {\n    html {\n        @content;\n    }\n}\n@include example{\n    background-color: red;\n    .logo {\n        width: 600px;\n    }\n}\n\n// compile:\nhtml {\n  background-color: red;\n}\n\nhtml .logo {\n  width: 600px;\n}\n\n~~~\n\n\n\n\n\n\n\n\n\n------\n\n## 十、函数指令\n\n### 1.内置函数\n\n#### a. 字符串函数\n\n> 索引第一个为1，最后一个为-1；切片两边均为闭区间\n\n| 函数名和参数类型                        |                  函数作用                   |\n| :-------------------------------------- | :-----------------------------------------: |\n| quote($string)                          |                  添加引号                   |\n| unquote($string)                        |                  除去引号                   |\n| to-lower-case($string)                  |                  变为小写                   |\n| to-upper-case($string)                  |                  变为大写                   |\n| str-length($string)                     |        返回$string的长度(汉字算一个)        |\n| str-index($string，$substring)          |        返回$substring在$string的位置        |\n| str-insert($string, $insert, $index)    |       在$string的$index处插入$insert        |\n| str-slice($string, $start-at, $end-at） | 截取$string的$start-at和$end-at之间的字符串 |\n\n\n\n#### b. 数字函数\n\n| 函数名和参数类型        |                           函数作用                           |\n| ----------------------- | :----------------------------------------------------------: |\n| percentage($number)     |                       转换为百分比形式                       |\n| round($number)          |                        四舍五入为整数                        |\n| ceil($number)           |                         数值向上取整                         |\n| floor($number)          |                         数值向下取整                         |\n| abs($number)            |                          获取绝对值                          |\n| min($number...)         |                          获取最小值                          |\n| max($number...)         |                          获取最大值                          |\n| random($number?:number) | 不传入值：获得0-1的随机数；传入正整数n：获得0-n的随机整数（左开右闭） |\n\n\n\n#### c. 数组函数\n\n| 函数名和参数类型                 |                           函数作用                           |\n| -------------------------------- | :----------------------------------------------------------: |\n| length($list)                    |                         获取数组长度                         |\n| nth($list, n)                    |                      获取指定下标的元素                      |\n| set-nth($list, $n, $value)       |                   向$list的$n处插入$value                    |\n| join($list1, $list2, $separator) | 拼接$list1和list2；$separator为新list的分隔符，默认为auto，可选择comma、space |\n| append($list, $val, $separator)  | 向$list的末尾添加$val；$separator为新list的分隔符，默认为auto，可选择comma、space |\n| index($list, $value)             |                返回$value值在$list中的索引值                 |\n| zip($lists…)                     | 将几个列表结合成一个多维的列表；要求每个的列表个数值必须是相同的 |\n\n\n\n#### d. 映射函数\n\n| 函数名和参数类型        |                 函数作用                 |\n| ----------------------- | :--------------------------------------: |\n| map-get($map, $key)     |        获取$map中$key对应的$value        |\n| map-merge($map1, $map2) |     合并$map1和$map2，返回一个新$map     |\n| map-remove($map, $key)  |     从$map中删除$key，返回一个新$map     |\n| map-keys($map)          |            返回$map所有的$key            |\n| map-values($map)        |           返回$map所有的$value           |\n| map-has-key($map, $key) | 判断$map中是否存在$key，返回对应的布尔值 |\n| keywords($args)         |  返回一个函数的参数，并可以动态修改其值  |\n\n\n\n#### e. 颜色函数\n\n- **RGB函数**\n\n\t| 函数名和参数类型               |                           函数作用                           |\n\t| ------------------------------ | :----------------------------------------------------------: |\n\t| rgb($red, $green, $blue)       |                     返回一个16进制颜色值                     |\n\t| rgba($red,$green,$blue,$alpha) | 返回一个rgba；$red,$green和$blue可被当作一个整体以颜色单词、hsl、rgb或16进制形式传入 |\n\t| red($color)                    |                   从$color中获取其中红色值                   |\n\t| green($color)                  |                   从$color中获取其中绿色值                   |\n\t| blue($color)                   |                   从$color中获取其中蓝色值                   |\n\t| mix($color1,$color2,$weight?)  |     按照$weight比例，将$color1和$color2混合为一个新颜色      |\n\n- **HSL函数**\n\n\t| 函数名和参数类型                         | 函数作用                                                     |\n\t| ---------------------------------------- | ------------------------------------------------------------ |\n\t| hsl($hue,$saturation,$lightness)         | 通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色 |\n\t| hsla($hue,$saturation,$lightness,$alpha) | 通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色 |\n\t| saturation($color)                       | 从一个颜色中获取饱和度（saturation）值                       |\n\t| lightness($color)                        | 从一个颜色中获取亮度（lightness）值                          |\n\t| adjust-hue($color,$degrees)              | 通过改变一个颜色的色相值，创建一个新的颜色                   |\n\t| lighten($color,$amount)                  | 通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色           |\n\t| darken($color,$amount)                   | 通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色           |\n\t| hue($color)                              | 从一个颜色中获取亮度色相（hue）值                            |\n\n- **Opacity函数**\n\n\t|                                                             |                  |\n\t| ----------------------------------------------------------- | ---------------- |\n\t| alpha($color)/opacity($color)                               | 获取颜色透明度值 |\n\t| rgba($color,$alpha)                                         | 改变颜色的透明度 |\n\t| opacify($color, $amount) / fade-in($color, $amount)         | 使颜色更不透明   |\n\t| transparentize($color, $amount) / fade-out($color, $amount) | 使颜色更加透明   |\n\n\n\n#### f. Introspection函数\n\n| 函数名和参数类型               |                           函数作用                           |\n| ------------------------------ | :----------------------------------------------------------: |\n| type-of($value)                |                       返回$value的类型                       |\n| unit($number)                  |                      返回$number的单位                       |\n| unitless($number)              |           判断$number是否带单位，返回对应的布尔值            |\n| comparable($number1, $number2) | 判断$number1和$number2是否可以做加、减和合并，返回对应的布尔值 |\n\n\n\n\n\n### 2.自定义函数\n\n> Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用\n>\n> Params: 与Mixin一致\n>\n> \n>\n> 支持返回值\n\n**基本格式：**\n\n~~~scss\n@function fn-name($params...) {\n    @return $params;\n}\n~~~\n\n\n\n~~~scss\n// example:\n@function fn-name($params...) {\n    @return nth($params, 1);\n}\np {\n    height: fn-name(1px);\n}\n\n// compiled:\np {\n  height: 1px;\n}\n~~~\n\n\n\n\n\n\n\n------\n\n## 十一、细节与展望\n\n### 1.细节\n\na. @extend、@Mixin和@function的选择\n\n[原文链接](https://csswizardry.com/2016/02/mixins-better-for-performance/)\n\n\n\n> `minxins`在网络传输中比`@extend` 拥有更好的性能.尽管有些文件未压缩时更大，但使用`gzip`压缩后，依然可以保证我们拥有更好的性能。\n\n\n\n\n\n**所以@extend我们就尽量不要使用了，而@Mixin和@function的差别在定义和使用上**\n\n\n\n> 定义方式不同： `@function` 需要调用`@return`输出结果。而 @mixin则不需要。\n>\n> 使用方式不同：`@mixin` 使用`@include`引用，而 `@function` 使用小括号执行函数。\n\n\n\n\n\n\n\n### 2.展望\n\n>\n>\n>以上内容算是\"基础\"部分，但是对于日常开发，我觉得是足够使用的了。\n>\n>如果想要进一步了解，就必须先去学习下Ruby，使用Ruby相关模块进行更丰富地学习\n\n### Unfinished...","source":"_posts/SassScript.md","raw":"---\ntitle: SassScript\ndate: 2021-05-25 15:29:25\ntags: css\ncategories: 前端\nindex_img: /img/sass.gif\nbanner_img: /img/sass.jpg\n---\n# SassScript\n\n\n> 在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。\n\n> 弱类型语言, 对语法要求没那么严格\n\n\n\n\n## 一、注释\n\n1. Sass 支持标准的 CSS 多行注释 `/* */`，以及单行注释 `//`，前者会被完整输出到编译后的 CSS 文件中，而后者则不会。\n\n2. 将 `!` 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。\n\n3. 插值语句 (interpolation) 也可写进多行注释中输出变量值\n\n例如：\n\n~~~scss\n/* \n\thello\n\tworld!\n*/\n\n// compile scss files to css\n// it's ready to do it.\n$pink: #f3e1e1;\nhtml{\n    background-color: $pink;\n}\n\n$author: 'gdream@126.com';\n/*!\n\tAuthor: #{$author}.\n*/\n~~~\n\n开发模式编译后:\n\n~~~css\n/* \n\thello\n\tworld!\n*/\nhtml{\n    background-color: #f3e1e1;\n}\n/*!\n\tAuthor: 'gdream@126.com'.\n*/\n~~~\n\n压缩输出模式编译后：\n\n~~~css\nhtml{\n    background-color: #f3e1e1;\n}\n/*!\n\tAuthor: 'gdream@126.com'.\n*/\n~~~\n\n\n\n\n\n\n\n------\n\n## 二、变量\n\n### 1.定义\n\n变量以美元符号开头，赋值方法与 CSS 属性的写法一样\n\n~~~scss\n$width: 1600px;\n$pen-size: 3em;\n~~~\n\n### 2.使用\n\n直接使用变量的名称即可调用变量\n\n~~~scss\n#app {\n    height: $width;\n    font-size: $pen-size;\n}\n~~~\n\n### 3.作用域\n\n变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 `!global` 声明\n\n~~~scss\n#foo {\n  $width: 5em !global;\n  width: $width;\n}\n\n#bar {\n  width: $width;\n}\n~~~\n\n编译后：\n\n~~~css\n#foo {\n  width: 5em;\n}\n\n#bar {\n  width: 5em;\n}\n~~~\n\n\n\n\n\n\n\n------\n\n## 三、数据类型\n\nSassScript 支持 7 种主要的数据类型：\n\n- 数字，`1, 2, 13, 10px，5a`\n- 字符串，有引号字符串与无引号字符串，`\"foo\", 'bar', baz`\n- 颜色，`blue, #04a3f9, rgba(255,0,0,0.5)rgba(#333,.5)`\n- 布尔型，`true, false`\n- 空值，`null`\n- 数组 (list)，用空格或逗号作分隔符，`1.5em 1em 0 2em, Helvetica, Arial, sans-serif`\n- maps, 相当于 JavaScript 的 object，`(key1: value1, key2: value2)`\n\nSassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 `!important` 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。\n\n\n\n判断数据类型的方式：`type-of($value)`\n\n\n\n### 1.字符串 (Strings)\n\nSassScript 支持 CSS 的两种字符串类型：`有引号字符串 (quoted strings)`，和`无引号字符串 (unquoted strings)`。\n\n~~~scss\n$name: 'Tom Bob';\n$container: \"top bottom\";\n$what: heart;\n\n// 注：在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 `#{}` (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名\n~~~\n\n\n\n### 2.数字(Numbers)\n\nSassScript支持两种数字类型：`带单位数字`和`不带单位数字`。（可正可负可为零，可正可浮点）\n\n~~~scss\n$my-age: 19;\n$your-age: 19.5;\n$height: 120px;\n\n// 注：单位会和数字当做一个整体，进行算数运算\n~~~\n\n\n\n### 3.空值(Null)\n\n只有一个取值`null`\n\n~~~scss\n$value: null;\n\n// 注：由于它代表空，所以不能够使用它与任何类型进行算数运算\n~~~\n\n\n\n### 4.布尔型(Booleans)\n\n只有两个取值：`true`和`false`\n\n~~~scss\n$a: true;\n$b: false;\n\n// 注：只有自身是false和null才会返回false，其他一切都将返回true\n~~~\n\n\n\n### 5.数组 (Lists)\n\n通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。索引从`1`开始\n\n~~~scss\n$list0: 1px 2px 5px 6px;\n$list1: 1px 2px, 5px 6px;\n$list2: (1px 2px) (5px 6px);\n~~~\n\n数组中可以包含子数组，比如 `1px 2px, 5px 6px` 是包含 `1px 2px` 与 `5px 6px` 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 `(1px 2px) (5px 6px)`。变化是，之前的 `1px 2px, 5px 6px` 使用逗号分割了两个子数组 (comma-separated)，而 `(1px 2px) (5px 6px)` 则使用空格分割(space-separated)。\n\n当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 `(1px 2px) (5px 6px)` 与 `1px 2px, 5px 6px` 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。\n\n用 `()` 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 `font-family: ()` Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 `1px 2px () 3px` 或 `1px 2px null 3px`。\n\n基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 `(1,)` 表示只包含 `1` 的数组，而 `(1 2 3,)` 表示包含 `1 2 3` 这个以空格分隔的数组的数组。\n\n\n\n### 6.映射(Maps)\n\nMaps必须被圆括号包围，可以映射任何类型键值对（任何类型，包括内嵌maps，不过不推荐这种内嵌方式）\n\n~~~scss\n$map: ( \n  $key1: value1, \n  $key2: value2, \n  $key3: value3 \n)\n~~~\n\n\n\n### 7.颜色 (Colors)\n\nCSS原有颜色类型，十六进制、RGB、RGBA、HSL、HSLA和色彩单词\n\nSCSS提供了内置Colors函数，从而更方便地使用颜色\n\n~~~scss\n$color0: green;\n$color1: lighten($color, 15%);\n$color2: darken($color, 15%);\n$color3: saturate($color, 15%);\n$color4: desaturate($color, 15%);\n$color5: (green + red);\n~~~\n\n\n\n\n\n\n\n\n\n------\n\n## 四、运算\n\n### 1.数字运算符\n\nSassScript 支持数字的加减乘除、取整等运算 (`+, -, *, /, %`)，如果必要会在不同单位间转换值\n\n如果要保留运算符号，则应该使用插值语法\n\n- `+`\n\n\t~~~scss\n\t// 纯数字\n\t$add1: 1 + 2;\t// 3\n\t$add2: 1 + 2px; // 3px\n\t$add3: 1px + 2; // 3px\n\t$add4: 1px + 2px;//3px\n\t\n\t// 纯字符串\n\t$add5: \"a\" + \"b\"; // \"ab\"\n\t$add6: \"a\" + b;\t  // \"ab\"\n\t$add7: a + \"b\";\t  // ab\n\t$add8: a + b;\t  // ab\n\t\n\t// 数字和字符串\n\t$add9: 1 + a;\t// 1a\n\t$adda: a + 1;\t// a1\n\t$addb: \"1\" + a; // \"1a\"\n\t$addc: 1 + \"a\"; // \"1a\"\n\t$addd: \"a\" + 1; // \"a1\"\n\t$adde: a + \"1\"; // a1\n\t$addf: 1 + \"1\"; // \"11\"\n\t~~~\n\n\t~~~scss\n\t// 总结：\n\ta.纯数字：只要有单位，结果必有单位\n\tb.纯字符串：第一个字符串有无引号决定结果是否有引号\n\tc数字和字符串：第一位有引号，结果必为引号；第一位对应数字非数字且最后一位带有引号，则结果必为引号\n\t~~~\n\n- `-`\n\n\t~~~scss\n\t$add1: 1 - 2;\t// -1\n\t$add2: 1 - 2px; // -1px\n\t$add3: 1px - 2; // -1px\n\t$add4: 1px - 2px;//-1px\n\t\n\t$sub1: a - 1;  // a-1\n\t$sub2: 1 - a;  // 1-a\n\t$sub3: \"a\" - 1;// \"a\"-1\n\t$sub4: a - \"1\";// a-\"1\"\n\t~~~\n\n\t~~~scss\n\t// 总结：\n\t每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。\n\t只要其中一个值首位不为数字的，结果就按顺序去除空格后拼接起来\n\t~~~\n\n- `*`\n\n\t~~~scss\n\t$num1: 1 * 2;    // 2\n\t$mul2: 1 * 2px;  // 2px\n\t$num3: 1px * 2;  // 2px\n\t$num4: 2px * 2px;// 编译不通过\n\t\n\t$num5: 1 * 2abc; // 2abc\n\t~~~\n\n\t~~~scss\n\t// 总结：\n\t每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。其余编译不通过\n\t~~~\n\n- `/`\n\n\t~~~scss\n\t// 总结：\n\ta.不会四舍五入，精确到小数点后5位\n\tb.每个字段必须前部分为数字，且当前者只是单纯数字无单位时，后者(除数)后部分不能有字符。其余结果就按顺序去除空格后拼接起来。\n\t(因为此时后缀被当被单位看待了)\n\t~~~\n\n- `%`\n\n\t~~~scss\n\t// 总结：\n\ta.值与\"%\"之间必须要有空格，否则会被看做字符串\n\t~~~\n\n\t\n\n### 2.关系运算符\n\n大前提：两端必须为`数字` 或 `前部分数字后部分字符`\n\n返回值：`true` or `false`\n\n\n- `>`\n\n\t~~~scss\n\t$a: 1 > 2; // false\n\t~~~\n\n- `<`\n\n\t~~~scss\n\t$a: 1 > 2; // true\n\t~~~\n\n- `>=`\n\n\t~~~scss\n\t$a: 1 >= 2; // false\n\t~~~\n\n- `<=`\n\n\t~~~scss\n\t$a: 1 <= 2; // true\n\t~~~\n\n\t\n\n### 3.相等运算符\n\n作用范围：相等运算 `==, !=` 可用于所有数据类型\n\n返回值：`true` or `false`\n\n~~~scss\n$a: 1 == 1px; // true\n$b: \"a\" == a; // true\n~~~\n\n~~~scss\n// 总结：\n前部分为不带引号数字时，对比的仅仅是数字部分；反之，忽略引号，要求字符一一对应\n~~~\n\n\n\n### 4.布尔运算符\n\nSassScript 支持布尔型的 `and` `or` 以及 `not` 运算。\n\n~~~scss\n$a: 1>0 and 0>=5; // fasle\n~~~\n\n~~~scss\n// 总结：\n值与\"and\"、\"or\"和\"not\"之间必须要有空格，否则会被看做字符串\n~~~\n\n\n\n### 5.颜色值运算\n\n颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值\n\n- `颜色值与颜色值`\n\n\t~~~scss\n\tp {\n\t  color: #010203 + #040506;\n\t}\n\t\n\t// 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为\n\t// p {\n\t  color: #050709; }\n\t~~~\n\n- `颜色值与数字`\n\n\t~~~scss\n\tp {\n\t  color: #010203 * 2;\n\t}\n\t\n\t// 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为\n\t// p {\n\t  color: #020406; }\n\t~~~\n\n- `RGB和HSL`\n\n\t~~~scss\n\t// 如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。\n\t\n\tp {\n\t  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);\n\t}\n\t\n\t// p {\n\t  color: rgba(255, 255, 0, 0.75); }\n\t~~~\n\n\n\n### 6.运算优先级\n\n0. `()`\n\n1. `*`、`/`、`%`\n2. `+`、`-`\n3. `>` 、`<`、`>=`、`<=`\n\n\n\n\n\n\n\n\n\n------\n\n## 五、嵌套语法\n\n\n\n\n\n\n\n\n\n------\n\n## 六、杂货语法\n\n### 1.`插值语法`\n\n通过 `#{}` 插值语句可以在选择器、属性名和属性值中使用变量。\n\n但大多数情况下，这样使用属性值可能还不如直接使用变量方便，但是使用 `#{}` 可以避免 Sass 运行运算表达式，直接编译 CSS。\n\n~~~scss\n$name: foo;\n$attr: border;\np.#{$name} {\n  #{$attr}-color: $name;\n}\n\n// 编译后：\np.foo {\n  border-color: foo;\n}\n~~~\n\n### 2.`& in SassScript`\n\n`&`为父选择器\n\n~~~scss\na {\n    color: yellow;\n    &:hover{\n        color: green;\n    }\n    &:active{\n        color: blank;\n    }\n}\n~~~\n\n\n\n### 3.`!default`\n\n可以在变量的结尾添加 `!default` 给一个未通过 `!default` 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。\n\n~~~scss\n$content: \"First content\";\n$content: \"Second content?\" !default;\n$new_content: \"First time reference\" !default;\n\n#main {\n  content: $content;\n  new-content: $new_content;\n}\n\n// 编译为：\n#main {\n  content: \"First content\";\n  new-content: \"First time reference\"; }\n~~~\n\n注意：变量是 null 空值时将视为未被 `!default` 赋值。\n\n\n\n### 3.`!global`\n\n将局部变量提升为全局变量\n\n\n\n### 4.`!optional`\n\n如果 `@extend` 失败会收到错误提示，比如，这样写 `a.important {@extend .notice}`，当没有 `.notice` 选择器时，将会报错，只有 `h1.notice` 包含 `.notice` 时也会报错，因为 `h1` 与 `a` 冲突，会生成新的选择器。\n\n如果要求 `@extend` 不生成新选择器，可以通过 `!optional` 声明达到这个目的.\n\n简而言之：当`@extend`相关代码出现语法错误时，编译器可能会给我们\"乱\"编译为css，我们加上这个参数可以在出现问题后不让他编译该部分代码\n\n\n\n\n\n\n\n\n\n\n\n------\n\n## 七、@-Rules与指令\n\n### 1.`@import`\n\nSass 拓展了 `@import` 的功能，允许其导入 SCSS 或 SASS 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。\n\n通常，`@import` 寻找 Sass 文件并将其导入，但在以下情况下，`@import` 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。\n\n- 文件拓展名是 `.css`；\n- 文件名以 `http://` 开头；\n- 文件名是 `url()`；\n- `@import` 包含 media queries。\n\n如果不在上述情况内，文件的拓展名是 `.scss` 或 `.sass`，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 `.scss` 或 `.sass` 的文件并将其导入。\n\n~~~scss\n@import \"foo.scss\";\n@import \"foo\";\n// 以上两种方式均可\n\n\n// 以下方式均不可行\n@import \"foo.css\";\n@import \"foo\" screen;\n@import \"http://foo.com/bar\";\n@import url(foo);\n~~~\n\nSass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：\n\n~~~scss\n@import \"rounded-corners\", \"text-shadow\";\n~~~\n\n导入文件也可以使用 `#{ }` 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 `url()` 导入方式：\n\n~~~scss\n$family: unquote(\"Droid+Sans\");\n@import url(\"http://fonts.googleapis.com/css?family=\\#{$family}\");\n\n// 编译为：\n@import url(\"http://fonts.googleapis.com/css?family=Droid+Sans\");\n~~~\n\n如果你有一个 SCSS 或 Sass 文件需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。\n\n除此之外，还支持嵌套 @import,但是不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 `@import`。\n\n\n\n### 2.`@media`\n\nSass 中 `@media` 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 `@media` 嵌套在 CSS 规则内，编译时，`@media` 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 `@media` 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。\n\n~~~scss\n.sidebar {\n  width: 300px;\n  @media screen and (orientation: landscape) {\n    width: 500px;\n  }\n}\n// 编译为\n.sidebar {\n  width: 300px;\n  @media screen and (orientation: landscape) {\n    width: 500px;\n  }\n}\n~~~\n\n`@media`的 queries 允许互相嵌套使用，编译时，Sass 自动添加 `and`\n\n~~~scss\n@media screen {\n  .sidebar {\n    @media (orientation: landscape) {\n      width: 500px;\n    }\n  }\n}\n// 编译为：\n@media screen and (orientation: landscape) {\n  .sidebar {\n    width: 500px; } }\n~~~\n\n`@media` 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值\n\n~~~scss\n$media: screen;\n$feature: -webkit-min-device-pixel-ratio;\n$value: 1.5;\n\n@media #{$media} and ($feature: $value) {\n  .sidebar {\n    width: 500px;\n  }\n}\n// 编译为：\n@media screen and (-webkit-min-device-pixel-ratio: 1.5) {\n  .sidebar {\n    width: 500px; } }\n~~~\n\n\n\n### 3.`*@extend`\n\n`@extend`即`继承`。在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。\n\n总的来看：支持层叠继承、多继承、允许延伸任何定义给单个元素的选择器（但是允许不一定好用）\n\na. `基本延伸`\n\n~~~scss\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\n// 上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。\n~~~\n\n`@extend` 的作用是将重复使用的样式 (`.error`) 延伸 (extend) 给需要包含这个样式的特殊样式（`.seriousError`）\n\n注意理解以下情况：\n\n~~~scss\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.error.intrusion {\n  background-image: url(\"/image/hacked.png\");\n}\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\n// .error, .seriousError {\n  border: 1px #f00;\n  background-color: #fdd; }\n\n.error.intrusion, .seriousError.intrusion {\n  background-image: url(\"/image/hacked.png\"); }\n\n.seriousError {\n  border-width: 3px; }\n~~~\n\n当合并选择器时，`@extend` 会很聪明地避免无谓的重复，`.seriousError.seriousError` 将编译为 `.seriousError`，不能匹配任何元素的选择器也会删除。\n\n\n\nb.  `延伸复杂的选择器`：Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 `.special.cool`，`a:hover` 或者 `a.user[href^=\"http://\"]` 等\n\n\n\nc. ` 多重延伸`：同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器\n\n\n\nd. `继续延伸`：当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个\n\n\n\ne.`*选择器列`：暂时不可以将选择器列 (Selector Sequences)，比如 `.foo .bar` 或 `.foo + .bar`，延伸给其他元素，但是，却可以将其他元素延伸给选择器列。\n\n尽量不使用`合并选择器列`，因为如果凭个人推理的话，会出现排列组合的情况，所以SASS编译器只会保留有用的组合形式，但依旧会存在排列组合的情况，有可能会留下隐患。\n\n1. 当两个列合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前\n\n\t~~~scss\n\t#admin .tabbar a {\n\t  font-weight: bold;\n\t}\n\t#demo .overview .fakelink {\n\t  @extend a;\n\t}\n\t// 编译为：\n\t#admin .tabbar a,\n\t#admin .tabbar #demo .overview .fakelink,\n\t#demo .overview #admin .tabbar .fakelink {\n\t  font-weight: bold; }\n\t~~~\n\n\t\n\n2. 如果两个列包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出\n\n\t~~~scss\n\t#admin .tabbar a {\n\t  font-weight: bold;\n\t}\n\t#admin .overview .fakelink {\n\t  @extend a;\n\t}\n\t// 编译为\n\t#admin .tabbar a,\n\t#admin .tabbar .overview .fakelink,\n\t#admin .overview .tabbar .fakelink {\n\t  font-weight: bold; }\n\t~~~\n\n\t\n\nf. `在指令中延伸`\n\n在指令中使用 `@extend` 时（比如在 `@media` 中）有一些限制：Sass 不可以将 `@media` 层外的 CSS 规则延伸给指令层内的 CSS.\n\n\n\ng.  `%placeholder`为选择器占位符，配合`@extend-Only选择器`使用。\n\n效果：只定义了样式，但不会对原有选择器匹配的元素生效\n\n~~~scss\n// example1:\n%img {\n    color: red;\n}\n.path{\n    @extend %img;\n}\n// 编译后：\n.path {\n  color: red;\n}\n~~~\n\n~~~scss\n// example2:\n#context a%extreme {\n  color: blue;\n  font-weight: bold;\n  font-size: 2em;\n}\n// 编译后：\n.notice {\n  @extend %extreme;\n}\n\n// 注：必须是\".\"和\"#\"选择器\n~~~\n\n\n\n### 4.`@at-root`\n\n> The @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector\n\n译文：@at root指令使一个或多个规则在文档的根发出，而不是嵌套在其父选择器下。它可以与单个内联选择器一起使用\n\n且@at-root 使多个规则跳出嵌套\n\n@at-root默认情况下并不能使规则或者选择器跳出指令，通过使用without和with可以解决该问题\n\n了解即可\n\n\n\n### 5.`@debug`\n\n用于调试，按标准错误输出流输出\n\n~~~scss\n$size: 9px;\n\n.file{\n  @debug $size;\n}\n~~~\n\n\n\n### 6.`@warn`\n\n用于警告，按标准错误输出流输出\n\n\n\n### 7.`@error`\n\n用于报错，按标准错误输出流输出\n\n\n\n\n\n| 序列 | @-rules  | 作用                               |\n| ---- | -------- | ---------------------------------- |\n| 1    | @import  | 导入sass或scss文件                 |\n| 2    | @media   | 用于将样式规则设置为不同的媒体类型 |\n| 3    | @extend  | 以继承的方式共享选择器             |\n| 4    | @at-root | 转到根节点                         |\n| 5    | @debug   | 用于调试，按标准错误输出流输出     |\n| 6    | @warn    | 用于警告，按标准错误输出流输出     |\n| 7    | @error   | 用于报错，按标准错误输出流输出     |\n\n\n\n\n\n\n\n\n\n------\n\n## 八、控制指令\n\n### 1.`if()`\n\n*三元运算符*\n\n表达式：`if(expression, value1, value2)`\n\n~~~scss\np {\n    color: if(1 + 1 = 2, green, yellow);\n}\n\n// compile:\np{\n    color: green;}\n~~~\n\n\n\n### 2.`@if`\n\n*条件语句*\n\n当 `@if` 的表达式返回值不是 `false` 或者 `null` 时，条件成立，输出 `{}` 内的代码\n\n`@if` 声明后面可以跟多个 `@else if` 声明，或者一个 `@else` 声明。如果 `@if` 声明失败，Sass 将逐条执行 `@else if` 声明，如果全部失败，最后执行 `@else` 声明\n\n- `单@if`\n\n\t~~~scss\n\tp {\n\t    @if 1 + 1 == 2 {\n\t        color: red;\n\t    }\n\t}\n\t\n\t// compile:\n\tp {\n\t  color: red;\n\t}\n\t~~~\n\n- `@if - @else`\n\n\t~~~scss\n\tp {\n\t    @if 1 + 1 != 2 {\n\t        color: red;\n\t    } @else {\n\t        color: blue;\n\t    }\n\t}\n\t\n\t// compile:\n\tp {\n\t  color: blue;\n\t}\n\t~~~\n\n- `@if - @else if - @else`\n\n\t~~~scss\n\t$age: 19;\n\t\n\tp {\n\t    @if $age == 18 {\n\t        color: red;\n\t    } @else if $age == 19 {\n\t        color: blue;\n\t    } @else {\n\t        color: green;\n\t    }\n\t}\n\t\n\t// compile:\n\tp {\n\t  color: blue;\n\t}\n\t~~~\n\n\n\n### 3.`@for`\n\n*循环语句*\n\n表达式：`@for $var from <start> through <end>` 或 `@for $var from <start> to <end>`\n\n\n\nthrough 和 to 的相同点与不同点：\n\n- 相同点：两者均包含<start>的值\n- 不同点：through包含<end>的值，但to不包含<end>的值\n\n\n\n~~~scss\n@for $i from 1 through 3 {\n  .item-#{$i} { width: 2em * $i; }\n}\n\n// compile:\n.item-1 {\n  width: 2em; }\n.item-2 {\n  width: 4em; }\n.item-3 {\n  width: 6em; }\n~~~\n\n\n\n\n\n### 4.`@while`\n\n*循环语句*\n\n表达式：`@while expression`\n\n\n\n`@while` 指令重复输出格式直到表达式返回结果为 `false`。这样可以实现比 `@for` 更复杂的循环，只是很少会用到\n\n\n\n~~~scss\n$i: 6;\n@while $i > 0 {\n  .item-#{$i} { width: 2em * $i; }\n  $i: $i - 2;\n}\n\n// compile:\n.item-6 {\n  width: 12em; }\n.item-4 {\n  width: 8em; }\n.item-2 {\n  width: 4em; }\n~~~\n\n\n\n\n\n### 5.`@each`\n\n*循环语句*\n\n表达式：`$var in $vars`\n\n\n\n`$var` 可以是任何变量名\n\n`$vars` 只能是`Lists`或者`Maps`\n\n\n\n- 一维列表\n\n\t~~~scss\n\t@each $animal in puma, sea-slug, egret, salamander {\n\t  .#{$animal}-icon {\n\t    background-image: url('/images/#{$animal}.png');\n\t  }\n\t}\n\t\n\t// compile:\n\t.puma-icon {\n\t  background-image: url('/images/puma.png'); }\n\t.sea-slug-icon {\n\t  background-image: url('/images/sea-slug.png'); }\n\t.egret-icon {\n\t  background-image: url('/images/egret.png'); }\n\t.salamander-icon {\n\t  background-image: url('/images/salamander.png'); }\n\t~~~\n\n- 二维列表\n\n\t~~~scss\n\t@each $animal, $color, $cursor in (puma, black, default),\n\t                                  (sea-slug, blue, pointer),\n\t                                  (egret, white, move) {\n\t  .#{$animal}-icon {\n\t    background-image: url('/images/#{$animal}.png');\n\t    border: 2px solid $color;\n\t    cursor: $cursor;\n\t  }\n\t}\n\t\n\t// compile:\n\t.puma-icon {\n\t  background-image: url('/images/puma.png');\n\t  border: 2px solid black;\n\t  cursor: default; }\n\t.sea-slug-icon {\n\t  background-image: url('/images/sea-slug.png');\n\t  border: 2px solid blue;\n\t  cursor: pointer; }\n\t.egret-icon {\n\t  background-image: url('/images/egret.png');\n\t  border: 2px solid white;\n\t  cursor: move; }\n\t~~~\n\n- maps\n\n\t~~~scss\n\t@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {\n\t  #{$header} {\n\t    font-size: $size;\n\t  }\n\t}\n\t\n\t// compile:\n\th1 {\n\t  font-size: 2em; }\n\th2 {\n\t  font-size: 1.5em; }\n\th3 {\n\t  font-size: 1.2em; }\n\t~~~\n\n\t\n\n\n\n\n\n\n\n-----\n\n## 九、混合指令\n\n> 混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 `.float-left`。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。\n\n注意：这不是函数！没有返回值！！\n\n\n\n### 1.定义混合指令\n\n混合指令的用法是在 `@mixin` 后添加名称与样式，以及需要的参数（可选）。\n\n~~~scss\n// 格式：\n@mixin name {\n    // 样式....\n}\n~~~\n\n~~~scss\n// example：\n@mixin large-text {\n  font: {\n    family: Arial;\n    size: 20px;\n    weight: bold;\n  }\n  color: #ff0000;\n}\n~~~\n\n\n\n### 2.引用混合样式\n\n使用 `@include` 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）。\n\n~~~scss\n// 格式：\n@include name;\n\n// 注：无参数或参数都有默认值时，带不带括号都可以\n~~~\n\n~~~scss\n// example：\np {\n    @include large-text;\n}\n\n// compile:\np {\n  font-family: Arial;\n  font-size: 20px;\n  font-weight: bold;\n  color: #ff0000;\n}\n~~~\n\n\n\n### 3.参数\n\n格式：按照变量的格式，通过逗号分隔，将参数写进Mixin名称后的圆括号里\n\n支持默认值；支持多参数；支持不定参数；支持位置传参和关键词传参\n\n\n\n#### a. 位置传参\n\n~~~scss\n@mixin mp($width) {\n    margin: $width;\n}\n\nbody {\n    @include mp(300px);\n}\n~~~\n\n\n\n#### b.关键词传参\n\n~~~scss\n@mixin mp($width) {\n    margin: $width;\n}\n\nbody {\n    @include mp($width: 300px);\n}\n~~~\n\n\n\n#### c.参数默认值\n\n~~~scss\n@mixin mp($width: 500px) {\n    margin: $width;\n}\n\nbody {\n    @include mp($width: 300px);\n    // or\n    @include mp(300px);\n}\n~~~\n\n\n\n#### d.不定参数\n\n> 官方：Variable Arguments\n>\n> 译文：参数变量\n>\n> \n>\n> 有时，不能确定混合指令需要使用多少个参数。这时，可以使用参数变量 `…` 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理\n\n~~~scss\n@mixin mar($value...) {\n    margin: $value;\n}\n~~~\n\n\n\n### 4.向混合样式中导入内容\n\n在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 `@content` 标志的地方\n\n可以看作参数的升级版\n\n~~~scss\n@mixin example {\n    html {\n        @content;\n    }\n}\n@include example{\n    background-color: red;\n    .logo {\n        width: 600px;\n    }\n}\n\n// compile:\nhtml {\n  background-color: red;\n}\n\nhtml .logo {\n  width: 600px;\n}\n\n~~~\n\n\n\n\n\n\n\n\n\n------\n\n## 十、函数指令\n\n### 1.内置函数\n\n#### a. 字符串函数\n\n> 索引第一个为1，最后一个为-1；切片两边均为闭区间\n\n| 函数名和参数类型                        |                  函数作用                   |\n| :-------------------------------------- | :-----------------------------------------: |\n| quote($string)                          |                  添加引号                   |\n| unquote($string)                        |                  除去引号                   |\n| to-lower-case($string)                  |                  变为小写                   |\n| to-upper-case($string)                  |                  变为大写                   |\n| str-length($string)                     |        返回$string的长度(汉字算一个)        |\n| str-index($string，$substring)          |        返回$substring在$string的位置        |\n| str-insert($string, $insert, $index)    |       在$string的$index处插入$insert        |\n| str-slice($string, $start-at, $end-at） | 截取$string的$start-at和$end-at之间的字符串 |\n\n\n\n#### b. 数字函数\n\n| 函数名和参数类型        |                           函数作用                           |\n| ----------------------- | :----------------------------------------------------------: |\n| percentage($number)     |                       转换为百分比形式                       |\n| round($number)          |                        四舍五入为整数                        |\n| ceil($number)           |                         数值向上取整                         |\n| floor($number)          |                         数值向下取整                         |\n| abs($number)            |                          获取绝对值                          |\n| min($number...)         |                          获取最小值                          |\n| max($number...)         |                          获取最大值                          |\n| random($number?:number) | 不传入值：获得0-1的随机数；传入正整数n：获得0-n的随机整数（左开右闭） |\n\n\n\n#### c. 数组函数\n\n| 函数名和参数类型                 |                           函数作用                           |\n| -------------------------------- | :----------------------------------------------------------: |\n| length($list)                    |                         获取数组长度                         |\n| nth($list, n)                    |                      获取指定下标的元素                      |\n| set-nth($list, $n, $value)       |                   向$list的$n处插入$value                    |\n| join($list1, $list2, $separator) | 拼接$list1和list2；$separator为新list的分隔符，默认为auto，可选择comma、space |\n| append($list, $val, $separator)  | 向$list的末尾添加$val；$separator为新list的分隔符，默认为auto，可选择comma、space |\n| index($list, $value)             |                返回$value值在$list中的索引值                 |\n| zip($lists…)                     | 将几个列表结合成一个多维的列表；要求每个的列表个数值必须是相同的 |\n\n\n\n#### d. 映射函数\n\n| 函数名和参数类型        |                 函数作用                 |\n| ----------------------- | :--------------------------------------: |\n| map-get($map, $key)     |        获取$map中$key对应的$value        |\n| map-merge($map1, $map2) |     合并$map1和$map2，返回一个新$map     |\n| map-remove($map, $key)  |     从$map中删除$key，返回一个新$map     |\n| map-keys($map)          |            返回$map所有的$key            |\n| map-values($map)        |           返回$map所有的$value           |\n| map-has-key($map, $key) | 判断$map中是否存在$key，返回对应的布尔值 |\n| keywords($args)         |  返回一个函数的参数，并可以动态修改其值  |\n\n\n\n#### e. 颜色函数\n\n- **RGB函数**\n\n\t| 函数名和参数类型               |                           函数作用                           |\n\t| ------------------------------ | :----------------------------------------------------------: |\n\t| rgb($red, $green, $blue)       |                     返回一个16进制颜色值                     |\n\t| rgba($red,$green,$blue,$alpha) | 返回一个rgba；$red,$green和$blue可被当作一个整体以颜色单词、hsl、rgb或16进制形式传入 |\n\t| red($color)                    |                   从$color中获取其中红色值                   |\n\t| green($color)                  |                   从$color中获取其中绿色值                   |\n\t| blue($color)                   |                   从$color中获取其中蓝色值                   |\n\t| mix($color1,$color2,$weight?)  |     按照$weight比例，将$color1和$color2混合为一个新颜色      |\n\n- **HSL函数**\n\n\t| 函数名和参数类型                         | 函数作用                                                     |\n\t| ---------------------------------------- | ------------------------------------------------------------ |\n\t| hsl($hue,$saturation,$lightness)         | 通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色 |\n\t| hsla($hue,$saturation,$lightness,$alpha) | 通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色 |\n\t| saturation($color)                       | 从一个颜色中获取饱和度（saturation）值                       |\n\t| lightness($color)                        | 从一个颜色中获取亮度（lightness）值                          |\n\t| adjust-hue($color,$degrees)              | 通过改变一个颜色的色相值，创建一个新的颜色                   |\n\t| lighten($color,$amount)                  | 通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色           |\n\t| darken($color,$amount)                   | 通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色           |\n\t| hue($color)                              | 从一个颜色中获取亮度色相（hue）值                            |\n\n- **Opacity函数**\n\n\t|                                                             |                  |\n\t| ----------------------------------------------------------- | ---------------- |\n\t| alpha($color)/opacity($color)                               | 获取颜色透明度值 |\n\t| rgba($color,$alpha)                                         | 改变颜色的透明度 |\n\t| opacify($color, $amount) / fade-in($color, $amount)         | 使颜色更不透明   |\n\t| transparentize($color, $amount) / fade-out($color, $amount) | 使颜色更加透明   |\n\n\n\n#### f. Introspection函数\n\n| 函数名和参数类型               |                           函数作用                           |\n| ------------------------------ | :----------------------------------------------------------: |\n| type-of($value)                |                       返回$value的类型                       |\n| unit($number)                  |                      返回$number的单位                       |\n| unitless($number)              |           判断$number是否带单位，返回对应的布尔值            |\n| comparable($number1, $number2) | 判断$number1和$number2是否可以做加、减和合并，返回对应的布尔值 |\n\n\n\n\n\n### 2.自定义函数\n\n> Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用\n>\n> Params: 与Mixin一致\n>\n> \n>\n> 支持返回值\n\n**基本格式：**\n\n~~~scss\n@function fn-name($params...) {\n    @return $params;\n}\n~~~\n\n\n\n~~~scss\n// example:\n@function fn-name($params...) {\n    @return nth($params, 1);\n}\np {\n    height: fn-name(1px);\n}\n\n// compiled:\np {\n  height: 1px;\n}\n~~~\n\n\n\n\n\n\n\n------\n\n## 十一、细节与展望\n\n### 1.细节\n\na. @extend、@Mixin和@function的选择\n\n[原文链接](https://csswizardry.com/2016/02/mixins-better-for-performance/)\n\n\n\n> `minxins`在网络传输中比`@extend` 拥有更好的性能.尽管有些文件未压缩时更大，但使用`gzip`压缩后，依然可以保证我们拥有更好的性能。\n\n\n\n\n\n**所以@extend我们就尽量不要使用了，而@Mixin和@function的差别在定义和使用上**\n\n\n\n> 定义方式不同： `@function` 需要调用`@return`输出结果。而 @mixin则不需要。\n>\n> 使用方式不同：`@mixin` 使用`@include`引用，而 `@function` 使用小括号执行函数。\n\n\n\n\n\n\n\n### 2.展望\n\n>\n>\n>以上内容算是\"基础\"部分，但是对于日常开发，我觉得是足够使用的了。\n>\n>如果想要进一步了解，就必须先去学习下Ruby，使用Ruby相关模块进行更丰富地学习\n\n### Unfinished...","slug":"SassScript","published":1,"updated":"2024-11-17T13:58:10.668Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpf000c73t38x5yf6h5","content":"<h1 id=\"SassScript\"><a href=\"#SassScript\" class=\"headerlink\" title=\"SassScript\"></a>SassScript</h1><blockquote>\n<p>在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。</p>\n</blockquote>\n<blockquote>\n<p>弱类型语言, 对语法要求没那么严格</p>\n</blockquote>\n<h2 id=\"一、注释\"><a href=\"#一、注释\" class=\"headerlink\" title=\"一、注释\"></a>一、注释</h2><ol>\n<li><p>Sass 支持标准的 CSS 多行注释 <code>/* */</code>，以及单行注释 <code>//</code>，前者会被完整输出到编译后的 CSS 文件中，而后者则不会。</p>\n</li>\n<li><p>将 <code>!</code> 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。</p>\n</li>\n<li><p>插值语句 (interpolation) 也可写进多行注释中输出变量值</p>\n</li>\n</ol>\n<p>例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">\thello</span><br><span class=\"hljs-comment\">\tworld!</span><br><span class=\"hljs-comment\">*/</span><br><br><span class=\"hljs-comment\">// compile scss files to css</span><br><span class=\"hljs-comment\">// it&#x27;s ready to do it.</span><br><span class=\"hljs-variable\">$pink</span>: <span class=\"hljs-number\">#f3e1e1</span>;<br><span class=\"hljs-selector-tag\">html</span>&#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-variable\">$pink</span>;<br>&#125;<br><br><span class=\"hljs-variable\">$author</span>: <span class=\"hljs-string\">&#x27;gdream@126.com&#x27;</span>;<br><span class=\"hljs-comment\">/*!</span><br><span class=\"hljs-comment\">\tAuthor: #&#123;$author&#125;.</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<p>开发模式编译后:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">\thello</span><br><span class=\"hljs-comment\">\tworld!</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-selector-tag\">html</span>&#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#f3e1e1</span>;<br>&#125;<br><span class=\"hljs-comment\">/*!</span><br><span class=\"hljs-comment\">\tAuthor: &#x27;gdream@126.com&#x27;.</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<p>压缩输出模式编译后：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">html</span>&#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#f3e1e1</span>;<br>&#125;<br><span class=\"hljs-comment\">/*!</span><br><span class=\"hljs-comment\">\tAuthor: &#x27;gdream@126.com&#x27;.</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<hr>\n<h2 id=\"二、变量\"><a href=\"#二、变量\" class=\"headerlink\" title=\"二、变量\"></a>二、变量</h2><h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1.定义\"></a>1.定义</h3><p>变量以美元符号开头，赋值方法与 CSS 属性的写法一样</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">1600px</span>;<br><span class=\"hljs-variable\">$pen-size</span>: <span class=\"hljs-number\">3em</span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2.使用\"></a>2.使用</h3><p>直接使用变量的名称即可调用变量</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-id\">#app</span> &#123;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-variable\">$width</span>;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-variable\">$pen-size</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-作用域\"><a href=\"#3-作用域\" class=\"headerlink\" title=\"3.作用域\"></a>3.作用域</h3><p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 <code>!global</code> 声明</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-id\">#foo</span> &#123;<br>  <span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">5em</span> !global;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-variable\">$width</span>;<br>&#125;<br><br><span class=\"hljs-selector-id\">#bar</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-variable\">$width</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>编译后：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-id\">#foo</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">5em</span>;<br>&#125;<br><br><span class=\"hljs-selector-id\">#bar</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">5em</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<hr>\n<h2 id=\"三、数据类型\"><a href=\"#三、数据类型\" class=\"headerlink\" title=\"三、数据类型\"></a>三、数据类型</h2><p>SassScript 支持 7 种主要的数据类型：</p>\n<ul>\n<li>数字，<code>1, 2, 13, 10px，5a</code></li>\n<li>字符串，有引号字符串与无引号字符串，<code>&quot;foo&quot;, &#39;bar&#39;, baz</code></li>\n<li>颜色，<code>blue, #04a3f9, rgba(255,0,0,0.5)rgba(#333,.5)</code></li>\n<li>布尔型，<code>true, false</code></li>\n<li>空值，<code>null</code></li>\n<li>数组 (list)，用空格或逗号作分隔符，<code>1.5em 1em 0 2em, Helvetica, Arial, sans-serif</code></li>\n<li>maps, 相当于 JavaScript 的 object，<code>(key1: value1, key2: value2)</code></li>\n</ul>\n<p>SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 <code>!important</code> 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。</p>\n<p>判断数据类型的方式：<code>type-of($value)</code></p>\n<h3 id=\"1-字符串-Strings\"><a href=\"#1-字符串-Strings\" class=\"headerlink\" title=\"1.字符串 (Strings)\"></a>1.字符串 (Strings)</h3><p>SassScript 支持 CSS 的两种字符串类型：<code>有引号字符串 (quoted strings)</code>，和<code>无引号字符串 (unquoted strings)</code>。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$name</span>: <span class=\"hljs-string\">&#x27;Tom Bob&#x27;</span>;<br><span class=\"hljs-variable\">$container</span>: <span class=\"hljs-string\">&quot;top bottom&quot;</span>;<br><span class=\"hljs-variable\">$what</span>: heart;<br><br><span class=\"hljs-comment\">// 注：在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 `#&#123;&#125;` (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-数字-Numbers\"><a href=\"#2-数字-Numbers\" class=\"headerlink\" title=\"2.数字(Numbers)\"></a>2.数字(Numbers)</h3><p>SassScript支持两种数字类型：<code>带单位数字</code>和<code>不带单位数字</code>。（可正可负可为零，可正可浮点）</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$my-age</span>: <span class=\"hljs-number\">19</span>;<br><span class=\"hljs-variable\">$your-age</span>: <span class=\"hljs-number\">19.5</span>;<br><span class=\"hljs-variable\">$height</span>: <span class=\"hljs-number\">120px</span>;<br><br><span class=\"hljs-comment\">// 注：单位会和数字当做一个整体，进行算数运算</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-空值-Null\"><a href=\"#3-空值-Null\" class=\"headerlink\" title=\"3.空值(Null)\"></a>3.空值(Null)</h3><p>只有一个取值<code>null</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$value</span>: null;<br><br><span class=\"hljs-comment\">// 注：由于它代表空，所以不能够使用它与任何类型进行算数运算</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-布尔型-Booleans\"><a href=\"#4-布尔型-Booleans\" class=\"headerlink\" title=\"4.布尔型(Booleans)\"></a>4.布尔型(Booleans)</h3><p>只有两个取值：<code>true</code>和<code>false</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: true;<br><span class=\"hljs-variable\">$b</span>: false;<br><br><span class=\"hljs-comment\">// 注：只有自身是false和null才会返回false，其他一切都将返回true</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-数组-Lists\"><a href=\"#5-数组-Lists\" class=\"headerlink\" title=\"5.数组 (Lists)\"></a>5.数组 (Lists)</h3><p>通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。索引从<code>1</code>开始</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$list0</span>: <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">6px</span>;<br><span class=\"hljs-variable\">$list1</span>: <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">2px</span>, <span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">6px</span>;<br><span class=\"hljs-variable\">$list2</span>: (<span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">2px</span>) (<span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">6px</span>);<br></code></pre></td></tr></table></figure>\n\n<p>数组中可以包含子数组，比如 <code>1px 2px, 5px 6px</code> 是包含 <code>1px 2px</code> 与 <code>5px 6px</code> 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 <code>(1px 2px) (5px 6px)</code>。变化是，之前的 <code>1px 2px, 5px 6px</code> 使用逗号分割了两个子数组 (comma-separated)，而 <code>(1px 2px) (5px 6px)</code> 则使用空格分割(space-separated)。</p>\n<p>当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 <code>(1px 2px) (5px 6px)</code> 与 <code>1px 2px, 5px 6px</code> 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。</p>\n<p>用 <code>()</code> 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 <code>font-family: ()</code> Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 <code>1px 2px () 3px</code> 或 <code>1px 2px null 3px</code>。</p>\n<p>基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 <code>(1,)</code> 表示只包含 <code>1</code> 的数组，而 <code>(1 2 3,)</code> 表示包含 <code>1 2 3</code> 这个以空格分隔的数组的数组。</p>\n<h3 id=\"6-映射-Maps\"><a href=\"#6-映射-Maps\" class=\"headerlink\" title=\"6.映射(Maps)\"></a>6.映射(Maps)</h3><p>Maps必须被圆括号包围，可以映射任何类型键值对（任何类型，包括内嵌maps，不过不推荐这种内嵌方式）</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$map</span>: ( <br>  <span class=\"hljs-variable\">$key1</span>: value1, <br>  <span class=\"hljs-variable\">$key2</span>: value2, <br>  <span class=\"hljs-variable\">$key3</span>: value3 <br>)<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"7-颜色-Colors\"><a href=\"#7-颜色-Colors\" class=\"headerlink\" title=\"7.颜色 (Colors)\"></a>7.颜色 (Colors)</h3><p>CSS原有颜色类型，十六进制、RGB、RGBA、HSL、HSLA和色彩单词</p>\n<p>SCSS提供了内置Colors函数，从而更方便地使用颜色</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$color0</span>: green;<br><span class=\"hljs-variable\">$color1</span>: <span class=\"hljs-built_in\">lighten</span>(<span class=\"hljs-variable\">$color</span>, <span class=\"hljs-number\">15%</span>);<br><span class=\"hljs-variable\">$color2</span>: <span class=\"hljs-built_in\">darken</span>(<span class=\"hljs-variable\">$color</span>, <span class=\"hljs-number\">15%</span>);<br><span class=\"hljs-variable\">$color3</span>: <span class=\"hljs-built_in\">saturate</span>(<span class=\"hljs-variable\">$color</span>, <span class=\"hljs-number\">15%</span>);<br><span class=\"hljs-variable\">$color4</span>: <span class=\"hljs-built_in\">desaturate</span>(<span class=\"hljs-variable\">$color</span>, <span class=\"hljs-number\">15%</span>);<br><span class=\"hljs-variable\">$color5</span>: (green + red);<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<hr>\n<h2 id=\"四、运算\"><a href=\"#四、运算\" class=\"headerlink\" title=\"四、运算\"></a>四、运算</h2><h3 id=\"1-数字运算符\"><a href=\"#1-数字运算符\" class=\"headerlink\" title=\"1.数字运算符\"></a>1.数字运算符</h3><p>SassScript 支持数字的加减乘除、取整等运算 (<code>+, -, *, /, %</code>)，如果必要会在不同单位间转换值</p>\n<p>如果要保留运算符号，则应该使用插值语法</p>\n<ul>\n<li><p><code>+</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 纯数字</span><br><span class=\"hljs-variable\">$add1</span>: <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span>;\t<span class=\"hljs-comment\">// 3</span><br><span class=\"hljs-variable\">$add2</span>: <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2px</span>; <span class=\"hljs-comment\">// 3px</span><br><span class=\"hljs-variable\">$add3</span>: <span class=\"hljs-number\">1px</span> + <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 3px</span><br><span class=\"hljs-variable\">$add4</span>: <span class=\"hljs-number\">1px</span> + <span class=\"hljs-number\">2px</span>;<span class=\"hljs-comment\">//3px</span><br><br><span class=\"hljs-comment\">// 纯字符串</span><br><span class=\"hljs-variable\">$add5</span>: <span class=\"hljs-string\">&quot;a&quot;</span> + <span class=\"hljs-string\">&quot;b&quot;</span>; <span class=\"hljs-comment\">// &quot;ab&quot;</span><br><span class=\"hljs-variable\">$add6</span>: <span class=\"hljs-string\">&quot;a&quot;</span> + b;\t  <span class=\"hljs-comment\">// &quot;ab&quot;</span><br><span class=\"hljs-variable\">$add7</span>: a + <span class=\"hljs-string\">&quot;b&quot;</span>;\t  <span class=\"hljs-comment\">// ab</span><br><span class=\"hljs-variable\">$add8</span>: a + b;\t  <span class=\"hljs-comment\">// ab</span><br><br><span class=\"hljs-comment\">// 数字和字符串</span><br><span class=\"hljs-variable\">$add9</span>: <span class=\"hljs-number\">1</span> + a;\t<span class=\"hljs-comment\">// 1a</span><br><span class=\"hljs-variable\">$adda</span>: a + <span class=\"hljs-number\">1</span>;\t<span class=\"hljs-comment\">// a1</span><br><span class=\"hljs-variable\">$addb</span>: <span class=\"hljs-string\">&quot;1&quot;</span> + a; <span class=\"hljs-comment\">// &quot;1a&quot;</span><br><span class=\"hljs-variable\">$addc</span>: <span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">&quot;a&quot;</span>; <span class=\"hljs-comment\">// &quot;1a&quot;</span><br><span class=\"hljs-variable\">$addd</span>: <span class=\"hljs-string\">&quot;a&quot;</span> + <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// &quot;a1&quot;</span><br><span class=\"hljs-variable\">$adde</span>: a + <span class=\"hljs-string\">&quot;1&quot;</span>; <span class=\"hljs-comment\">// a1</span><br><span class=\"hljs-variable\">$addf</span>: <span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">&quot;1&quot;</span>; <span class=\"hljs-comment\">// &quot;11&quot;</span><br></code></pre></td></tr></table></figure>\n\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br><span class=\"hljs-selector-tag\">a</span>.纯数字：只要有单位，结果必有单位<br><span class=\"hljs-selector-tag\">b</span>.纯字符串：第一个字符串有无引号决定结果是否有引号<br>c数字和字符串：第一位有引号，结果必为引号；第一位对应数字非数字且最后一位带有引号，则结果必为引号<br></code></pre></td></tr></table></figure></li>\n<li><p><code>-</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$add1</span>: <span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">2</span>;\t<span class=\"hljs-comment\">// -1</span><br><span class=\"hljs-variable\">$add2</span>: <span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">2px</span>; <span class=\"hljs-comment\">// -1px</span><br><span class=\"hljs-variable\">$add3</span>: <span class=\"hljs-number\">1px</span> - <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// -1px</span><br><span class=\"hljs-variable\">$add4</span>: <span class=\"hljs-number\">1px</span> - <span class=\"hljs-number\">2px</span>;<span class=\"hljs-comment\">//-1px</span><br><br><span class=\"hljs-variable\">$sub1</span>: a - <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// a-1</span><br><span class=\"hljs-variable\">$sub2</span>: <span class=\"hljs-number\">1</span> - a;  <span class=\"hljs-comment\">// 1-a</span><br><span class=\"hljs-variable\">$sub3</span>: <span class=\"hljs-string\">&quot;a&quot;</span> - <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">// &quot;a&quot;-1</span><br><span class=\"hljs-variable\">$sub4</span>: a - <span class=\"hljs-string\">&quot;1&quot;</span>;<span class=\"hljs-comment\">// a-&quot;1&quot;</span><br></code></pre></td></tr></table></figure>\n\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br>每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。<br>只要其中一个值首位不为数字的，结果就按顺序去除空格后拼接起来<br></code></pre></td></tr></table></figure></li>\n<li><p><code>*</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$num1</span>: <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">2</span>;    <span class=\"hljs-comment\">// 2</span><br><span class=\"hljs-variable\">$mul2</span>: <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">2px</span>;  <span class=\"hljs-comment\">// 2px</span><br><span class=\"hljs-variable\">$num3</span>: <span class=\"hljs-number\">1px</span> * <span class=\"hljs-number\">2</span>;  <span class=\"hljs-comment\">// 2px</span><br><span class=\"hljs-variable\">$num4</span>: <span class=\"hljs-number\">2px</span> * <span class=\"hljs-number\">2px</span>;<span class=\"hljs-comment\">// 编译不通过</span><br><br><span class=\"hljs-variable\">$num5</span>: <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">2</span>abc; <span class=\"hljs-comment\">// 2abc</span><br></code></pre></td></tr></table></figure>\n\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br>每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。其余编译不通过<br></code></pre></td></tr></table></figure></li>\n<li><p><code>/</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br><span class=\"hljs-selector-tag\">a</span>.不会四舍五入，精确到小数点后<span class=\"hljs-number\">5</span>位<br><span class=\"hljs-selector-tag\">b</span>.每个字段必须前部分为数字，且当前者只是单纯数字无单位时，后者(除数)后部分不能有字符。其余结果就按顺序去除空格后拼接起来。<br>(因为此时后缀被当被单位看待了)<br></code></pre></td></tr></table></figure></li>\n<li><p><code>%</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br><span class=\"hljs-selector-tag\">a</span>.值与&quot;%&quot;之间必须要有空格，否则会被看做字符串<br></code></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"2-关系运算符\"><a href=\"#2-关系运算符\" class=\"headerlink\" title=\"2.关系运算符\"></a>2.关系运算符</h3><p>大前提：两端必须为<code>数字</code> 或 <code>前部分数字后部分字符</code></p>\n<p>返回值：<code>true</code> or <code>false</code></p>\n<ul>\n<li><p><code>&gt;</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: <span class=\"hljs-number\">1</span> &gt; <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>&lt;</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: <span class=\"hljs-number\">1</span> &gt; <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>&gt;=</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: <span class=\"hljs-number\">1</span> &gt;= <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>&lt;=</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: <span class=\"hljs-number\">1</span> &lt;= <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"3-相等运算符\"><a href=\"#3-相等运算符\" class=\"headerlink\" title=\"3.相等运算符\"></a>3.相等运算符</h3><p>作用范围：相等运算 <code>==, !=</code> 可用于所有数据类型</p>\n<p>返回值：<code>true</code> or <code>false</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1px</span>; <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable\">$b</span>: <span class=\"hljs-string\">&quot;a&quot;</span> == a; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br>前部分为不带引号数字时，对比的仅仅是数字部分；反之，忽略引号，要求字符一一对应<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-布尔运算符\"><a href=\"#4-布尔运算符\" class=\"headerlink\" title=\"4.布尔运算符\"></a>4.布尔运算符</h3><p>SassScript 支持布尔型的 <code>and</code> <code>or</code> 以及 <code>not</code> 运算。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: <span class=\"hljs-number\">1</span>&gt;<span class=\"hljs-number\">0</span> and <span class=\"hljs-number\">0</span>&gt;=<span class=\"hljs-number\">5</span>; <span class=\"hljs-comment\">// fasle</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br>值与&quot;and&quot;、&quot;or&quot;和&quot;not&quot;之间必须要有空格，否则会被看做字符串<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-颜色值运算\"><a href=\"#5-颜色值运算\" class=\"headerlink\" title=\"5.颜色值运算\"></a>5.颜色值运算</h3><p>颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值</p>\n<ul>\n<li><p><code>颜色值与颜色值</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#010203</span> + <span class=\"hljs-number\">#040506</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为</span><br><span class=\"hljs-comment\">// p &#123;</span><br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#050709</span>; &#125;<br></code></pre></td></tr></table></figure></li>\n<li><p><code>颜色值与数字</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#010203</span> * <span class=\"hljs-number\">2</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为</span><br><span class=\"hljs-comment\">// p &#123;</span><br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#020406</span>; &#125;<br></code></pre></td></tr></table></figure></li>\n<li><p><code>RGB和HSL</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。</span><br><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.75</span>) + <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.75</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// p &#123;</span><br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.75</span>); &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"6-运算优先级\"><a href=\"#6-运算优先级\" class=\"headerlink\" title=\"6.运算优先级\"></a>6.运算优先级</h3><ol start=\"0\">\n<li><p><code>()</code></p>\n</li>\n<li><p><code>*</code>、<code>/</code>、<code>%</code></p>\n</li>\n<li><p><code>+</code>、<code>-</code></p>\n</li>\n<li><p><code>&gt;</code> 、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p>\n</li>\n</ol>\n<hr>\n<h2 id=\"五、嵌套语法\"><a href=\"#五、嵌套语法\" class=\"headerlink\" title=\"五、嵌套语法\"></a>五、嵌套语法</h2><hr>\n<h2 id=\"六、杂货语法\"><a href=\"#六、杂货语法\" class=\"headerlink\" title=\"六、杂货语法\"></a>六、杂货语法</h2><h3 id=\"1-插值语法\"><a href=\"#1-插值语法\" class=\"headerlink\" title=\"1.插值语法\"></a>1.<code>插值语法</code></h3><p>通过 <code>#&#123;&#125;</code> 插值语句可以在选择器、属性名和属性值中使用变量。</p>\n<p>但大多数情况下，这样使用属性值可能还不如直接使用变量方便，但是使用 <code>#&#123;&#125;</code> 可以避免 Sass 运行运算表达式，直接编译 CSS。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$name</span>: foo;<br><span class=\"hljs-variable\">$attr</span>: border;<br><span class=\"hljs-selector-tag\">p</span>.#&#123;<span class=\"hljs-variable\">$name</span>&#125; &#123;<br>  #&#123;<span class=\"hljs-variable\">$attr</span>&#125;-<span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$name</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 编译后：</span><br><span class=\"hljs-selector-tag\">p</span><span class=\"hljs-selector-class\">.foo</span> &#123;<br>  <span class=\"hljs-attribute\">border-color</span>: foo;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-amp-in-SassScript\"><a href=\"#2-amp-in-SassScript\" class=\"headerlink\" title=\"2.&amp; in SassScript\"></a>2.<code>&amp; in SassScript</code></h3><p><code>&amp;</code>为父选择器</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">a</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: yellow;<br>    &amp;<span class=\"hljs-selector-pseudo\">:hover</span>&#123;<br>        <span class=\"hljs-attribute\">color</span>: green;<br>    &#125;<br>    &amp;<span class=\"hljs-selector-pseudo\">:active</span>&#123;<br>        <span class=\"hljs-attribute\">color</span>: blank;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-default\"><a href=\"#3-default\" class=\"headerlink\" title=\"3.!default\"></a>3.<code>!default</code></h3><p>可以在变量的结尾添加 <code>!default</code> 给一个未通过 <code>!default</code> 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$content</span>: <span class=\"hljs-string\">&quot;First content&quot;</span>;<br><span class=\"hljs-variable\">$content</span>: <span class=\"hljs-string\">&quot;Second content?&quot;</span> !default;<br><span class=\"hljs-variable\">$new_content</span>: <span class=\"hljs-string\">&quot;First time reference&quot;</span> !default;<br><br><span class=\"hljs-selector-id\">#main</span> &#123;<br>  <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-variable\">$content</span>;<br>  new-<span class=\"hljs-attribute\">content</span>: <span class=\"hljs-variable\">$new_content</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 编译为：</span><br><span class=\"hljs-selector-id\">#main</span> &#123;<br>  <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;First content&quot;</span>;<br>  new-<span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;First time reference&quot;</span>; &#125;<br></code></pre></td></tr></table></figure>\n\n<p>注意：变量是 null 空值时将视为未被 <code>!default</code> 赋值。</p>\n<h3 id=\"3-global\"><a href=\"#3-global\" class=\"headerlink\" title=\"3.!global\"></a>3.<code>!global</code></h3><p>将局部变量提升为全局变量</p>\n<h3 id=\"4-optional\"><a href=\"#4-optional\" class=\"headerlink\" title=\"4.!optional\"></a>4.<code>!optional</code></h3><p>如果 <code>@extend</code> 失败会收到错误提示，比如，这样写 <code>a.important &#123;@extend .notice&#125;</code>，当没有 <code>.notice</code> 选择器时，将会报错，只有 <code>h1.notice</code> 包含 <code>.notice</code> 时也会报错，因为 <code>h1</code> 与 <code>a</code> 冲突，会生成新的选择器。</p>\n<p>如果要求 <code>@extend</code> 不生成新选择器，可以通过 <code>!optional</code> 声明达到这个目的.</p>\n<p>简而言之：当<code>@extend</code>相关代码出现语法错误时，编译器可能会给我们”乱”编译为css，我们加上这个参数可以在出现问题后不让他编译该部分代码</p>\n<hr>\n<h2 id=\"七、-Rules与指令\"><a href=\"#七、-Rules与指令\" class=\"headerlink\" title=\"七、@-Rules与指令\"></a>七、@-Rules与指令</h2><h3 id=\"1-import\"><a href=\"#1-import\" class=\"headerlink\" title=\"1.@import\"></a>1.<code>@import</code></h3><p>Sass 拓展了 <code>@import</code> 的功能，允许其导入 SCSS 或 SASS 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。</p>\n<p>通常，<code>@import</code> 寻找 Sass 文件并将其导入，但在以下情况下，<code>@import</code> 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。</p>\n<ul>\n<li>文件拓展名是 <code>.css</code>；</li>\n<li>文件名以 <code>http://</code> 开头；</li>\n<li>文件名是 <code>url()</code>；</li>\n<li><code>@import</code> 包含 media queries。</li>\n</ul>\n<p>如果不在上述情况内，文件的拓展名是 <code>.scss</code> 或 <code>.sass</code>，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 <code>.scss</code> 或 <code>.sass</code> 的文件并将其导入。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;foo.scss&quot;</span>;<br><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;foo&quot;</span>;<br><span class=\"hljs-comment\">// 以上两种方式均可</span><br><br><br><span class=\"hljs-comment\">// 以下方式均不可行</span><br><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;foo.css&quot;</span>;<br><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;foo&quot;</span> screen;<br><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;http://foo.com/bar&quot;</span>;<br><span class=\"hljs-keyword\">@import</span> url(foo);<br></code></pre></td></tr></table></figure>\n\n<p>Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;rounded-corners&quot;</span>, <span class=\"hljs-string\">&quot;text-shadow&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>导入文件也可以使用 <code>#&#123; &#125;</code> 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 <code>url()</code> 导入方式：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$family</span>: <span class=\"hljs-built_in\">unquote</span>(<span class=\"hljs-string\">&quot;Droid+Sans&quot;</span>);<br><span class=\"hljs-keyword\">@import</span> url(<span class=\"hljs-string\">&quot;http://fonts.googleapis.com/css?family=\\#&#123;$family&#125;&quot;</span>);<br><br><span class=\"hljs-comment\">// 编译为：</span><br><span class=\"hljs-keyword\">@import</span> url(<span class=\"hljs-string\">&quot;http://fonts.googleapis.com/css?family=Droid+Sans&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>如果你有一个 SCSS 或 Sass 文件需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。</p>\n<p>除此之外，还支持嵌套 @import,但是不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 <code>@import</code>。</p>\n<h3 id=\"2-media\"><a href=\"#2-media\" class=\"headerlink\" title=\"2.@media\"></a>2.<code>@media</code></h3><p>Sass 中 <code>@media</code> 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 <code>@media</code> 嵌套在 CSS 规则内，编译时，<code>@media</code> 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 <code>@media</code> 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.sidebar</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">300px</span>;<br>  <span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span>;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 编译为</span><br><span class=\"hljs-selector-class\">.sidebar</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">300px</span>;<br>  <span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>@media</code>的 queries 允许互相嵌套使用，编译时，Sass 自动添加 <code>and</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@media</span> screen &#123;<br>  <span class=\"hljs-selector-class\">.sidebar</span> &#123;<br>    <span class=\"hljs-keyword\">@media</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br>      <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 编译为：</span><br><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br>  <span class=\"hljs-selector-class\">.sidebar</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span>; &#125; &#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>@media</code> 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$media</span>: screen;<br><span class=\"hljs-variable\">$feature</span>: -webkit-min-device-pixel-ratio;<br><span class=\"hljs-variable\">$value</span>: <span class=\"hljs-number\">1.5</span>;<br><br><span class=\"hljs-keyword\">@media</span> #&#123;<span class=\"hljs-variable\">$media</span>&#125; and ($feature: $value) &#123;<br>  <span class=\"hljs-selector-class\">.sidebar</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span>;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 编译为：</span><br><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">-webkit-min-device-pixel-ratio</span>: <span class=\"hljs-number\">1.5</span>) &#123;<br>  <span class=\"hljs-selector-class\">.sidebar</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span>; &#125; &#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-extend\"><a href=\"#3-extend\" class=\"headerlink\" title=\"3.*@extend\"></a>3.<code>*@extend</code></h3><p><code>@extend</code>即<code>继承</code>。在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。</p>\n<p>总的来看：支持层叠继承、多继承、允许延伸任何定义给单个元素的选择器（但是允许不一定好用）</p>\n<p>a. <code>基本延伸</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.error</span> &#123;<br>  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">#f00</span>;<br>  <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#fdd</span>;<br>&#125;<br><span class=\"hljs-selector-class\">.seriousError</span> &#123;<br>  <span class=\"hljs-keyword\">@extend</span> .error;<br>  <span class=\"hljs-attribute\">border-width</span>: <span class=\"hljs-number\">3px</span>;<br>&#125;<br><span class=\"hljs-comment\">// 上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。</span><br></code></pre></td></tr></table></figure>\n\n<p><code>@extend</code> 的作用是将重复使用的样式 (<code>.error</code>) 延伸 (extend) 给需要包含这个样式的特殊样式（<code>.seriousError</code>）</p>\n<p>注意理解以下情况：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.error</span> &#123;<br>  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">#f00</span>;<br>  <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#fdd</span>;<br>&#125;<br><span class=\"hljs-selector-class\">.error</span><span class=\"hljs-selector-class\">.intrusion</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&quot;/image/hacked.png&quot;</span>);<br>&#125;<br><span class=\"hljs-selector-class\">.seriousError</span> &#123;<br>  <span class=\"hljs-keyword\">@extend</span> .error;<br>  <span class=\"hljs-attribute\">border-width</span>: <span class=\"hljs-number\">3px</span>;<br>&#125;<br><span class=\"hljs-comment\">// .error, .seriousError &#123;</span><br>  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">#f00</span>;<br>  <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#fdd</span>; &#125;<br><br><span class=\"hljs-selector-class\">.error</span><span class=\"hljs-selector-class\">.intrusion</span>, <span class=\"hljs-selector-class\">.seriousError</span><span class=\"hljs-selector-class\">.intrusion</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&quot;/image/hacked.png&quot;</span>); &#125;<br><br><span class=\"hljs-selector-class\">.seriousError</span> &#123;<br>  <span class=\"hljs-attribute\">border-width</span>: <span class=\"hljs-number\">3px</span>; &#125;<br></code></pre></td></tr></table></figure>\n\n<p>当合并选择器时，<code>@extend</code> 会很聪明地避免无谓的重复，<code>.seriousError.seriousError</code> 将编译为 <code>.seriousError</code>，不能匹配任何元素的选择器也会删除。</p>\n<p>b.  <code>延伸复杂的选择器</code>：Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 <code>.special.cool</code>，<code>a:hover</code> 或者 <code>a.user[href^=&quot;http://&quot;]</code> 等</p>\n<p>c. <code> 多重延伸</code>：同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器</p>\n<p>d. <code>继续延伸</code>：当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个</p>\n<p>e.<code>*选择器列</code>：暂时不可以将选择器列 (Selector Sequences)，比如 <code>.foo .bar</code> 或 <code>.foo + .bar</code>，延伸给其他元素，但是，却可以将其他元素延伸给选择器列。</p>\n<p>尽量不使用<code>合并选择器列</code>，因为如果凭个人推理的话，会出现排列组合的情况，所以SASS编译器只会保留有用的组合形式，但依旧会存在排列组合的情况，有可能会留下隐患。</p>\n<ol>\n<li><p>当两个列合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前</p>\n <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-tag\">a</span> &#123;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold;<br>&#125;<br><span class=\"hljs-selector-id\">#demo</span> <span class=\"hljs-selector-class\">.overview</span> <span class=\"hljs-selector-class\">.fakelink</span> &#123;<br>  <span class=\"hljs-keyword\">@extend</span> a;<br>&#125;<br><span class=\"hljs-comment\">// 编译为：</span><br><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-tag\">a</span>,<br><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-id\">#demo</span> <span class=\"hljs-selector-class\">.overview</span> <span class=\"hljs-selector-class\">.fakelink</span>,<br><span class=\"hljs-selector-id\">#demo</span> <span class=\"hljs-selector-class\">.overview</span> <span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-class\">.fakelink</span> &#123;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold; &#125;<br></code></pre></td></tr></table></figure>\n\n</li>\n<li><p>如果两个列包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出</p>\n <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-tag\">a</span> &#123;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold;<br>&#125;<br><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.overview</span> <span class=\"hljs-selector-class\">.fakelink</span> &#123;<br>  <span class=\"hljs-keyword\">@extend</span> a;<br>&#125;<br><span class=\"hljs-comment\">// 编译为</span><br><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-tag\">a</span>,<br><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-class\">.overview</span> <span class=\"hljs-selector-class\">.fakelink</span>,<br><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.overview</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-class\">.fakelink</span> &#123;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold; &#125;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>f. <code>在指令中延伸</code></p>\n<p>在指令中使用 <code>@extend</code> 时（比如在 <code>@media</code> 中）有一些限制：Sass 不可以将 <code>@media</code> 层外的 CSS 规则延伸给指令层内的 CSS.</p>\n<p>g.  <code>%placeholder</code>为选择器占位符，配合<code>@extend-Only选择器</code>使用。</p>\n<p>效果：只定义了样式，但不会对原有选择器匹配的元素生效</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// example1:</span><br>%<span class=\"hljs-selector-tag\">img</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: red;<br>&#125;<br><span class=\"hljs-selector-class\">.path</span>&#123;<br>    <span class=\"hljs-keyword\">@extend</span> %img;<br>&#125;<br><span class=\"hljs-comment\">// 编译后：</span><br><span class=\"hljs-selector-class\">.path</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// example2:</span><br><span class=\"hljs-selector-id\">#context</span> <span class=\"hljs-selector-tag\">a</span>%extreme &#123;<br>  <span class=\"hljs-attribute\">color</span>: blue;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">2em</span>;<br>&#125;<br><span class=\"hljs-comment\">// 编译后：</span><br><span class=\"hljs-selector-class\">.notice</span> &#123;<br>  <span class=\"hljs-keyword\">@extend</span> %extreme;<br>&#125;<br><br><span class=\"hljs-comment\">// 注：必须是&quot;.&quot;和&quot;#&quot;选择器</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-at-root\"><a href=\"#4-at-root\" class=\"headerlink\" title=\"4.@at-root\"></a>4.<code>@at-root</code></h3><blockquote>\n<p>The @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector</p>\n</blockquote>\n<p>译文：@at root指令使一个或多个规则在文档的根发出，而不是嵌套在其父选择器下。它可以与单个内联选择器一起使用</p>\n<p>且@at-root 使多个规则跳出嵌套</p>\n<p>@at-root默认情况下并不能使规则或者选择器跳出指令，通过使用without和with可以解决该问题</p>\n<p>了解即可</p>\n<h3 id=\"5-debug\"><a href=\"#5-debug\" class=\"headerlink\" title=\"5.@debug\"></a>5.<code>@debug</code></h3><p>用于调试，按标准错误输出流输出</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$size</span>: <span class=\"hljs-number\">9px</span>;<br><br><span class=\"hljs-selector-class\">.file</span>&#123;<br>  <span class=\"hljs-keyword\">@debug</span> <span class=\"hljs-variable\">$size</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-warn\"><a href=\"#6-warn\" class=\"headerlink\" title=\"6.@warn\"></a>6.<code>@warn</code></h3><p>用于警告，按标准错误输出流输出</p>\n<h3 id=\"7-error\"><a href=\"#7-error\" class=\"headerlink\" title=\"7.@error\"></a>7.<code>@error</code></h3><p>用于报错，按标准错误输出流输出</p>\n<table>\n<thead>\n<tr>\n<th>序列</th>\n<th>@-rules</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>@import</td>\n<td>导入sass或scss文件</td>\n</tr>\n<tr>\n<td>2</td>\n<td>@media</td>\n<td>用于将样式规则设置为不同的媒体类型</td>\n</tr>\n<tr>\n<td>3</td>\n<td>@extend</td>\n<td>以继承的方式共享选择器</td>\n</tr>\n<tr>\n<td>4</td>\n<td>@at-root</td>\n<td>转到根节点</td>\n</tr>\n<tr>\n<td>5</td>\n<td>@debug</td>\n<td>用于调试，按标准错误输出流输出</td>\n</tr>\n<tr>\n<td>6</td>\n<td>@warn</td>\n<td>用于警告，按标准错误输出流输出</td>\n</tr>\n<tr>\n<td>7</td>\n<td>@error</td>\n<td>用于报错，按标准错误输出流输出</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"八、控制指令\"><a href=\"#八、控制指令\" class=\"headerlink\" title=\"八、控制指令\"></a>八、控制指令</h2><h3 id=\"1-if\"><a href=\"#1-if\" class=\"headerlink\" title=\"1.if()\"></a>1.<code>if()</code></h3><p><em>三元运算符</em></p>\n<p>表达式：<code>if(expression, value1, value2)</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">p</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">if</span>(<span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span> = <span class=\"hljs-number\">2</span>, green, yellow);<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">p</span>&#123;<br>    <span class=\"hljs-attribute\">color</span>: green;&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-if\"><a href=\"#2-if\" class=\"headerlink\" title=\"2.@if\"></a>2.<code>@if</code></h3><p><em>条件语句</em></p>\n<p>当 <code>@if</code> 的表达式返回值不是 <code>false</code> 或者 <code>null</code> 时，条件成立，输出 <code>&#123;&#125;</code> 内的代码</p>\n<p><code>@if</code> 声明后面可以跟多个 <code>@else if</code> 声明，或者一个 <code>@else</code> 声明。如果 <code>@if</code> 声明失败，Sass 将逐条执行 <code>@else if</code> 声明，如果全部失败，最后执行 <code>@else</code> 声明</p>\n<ul>\n<li><p><code>单@if</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">p</span> &#123;<br>    <span class=\"hljs-keyword\">@if</span> <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> &#123;<br>        <span class=\"hljs-attribute\">color</span>: red;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p><code>@if - @else</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">p</span> &#123;<br>    <span class=\"hljs-keyword\">@if</span> <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span> != <span class=\"hljs-number\">2</span> &#123;<br>        <span class=\"hljs-attribute\">color</span>: red;<br>    &#125; <span class=\"hljs-keyword\">@else</span> &#123;<br>        <span class=\"hljs-attribute\">color</span>: blue;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p><code>@if - @else if - @else</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$age</span>: <span class=\"hljs-number\">19</span>;<br><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>    <span class=\"hljs-keyword\">@if</span> <span class=\"hljs-variable\">$age</span> == <span class=\"hljs-number\">18</span> &#123;<br>        <span class=\"hljs-attribute\">color</span>: red;<br>    &#125; <span class=\"hljs-keyword\">@else</span> if <span class=\"hljs-variable\">$age</span> == <span class=\"hljs-number\">19</span> &#123;<br>        <span class=\"hljs-attribute\">color</span>: blue;<br>    &#125; <span class=\"hljs-keyword\">@else</span> &#123;<br>        <span class=\"hljs-attribute\">color</span>: green;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-for\"><a href=\"#3-for\" class=\"headerlink\" title=\"3.@for\"></a>3.<code>@for</code></h3><p><em>循环语句</em></p>\n<p>表达式：<code>@for $var from &lt;start&gt; through &lt;end&gt;</code> 或 <code>@for $var from &lt;start&gt; to &lt;end&gt;</code></p>\n<p>through 和 to 的相同点与不同点：</p>\n<ul>\n<li>相同点：两者均包含<start>的值</start></li>\n<li>不同点：through包含<end>的值，但to不包含<end>的值</end></end></li>\n</ul>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@for</span> <span class=\"hljs-variable\">$i</span> from <span class=\"hljs-number\">1</span> through <span class=\"hljs-number\">3</span> &#123;<br>  <span class=\"hljs-selector-class\">.item-</span>#&#123;<span class=\"hljs-variable\">$i</span>&#125; &#123; <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">2em</span> * <span class=\"hljs-variable\">$i</span>; &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-class\">.item-1</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">2em</span>; &#125;<br><span class=\"hljs-selector-class\">.item-2</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">4em</span>; &#125;<br><span class=\"hljs-selector-class\">.item-3</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">6em</span>; &#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"4-while\"><a href=\"#4-while\" class=\"headerlink\" title=\"4.@while\"></a>4.<code>@while</code></h3><p><em>循环语句</em></p>\n<p>表达式：<code>@while expression</code></p>\n<p><code>@while</code> 指令重复输出格式直到表达式返回结果为 <code>false</code>。这样可以实现比 <code>@for</code> 更复杂的循环，只是很少会用到</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$i</span>: <span class=\"hljs-number\">6</span>;<br><span class=\"hljs-keyword\">@while</span> <span class=\"hljs-variable\">$i</span> &gt; <span class=\"hljs-number\">0</span> &#123;<br>  <span class=\"hljs-selector-class\">.item-</span>#&#123;<span class=\"hljs-variable\">$i</span>&#125; &#123; <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">2em</span> * <span class=\"hljs-variable\">$i</span>; &#125;<br>  <span class=\"hljs-variable\">$i</span>: <span class=\"hljs-variable\">$i</span> - <span class=\"hljs-number\">2</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-class\">.item-6</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">12em</span>; &#125;<br><span class=\"hljs-selector-class\">.item-4</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">8em</span>; &#125;<br><span class=\"hljs-selector-class\">.item-2</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">4em</span>; &#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"5-each\"><a href=\"#5-each\" class=\"headerlink\" title=\"5.@each\"></a>5.<code>@each</code></h3><p><em>循环语句</em></p>\n<p>表达式：<code>$var in $vars</code></p>\n<p><code>$var</code> 可以是任何变量名</p>\n<p><code>$vars</code> 只能是<code>Lists</code>或者<code>Maps</code></p>\n<ul>\n<li><p>一维列表</p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@each</span> <span class=\"hljs-variable\">$animal</span> in puma, sea-slug, egret, salamander &#123;<br>  .#&#123;<span class=\"hljs-variable\">$animal</span>&#125;-<span class=\"hljs-attribute\">icon</span> &#123;<br>    <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-class\">.puma-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/puma.png&#x27;</span>); &#125;<br><span class=\"hljs-selector-class\">.sea-slug-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/sea-slug.png&#x27;</span>); &#125;<br><span class=\"hljs-selector-class\">.egret-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/egret.png&#x27;</span>); &#125;<br><span class=\"hljs-selector-class\">.salamander-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/salamander.png&#x27;</span>); &#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>二维列表</p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@each</span> <span class=\"hljs-variable\">$animal</span>, <span class=\"hljs-variable\">$color</span>, <span class=\"hljs-variable\">$cursor</span> in (puma, black, default),<br>                                  (sea-slug, blue, <span class=\"hljs-attribute\">pointer</span>),<br>                                  (egret, white, move) &#123;<br>  .#&#123;<span class=\"hljs-variable\">$animal</span>&#125;-<span class=\"hljs-attribute\">icon</span> &#123;<br>    <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">2px</span> solid <span class=\"hljs-variable\">$color</span>;<br>    <span class=\"hljs-attribute\">cursor</span>: <span class=\"hljs-variable\">$cursor</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-class\">.puma-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/puma.png&#x27;</span>);<br>  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">2px</span> solid black;<br>  <span class=\"hljs-attribute\">cursor</span>: default; &#125;<br><span class=\"hljs-selector-class\">.sea-slug-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/sea-slug.png&#x27;</span>);<br>  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">2px</span> solid blue;<br>  <span class=\"hljs-attribute\">cursor</span>: pointer; &#125;<br><span class=\"hljs-selector-class\">.egret-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/egret.png&#x27;</span>);<br>  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">2px</span> solid white;<br>  <span class=\"hljs-attribute\">cursor</span>: move; &#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>maps</p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@each</span> <span class=\"hljs-variable\">$header</span>, <span class=\"hljs-variable\">$size</span> in (h1: <span class=\"hljs-number\">2em</span>, h2: <span class=\"hljs-number\">1.5em</span>, h3: <span class=\"hljs-number\">1.2em</span>) &#123;<br>  #&#123;<span class=\"hljs-variable\">$header</span>&#125; &#123;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-variable\">$size</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">2em</span>; &#125;<br><span class=\"hljs-selector-tag\">h2</span> &#123;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1.5em</span>; &#125;<br><span class=\"hljs-selector-tag\">h3</span> &#123;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1.2em</span>; &#125;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<hr>\n<h2 id=\"九、混合指令\"><a href=\"#九、混合指令\" class=\"headerlink\" title=\"九、混合指令\"></a>九、混合指令</h2><blockquote>\n<p>混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 <code>.float-left</code>。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。</p>\n</blockquote>\n<p>注意：这不是函数！没有返回值！！</p>\n<h3 id=\"1-定义混合指令\"><a href=\"#1-定义混合指令\" class=\"headerlink\" title=\"1.定义混合指令\"></a>1.定义混合指令</h3><p>混合指令的用法是在 <code>@mixin</code> 后添加名称与样式，以及需要的参数（可选）。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 格式：</span><br><span class=\"hljs-keyword\">@mixin</span> name &#123;<br>    <span class=\"hljs-comment\">// 样式....</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// example：</span><br><span class=\"hljs-keyword\">@mixin</span> large-text &#123;<br>  <span class=\"hljs-attribute\">font</span>: &#123;<br>    family: Arial;<br>    size: <span class=\"hljs-number\">20px</span>;<br>    weight: bold;<br>  &#125;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#ff0000</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-引用混合样式\"><a href=\"#2-引用混合样式\" class=\"headerlink\" title=\"2.引用混合样式\"></a>2.引用混合样式</h3><p>使用 <code>@include</code> 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 格式：</span><br><span class=\"hljs-keyword\">@include</span> name;<br><br><span class=\"hljs-comment\">// 注：无参数或参数都有默认值时，带不带括号都可以</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// example：</span><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> large-text;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">font-family</span>: Arial;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">20px</span>;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#ff0000</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-参数\"><a href=\"#3-参数\" class=\"headerlink\" title=\"3.参数\"></a>3.参数</h3><p>格式：按照变量的格式，通过逗号分隔，将参数写进Mixin名称后的圆括号里</p>\n<p>支持默认值；支持多参数；支持不定参数；支持位置传参和关键词传参</p>\n<h4 id=\"a-位置传参\"><a href=\"#a-位置传参\" class=\"headerlink\" title=\"a. 位置传参\"></a>a. 位置传参</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> mp(<span class=\"hljs-variable\">$width</span>) &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-variable\">$width</span>;<br>&#125;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> mp(<span class=\"hljs-number\">300px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"b-关键词传参\"><a href=\"#b-关键词传参\" class=\"headerlink\" title=\"b.关键词传参\"></a>b.关键词传参</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> mp(<span class=\"hljs-variable\">$width</span>) &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-variable\">$width</span>;<br>&#125;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> mp(<span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">300px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"c-参数默认值\"><a href=\"#c-参数默认值\" class=\"headerlink\" title=\"c.参数默认值\"></a>c.参数默认值</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> mp(<span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">500px</span>) &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-variable\">$width</span>;<br>&#125;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> mp(<span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">300px</span>);<br>    <span class=\"hljs-comment\">// or</span><br>    <span class=\"hljs-keyword\">@include</span> mp(<span class=\"hljs-number\">300px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"d-不定参数\"><a href=\"#d-不定参数\" class=\"headerlink\" title=\"d.不定参数\"></a>d.不定参数</h4><blockquote>\n<p>官方：Variable Arguments</p>\n<p>译文：参数变量</p>\n<p>有时，不能确定混合指令需要使用多少个参数。这时，可以使用参数变量 <code>…</code> 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理</p>\n</blockquote>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> mar(<span class=\"hljs-variable\">$value</span>...) &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-variable\">$value</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-向混合样式中导入内容\"><a href=\"#4-向混合样式中导入内容\" class=\"headerlink\" title=\"4.向混合样式中导入内容\"></a>4.向混合样式中导入内容</h3><p>在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 <code>@content</code> 标志的地方</p>\n<p>可以看作参数的升级版</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> example &#123;<br>    <span class=\"hljs-selector-tag\">html</span> &#123;<br>        <span class=\"hljs-keyword\">@content</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">@include</span> example&#123;<br>    <span class=\"hljs-attribute\">background-color</span>: red;<br>    <span class=\"hljs-selector-class\">.logo</span> &#123;<br>        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">600px</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">html</span> &#123;<br>  <span class=\"hljs-attribute\">background-color</span>: red;<br>&#125;<br><br><span class=\"hljs-selector-tag\">html</span> <span class=\"hljs-selector-class\">.logo</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">600px</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<hr>\n<h2 id=\"十、函数指令\"><a href=\"#十、函数指令\" class=\"headerlink\" title=\"十、函数指令\"></a>十、函数指令</h2><h3 id=\"1-内置函数\"><a href=\"#1-内置函数\" class=\"headerlink\" title=\"1.内置函数\"></a>1.内置函数</h3><h4 id=\"a-字符串函数\"><a href=\"#a-字符串函数\" class=\"headerlink\" title=\"a. 字符串函数\"></a>a. 字符串函数</h4><blockquote>\n<p>索引第一个为1，最后一个为-1；切片两边均为闭区间</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">quote($string)</td>\n<td align=\"center\">添加引号</td>\n</tr>\n<tr>\n<td align=\"left\">unquote($string)</td>\n<td align=\"center\">除去引号</td>\n</tr>\n<tr>\n<td align=\"left\">to-lower-case($string)</td>\n<td align=\"center\">变为小写</td>\n</tr>\n<tr>\n<td align=\"left\">to-upper-case($string)</td>\n<td align=\"center\">变为大写</td>\n</tr>\n<tr>\n<td align=\"left\">str-length($string)</td>\n<td align=\"center\">返回$string的长度(汉字算一个)</td>\n</tr>\n<tr>\n<td align=\"left\">str-index($string，$substring)</td>\n<td align=\"center\">返回$substring在$string的位置</td>\n</tr>\n<tr>\n<td align=\"left\">str-insert($string, $insert, $index)</td>\n<td align=\"center\">在$string的$index处插入$insert</td>\n</tr>\n<tr>\n<td align=\"left\">str-slice($string, $start-at, $end-at）</td>\n<td align=\"center\">截取$string的$start-at和$end-at之间的字符串</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-数字函数\"><a href=\"#b-数字函数\" class=\"headerlink\" title=\"b. 数字函数\"></a>b. 数字函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>percentage($number)</td>\n<td align=\"center\">转换为百分比形式</td>\n</tr>\n<tr>\n<td>round($number)</td>\n<td align=\"center\">四舍五入为整数</td>\n</tr>\n<tr>\n<td>ceil($number)</td>\n<td align=\"center\">数值向上取整</td>\n</tr>\n<tr>\n<td>floor($number)</td>\n<td align=\"center\">数值向下取整</td>\n</tr>\n<tr>\n<td>abs($number)</td>\n<td align=\"center\">获取绝对值</td>\n</tr>\n<tr>\n<td>min($number…)</td>\n<td align=\"center\">获取最小值</td>\n</tr>\n<tr>\n<td>max($number…)</td>\n<td align=\"center\">获取最大值</td>\n</tr>\n<tr>\n<td>random($number?:number)</td>\n<td align=\"center\">不传入值：获得0-1的随机数；传入正整数n：获得0-n的随机整数（左开右闭）</td>\n</tr>\n</tbody></table>\n<h4 id=\"c-数组函数\"><a href=\"#c-数组函数\" class=\"headerlink\" title=\"c. 数组函数\"></a>c. 数组函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>length($list)</td>\n<td align=\"center\">获取数组长度</td>\n</tr>\n<tr>\n<td>nth($list, n)</td>\n<td align=\"center\">获取指定下标的元素</td>\n</tr>\n<tr>\n<td>set-nth($list, $n, $value)</td>\n<td align=\"center\">向$list的$n处插入$value</td>\n</tr>\n<tr>\n<td>join($list1, $list2, $separator)</td>\n<td align=\"center\">拼接$list1和list2；$separator为新list的分隔符，默认为auto，可选择comma、space</td>\n</tr>\n<tr>\n<td>append($list, $val, $separator)</td>\n<td align=\"center\">向$list的末尾添加$val；$separator为新list的分隔符，默认为auto，可选择comma、space</td>\n</tr>\n<tr>\n<td>index($list, $value)</td>\n<td align=\"center\">返回$value值在$list中的索引值</td>\n</tr>\n<tr>\n<td>zip($lists…)</td>\n<td align=\"center\">将几个列表结合成一个多维的列表；要求每个的列表个数值必须是相同的</td>\n</tr>\n</tbody></table>\n<h4 id=\"d-映射函数\"><a href=\"#d-映射函数\" class=\"headerlink\" title=\"d. 映射函数\"></a>d. 映射函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>map-get($map, $key)</td>\n<td align=\"center\">获取$map中$key对应的$value</td>\n</tr>\n<tr>\n<td>map-merge($map1, $map2)</td>\n<td align=\"center\">合并$map1和$map2，返回一个新$map</td>\n</tr>\n<tr>\n<td>map-remove($map, $key)</td>\n<td align=\"center\">从$map中删除$key，返回一个新$map</td>\n</tr>\n<tr>\n<td>map-keys($map)</td>\n<td align=\"center\">返回$map所有的$key</td>\n</tr>\n<tr>\n<td>map-values($map)</td>\n<td align=\"center\">返回$map所有的$value</td>\n</tr>\n<tr>\n<td>map-has-key($map, $key)</td>\n<td align=\"center\">判断$map中是否存在$key，返回对应的布尔值</td>\n</tr>\n<tr>\n<td>keywords($args)</td>\n<td align=\"center\">返回一个函数的参数，并可以动态修改其值</td>\n</tr>\n</tbody></table>\n<h4 id=\"e-颜色函数\"><a href=\"#e-颜色函数\" class=\"headerlink\" title=\"e. 颜色函数\"></a>e. 颜色函数</h4><ul>\n<li><p><strong>RGB函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>rgb($red, $green, $blue)</td>\n<td align=\"center\">返回一个16进制颜色值</td>\n</tr>\n<tr>\n<td>rgba($red,$green,$blue,$alpha)</td>\n<td align=\"center\">返回一个rgba；$red,$green和$blue可被当作一个整体以颜色单词、hsl、rgb或16进制形式传入</td>\n</tr>\n<tr>\n<td>red($color)</td>\n<td align=\"center\">从$color中获取其中红色值</td>\n</tr>\n<tr>\n<td>green($color)</td>\n<td align=\"center\">从$color中获取其中绿色值</td>\n</tr>\n<tr>\n<td>blue($color)</td>\n<td align=\"center\">从$color中获取其中蓝色值</td>\n</tr>\n<tr>\n<td>mix($color1,$color2,$weight?)</td>\n<td align=\"center\">按照$weight比例，将$color1和$color2混合为一个新颜色</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>HSL函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th>函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hsl($hue,$saturation,$lightness)</td>\n<td>通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色</td>\n</tr>\n<tr>\n<td>hsla($hue,$saturation,$lightness,$alpha)</td>\n<td>通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色</td>\n</tr>\n<tr>\n<td>saturation($color)</td>\n<td>从一个颜色中获取饱和度（saturation）值</td>\n</tr>\n<tr>\n<td>lightness($color)</td>\n<td>从一个颜色中获取亮度（lightness）值</td>\n</tr>\n<tr>\n<td>adjust-hue($color,$degrees)</td>\n<td>通过改变一个颜色的色相值，创建一个新的颜色</td>\n</tr>\n<tr>\n<td>lighten($color,$amount)</td>\n<td>通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色</td>\n</tr>\n<tr>\n<td>darken($color,$amount)</td>\n<td>通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色</td>\n</tr>\n<tr>\n<td>hue($color)</td>\n<td>从一个颜色中获取亮度色相（hue）值</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>Opacity函数</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>alpha($color)/opacity($color)</td>\n<td>获取颜色透明度值</td>\n</tr>\n<tr>\n<td>rgba($color,$alpha)</td>\n<td>改变颜色的透明度</td>\n</tr>\n<tr>\n<td>opacify($color, $amount) / fade-in($color, $amount)</td>\n<td>使颜色更不透明</td>\n</tr>\n<tr>\n<td>transparentize($color, $amount) / fade-out($color, $amount)</td>\n<td>使颜色更加透明</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h4 id=\"f-Introspection函数\"><a href=\"#f-Introspection函数\" class=\"headerlink\" title=\"f. Introspection函数\"></a>f. Introspection函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>type-of($value)</td>\n<td align=\"center\">返回$value的类型</td>\n</tr>\n<tr>\n<td>unit($number)</td>\n<td align=\"center\">返回$number的单位</td>\n</tr>\n<tr>\n<td>unitless($number)</td>\n<td align=\"center\">判断$number是否带单位，返回对应的布尔值</td>\n</tr>\n<tr>\n<td>comparable($number1, $number2)</td>\n<td align=\"center\">判断$number1和$number2是否可以做加、减和合并，返回对应的布尔值</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-自定义函数\"><a href=\"#2-自定义函数\" class=\"headerlink\" title=\"2.自定义函数\"></a>2.自定义函数</h3><blockquote>\n<p>Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用</p>\n<p>Params: 与Mixin一致</p>\n<p>支持返回值</p>\n</blockquote>\n<p><strong>基本格式：</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@function</span> fn-name(<span class=\"hljs-variable\">$params</span>...) &#123;<br>    <span class=\"hljs-keyword\">@return</span> <span class=\"hljs-variable\">$params</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// example:</span><br><span class=\"hljs-keyword\">@function</span> fn-name(<span class=\"hljs-variable\">$params</span>...) &#123;<br>    <span class=\"hljs-keyword\">@return</span> nth(<span class=\"hljs-variable\">$params</span>, <span class=\"hljs-number\">1</span>);<br>&#125;<br><span class=\"hljs-selector-tag\">p</span> &#123;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-built_in\">fn-name</span>(<span class=\"hljs-number\">1px</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// compiled:</span><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">1px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<hr>\n<h2 id=\"十一、细节与展望\"><a href=\"#十一、细节与展望\" class=\"headerlink\" title=\"十一、细节与展望\"></a>十一、细节与展望</h2><h3 id=\"1-细节\"><a href=\"#1-细节\" class=\"headerlink\" title=\"1.细节\"></a>1.细节</h3><p>a. @extend、@Mixin和@function的选择</p>\n<p><a href=\"https://csswizardry.com/2016/02/mixins-better-for-performance/\">原文链接</a></p>\n<blockquote>\n<p><code>minxins</code>在网络传输中比<code>@extend</code> 拥有更好的性能.尽管有些文件未压缩时更大，但使用<code>gzip</code>压缩后，依然可以保证我们拥有更好的性能。</p>\n</blockquote>\n<p><strong>所以@extend我们就尽量不要使用了，而@Mixin和@function的差别在定义和使用上</strong></p>\n<blockquote>\n<p>定义方式不同： <code>@function</code> 需要调用<code>@return</code>输出结果。而 @mixin则不需要。</p>\n<p>使用方式不同：<code>@mixin</code> 使用<code>@include</code>引用，而 <code>@function</code> 使用小括号执行函数。</p>\n</blockquote>\n<h3 id=\"2-展望\"><a href=\"#2-展望\" class=\"headerlink\" title=\"2.展望\"></a>2.展望</h3><blockquote>\n<p>以上内容算是”基础”部分，但是对于日常开发，我觉得是足够使用的了。</p>\n<p>如果想要进一步了解，就必须先去学习下Ruby，使用Ruby相关模块进行更丰富地学习</p>\n</blockquote>\n<h3 id=\"Unfinished…\"><a href=\"#Unfinished…\" class=\"headerlink\" title=\"Unfinished…\"></a>Unfinished…</h3>","site":{"data":{}},"wordcount":18160,"excerpt":"","more":"<h1 id=\"SassScript\"><a href=\"#SassScript\" class=\"headerlink\" title=\"SassScript\"></a>SassScript</h1><blockquote>\n<p>在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。</p>\n</blockquote>\n<blockquote>\n<p>弱类型语言, 对语法要求没那么严格</p>\n</blockquote>\n<h2 id=\"一、注释\"><a href=\"#一、注释\" class=\"headerlink\" title=\"一、注释\"></a>一、注释</h2><ol>\n<li><p>Sass 支持标准的 CSS 多行注释 <code>/* */</code>，以及单行注释 <code>//</code>，前者会被完整输出到编译后的 CSS 文件中，而后者则不会。</p>\n</li>\n<li><p>将 <code>!</code> 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。</p>\n</li>\n<li><p>插值语句 (interpolation) 也可写进多行注释中输出变量值</p>\n</li>\n</ol>\n<p>例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">\thello</span><br><span class=\"hljs-comment\">\tworld!</span><br><span class=\"hljs-comment\">*/</span><br><br><span class=\"hljs-comment\">// compile scss files to css</span><br><span class=\"hljs-comment\">// it&#x27;s ready to do it.</span><br><span class=\"hljs-variable\">$pink</span>: <span class=\"hljs-number\">#f3e1e1</span>;<br><span class=\"hljs-selector-tag\">html</span>&#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-variable\">$pink</span>;<br>&#125;<br><br><span class=\"hljs-variable\">$author</span>: <span class=\"hljs-string\">&#x27;gdream@126.com&#x27;</span>;<br><span class=\"hljs-comment\">/*!</span><br><span class=\"hljs-comment\">\tAuthor: #&#123;$author&#125;.</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<p>开发模式编译后:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">\thello</span><br><span class=\"hljs-comment\">\tworld!</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-selector-tag\">html</span>&#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#f3e1e1</span>;<br>&#125;<br><span class=\"hljs-comment\">/*!</span><br><span class=\"hljs-comment\">\tAuthor: &#x27;gdream@126.com&#x27;.</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<p>压缩输出模式编译后：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">html</span>&#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#f3e1e1</span>;<br>&#125;<br><span class=\"hljs-comment\">/*!</span><br><span class=\"hljs-comment\">\tAuthor: &#x27;gdream@126.com&#x27;.</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<hr>\n<h2 id=\"二、变量\"><a href=\"#二、变量\" class=\"headerlink\" title=\"二、变量\"></a>二、变量</h2><h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1.定义\"></a>1.定义</h3><p>变量以美元符号开头，赋值方法与 CSS 属性的写法一样</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">1600px</span>;<br><span class=\"hljs-variable\">$pen-size</span>: <span class=\"hljs-number\">3em</span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2.使用\"></a>2.使用</h3><p>直接使用变量的名称即可调用变量</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-id\">#app</span> &#123;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-variable\">$width</span>;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-variable\">$pen-size</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-作用域\"><a href=\"#3-作用域\" class=\"headerlink\" title=\"3.作用域\"></a>3.作用域</h3><p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 <code>!global</code> 声明</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-id\">#foo</span> &#123;<br>  <span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">5em</span> !global;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-variable\">$width</span>;<br>&#125;<br><br><span class=\"hljs-selector-id\">#bar</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-variable\">$width</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>编译后：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-id\">#foo</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">5em</span>;<br>&#125;<br><br><span class=\"hljs-selector-id\">#bar</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">5em</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<hr>\n<h2 id=\"三、数据类型\"><a href=\"#三、数据类型\" class=\"headerlink\" title=\"三、数据类型\"></a>三、数据类型</h2><p>SassScript 支持 7 种主要的数据类型：</p>\n<ul>\n<li>数字，<code>1, 2, 13, 10px，5a</code></li>\n<li>字符串，有引号字符串与无引号字符串，<code>&quot;foo&quot;, &#39;bar&#39;, baz</code></li>\n<li>颜色，<code>blue, #04a3f9, rgba(255,0,0,0.5)rgba(#333,.5)</code></li>\n<li>布尔型，<code>true, false</code></li>\n<li>空值，<code>null</code></li>\n<li>数组 (list)，用空格或逗号作分隔符，<code>1.5em 1em 0 2em, Helvetica, Arial, sans-serif</code></li>\n<li>maps, 相当于 JavaScript 的 object，<code>(key1: value1, key2: value2)</code></li>\n</ul>\n<p>SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 <code>!important</code> 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。</p>\n<p>判断数据类型的方式：<code>type-of($value)</code></p>\n<h3 id=\"1-字符串-Strings\"><a href=\"#1-字符串-Strings\" class=\"headerlink\" title=\"1.字符串 (Strings)\"></a>1.字符串 (Strings)</h3><p>SassScript 支持 CSS 的两种字符串类型：<code>有引号字符串 (quoted strings)</code>，和<code>无引号字符串 (unquoted strings)</code>。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$name</span>: <span class=\"hljs-string\">&#x27;Tom Bob&#x27;</span>;<br><span class=\"hljs-variable\">$container</span>: <span class=\"hljs-string\">&quot;top bottom&quot;</span>;<br><span class=\"hljs-variable\">$what</span>: heart;<br><br><span class=\"hljs-comment\">// 注：在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 `#&#123;&#125;` (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-数字-Numbers\"><a href=\"#2-数字-Numbers\" class=\"headerlink\" title=\"2.数字(Numbers)\"></a>2.数字(Numbers)</h3><p>SassScript支持两种数字类型：<code>带单位数字</code>和<code>不带单位数字</code>。（可正可负可为零，可正可浮点）</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$my-age</span>: <span class=\"hljs-number\">19</span>;<br><span class=\"hljs-variable\">$your-age</span>: <span class=\"hljs-number\">19.5</span>;<br><span class=\"hljs-variable\">$height</span>: <span class=\"hljs-number\">120px</span>;<br><br><span class=\"hljs-comment\">// 注：单位会和数字当做一个整体，进行算数运算</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-空值-Null\"><a href=\"#3-空值-Null\" class=\"headerlink\" title=\"3.空值(Null)\"></a>3.空值(Null)</h3><p>只有一个取值<code>null</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$value</span>: null;<br><br><span class=\"hljs-comment\">// 注：由于它代表空，所以不能够使用它与任何类型进行算数运算</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-布尔型-Booleans\"><a href=\"#4-布尔型-Booleans\" class=\"headerlink\" title=\"4.布尔型(Booleans)\"></a>4.布尔型(Booleans)</h3><p>只有两个取值：<code>true</code>和<code>false</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: true;<br><span class=\"hljs-variable\">$b</span>: false;<br><br><span class=\"hljs-comment\">// 注：只有自身是false和null才会返回false，其他一切都将返回true</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-数组-Lists\"><a href=\"#5-数组-Lists\" class=\"headerlink\" title=\"5.数组 (Lists)\"></a>5.数组 (Lists)</h3><p>通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。索引从<code>1</code>开始</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$list0</span>: <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">6px</span>;<br><span class=\"hljs-variable\">$list1</span>: <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">2px</span>, <span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">6px</span>;<br><span class=\"hljs-variable\">$list2</span>: (<span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">2px</span>) (<span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">6px</span>);<br></code></pre></td></tr></table></figure>\n\n<p>数组中可以包含子数组，比如 <code>1px 2px, 5px 6px</code> 是包含 <code>1px 2px</code> 与 <code>5px 6px</code> 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 <code>(1px 2px) (5px 6px)</code>。变化是，之前的 <code>1px 2px, 5px 6px</code> 使用逗号分割了两个子数组 (comma-separated)，而 <code>(1px 2px) (5px 6px)</code> 则使用空格分割(space-separated)。</p>\n<p>当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 <code>(1px 2px) (5px 6px)</code> 与 <code>1px 2px, 5px 6px</code> 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。</p>\n<p>用 <code>()</code> 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 <code>font-family: ()</code> Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 <code>1px 2px () 3px</code> 或 <code>1px 2px null 3px</code>。</p>\n<p>基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 <code>(1,)</code> 表示只包含 <code>1</code> 的数组，而 <code>(1 2 3,)</code> 表示包含 <code>1 2 3</code> 这个以空格分隔的数组的数组。</p>\n<h3 id=\"6-映射-Maps\"><a href=\"#6-映射-Maps\" class=\"headerlink\" title=\"6.映射(Maps)\"></a>6.映射(Maps)</h3><p>Maps必须被圆括号包围，可以映射任何类型键值对（任何类型，包括内嵌maps，不过不推荐这种内嵌方式）</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$map</span>: ( <br>  <span class=\"hljs-variable\">$key1</span>: value1, <br>  <span class=\"hljs-variable\">$key2</span>: value2, <br>  <span class=\"hljs-variable\">$key3</span>: value3 <br>)<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"7-颜色-Colors\"><a href=\"#7-颜色-Colors\" class=\"headerlink\" title=\"7.颜色 (Colors)\"></a>7.颜色 (Colors)</h3><p>CSS原有颜色类型，十六进制、RGB、RGBA、HSL、HSLA和色彩单词</p>\n<p>SCSS提供了内置Colors函数，从而更方便地使用颜色</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$color0</span>: green;<br><span class=\"hljs-variable\">$color1</span>: <span class=\"hljs-built_in\">lighten</span>(<span class=\"hljs-variable\">$color</span>, <span class=\"hljs-number\">15%</span>);<br><span class=\"hljs-variable\">$color2</span>: <span class=\"hljs-built_in\">darken</span>(<span class=\"hljs-variable\">$color</span>, <span class=\"hljs-number\">15%</span>);<br><span class=\"hljs-variable\">$color3</span>: <span class=\"hljs-built_in\">saturate</span>(<span class=\"hljs-variable\">$color</span>, <span class=\"hljs-number\">15%</span>);<br><span class=\"hljs-variable\">$color4</span>: <span class=\"hljs-built_in\">desaturate</span>(<span class=\"hljs-variable\">$color</span>, <span class=\"hljs-number\">15%</span>);<br><span class=\"hljs-variable\">$color5</span>: (green + red);<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<hr>\n<h2 id=\"四、运算\"><a href=\"#四、运算\" class=\"headerlink\" title=\"四、运算\"></a>四、运算</h2><h3 id=\"1-数字运算符\"><a href=\"#1-数字运算符\" class=\"headerlink\" title=\"1.数字运算符\"></a>1.数字运算符</h3><p>SassScript 支持数字的加减乘除、取整等运算 (<code>+, -, *, /, %</code>)，如果必要会在不同单位间转换值</p>\n<p>如果要保留运算符号，则应该使用插值语法</p>\n<ul>\n<li><p><code>+</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 纯数字</span><br><span class=\"hljs-variable\">$add1</span>: <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span>;\t<span class=\"hljs-comment\">// 3</span><br><span class=\"hljs-variable\">$add2</span>: <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2px</span>; <span class=\"hljs-comment\">// 3px</span><br><span class=\"hljs-variable\">$add3</span>: <span class=\"hljs-number\">1px</span> + <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 3px</span><br><span class=\"hljs-variable\">$add4</span>: <span class=\"hljs-number\">1px</span> + <span class=\"hljs-number\">2px</span>;<span class=\"hljs-comment\">//3px</span><br><br><span class=\"hljs-comment\">// 纯字符串</span><br><span class=\"hljs-variable\">$add5</span>: <span class=\"hljs-string\">&quot;a&quot;</span> + <span class=\"hljs-string\">&quot;b&quot;</span>; <span class=\"hljs-comment\">// &quot;ab&quot;</span><br><span class=\"hljs-variable\">$add6</span>: <span class=\"hljs-string\">&quot;a&quot;</span> + b;\t  <span class=\"hljs-comment\">// &quot;ab&quot;</span><br><span class=\"hljs-variable\">$add7</span>: a + <span class=\"hljs-string\">&quot;b&quot;</span>;\t  <span class=\"hljs-comment\">// ab</span><br><span class=\"hljs-variable\">$add8</span>: a + b;\t  <span class=\"hljs-comment\">// ab</span><br><br><span class=\"hljs-comment\">// 数字和字符串</span><br><span class=\"hljs-variable\">$add9</span>: <span class=\"hljs-number\">1</span> + a;\t<span class=\"hljs-comment\">// 1a</span><br><span class=\"hljs-variable\">$adda</span>: a + <span class=\"hljs-number\">1</span>;\t<span class=\"hljs-comment\">// a1</span><br><span class=\"hljs-variable\">$addb</span>: <span class=\"hljs-string\">&quot;1&quot;</span> + a; <span class=\"hljs-comment\">// &quot;1a&quot;</span><br><span class=\"hljs-variable\">$addc</span>: <span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">&quot;a&quot;</span>; <span class=\"hljs-comment\">// &quot;1a&quot;</span><br><span class=\"hljs-variable\">$addd</span>: <span class=\"hljs-string\">&quot;a&quot;</span> + <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// &quot;a1&quot;</span><br><span class=\"hljs-variable\">$adde</span>: a + <span class=\"hljs-string\">&quot;1&quot;</span>; <span class=\"hljs-comment\">// a1</span><br><span class=\"hljs-variable\">$addf</span>: <span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">&quot;1&quot;</span>; <span class=\"hljs-comment\">// &quot;11&quot;</span><br></code></pre></td></tr></table></figure>\n\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br><span class=\"hljs-selector-tag\">a</span>.纯数字：只要有单位，结果必有单位<br><span class=\"hljs-selector-tag\">b</span>.纯字符串：第一个字符串有无引号决定结果是否有引号<br>c数字和字符串：第一位有引号，结果必为引号；第一位对应数字非数字且最后一位带有引号，则结果必为引号<br></code></pre></td></tr></table></figure></li>\n<li><p><code>-</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$add1</span>: <span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">2</span>;\t<span class=\"hljs-comment\">// -1</span><br><span class=\"hljs-variable\">$add2</span>: <span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">2px</span>; <span class=\"hljs-comment\">// -1px</span><br><span class=\"hljs-variable\">$add3</span>: <span class=\"hljs-number\">1px</span> - <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// -1px</span><br><span class=\"hljs-variable\">$add4</span>: <span class=\"hljs-number\">1px</span> - <span class=\"hljs-number\">2px</span>;<span class=\"hljs-comment\">//-1px</span><br><br><span class=\"hljs-variable\">$sub1</span>: a - <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// a-1</span><br><span class=\"hljs-variable\">$sub2</span>: <span class=\"hljs-number\">1</span> - a;  <span class=\"hljs-comment\">// 1-a</span><br><span class=\"hljs-variable\">$sub3</span>: <span class=\"hljs-string\">&quot;a&quot;</span> - <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">// &quot;a&quot;-1</span><br><span class=\"hljs-variable\">$sub4</span>: a - <span class=\"hljs-string\">&quot;1&quot;</span>;<span class=\"hljs-comment\">// a-&quot;1&quot;</span><br></code></pre></td></tr></table></figure>\n\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br>每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。<br>只要其中一个值首位不为数字的，结果就按顺序去除空格后拼接起来<br></code></pre></td></tr></table></figure></li>\n<li><p><code>*</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$num1</span>: <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">2</span>;    <span class=\"hljs-comment\">// 2</span><br><span class=\"hljs-variable\">$mul2</span>: <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">2px</span>;  <span class=\"hljs-comment\">// 2px</span><br><span class=\"hljs-variable\">$num3</span>: <span class=\"hljs-number\">1px</span> * <span class=\"hljs-number\">2</span>;  <span class=\"hljs-comment\">// 2px</span><br><span class=\"hljs-variable\">$num4</span>: <span class=\"hljs-number\">2px</span> * <span class=\"hljs-number\">2px</span>;<span class=\"hljs-comment\">// 编译不通过</span><br><br><span class=\"hljs-variable\">$num5</span>: <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">2</span>abc; <span class=\"hljs-comment\">// 2abc</span><br></code></pre></td></tr></table></figure>\n\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br>每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。其余编译不通过<br></code></pre></td></tr></table></figure></li>\n<li><p><code>/</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br><span class=\"hljs-selector-tag\">a</span>.不会四舍五入，精确到小数点后<span class=\"hljs-number\">5</span>位<br><span class=\"hljs-selector-tag\">b</span>.每个字段必须前部分为数字，且当前者只是单纯数字无单位时，后者(除数)后部分不能有字符。其余结果就按顺序去除空格后拼接起来。<br>(因为此时后缀被当被单位看待了)<br></code></pre></td></tr></table></figure></li>\n<li><p><code>%</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br><span class=\"hljs-selector-tag\">a</span>.值与&quot;%&quot;之间必须要有空格，否则会被看做字符串<br></code></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"2-关系运算符\"><a href=\"#2-关系运算符\" class=\"headerlink\" title=\"2.关系运算符\"></a>2.关系运算符</h3><p>大前提：两端必须为<code>数字</code> 或 <code>前部分数字后部分字符</code></p>\n<p>返回值：<code>true</code> or <code>false</code></p>\n<ul>\n<li><p><code>&gt;</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: <span class=\"hljs-number\">1</span> &gt; <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>&lt;</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: <span class=\"hljs-number\">1</span> &gt; <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>&gt;=</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: <span class=\"hljs-number\">1</span> &gt;= <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>&lt;=</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: <span class=\"hljs-number\">1</span> &lt;= <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"3-相等运算符\"><a href=\"#3-相等运算符\" class=\"headerlink\" title=\"3.相等运算符\"></a>3.相等运算符</h3><p>作用范围：相等运算 <code>==, !=</code> 可用于所有数据类型</p>\n<p>返回值：<code>true</code> or <code>false</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1px</span>; <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable\">$b</span>: <span class=\"hljs-string\">&quot;a&quot;</span> == a; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br>前部分为不带引号数字时，对比的仅仅是数字部分；反之，忽略引号，要求字符一一对应<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-布尔运算符\"><a href=\"#4-布尔运算符\" class=\"headerlink\" title=\"4.布尔运算符\"></a>4.布尔运算符</h3><p>SassScript 支持布尔型的 <code>and</code> <code>or</code> 以及 <code>not</code> 运算。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$a</span>: <span class=\"hljs-number\">1</span>&gt;<span class=\"hljs-number\">0</span> and <span class=\"hljs-number\">0</span>&gt;=<span class=\"hljs-number\">5</span>; <span class=\"hljs-comment\">// fasle</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 总结：</span><br>值与&quot;and&quot;、&quot;or&quot;和&quot;not&quot;之间必须要有空格，否则会被看做字符串<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-颜色值运算\"><a href=\"#5-颜色值运算\" class=\"headerlink\" title=\"5.颜色值运算\"></a>5.颜色值运算</h3><p>颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值</p>\n<ul>\n<li><p><code>颜色值与颜色值</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#010203</span> + <span class=\"hljs-number\">#040506</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为</span><br><span class=\"hljs-comment\">// p &#123;</span><br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#050709</span>; &#125;<br></code></pre></td></tr></table></figure></li>\n<li><p><code>颜色值与数字</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#010203</span> * <span class=\"hljs-number\">2</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为</span><br><span class=\"hljs-comment\">// p &#123;</span><br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#020406</span>; &#125;<br></code></pre></td></tr></table></figure></li>\n<li><p><code>RGB和HSL</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。</span><br><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.75</span>) + <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.75</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// p &#123;</span><br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.75</span>); &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"6-运算优先级\"><a href=\"#6-运算优先级\" class=\"headerlink\" title=\"6.运算优先级\"></a>6.运算优先级</h3><ol start=\"0\">\n<li><p><code>()</code></p>\n</li>\n<li><p><code>*</code>、<code>/</code>、<code>%</code></p>\n</li>\n<li><p><code>+</code>、<code>-</code></p>\n</li>\n<li><p><code>&gt;</code> 、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p>\n</li>\n</ol>\n<hr>\n<h2 id=\"五、嵌套语法\"><a href=\"#五、嵌套语法\" class=\"headerlink\" title=\"五、嵌套语法\"></a>五、嵌套语法</h2><hr>\n<h2 id=\"六、杂货语法\"><a href=\"#六、杂货语法\" class=\"headerlink\" title=\"六、杂货语法\"></a>六、杂货语法</h2><h3 id=\"1-插值语法\"><a href=\"#1-插值语法\" class=\"headerlink\" title=\"1.插值语法\"></a>1.<code>插值语法</code></h3><p>通过 <code>#&#123;&#125;</code> 插值语句可以在选择器、属性名和属性值中使用变量。</p>\n<p>但大多数情况下，这样使用属性值可能还不如直接使用变量方便，但是使用 <code>#&#123;&#125;</code> 可以避免 Sass 运行运算表达式，直接编译 CSS。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$name</span>: foo;<br><span class=\"hljs-variable\">$attr</span>: border;<br><span class=\"hljs-selector-tag\">p</span>.#&#123;<span class=\"hljs-variable\">$name</span>&#125; &#123;<br>  #&#123;<span class=\"hljs-variable\">$attr</span>&#125;-<span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$name</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 编译后：</span><br><span class=\"hljs-selector-tag\">p</span><span class=\"hljs-selector-class\">.foo</span> &#123;<br>  <span class=\"hljs-attribute\">border-color</span>: foo;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-amp-in-SassScript\"><a href=\"#2-amp-in-SassScript\" class=\"headerlink\" title=\"2.&amp; in SassScript\"></a>2.<code>&amp; in SassScript</code></h3><p><code>&amp;</code>为父选择器</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">a</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: yellow;<br>    &amp;<span class=\"hljs-selector-pseudo\">:hover</span>&#123;<br>        <span class=\"hljs-attribute\">color</span>: green;<br>    &#125;<br>    &amp;<span class=\"hljs-selector-pseudo\">:active</span>&#123;<br>        <span class=\"hljs-attribute\">color</span>: blank;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-default\"><a href=\"#3-default\" class=\"headerlink\" title=\"3.!default\"></a>3.<code>!default</code></h3><p>可以在变量的结尾添加 <code>!default</code> 给一个未通过 <code>!default</code> 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$content</span>: <span class=\"hljs-string\">&quot;First content&quot;</span>;<br><span class=\"hljs-variable\">$content</span>: <span class=\"hljs-string\">&quot;Second content?&quot;</span> !default;<br><span class=\"hljs-variable\">$new_content</span>: <span class=\"hljs-string\">&quot;First time reference&quot;</span> !default;<br><br><span class=\"hljs-selector-id\">#main</span> &#123;<br>  <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-variable\">$content</span>;<br>  new-<span class=\"hljs-attribute\">content</span>: <span class=\"hljs-variable\">$new_content</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 编译为：</span><br><span class=\"hljs-selector-id\">#main</span> &#123;<br>  <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;First content&quot;</span>;<br>  new-<span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;First time reference&quot;</span>; &#125;<br></code></pre></td></tr></table></figure>\n\n<p>注意：变量是 null 空值时将视为未被 <code>!default</code> 赋值。</p>\n<h3 id=\"3-global\"><a href=\"#3-global\" class=\"headerlink\" title=\"3.!global\"></a>3.<code>!global</code></h3><p>将局部变量提升为全局变量</p>\n<h3 id=\"4-optional\"><a href=\"#4-optional\" class=\"headerlink\" title=\"4.!optional\"></a>4.<code>!optional</code></h3><p>如果 <code>@extend</code> 失败会收到错误提示，比如，这样写 <code>a.important &#123;@extend .notice&#125;</code>，当没有 <code>.notice</code> 选择器时，将会报错，只有 <code>h1.notice</code> 包含 <code>.notice</code> 时也会报错，因为 <code>h1</code> 与 <code>a</code> 冲突，会生成新的选择器。</p>\n<p>如果要求 <code>@extend</code> 不生成新选择器，可以通过 <code>!optional</code> 声明达到这个目的.</p>\n<p>简而言之：当<code>@extend</code>相关代码出现语法错误时，编译器可能会给我们”乱”编译为css，我们加上这个参数可以在出现问题后不让他编译该部分代码</p>\n<hr>\n<h2 id=\"七、-Rules与指令\"><a href=\"#七、-Rules与指令\" class=\"headerlink\" title=\"七、@-Rules与指令\"></a>七、@-Rules与指令</h2><h3 id=\"1-import\"><a href=\"#1-import\" class=\"headerlink\" title=\"1.@import\"></a>1.<code>@import</code></h3><p>Sass 拓展了 <code>@import</code> 的功能，允许其导入 SCSS 或 SASS 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。</p>\n<p>通常，<code>@import</code> 寻找 Sass 文件并将其导入，但在以下情况下，<code>@import</code> 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。</p>\n<ul>\n<li>文件拓展名是 <code>.css</code>；</li>\n<li>文件名以 <code>http://</code> 开头；</li>\n<li>文件名是 <code>url()</code>；</li>\n<li><code>@import</code> 包含 media queries。</li>\n</ul>\n<p>如果不在上述情况内，文件的拓展名是 <code>.scss</code> 或 <code>.sass</code>，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 <code>.scss</code> 或 <code>.sass</code> 的文件并将其导入。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;foo.scss&quot;</span>;<br><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;foo&quot;</span>;<br><span class=\"hljs-comment\">// 以上两种方式均可</span><br><br><br><span class=\"hljs-comment\">// 以下方式均不可行</span><br><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;foo.css&quot;</span>;<br><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;foo&quot;</span> screen;<br><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;http://foo.com/bar&quot;</span>;<br><span class=\"hljs-keyword\">@import</span> url(foo);<br></code></pre></td></tr></table></figure>\n\n<p>Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;rounded-corners&quot;</span>, <span class=\"hljs-string\">&quot;text-shadow&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>导入文件也可以使用 <code>#&#123; &#125;</code> 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 <code>url()</code> 导入方式：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$family</span>: <span class=\"hljs-built_in\">unquote</span>(<span class=\"hljs-string\">&quot;Droid+Sans&quot;</span>);<br><span class=\"hljs-keyword\">@import</span> url(<span class=\"hljs-string\">&quot;http://fonts.googleapis.com/css?family=\\#&#123;$family&#125;&quot;</span>);<br><br><span class=\"hljs-comment\">// 编译为：</span><br><span class=\"hljs-keyword\">@import</span> url(<span class=\"hljs-string\">&quot;http://fonts.googleapis.com/css?family=Droid+Sans&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>如果你有一个 SCSS 或 Sass 文件需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。</p>\n<p>除此之外，还支持嵌套 @import,但是不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 <code>@import</code>。</p>\n<h3 id=\"2-media\"><a href=\"#2-media\" class=\"headerlink\" title=\"2.@media\"></a>2.<code>@media</code></h3><p>Sass 中 <code>@media</code> 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 <code>@media</code> 嵌套在 CSS 规则内，编译时，<code>@media</code> 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 <code>@media</code> 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.sidebar</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">300px</span>;<br>  <span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span>;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 编译为</span><br><span class=\"hljs-selector-class\">.sidebar</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">300px</span>;<br>  <span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>@media</code>的 queries 允许互相嵌套使用，编译时，Sass 自动添加 <code>and</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@media</span> screen &#123;<br>  <span class=\"hljs-selector-class\">.sidebar</span> &#123;<br>    <span class=\"hljs-keyword\">@media</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br>      <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 编译为：</span><br><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br>  <span class=\"hljs-selector-class\">.sidebar</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span>; &#125; &#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>@media</code> 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$media</span>: screen;<br><span class=\"hljs-variable\">$feature</span>: -webkit-min-device-pixel-ratio;<br><span class=\"hljs-variable\">$value</span>: <span class=\"hljs-number\">1.5</span>;<br><br><span class=\"hljs-keyword\">@media</span> #&#123;<span class=\"hljs-variable\">$media</span>&#125; and ($feature: $value) &#123;<br>  <span class=\"hljs-selector-class\">.sidebar</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span>;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 编译为：</span><br><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">-webkit-min-device-pixel-ratio</span>: <span class=\"hljs-number\">1.5</span>) &#123;<br>  <span class=\"hljs-selector-class\">.sidebar</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span>; &#125; &#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-extend\"><a href=\"#3-extend\" class=\"headerlink\" title=\"3.*@extend\"></a>3.<code>*@extend</code></h3><p><code>@extend</code>即<code>继承</code>。在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。</p>\n<p>总的来看：支持层叠继承、多继承、允许延伸任何定义给单个元素的选择器（但是允许不一定好用）</p>\n<p>a. <code>基本延伸</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.error</span> &#123;<br>  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">#f00</span>;<br>  <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#fdd</span>;<br>&#125;<br><span class=\"hljs-selector-class\">.seriousError</span> &#123;<br>  <span class=\"hljs-keyword\">@extend</span> .error;<br>  <span class=\"hljs-attribute\">border-width</span>: <span class=\"hljs-number\">3px</span>;<br>&#125;<br><span class=\"hljs-comment\">// 上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。</span><br></code></pre></td></tr></table></figure>\n\n<p><code>@extend</code> 的作用是将重复使用的样式 (<code>.error</code>) 延伸 (extend) 给需要包含这个样式的特殊样式（<code>.seriousError</code>）</p>\n<p>注意理解以下情况：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.error</span> &#123;<br>  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">#f00</span>;<br>  <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#fdd</span>;<br>&#125;<br><span class=\"hljs-selector-class\">.error</span><span class=\"hljs-selector-class\">.intrusion</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&quot;/image/hacked.png&quot;</span>);<br>&#125;<br><span class=\"hljs-selector-class\">.seriousError</span> &#123;<br>  <span class=\"hljs-keyword\">@extend</span> .error;<br>  <span class=\"hljs-attribute\">border-width</span>: <span class=\"hljs-number\">3px</span>;<br>&#125;<br><span class=\"hljs-comment\">// .error, .seriousError &#123;</span><br>  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">#f00</span>;<br>  <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#fdd</span>; &#125;<br><br><span class=\"hljs-selector-class\">.error</span><span class=\"hljs-selector-class\">.intrusion</span>, <span class=\"hljs-selector-class\">.seriousError</span><span class=\"hljs-selector-class\">.intrusion</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&quot;/image/hacked.png&quot;</span>); &#125;<br><br><span class=\"hljs-selector-class\">.seriousError</span> &#123;<br>  <span class=\"hljs-attribute\">border-width</span>: <span class=\"hljs-number\">3px</span>; &#125;<br></code></pre></td></tr></table></figure>\n\n<p>当合并选择器时，<code>@extend</code> 会很聪明地避免无谓的重复，<code>.seriousError.seriousError</code> 将编译为 <code>.seriousError</code>，不能匹配任何元素的选择器也会删除。</p>\n<p>b.  <code>延伸复杂的选择器</code>：Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 <code>.special.cool</code>，<code>a:hover</code> 或者 <code>a.user[href^=&quot;http://&quot;]</code> 等</p>\n<p>c. <code> 多重延伸</code>：同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器</p>\n<p>d. <code>继续延伸</code>：当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个</p>\n<p>e.<code>*选择器列</code>：暂时不可以将选择器列 (Selector Sequences)，比如 <code>.foo .bar</code> 或 <code>.foo + .bar</code>，延伸给其他元素，但是，却可以将其他元素延伸给选择器列。</p>\n<p>尽量不使用<code>合并选择器列</code>，因为如果凭个人推理的话，会出现排列组合的情况，所以SASS编译器只会保留有用的组合形式，但依旧会存在排列组合的情况，有可能会留下隐患。</p>\n<ol>\n<li><p>当两个列合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前</p>\n <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-tag\">a</span> &#123;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold;<br>&#125;<br><span class=\"hljs-selector-id\">#demo</span> <span class=\"hljs-selector-class\">.overview</span> <span class=\"hljs-selector-class\">.fakelink</span> &#123;<br>  <span class=\"hljs-keyword\">@extend</span> a;<br>&#125;<br><span class=\"hljs-comment\">// 编译为：</span><br><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-tag\">a</span>,<br><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-id\">#demo</span> <span class=\"hljs-selector-class\">.overview</span> <span class=\"hljs-selector-class\">.fakelink</span>,<br><span class=\"hljs-selector-id\">#demo</span> <span class=\"hljs-selector-class\">.overview</span> <span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-class\">.fakelink</span> &#123;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold; &#125;<br></code></pre></td></tr></table></figure>\n\n</li>\n<li><p>如果两个列包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出</p>\n <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-tag\">a</span> &#123;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold;<br>&#125;<br><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.overview</span> <span class=\"hljs-selector-class\">.fakelink</span> &#123;<br>  <span class=\"hljs-keyword\">@extend</span> a;<br>&#125;<br><span class=\"hljs-comment\">// 编译为</span><br><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-tag\">a</span>,<br><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-class\">.overview</span> <span class=\"hljs-selector-class\">.fakelink</span>,<br><span class=\"hljs-selector-id\">#admin</span> <span class=\"hljs-selector-class\">.overview</span> <span class=\"hljs-selector-class\">.tabbar</span> <span class=\"hljs-selector-class\">.fakelink</span> &#123;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold; &#125;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>f. <code>在指令中延伸</code></p>\n<p>在指令中使用 <code>@extend</code> 时（比如在 <code>@media</code> 中）有一些限制：Sass 不可以将 <code>@media</code> 层外的 CSS 规则延伸给指令层内的 CSS.</p>\n<p>g.  <code>%placeholder</code>为选择器占位符，配合<code>@extend-Only选择器</code>使用。</p>\n<p>效果：只定义了样式，但不会对原有选择器匹配的元素生效</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// example1:</span><br>%<span class=\"hljs-selector-tag\">img</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: red;<br>&#125;<br><span class=\"hljs-selector-class\">.path</span>&#123;<br>    <span class=\"hljs-keyword\">@extend</span> %img;<br>&#125;<br><span class=\"hljs-comment\">// 编译后：</span><br><span class=\"hljs-selector-class\">.path</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// example2:</span><br><span class=\"hljs-selector-id\">#context</span> <span class=\"hljs-selector-tag\">a</span>%extreme &#123;<br>  <span class=\"hljs-attribute\">color</span>: blue;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">2em</span>;<br>&#125;<br><span class=\"hljs-comment\">// 编译后：</span><br><span class=\"hljs-selector-class\">.notice</span> &#123;<br>  <span class=\"hljs-keyword\">@extend</span> %extreme;<br>&#125;<br><br><span class=\"hljs-comment\">// 注：必须是&quot;.&quot;和&quot;#&quot;选择器</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-at-root\"><a href=\"#4-at-root\" class=\"headerlink\" title=\"4.@at-root\"></a>4.<code>@at-root</code></h3><blockquote>\n<p>The @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector</p>\n</blockquote>\n<p>译文：@at root指令使一个或多个规则在文档的根发出，而不是嵌套在其父选择器下。它可以与单个内联选择器一起使用</p>\n<p>且@at-root 使多个规则跳出嵌套</p>\n<p>@at-root默认情况下并不能使规则或者选择器跳出指令，通过使用without和with可以解决该问题</p>\n<p>了解即可</p>\n<h3 id=\"5-debug\"><a href=\"#5-debug\" class=\"headerlink\" title=\"5.@debug\"></a>5.<code>@debug</code></h3><p>用于调试，按标准错误输出流输出</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$size</span>: <span class=\"hljs-number\">9px</span>;<br><br><span class=\"hljs-selector-class\">.file</span>&#123;<br>  <span class=\"hljs-keyword\">@debug</span> <span class=\"hljs-variable\">$size</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-warn\"><a href=\"#6-warn\" class=\"headerlink\" title=\"6.@warn\"></a>6.<code>@warn</code></h3><p>用于警告，按标准错误输出流输出</p>\n<h3 id=\"7-error\"><a href=\"#7-error\" class=\"headerlink\" title=\"7.@error\"></a>7.<code>@error</code></h3><p>用于报错，按标准错误输出流输出</p>\n<table>\n<thead>\n<tr>\n<th>序列</th>\n<th>@-rules</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>@import</td>\n<td>导入sass或scss文件</td>\n</tr>\n<tr>\n<td>2</td>\n<td>@media</td>\n<td>用于将样式规则设置为不同的媒体类型</td>\n</tr>\n<tr>\n<td>3</td>\n<td>@extend</td>\n<td>以继承的方式共享选择器</td>\n</tr>\n<tr>\n<td>4</td>\n<td>@at-root</td>\n<td>转到根节点</td>\n</tr>\n<tr>\n<td>5</td>\n<td>@debug</td>\n<td>用于调试，按标准错误输出流输出</td>\n</tr>\n<tr>\n<td>6</td>\n<td>@warn</td>\n<td>用于警告，按标准错误输出流输出</td>\n</tr>\n<tr>\n<td>7</td>\n<td>@error</td>\n<td>用于报错，按标准错误输出流输出</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"八、控制指令\"><a href=\"#八、控制指令\" class=\"headerlink\" title=\"八、控制指令\"></a>八、控制指令</h2><h3 id=\"1-if\"><a href=\"#1-if\" class=\"headerlink\" title=\"1.if()\"></a>1.<code>if()</code></h3><p><em>三元运算符</em></p>\n<p>表达式：<code>if(expression, value1, value2)</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">p</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">if</span>(<span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span> = <span class=\"hljs-number\">2</span>, green, yellow);<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">p</span>&#123;<br>    <span class=\"hljs-attribute\">color</span>: green;&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-if\"><a href=\"#2-if\" class=\"headerlink\" title=\"2.@if\"></a>2.<code>@if</code></h3><p><em>条件语句</em></p>\n<p>当 <code>@if</code> 的表达式返回值不是 <code>false</code> 或者 <code>null</code> 时，条件成立，输出 <code>&#123;&#125;</code> 内的代码</p>\n<p><code>@if</code> 声明后面可以跟多个 <code>@else if</code> 声明，或者一个 <code>@else</code> 声明。如果 <code>@if</code> 声明失败，Sass 将逐条执行 <code>@else if</code> 声明，如果全部失败，最后执行 <code>@else</code> 声明</p>\n<ul>\n<li><p><code>单@if</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">p</span> &#123;<br>    <span class=\"hljs-keyword\">@if</span> <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> &#123;<br>        <span class=\"hljs-attribute\">color</span>: red;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p><code>@if - @else</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">p</span> &#123;<br>    <span class=\"hljs-keyword\">@if</span> <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span> != <span class=\"hljs-number\">2</span> &#123;<br>        <span class=\"hljs-attribute\">color</span>: red;<br>    &#125; <span class=\"hljs-keyword\">@else</span> &#123;<br>        <span class=\"hljs-attribute\">color</span>: blue;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p><code>@if - @else if - @else</code></p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$age</span>: <span class=\"hljs-number\">19</span>;<br><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>    <span class=\"hljs-keyword\">@if</span> <span class=\"hljs-variable\">$age</span> == <span class=\"hljs-number\">18</span> &#123;<br>        <span class=\"hljs-attribute\">color</span>: red;<br>    &#125; <span class=\"hljs-keyword\">@else</span> if <span class=\"hljs-variable\">$age</span> == <span class=\"hljs-number\">19</span> &#123;<br>        <span class=\"hljs-attribute\">color</span>: blue;<br>    &#125; <span class=\"hljs-keyword\">@else</span> &#123;<br>        <span class=\"hljs-attribute\">color</span>: green;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-for\"><a href=\"#3-for\" class=\"headerlink\" title=\"3.@for\"></a>3.<code>@for</code></h3><p><em>循环语句</em></p>\n<p>表达式：<code>@for $var from &lt;start&gt; through &lt;end&gt;</code> 或 <code>@for $var from &lt;start&gt; to &lt;end&gt;</code></p>\n<p>through 和 to 的相同点与不同点：</p>\n<ul>\n<li>相同点：两者均包含<start>的值</start></li>\n<li>不同点：through包含<end>的值，但to不包含<end>的值</end></end></li>\n</ul>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@for</span> <span class=\"hljs-variable\">$i</span> from <span class=\"hljs-number\">1</span> through <span class=\"hljs-number\">3</span> &#123;<br>  <span class=\"hljs-selector-class\">.item-</span>#&#123;<span class=\"hljs-variable\">$i</span>&#125; &#123; <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">2em</span> * <span class=\"hljs-variable\">$i</span>; &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-class\">.item-1</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">2em</span>; &#125;<br><span class=\"hljs-selector-class\">.item-2</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">4em</span>; &#125;<br><span class=\"hljs-selector-class\">.item-3</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">6em</span>; &#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"4-while\"><a href=\"#4-while\" class=\"headerlink\" title=\"4.@while\"></a>4.<code>@while</code></h3><p><em>循环语句</em></p>\n<p>表达式：<code>@while expression</code></p>\n<p><code>@while</code> 指令重复输出格式直到表达式返回结果为 <code>false</code>。这样可以实现比 <code>@for</code> 更复杂的循环，只是很少会用到</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$i</span>: <span class=\"hljs-number\">6</span>;<br><span class=\"hljs-keyword\">@while</span> <span class=\"hljs-variable\">$i</span> &gt; <span class=\"hljs-number\">0</span> &#123;<br>  <span class=\"hljs-selector-class\">.item-</span>#&#123;<span class=\"hljs-variable\">$i</span>&#125; &#123; <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">2em</span> * <span class=\"hljs-variable\">$i</span>; &#125;<br>  <span class=\"hljs-variable\">$i</span>: <span class=\"hljs-variable\">$i</span> - <span class=\"hljs-number\">2</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-class\">.item-6</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">12em</span>; &#125;<br><span class=\"hljs-selector-class\">.item-4</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">8em</span>; &#125;<br><span class=\"hljs-selector-class\">.item-2</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">4em</span>; &#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"5-each\"><a href=\"#5-each\" class=\"headerlink\" title=\"5.@each\"></a>5.<code>@each</code></h3><p><em>循环语句</em></p>\n<p>表达式：<code>$var in $vars</code></p>\n<p><code>$var</code> 可以是任何变量名</p>\n<p><code>$vars</code> 只能是<code>Lists</code>或者<code>Maps</code></p>\n<ul>\n<li><p>一维列表</p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@each</span> <span class=\"hljs-variable\">$animal</span> in puma, sea-slug, egret, salamander &#123;<br>  .#&#123;<span class=\"hljs-variable\">$animal</span>&#125;-<span class=\"hljs-attribute\">icon</span> &#123;<br>    <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-class\">.puma-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/puma.png&#x27;</span>); &#125;<br><span class=\"hljs-selector-class\">.sea-slug-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/sea-slug.png&#x27;</span>); &#125;<br><span class=\"hljs-selector-class\">.egret-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/egret.png&#x27;</span>); &#125;<br><span class=\"hljs-selector-class\">.salamander-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/salamander.png&#x27;</span>); &#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>二维列表</p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@each</span> <span class=\"hljs-variable\">$animal</span>, <span class=\"hljs-variable\">$color</span>, <span class=\"hljs-variable\">$cursor</span> in (puma, black, default),<br>                                  (sea-slug, blue, <span class=\"hljs-attribute\">pointer</span>),<br>                                  (egret, white, move) &#123;<br>  .#&#123;<span class=\"hljs-variable\">$animal</span>&#125;-<span class=\"hljs-attribute\">icon</span> &#123;<br>    <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">2px</span> solid <span class=\"hljs-variable\">$color</span>;<br>    <span class=\"hljs-attribute\">cursor</span>: <span class=\"hljs-variable\">$cursor</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-class\">.puma-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/puma.png&#x27;</span>);<br>  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">2px</span> solid black;<br>  <span class=\"hljs-attribute\">cursor</span>: default; &#125;<br><span class=\"hljs-selector-class\">.sea-slug-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/sea-slug.png&#x27;</span>);<br>  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">2px</span> solid blue;<br>  <span class=\"hljs-attribute\">cursor</span>: pointer; &#125;<br><span class=\"hljs-selector-class\">.egret-icon</span> &#123;<br>  <span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&#x27;/images/egret.png&#x27;</span>);<br>  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">2px</span> solid white;<br>  <span class=\"hljs-attribute\">cursor</span>: move; &#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>maps</p>\n  <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@each</span> <span class=\"hljs-variable\">$header</span>, <span class=\"hljs-variable\">$size</span> in (h1: <span class=\"hljs-number\">2em</span>, h2: <span class=\"hljs-number\">1.5em</span>, h3: <span class=\"hljs-number\">1.2em</span>) &#123;<br>  #&#123;<span class=\"hljs-variable\">$header</span>&#125; &#123;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-variable\">$size</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">2em</span>; &#125;<br><span class=\"hljs-selector-tag\">h2</span> &#123;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1.5em</span>; &#125;<br><span class=\"hljs-selector-tag\">h3</span> &#123;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1.2em</span>; &#125;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<hr>\n<h2 id=\"九、混合指令\"><a href=\"#九、混合指令\" class=\"headerlink\" title=\"九、混合指令\"></a>九、混合指令</h2><blockquote>\n<p>混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 <code>.float-left</code>。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。</p>\n</blockquote>\n<p>注意：这不是函数！没有返回值！！</p>\n<h3 id=\"1-定义混合指令\"><a href=\"#1-定义混合指令\" class=\"headerlink\" title=\"1.定义混合指令\"></a>1.定义混合指令</h3><p>混合指令的用法是在 <code>@mixin</code> 后添加名称与样式，以及需要的参数（可选）。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 格式：</span><br><span class=\"hljs-keyword\">@mixin</span> name &#123;<br>    <span class=\"hljs-comment\">// 样式....</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// example：</span><br><span class=\"hljs-keyword\">@mixin</span> large-text &#123;<br>  <span class=\"hljs-attribute\">font</span>: &#123;<br>    family: Arial;<br>    size: <span class=\"hljs-number\">20px</span>;<br>    weight: bold;<br>  &#125;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#ff0000</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-引用混合样式\"><a href=\"#2-引用混合样式\" class=\"headerlink\" title=\"2.引用混合样式\"></a>2.引用混合样式</h3><p>使用 <code>@include</code> 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 格式：</span><br><span class=\"hljs-keyword\">@include</span> name;<br><br><span class=\"hljs-comment\">// 注：无参数或参数都有默认值时，带不带括号都可以</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// example：</span><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> large-text;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">font-family</span>: Arial;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">20px</span>;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#ff0000</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-参数\"><a href=\"#3-参数\" class=\"headerlink\" title=\"3.参数\"></a>3.参数</h3><p>格式：按照变量的格式，通过逗号分隔，将参数写进Mixin名称后的圆括号里</p>\n<p>支持默认值；支持多参数；支持不定参数；支持位置传参和关键词传参</p>\n<h4 id=\"a-位置传参\"><a href=\"#a-位置传参\" class=\"headerlink\" title=\"a. 位置传参\"></a>a. 位置传参</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> mp(<span class=\"hljs-variable\">$width</span>) &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-variable\">$width</span>;<br>&#125;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> mp(<span class=\"hljs-number\">300px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"b-关键词传参\"><a href=\"#b-关键词传参\" class=\"headerlink\" title=\"b.关键词传参\"></a>b.关键词传参</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> mp(<span class=\"hljs-variable\">$width</span>) &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-variable\">$width</span>;<br>&#125;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> mp(<span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">300px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"c-参数默认值\"><a href=\"#c-参数默认值\" class=\"headerlink\" title=\"c.参数默认值\"></a>c.参数默认值</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> mp(<span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">500px</span>) &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-variable\">$width</span>;<br>&#125;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> mp(<span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">300px</span>);<br>    <span class=\"hljs-comment\">// or</span><br>    <span class=\"hljs-keyword\">@include</span> mp(<span class=\"hljs-number\">300px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"d-不定参数\"><a href=\"#d-不定参数\" class=\"headerlink\" title=\"d.不定参数\"></a>d.不定参数</h4><blockquote>\n<p>官方：Variable Arguments</p>\n<p>译文：参数变量</p>\n<p>有时，不能确定混合指令需要使用多少个参数。这时，可以使用参数变量 <code>…</code> 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理</p>\n</blockquote>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> mar(<span class=\"hljs-variable\">$value</span>...) &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-variable\">$value</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-向混合样式中导入内容\"><a href=\"#4-向混合样式中导入内容\" class=\"headerlink\" title=\"4.向混合样式中导入内容\"></a>4.向混合样式中导入内容</h3><p>在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 <code>@content</code> 标志的地方</p>\n<p>可以看作参数的升级版</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> example &#123;<br>    <span class=\"hljs-selector-tag\">html</span> &#123;<br>        <span class=\"hljs-keyword\">@content</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">@include</span> example&#123;<br>    <span class=\"hljs-attribute\">background-color</span>: red;<br>    <span class=\"hljs-selector-class\">.logo</span> &#123;<br>        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">600px</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// compile:</span><br><span class=\"hljs-selector-tag\">html</span> &#123;<br>  <span class=\"hljs-attribute\">background-color</span>: red;<br>&#125;<br><br><span class=\"hljs-selector-tag\">html</span> <span class=\"hljs-selector-class\">.logo</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">600px</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<hr>\n<h2 id=\"十、函数指令\"><a href=\"#十、函数指令\" class=\"headerlink\" title=\"十、函数指令\"></a>十、函数指令</h2><h3 id=\"1-内置函数\"><a href=\"#1-内置函数\" class=\"headerlink\" title=\"1.内置函数\"></a>1.内置函数</h3><h4 id=\"a-字符串函数\"><a href=\"#a-字符串函数\" class=\"headerlink\" title=\"a. 字符串函数\"></a>a. 字符串函数</h4><blockquote>\n<p>索引第一个为1，最后一个为-1；切片两边均为闭区间</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">quote($string)</td>\n<td align=\"center\">添加引号</td>\n</tr>\n<tr>\n<td align=\"left\">unquote($string)</td>\n<td align=\"center\">除去引号</td>\n</tr>\n<tr>\n<td align=\"left\">to-lower-case($string)</td>\n<td align=\"center\">变为小写</td>\n</tr>\n<tr>\n<td align=\"left\">to-upper-case($string)</td>\n<td align=\"center\">变为大写</td>\n</tr>\n<tr>\n<td align=\"left\">str-length($string)</td>\n<td align=\"center\">返回$string的长度(汉字算一个)</td>\n</tr>\n<tr>\n<td align=\"left\">str-index($string，$substring)</td>\n<td align=\"center\">返回$substring在$string的位置</td>\n</tr>\n<tr>\n<td align=\"left\">str-insert($string, $insert, $index)</td>\n<td align=\"center\">在$string的$index处插入$insert</td>\n</tr>\n<tr>\n<td align=\"left\">str-slice($string, $start-at, $end-at）</td>\n<td align=\"center\">截取$string的$start-at和$end-at之间的字符串</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-数字函数\"><a href=\"#b-数字函数\" class=\"headerlink\" title=\"b. 数字函数\"></a>b. 数字函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>percentage($number)</td>\n<td align=\"center\">转换为百分比形式</td>\n</tr>\n<tr>\n<td>round($number)</td>\n<td align=\"center\">四舍五入为整数</td>\n</tr>\n<tr>\n<td>ceil($number)</td>\n<td align=\"center\">数值向上取整</td>\n</tr>\n<tr>\n<td>floor($number)</td>\n<td align=\"center\">数值向下取整</td>\n</tr>\n<tr>\n<td>abs($number)</td>\n<td align=\"center\">获取绝对值</td>\n</tr>\n<tr>\n<td>min($number…)</td>\n<td align=\"center\">获取最小值</td>\n</tr>\n<tr>\n<td>max($number…)</td>\n<td align=\"center\">获取最大值</td>\n</tr>\n<tr>\n<td>random($number?:number)</td>\n<td align=\"center\">不传入值：获得0-1的随机数；传入正整数n：获得0-n的随机整数（左开右闭）</td>\n</tr>\n</tbody></table>\n<h4 id=\"c-数组函数\"><a href=\"#c-数组函数\" class=\"headerlink\" title=\"c. 数组函数\"></a>c. 数组函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>length($list)</td>\n<td align=\"center\">获取数组长度</td>\n</tr>\n<tr>\n<td>nth($list, n)</td>\n<td align=\"center\">获取指定下标的元素</td>\n</tr>\n<tr>\n<td>set-nth($list, $n, $value)</td>\n<td align=\"center\">向$list的$n处插入$value</td>\n</tr>\n<tr>\n<td>join($list1, $list2, $separator)</td>\n<td align=\"center\">拼接$list1和list2；$separator为新list的分隔符，默认为auto，可选择comma、space</td>\n</tr>\n<tr>\n<td>append($list, $val, $separator)</td>\n<td align=\"center\">向$list的末尾添加$val；$separator为新list的分隔符，默认为auto，可选择comma、space</td>\n</tr>\n<tr>\n<td>index($list, $value)</td>\n<td align=\"center\">返回$value值在$list中的索引值</td>\n</tr>\n<tr>\n<td>zip($lists…)</td>\n<td align=\"center\">将几个列表结合成一个多维的列表；要求每个的列表个数值必须是相同的</td>\n</tr>\n</tbody></table>\n<h4 id=\"d-映射函数\"><a href=\"#d-映射函数\" class=\"headerlink\" title=\"d. 映射函数\"></a>d. 映射函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>map-get($map, $key)</td>\n<td align=\"center\">获取$map中$key对应的$value</td>\n</tr>\n<tr>\n<td>map-merge($map1, $map2)</td>\n<td align=\"center\">合并$map1和$map2，返回一个新$map</td>\n</tr>\n<tr>\n<td>map-remove($map, $key)</td>\n<td align=\"center\">从$map中删除$key，返回一个新$map</td>\n</tr>\n<tr>\n<td>map-keys($map)</td>\n<td align=\"center\">返回$map所有的$key</td>\n</tr>\n<tr>\n<td>map-values($map)</td>\n<td align=\"center\">返回$map所有的$value</td>\n</tr>\n<tr>\n<td>map-has-key($map, $key)</td>\n<td align=\"center\">判断$map中是否存在$key，返回对应的布尔值</td>\n</tr>\n<tr>\n<td>keywords($args)</td>\n<td align=\"center\">返回一个函数的参数，并可以动态修改其值</td>\n</tr>\n</tbody></table>\n<h4 id=\"e-颜色函数\"><a href=\"#e-颜色函数\" class=\"headerlink\" title=\"e. 颜色函数\"></a>e. 颜色函数</h4><ul>\n<li><p><strong>RGB函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>rgb($red, $green, $blue)</td>\n<td align=\"center\">返回一个16进制颜色值</td>\n</tr>\n<tr>\n<td>rgba($red,$green,$blue,$alpha)</td>\n<td align=\"center\">返回一个rgba；$red,$green和$blue可被当作一个整体以颜色单词、hsl、rgb或16进制形式传入</td>\n</tr>\n<tr>\n<td>red($color)</td>\n<td align=\"center\">从$color中获取其中红色值</td>\n</tr>\n<tr>\n<td>green($color)</td>\n<td align=\"center\">从$color中获取其中绿色值</td>\n</tr>\n<tr>\n<td>blue($color)</td>\n<td align=\"center\">从$color中获取其中蓝色值</td>\n</tr>\n<tr>\n<td>mix($color1,$color2,$weight?)</td>\n<td align=\"center\">按照$weight比例，将$color1和$color2混合为一个新颜色</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>HSL函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th>函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hsl($hue,$saturation,$lightness)</td>\n<td>通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色</td>\n</tr>\n<tr>\n<td>hsla($hue,$saturation,$lightness,$alpha)</td>\n<td>通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色</td>\n</tr>\n<tr>\n<td>saturation($color)</td>\n<td>从一个颜色中获取饱和度（saturation）值</td>\n</tr>\n<tr>\n<td>lightness($color)</td>\n<td>从一个颜色中获取亮度（lightness）值</td>\n</tr>\n<tr>\n<td>adjust-hue($color,$degrees)</td>\n<td>通过改变一个颜色的色相值，创建一个新的颜色</td>\n</tr>\n<tr>\n<td>lighten($color,$amount)</td>\n<td>通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色</td>\n</tr>\n<tr>\n<td>darken($color,$amount)</td>\n<td>通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色</td>\n</tr>\n<tr>\n<td>hue($color)</td>\n<td>从一个颜色中获取亮度色相（hue）值</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>Opacity函数</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>alpha($color)/opacity($color)</td>\n<td>获取颜色透明度值</td>\n</tr>\n<tr>\n<td>rgba($color,$alpha)</td>\n<td>改变颜色的透明度</td>\n</tr>\n<tr>\n<td>opacify($color, $amount) / fade-in($color, $amount)</td>\n<td>使颜色更不透明</td>\n</tr>\n<tr>\n<td>transparentize($color, $amount) / fade-out($color, $amount)</td>\n<td>使颜色更加透明</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h4 id=\"f-Introspection函数\"><a href=\"#f-Introspection函数\" class=\"headerlink\" title=\"f. Introspection函数\"></a>f. Introspection函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>type-of($value)</td>\n<td align=\"center\">返回$value的类型</td>\n</tr>\n<tr>\n<td>unit($number)</td>\n<td align=\"center\">返回$number的单位</td>\n</tr>\n<tr>\n<td>unitless($number)</td>\n<td align=\"center\">判断$number是否带单位，返回对应的布尔值</td>\n</tr>\n<tr>\n<td>comparable($number1, $number2)</td>\n<td align=\"center\">判断$number1和$number2是否可以做加、减和合并，返回对应的布尔值</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-自定义函数\"><a href=\"#2-自定义函数\" class=\"headerlink\" title=\"2.自定义函数\"></a>2.自定义函数</h3><blockquote>\n<p>Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用</p>\n<p>Params: 与Mixin一致</p>\n<p>支持返回值</p>\n</blockquote>\n<p><strong>基本格式：</strong></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@function</span> fn-name(<span class=\"hljs-variable\">$params</span>...) &#123;<br>    <span class=\"hljs-keyword\">@return</span> <span class=\"hljs-variable\">$params</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// example:</span><br><span class=\"hljs-keyword\">@function</span> fn-name(<span class=\"hljs-variable\">$params</span>...) &#123;<br>    <span class=\"hljs-keyword\">@return</span> nth(<span class=\"hljs-variable\">$params</span>, <span class=\"hljs-number\">1</span>);<br>&#125;<br><span class=\"hljs-selector-tag\">p</span> &#123;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-built_in\">fn-name</span>(<span class=\"hljs-number\">1px</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// compiled:</span><br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">1px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<hr>\n<h2 id=\"十一、细节与展望\"><a href=\"#十一、细节与展望\" class=\"headerlink\" title=\"十一、细节与展望\"></a>十一、细节与展望</h2><h3 id=\"1-细节\"><a href=\"#1-细节\" class=\"headerlink\" title=\"1.细节\"></a>1.细节</h3><p>a. @extend、@Mixin和@function的选择</p>\n<p><a href=\"https://csswizardry.com/2016/02/mixins-better-for-performance/\">原文链接</a></p>\n<blockquote>\n<p><code>minxins</code>在网络传输中比<code>@extend</code> 拥有更好的性能.尽管有些文件未压缩时更大，但使用<code>gzip</code>压缩后，依然可以保证我们拥有更好的性能。</p>\n</blockquote>\n<p><strong>所以@extend我们就尽量不要使用了，而@Mixin和@function的差别在定义和使用上</strong></p>\n<blockquote>\n<p>定义方式不同： <code>@function</code> 需要调用<code>@return</code>输出结果。而 @mixin则不需要。</p>\n<p>使用方式不同：<code>@mixin</code> 使用<code>@include</code>引用，而 <code>@function</code> 使用小括号执行函数。</p>\n</blockquote>\n<h3 id=\"2-展望\"><a href=\"#2-展望\" class=\"headerlink\" title=\"2.展望\"></a>2.展望</h3><blockquote>\n<p>以上内容算是”基础”部分，但是对于日常开发，我觉得是足够使用的了。</p>\n<p>如果想要进一步了解，就必须先去学习下Ruby，使用Ruby相关模块进行更丰富地学习</p>\n</blockquote>\n<h3 id=\"Unfinished…\"><a href=\"#Unfinished…\" class=\"headerlink\" title=\"Unfinished…\"></a>Unfinished…</h3>"},{"title":"Vue 路由","date":"2021-05-31T11:15:21.000Z","index_img":"/img/Vue-router.jpeg","banner_img":"/img/vueRouter.jpg","_content":"\n## 1.路由的基本概念与原理\n\n路由是一个比较广义和抽象的概念，`路由的本质就是对应关系`\n\n在开发中，路由分为：\n\n- 后端路由\n- 前端路由\n\n#### 1.1 路由\n\n##### 1.1.1 后端路由\n\n- 概念：根据不同的`用户URL请求` 返回不同的内容\n- 本质：`URL请求地址`与`服务器资源`之间的对应关系![屏幕截图 2021-05-25 105809](./vueRouter.jpg)\n\n##### 1.1.2 SPA(Single Page Application)\n\n- 后端渲染（存在性能问题）\n\n- Ajax 前端渲染（前端渲染提高性能，但是不支持浏览器的前进后退操作）\n\n- SPA 单页面应用程序： 整个网站只有一个页面，内容的变化通过 Ajax 局部更新实现，同时支持浏览器地址栏的前进和后退操作\n\n- SPA 实现原理之一：基于 URL 地址的 hash（hash 的变化会导致浏览器记录访问历史的变化，但是 hash 的变化不会触发新的 URL 请求）\n\n- 在实现 SPA 过程中，最核心的技术点就是前端路由\n\n##### 1.1.3 前端路由\n\n- 概念： 根据不同的`用户事件`，显示不同的页面内容\n- 本质： `用户事件`与`事件处理函数`之间的对应关系\n\n![屏幕截图 2021-05-25 105736](C:\\Users\\yellowapple\\Desktop\\屏幕截图 2021-05-25 105736.png)\n\n##### 1.1.4 实现简易前端路由\n\n- 基于 URL 中的 hash 实现（点击菜单的时候改变 URL 的 hash，根据 hash 的变化控制组件的切换）\n\n```javascript\n//监听 window 的 onhashchange 事件，根据获取到的最新的 hash 值，切换要显示的组件的名称\nwindow.onhashchange = function () {\n  //通过 location.hash 获取最新的hash 值\n};\n```\n\n#### 1.2 Vue Router\n\n包含的功能\n\n- 支持 html5 历史模式 或 hash 模式\n- 支持嵌套路由\n- 支持路由参数\n- 支持编程式路由\n- 支持命名路由\n\n## 2.Vue-router 的基本使用\n\n#### 2.1 基本使用步骤\n\n1. 引入相关的库文件\n2. 添加路由链接\n3. 添加路由填充位\n4. 定义路由组件\n5. 配置路由规则并创建路由实例\n6. 把路由挂载到 Vue 根实例中\n\n**引入相关的库文件**\n\n```javascript\n//导入 Vue 文件，为全局 window 对象挂载 Vue 构造函数\n<script src=\"./Vue.js\"></script>\n\n//导入Vue-router 文件，为全局 window 对象挂载 VueRouter 构造函数\n<script src=\"../vue-router.js\"></script>\n```\n\n**添加路由链接**\n\n```html\n<!-- router-link 是vue中提供的标签，默认会被渲染成a标签 -->\n<!-- to 属性默认会被渲染为 href属性-->\n<!-- to 属性的值默认会被渲染为 #开头的hash地址-->\n\n<router-link to=\"/user\">User</router-link>\n<router-link to=\"/register\">Register</router-link>\n```\n\n**添加路由填充位**\n\n```html\n<!-- 路由填充位（也叫路由占位符）-->\n<!-- 将来通过路由规则匹配到的组件，将会被渲染到 router-view 所在的位置-->\n\n<router-view></router-view>\n```\n\n**定义路由组件**\n\n```javascript\nvar Users = {\n  template: `<div>Users</div>`,\n};\nvar Register = {\n  template: `<div>Register</div>`,\n};\n```\n\n**配置路由规则并创建路由实例**\n\n```javascript\n//创建路由实例对象\nvar router = new VueRouter({\n  //routes 是路由规则数组\n  routes: [\n    //每个路由规则都是一个配置对象，其中至少包含path 和 component 两个属性:\n    //path 表示当前路由规则匹配的hash地址\n    //component 表示当前路由规则对应要展示的组件\n    { path: \"/user\", component: User },\n    { path: \"/register\", component: Register },\n  ],\n});\n```\n\n**把路由挂载到 Vue 根实例中**\n\n```javascript\nnew Vue({\n\tel:'app'\n    //为了能够让路由规则生效，必须把路由对象挂载到vue实例对象上\n    router\n})\n```\n\n#### 2.2 路由重定向\n\n路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 c，从而展示特定的组件页面；通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便的设置路由的重定向\n\n```javascript\nvar router = new VueRouter({\n  routes: [\n    //其中 path 表示需要被重定向的原地址， redirect 表示将要被重定向的新地址\n    { path: \"/\", redirect: \"/user\" },\n    { path: \"/user\", component: User },\n    { path: \"/register\", component: Register },\n  ],\n});\n```\n\n## 3.嵌套路由用法\n\n#### 3.1 嵌套路由功能分析\n\n- 点击父级路由链接显示模板内容\n- 模板内容中又有子级路由链接\n- 点击子级路由链接显示子级模板内容\n\n## 4.动态路由匹配\n\n通过动态路哟参数的模式进行路由匹配\n\n```javascript\nvar router = new VueRouter({\n  routes: [\n    //动态路径参数 以冒号开头\n    { path: \"/user/:id\", component: User },\n  ],\n});\n```\n\n```javascript\nconst User = {\n  //路由组件中通过$route.params 获取路由参数\n  template: `<div> User {{$route.params.id}} </div>`,\n};\n```\n\n#### 4.1 路由组件传递参数\n\n$route 与对应路由形成高度耦合，不够灵活，所以可以使用 props 将组件和路由解耦\n\n**props 的值为布尔类型**\n\n```javascript\nconst router = new VueRouter({\n  routes: [\n    //如果props 被设置为 true，route.params 将会被设置为组件\n    { path: \"/user:id\", component: User, props: true },\n  ],\n});\n\nconst User = {\n  props: [\"id\"], //使用props 接收路由参数\n  template: `<div>用户id： {{id}} </div>`, //使用路由参数\n};\n```\n\n**props 的值为对象类型**\n\n```javascript\nconst router = new VueRouter({\n  routes: [\n    //如果props 被设置为 true，route.params 将会被设置为组件\n    { path: \"/user:id\", component: User, props: { uname: \"lisi\", age: 12 } },\n  ],\n});\n\nconst User = {\n  props: [\"uname\", \"age\"], //使用props 接收路由参数\n  template: `<div>uname + '----'+ age </div>`, //使用路由参数\n};\n```\n\n**props 的值为函数类型**\n\n```javascript\nconst router = new VueRouter({\n    routes: [\n        //如果props 被设置为 true，route.params 将会被设置为组件\n        {path:'/user:id',component:User,\n         props: route => {{uname:'zs',age:20,id: route.params.id}}\n    ]\n})\n\nconst User = {\n\tprops: ['uname','age','id'], //使用props 接收路由参数\n    template:`<div>uname + '----'+ age +'-----'+ id </div>`  //使用路由参数\n}\n```\n\n## 5.Vue-router 编程式导航\n\n#### 5.1 页面导航的两种方式\n\n- 声明式导航： 通过点击链接实现导航的方式，叫做声明式导航\n\n  例如：普通网页的 a 链接\n\n- 编程式导航： 通过调用 JavaScript 形式的 API 实现的导航的方式，叫做编程式导航\n\n  例如：普通网页中的 location.href\n\n#### 5.2 编程式导航基本用法\n\n- this,$router.push('hash 地址')\n- this.$router.gon(n)\n\n```javascript\nconst User = {\n  template: `<div><button @click=\"goRegister\">跳转到页面</button></div>`,\n  methods: {\n    Register: function () {\n      this.$router.push(\"/register\");\n    },\n  },\n};\n```\n","source":"_posts/Vue-路由.md","raw":"---\ntitle: Vue 路由\ndate: 2021-05-31 19:15:21\ntags: Vue\ncategories: 前端\nindex_img: /img/Vue-router.jpeg\nbanner_img: /img/vueRouter.jpg\n---\n\n## 1.路由的基本概念与原理\n\n路由是一个比较广义和抽象的概念，`路由的本质就是对应关系`\n\n在开发中，路由分为：\n\n- 后端路由\n- 前端路由\n\n#### 1.1 路由\n\n##### 1.1.1 后端路由\n\n- 概念：根据不同的`用户URL请求` 返回不同的内容\n- 本质：`URL请求地址`与`服务器资源`之间的对应关系![屏幕截图 2021-05-25 105809](./vueRouter.jpg)\n\n##### 1.1.2 SPA(Single Page Application)\n\n- 后端渲染（存在性能问题）\n\n- Ajax 前端渲染（前端渲染提高性能，但是不支持浏览器的前进后退操作）\n\n- SPA 单页面应用程序： 整个网站只有一个页面，内容的变化通过 Ajax 局部更新实现，同时支持浏览器地址栏的前进和后退操作\n\n- SPA 实现原理之一：基于 URL 地址的 hash（hash 的变化会导致浏览器记录访问历史的变化，但是 hash 的变化不会触发新的 URL 请求）\n\n- 在实现 SPA 过程中，最核心的技术点就是前端路由\n\n##### 1.1.3 前端路由\n\n- 概念： 根据不同的`用户事件`，显示不同的页面内容\n- 本质： `用户事件`与`事件处理函数`之间的对应关系\n\n![屏幕截图 2021-05-25 105736](C:\\Users\\yellowapple\\Desktop\\屏幕截图 2021-05-25 105736.png)\n\n##### 1.1.4 实现简易前端路由\n\n- 基于 URL 中的 hash 实现（点击菜单的时候改变 URL 的 hash，根据 hash 的变化控制组件的切换）\n\n```javascript\n//监听 window 的 onhashchange 事件，根据获取到的最新的 hash 值，切换要显示的组件的名称\nwindow.onhashchange = function () {\n  //通过 location.hash 获取最新的hash 值\n};\n```\n\n#### 1.2 Vue Router\n\n包含的功能\n\n- 支持 html5 历史模式 或 hash 模式\n- 支持嵌套路由\n- 支持路由参数\n- 支持编程式路由\n- 支持命名路由\n\n## 2.Vue-router 的基本使用\n\n#### 2.1 基本使用步骤\n\n1. 引入相关的库文件\n2. 添加路由链接\n3. 添加路由填充位\n4. 定义路由组件\n5. 配置路由规则并创建路由实例\n6. 把路由挂载到 Vue 根实例中\n\n**引入相关的库文件**\n\n```javascript\n//导入 Vue 文件，为全局 window 对象挂载 Vue 构造函数\n<script src=\"./Vue.js\"></script>\n\n//导入Vue-router 文件，为全局 window 对象挂载 VueRouter 构造函数\n<script src=\"../vue-router.js\"></script>\n```\n\n**添加路由链接**\n\n```html\n<!-- router-link 是vue中提供的标签，默认会被渲染成a标签 -->\n<!-- to 属性默认会被渲染为 href属性-->\n<!-- to 属性的值默认会被渲染为 #开头的hash地址-->\n\n<router-link to=\"/user\">User</router-link>\n<router-link to=\"/register\">Register</router-link>\n```\n\n**添加路由填充位**\n\n```html\n<!-- 路由填充位（也叫路由占位符）-->\n<!-- 将来通过路由规则匹配到的组件，将会被渲染到 router-view 所在的位置-->\n\n<router-view></router-view>\n```\n\n**定义路由组件**\n\n```javascript\nvar Users = {\n  template: `<div>Users</div>`,\n};\nvar Register = {\n  template: `<div>Register</div>`,\n};\n```\n\n**配置路由规则并创建路由实例**\n\n```javascript\n//创建路由实例对象\nvar router = new VueRouter({\n  //routes 是路由规则数组\n  routes: [\n    //每个路由规则都是一个配置对象，其中至少包含path 和 component 两个属性:\n    //path 表示当前路由规则匹配的hash地址\n    //component 表示当前路由规则对应要展示的组件\n    { path: \"/user\", component: User },\n    { path: \"/register\", component: Register },\n  ],\n});\n```\n\n**把路由挂载到 Vue 根实例中**\n\n```javascript\nnew Vue({\n\tel:'app'\n    //为了能够让路由规则生效，必须把路由对象挂载到vue实例对象上\n    router\n})\n```\n\n#### 2.2 路由重定向\n\n路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 c，从而展示特定的组件页面；通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便的设置路由的重定向\n\n```javascript\nvar router = new VueRouter({\n  routes: [\n    //其中 path 表示需要被重定向的原地址， redirect 表示将要被重定向的新地址\n    { path: \"/\", redirect: \"/user\" },\n    { path: \"/user\", component: User },\n    { path: \"/register\", component: Register },\n  ],\n});\n```\n\n## 3.嵌套路由用法\n\n#### 3.1 嵌套路由功能分析\n\n- 点击父级路由链接显示模板内容\n- 模板内容中又有子级路由链接\n- 点击子级路由链接显示子级模板内容\n\n## 4.动态路由匹配\n\n通过动态路哟参数的模式进行路由匹配\n\n```javascript\nvar router = new VueRouter({\n  routes: [\n    //动态路径参数 以冒号开头\n    { path: \"/user/:id\", component: User },\n  ],\n});\n```\n\n```javascript\nconst User = {\n  //路由组件中通过$route.params 获取路由参数\n  template: `<div> User {{$route.params.id}} </div>`,\n};\n```\n\n#### 4.1 路由组件传递参数\n\n$route 与对应路由形成高度耦合，不够灵活，所以可以使用 props 将组件和路由解耦\n\n**props 的值为布尔类型**\n\n```javascript\nconst router = new VueRouter({\n  routes: [\n    //如果props 被设置为 true，route.params 将会被设置为组件\n    { path: \"/user:id\", component: User, props: true },\n  ],\n});\n\nconst User = {\n  props: [\"id\"], //使用props 接收路由参数\n  template: `<div>用户id： {{id}} </div>`, //使用路由参数\n};\n```\n\n**props 的值为对象类型**\n\n```javascript\nconst router = new VueRouter({\n  routes: [\n    //如果props 被设置为 true，route.params 将会被设置为组件\n    { path: \"/user:id\", component: User, props: { uname: \"lisi\", age: 12 } },\n  ],\n});\n\nconst User = {\n  props: [\"uname\", \"age\"], //使用props 接收路由参数\n  template: `<div>uname + '----'+ age </div>`, //使用路由参数\n};\n```\n\n**props 的值为函数类型**\n\n```javascript\nconst router = new VueRouter({\n    routes: [\n        //如果props 被设置为 true，route.params 将会被设置为组件\n        {path:'/user:id',component:User,\n         props: route => {{uname:'zs',age:20,id: route.params.id}}\n    ]\n})\n\nconst User = {\n\tprops: ['uname','age','id'], //使用props 接收路由参数\n    template:`<div>uname + '----'+ age +'-----'+ id </div>`  //使用路由参数\n}\n```\n\n## 5.Vue-router 编程式导航\n\n#### 5.1 页面导航的两种方式\n\n- 声明式导航： 通过点击链接实现导航的方式，叫做声明式导航\n\n  例如：普通网页的 a 链接\n\n- 编程式导航： 通过调用 JavaScript 形式的 API 实现的导航的方式，叫做编程式导航\n\n  例如：普通网页中的 location.href\n\n#### 5.2 编程式导航基本用法\n\n- this,$router.push('hash 地址')\n- this.$router.gon(n)\n\n```javascript\nconst User = {\n  template: `<div><button @click=\"goRegister\">跳转到页面</button></div>`,\n  methods: {\n    Register: function () {\n      this.$router.push(\"/register\");\n    },\n  },\n};\n```\n","slug":"Vue-路由","published":1,"updated":"2024-11-17T13:58:10.668Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpf000d73t3elqo33et","content":"<h2 id=\"1-路由的基本概念与原理\"><a href=\"#1-路由的基本概念与原理\" class=\"headerlink\" title=\"1.路由的基本概念与原理\"></a>1.路由的基本概念与原理</h2><p>路由是一个比较广义和抽象的概念，<code>路由的本质就是对应关系</code></p>\n<p>在开发中，路由分为：</p>\n<ul>\n<li>后端路由</li>\n<li>前端路由</li>\n</ul>\n<h4 id=\"1-1-路由\"><a href=\"#1-1-路由\" class=\"headerlink\" title=\"1.1 路由\"></a>1.1 路由</h4><h5 id=\"1-1-1-后端路由\"><a href=\"#1-1-1-后端路由\" class=\"headerlink\" title=\"1.1.1 后端路由\"></a>1.1.1 后端路由</h5><ul>\n<li>概念：根据不同的<code>用户URL请求</code> 返回不同的内容</li>\n<li>本质：<code>URL请求地址</code>与<code>服务器资源</code>之间的对应关系<img src=\"/2021/05/31/Vue-%E8%B7%AF%E7%94%B1/vueRouter.jpg\" alt=\"屏幕截图 2021-05-25 105809\"></li>\n</ul>\n<h5 id=\"1-1-2-SPA-Single-Page-Application\"><a href=\"#1-1-2-SPA-Single-Page-Application\" class=\"headerlink\" title=\"1.1.2 SPA(Single Page Application)\"></a>1.1.2 SPA(Single Page Application)</h5><ul>\n<li><p>后端渲染（存在性能问题）</p>\n</li>\n<li><p>Ajax 前端渲染（前端渲染提高性能，但是不支持浏览器的前进后退操作）</p>\n</li>\n<li><p>SPA 单页面应用程序： 整个网站只有一个页面，内容的变化通过 Ajax 局部更新实现，同时支持浏览器地址栏的前进和后退操作</p>\n</li>\n<li><p>SPA 实现原理之一：基于 URL 地址的 hash（hash 的变化会导致浏览器记录访问历史的变化，但是 hash 的变化不会触发新的 URL 请求）</p>\n</li>\n<li><p>在实现 SPA 过程中，最核心的技术点就是前端路由</p>\n</li>\n</ul>\n<h5 id=\"1-1-3-前端路由\"><a href=\"#1-1-3-前端路由\" class=\"headerlink\" title=\"1.1.3 前端路由\"></a>1.1.3 前端路由</h5><ul>\n<li>概念： 根据不同的<code>用户事件</code>，显示不同的页面内容</li>\n<li>本质： <code>用户事件</code>与<code>事件处理函数</code>之间的对应关系</li>\n</ul>\n<p>![屏幕截图 2021-05-25 105736](C:\\Users\\yellowapple\\Desktop\\屏幕截图 2021-05-25 105736.png)</p>\n<h5 id=\"1-1-4-实现简易前端路由\"><a href=\"#1-1-4-实现简易前端路由\" class=\"headerlink\" title=\"1.1.4 实现简易前端路由\"></a>1.1.4 实现简易前端路由</h5><ul>\n<li>基于 URL 中的 hash 实现（点击菜单的时候改变 URL 的 hash，根据 hash 的变化控制组件的切换）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//监听 window 的 onhashchange 事件，根据获取到的最新的 hash 值，切换要显示的组件的名称</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onhashchange</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">//通过 location.hash 获取最新的hash 值</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-Vue-Router\"><a href=\"#1-2-Vue-Router\" class=\"headerlink\" title=\"1.2 Vue Router\"></a>1.2 Vue Router</h4><p>包含的功能</p>\n<ul>\n<li>支持 html5 历史模式 或 hash 模式</li>\n<li>支持嵌套路由</li>\n<li>支持路由参数</li>\n<li>支持编程式路由</li>\n<li>支持命名路由</li>\n</ul>\n<h2 id=\"2-Vue-router-的基本使用\"><a href=\"#2-Vue-router-的基本使用\" class=\"headerlink\" title=\"2.Vue-router 的基本使用\"></a>2.Vue-router 的基本使用</h2><h4 id=\"2-1-基本使用步骤\"><a href=\"#2-1-基本使用步骤\" class=\"headerlink\" title=\"2.1 基本使用步骤\"></a>2.1 基本使用步骤</h4><ol>\n<li>引入相关的库文件</li>\n<li>添加路由链接</li>\n<li>添加路由填充位</li>\n<li>定义路由组件</li>\n<li>配置路由规则并创建路由实例</li>\n<li>把路由挂载到 Vue 根实例中</li>\n</ol>\n<p><strong>引入相关的库文件</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//导入 Vue 文件，为全局 window 对象挂载 Vue 构造函数</span><br>&lt;script src=<span class=\"hljs-string\">&quot;./Vue.js&quot;</span>&gt;&lt;/script&gt;<br><br><span class=\"hljs-comment\">//导入Vue-router 文件，为全局 window 对象挂载 VueRouter 构造函数</span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../vue-router.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>添加路由链接</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- router-link 是vue中提供的标签，默认会被渲染成a标签 --&gt;</span><br><span class=\"hljs-comment\">&lt;!-- to 属性默认会被渲染为 href属性--&gt;</span><br><span class=\"hljs-comment\">&lt;!-- to 属性的值默认会被渲染为 #开头的hash地址--&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;/user&quot;</span>&gt;</span>User<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;/register&quot;</span>&gt;</span>Register<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>添加路由填充位</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 路由填充位（也叫路由占位符）--&gt;</span><br><span class=\"hljs-comment\">&lt;!-- 将来通过路由规则匹配到的组件，将会被渲染到 router-view 所在的位置--&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-view</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-view</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>定义路由组件</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">Users</span> = &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div&gt;Users&lt;/div&gt;`</span>,<br>&#125;;<br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">Register</span> = &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div&gt;Register&lt;/div&gt;`</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>配置路由规则并创建路由实例</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//创建路由实例对象</span><br><span class=\"hljs-keyword\">var</span> router = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VueRouter</span>(&#123;<br>  <span class=\"hljs-comment\">//routes 是路由规则数组</span><br>  <span class=\"hljs-attr\">routes</span>: [<br>    <span class=\"hljs-comment\">//每个路由规则都是一个配置对象，其中至少包含path 和 component 两个属性:</span><br>    <span class=\"hljs-comment\">//path 表示当前路由规则匹配的hash地址</span><br>    <span class=\"hljs-comment\">//component 表示当前路由规则对应要展示的组件</span><br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/user&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">User</span> &#125;,<br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/register&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">Register</span> &#125;,<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p><strong>把路由挂载到 Vue 根实例中</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vue</span>(&#123;<br>\t<span class=\"hljs-attr\">el</span>:<span class=\"hljs-string\">&#x27;app&#x27;</span><br>    <span class=\"hljs-comment\">//为了能够让路由规则生效，必须把路由对象挂载到vue实例对象上</span><br>    router<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-路由重定向\"><a href=\"#2-2-路由重定向\" class=\"headerlink\" title=\"2.2 路由重定向\"></a>2.2 路由重定向</h4><p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 c，从而展示特定的组件页面；通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便的设置路由的重定向</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> router = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VueRouter</span>(&#123;<br>  <span class=\"hljs-attr\">routes</span>: [<br>    <span class=\"hljs-comment\">//其中 path 表示需要被重定向的原地址， redirect 表示将要被重定向的新地址</span><br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-attr\">redirect</span>: <span class=\"hljs-string\">&quot;/user&quot;</span> &#125;,<br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/user&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">User</span> &#125;,<br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/register&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">Register</span> &#125;,<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-嵌套路由用法\"><a href=\"#3-嵌套路由用法\" class=\"headerlink\" title=\"3.嵌套路由用法\"></a>3.嵌套路由用法</h2><h4 id=\"3-1-嵌套路由功能分析\"><a href=\"#3-1-嵌套路由功能分析\" class=\"headerlink\" title=\"3.1 嵌套路由功能分析\"></a>3.1 嵌套路由功能分析</h4><ul>\n<li>点击父级路由链接显示模板内容</li>\n<li>模板内容中又有子级路由链接</li>\n<li>点击子级路由链接显示子级模板内容</li>\n</ul>\n<h2 id=\"4-动态路由匹配\"><a href=\"#4-动态路由匹配\" class=\"headerlink\" title=\"4.动态路由匹配\"></a>4.动态路由匹配</h2><p>通过动态路哟参数的模式进行路由匹配</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> router = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VueRouter</span>(&#123;<br>  <span class=\"hljs-attr\">routes</span>: [<br>    <span class=\"hljs-comment\">//动态路径参数 以冒号开头</span><br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/user/:id&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">User</span> &#125;,<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = &#123;<br>  <span class=\"hljs-comment\">//路由组件中通过$route.params 获取路由参数</span><br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div&gt; User &#123;&#123;$route.params.id&#125;&#125; &lt;/div&gt;`</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-1-路由组件传递参数\"><a href=\"#4-1-路由组件传递参数\" class=\"headerlink\" title=\"4.1 路由组件传递参数\"></a>4.1 路由组件传递参数</h4><p>$route 与对应路由形成高度耦合，不够灵活，所以可以使用 props 将组件和路由解耦</p>\n<p><strong>props 的值为布尔类型</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VueRouter</span>(&#123;<br>  <span class=\"hljs-attr\">routes</span>: [<br>    <span class=\"hljs-comment\">//如果props 被设置为 true，route.params 将会被设置为组件</span><br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/user:id&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">User</span>, <span class=\"hljs-attr\">props</span>: <span class=\"hljs-literal\">true</span> &#125;,<br>  ],<br>&#125;);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&quot;id&quot;</span>], <span class=\"hljs-comment\">//使用props 接收路由参数</span><br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div&gt;用户id： &#123;&#123;id&#125;&#125; &lt;/div&gt;`</span>, <span class=\"hljs-comment\">//使用路由参数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>props 的值为对象类型</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VueRouter</span>(&#123;<br>  <span class=\"hljs-attr\">routes</span>: [<br>    <span class=\"hljs-comment\">//如果props 被设置为 true，route.params 将会被设置为组件</span><br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/user:id&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">User</span>, <span class=\"hljs-attr\">props</span>: &#123; <span class=\"hljs-attr\">uname</span>: <span class=\"hljs-string\">&quot;lisi&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">12</span> &#125; &#125;,<br>  ],<br>&#125;);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&quot;uname&quot;</span>, <span class=\"hljs-string\">&quot;age&quot;</span>], <span class=\"hljs-comment\">//使用props 接收路由参数</span><br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div&gt;uname + &#x27;----&#x27;+ age &lt;/div&gt;`</span>, <span class=\"hljs-comment\">//使用路由参数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>props 的值为函数类型</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VueRouter</span>(&#123;<br>    <span class=\"hljs-attr\">routes</span>: [<br>        <span class=\"hljs-comment\">//如果props 被设置为 true，route.params 将会被设置为组件</span><br>        &#123;<span class=\"hljs-attr\">path</span>:<span class=\"hljs-string\">&#x27;/user:id&#x27;</span>,<span class=\"hljs-attr\">component</span>:<span class=\"hljs-title class_\">User</span>,<br>         <span class=\"hljs-attr\">props</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;&#123;<span class=\"hljs-attr\">uname</span>:<span class=\"hljs-string\">&#x27;zs&#x27;</span>,<span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">20</span>,<span class=\"hljs-attr\">id</span>: route.<span class=\"hljs-property\">params</span>.<span class=\"hljs-property\">id</span>&#125;&#125;<br>    ]<br>&#125;)<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = &#123;<br>\t<span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;uname&#x27;</span>,<span class=\"hljs-string\">&#x27;age&#x27;</span>,<span class=\"hljs-string\">&#x27;id&#x27;</span>], <span class=\"hljs-comment\">//使用props 接收路由参数</span><br>    <span class=\"hljs-attr\">template</span>:<span class=\"hljs-string\">`&lt;div&gt;uname + &#x27;----&#x27;+ age +&#x27;-----&#x27;+ id &lt;/div&gt;`</span>  <span class=\"hljs-comment\">//使用路由参数</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-Vue-router-编程式导航\"><a href=\"#5-Vue-router-编程式导航\" class=\"headerlink\" title=\"5.Vue-router 编程式导航\"></a>5.Vue-router 编程式导航</h2><h4 id=\"5-1-页面导航的两种方式\"><a href=\"#5-1-页面导航的两种方式\" class=\"headerlink\" title=\"5.1 页面导航的两种方式\"></a>5.1 页面导航的两种方式</h4><ul>\n<li><p>声明式导航： 通过点击链接实现导航的方式，叫做声明式导航</p>\n<p>例如：普通网页的 a 链接</p>\n</li>\n<li><p>编程式导航： 通过调用 JavaScript 形式的 API 实现的导航的方式，叫做编程式导航</p>\n<p>例如：普通网页中的 location.href</p>\n</li>\n</ul>\n<h4 id=\"5-2-编程式导航基本用法\"><a href=\"#5-2-编程式导航基本用法\" class=\"headerlink\" title=\"5.2 编程式导航基本用法\"></a>5.2 编程式导航基本用法</h4><ul>\n<li>this,$router.push(‘hash 地址’)</li>\n<li>this.$router.gon(n)</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div&gt;&lt;button @click=&quot;goRegister&quot;&gt;跳转到页面&lt;/button&gt;&lt;/div&gt;`</span>,<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-title class_\">Register</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$router</span>.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&quot;/register&quot;</span>);<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":4180,"excerpt":"","more":"<h2 id=\"1-路由的基本概念与原理\"><a href=\"#1-路由的基本概念与原理\" class=\"headerlink\" title=\"1.路由的基本概念与原理\"></a>1.路由的基本概念与原理</h2><p>路由是一个比较广义和抽象的概念，<code>路由的本质就是对应关系</code></p>\n<p>在开发中，路由分为：</p>\n<ul>\n<li>后端路由</li>\n<li>前端路由</li>\n</ul>\n<h4 id=\"1-1-路由\"><a href=\"#1-1-路由\" class=\"headerlink\" title=\"1.1 路由\"></a>1.1 路由</h4><h5 id=\"1-1-1-后端路由\"><a href=\"#1-1-1-后端路由\" class=\"headerlink\" title=\"1.1.1 后端路由\"></a>1.1.1 后端路由</h5><ul>\n<li>概念：根据不同的<code>用户URL请求</code> 返回不同的内容</li>\n<li>本质：<code>URL请求地址</code>与<code>服务器资源</code>之间的对应关系<img src=\"/2021/05/31/Vue-%E8%B7%AF%E7%94%B1/vueRouter.jpg\" alt=\"屏幕截图 2021-05-25 105809\"></li>\n</ul>\n<h5 id=\"1-1-2-SPA-Single-Page-Application\"><a href=\"#1-1-2-SPA-Single-Page-Application\" class=\"headerlink\" title=\"1.1.2 SPA(Single Page Application)\"></a>1.1.2 SPA(Single Page Application)</h5><ul>\n<li><p>后端渲染（存在性能问题）</p>\n</li>\n<li><p>Ajax 前端渲染（前端渲染提高性能，但是不支持浏览器的前进后退操作）</p>\n</li>\n<li><p>SPA 单页面应用程序： 整个网站只有一个页面，内容的变化通过 Ajax 局部更新实现，同时支持浏览器地址栏的前进和后退操作</p>\n</li>\n<li><p>SPA 实现原理之一：基于 URL 地址的 hash（hash 的变化会导致浏览器记录访问历史的变化，但是 hash 的变化不会触发新的 URL 请求）</p>\n</li>\n<li><p>在实现 SPA 过程中，最核心的技术点就是前端路由</p>\n</li>\n</ul>\n<h5 id=\"1-1-3-前端路由\"><a href=\"#1-1-3-前端路由\" class=\"headerlink\" title=\"1.1.3 前端路由\"></a>1.1.3 前端路由</h5><ul>\n<li>概念： 根据不同的<code>用户事件</code>，显示不同的页面内容</li>\n<li>本质： <code>用户事件</code>与<code>事件处理函数</code>之间的对应关系</li>\n</ul>\n<p>![屏幕截图 2021-05-25 105736](C:\\Users\\yellowapple\\Desktop\\屏幕截图 2021-05-25 105736.png)</p>\n<h5 id=\"1-1-4-实现简易前端路由\"><a href=\"#1-1-4-实现简易前端路由\" class=\"headerlink\" title=\"1.1.4 实现简易前端路由\"></a>1.1.4 实现简易前端路由</h5><ul>\n<li>基于 URL 中的 hash 实现（点击菜单的时候改变 URL 的 hash，根据 hash 的变化控制组件的切换）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//监听 window 的 onhashchange 事件，根据获取到的最新的 hash 值，切换要显示的组件的名称</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onhashchange</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">//通过 location.hash 获取最新的hash 值</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-Vue-Router\"><a href=\"#1-2-Vue-Router\" class=\"headerlink\" title=\"1.2 Vue Router\"></a>1.2 Vue Router</h4><p>包含的功能</p>\n<ul>\n<li>支持 html5 历史模式 或 hash 模式</li>\n<li>支持嵌套路由</li>\n<li>支持路由参数</li>\n<li>支持编程式路由</li>\n<li>支持命名路由</li>\n</ul>\n<h2 id=\"2-Vue-router-的基本使用\"><a href=\"#2-Vue-router-的基本使用\" class=\"headerlink\" title=\"2.Vue-router 的基本使用\"></a>2.Vue-router 的基本使用</h2><h4 id=\"2-1-基本使用步骤\"><a href=\"#2-1-基本使用步骤\" class=\"headerlink\" title=\"2.1 基本使用步骤\"></a>2.1 基本使用步骤</h4><ol>\n<li>引入相关的库文件</li>\n<li>添加路由链接</li>\n<li>添加路由填充位</li>\n<li>定义路由组件</li>\n<li>配置路由规则并创建路由实例</li>\n<li>把路由挂载到 Vue 根实例中</li>\n</ol>\n<p><strong>引入相关的库文件</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//导入 Vue 文件，为全局 window 对象挂载 Vue 构造函数</span><br>&lt;script src=<span class=\"hljs-string\">&quot;./Vue.js&quot;</span>&gt;&lt;/script&gt;<br><br><span class=\"hljs-comment\">//导入Vue-router 文件，为全局 window 对象挂载 VueRouter 构造函数</span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../vue-router.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>添加路由链接</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- router-link 是vue中提供的标签，默认会被渲染成a标签 --&gt;</span><br><span class=\"hljs-comment\">&lt;!-- to 属性默认会被渲染为 href属性--&gt;</span><br><span class=\"hljs-comment\">&lt;!-- to 属性的值默认会被渲染为 #开头的hash地址--&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;/user&quot;</span>&gt;</span>User<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;/register&quot;</span>&gt;</span>Register<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>添加路由填充位</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 路由填充位（也叫路由占位符）--&gt;</span><br><span class=\"hljs-comment\">&lt;!-- 将来通过路由规则匹配到的组件，将会被渲染到 router-view 所在的位置--&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-view</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-view</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>定义路由组件</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">Users</span> = &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div&gt;Users&lt;/div&gt;`</span>,<br>&#125;;<br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">Register</span> = &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div&gt;Register&lt;/div&gt;`</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>配置路由规则并创建路由实例</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//创建路由实例对象</span><br><span class=\"hljs-keyword\">var</span> router = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VueRouter</span>(&#123;<br>  <span class=\"hljs-comment\">//routes 是路由规则数组</span><br>  <span class=\"hljs-attr\">routes</span>: [<br>    <span class=\"hljs-comment\">//每个路由规则都是一个配置对象，其中至少包含path 和 component 两个属性:</span><br>    <span class=\"hljs-comment\">//path 表示当前路由规则匹配的hash地址</span><br>    <span class=\"hljs-comment\">//component 表示当前路由规则对应要展示的组件</span><br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/user&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">User</span> &#125;,<br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/register&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">Register</span> &#125;,<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p><strong>把路由挂载到 Vue 根实例中</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vue</span>(&#123;<br>\t<span class=\"hljs-attr\">el</span>:<span class=\"hljs-string\">&#x27;app&#x27;</span><br>    <span class=\"hljs-comment\">//为了能够让路由规则生效，必须把路由对象挂载到vue实例对象上</span><br>    router<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-路由重定向\"><a href=\"#2-2-路由重定向\" class=\"headerlink\" title=\"2.2 路由重定向\"></a>2.2 路由重定向</h4><p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 c，从而展示特定的组件页面；通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便的设置路由的重定向</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> router = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VueRouter</span>(&#123;<br>  <span class=\"hljs-attr\">routes</span>: [<br>    <span class=\"hljs-comment\">//其中 path 表示需要被重定向的原地址， redirect 表示将要被重定向的新地址</span><br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-attr\">redirect</span>: <span class=\"hljs-string\">&quot;/user&quot;</span> &#125;,<br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/user&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">User</span> &#125;,<br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/register&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">Register</span> &#125;,<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-嵌套路由用法\"><a href=\"#3-嵌套路由用法\" class=\"headerlink\" title=\"3.嵌套路由用法\"></a>3.嵌套路由用法</h2><h4 id=\"3-1-嵌套路由功能分析\"><a href=\"#3-1-嵌套路由功能分析\" class=\"headerlink\" title=\"3.1 嵌套路由功能分析\"></a>3.1 嵌套路由功能分析</h4><ul>\n<li>点击父级路由链接显示模板内容</li>\n<li>模板内容中又有子级路由链接</li>\n<li>点击子级路由链接显示子级模板内容</li>\n</ul>\n<h2 id=\"4-动态路由匹配\"><a href=\"#4-动态路由匹配\" class=\"headerlink\" title=\"4.动态路由匹配\"></a>4.动态路由匹配</h2><p>通过动态路哟参数的模式进行路由匹配</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> router = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VueRouter</span>(&#123;<br>  <span class=\"hljs-attr\">routes</span>: [<br>    <span class=\"hljs-comment\">//动态路径参数 以冒号开头</span><br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/user/:id&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">User</span> &#125;,<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = &#123;<br>  <span class=\"hljs-comment\">//路由组件中通过$route.params 获取路由参数</span><br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div&gt; User &#123;&#123;$route.params.id&#125;&#125; &lt;/div&gt;`</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-1-路由组件传递参数\"><a href=\"#4-1-路由组件传递参数\" class=\"headerlink\" title=\"4.1 路由组件传递参数\"></a>4.1 路由组件传递参数</h4><p>$route 与对应路由形成高度耦合，不够灵活，所以可以使用 props 将组件和路由解耦</p>\n<p><strong>props 的值为布尔类型</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VueRouter</span>(&#123;<br>  <span class=\"hljs-attr\">routes</span>: [<br>    <span class=\"hljs-comment\">//如果props 被设置为 true，route.params 将会被设置为组件</span><br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/user:id&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">User</span>, <span class=\"hljs-attr\">props</span>: <span class=\"hljs-literal\">true</span> &#125;,<br>  ],<br>&#125;);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&quot;id&quot;</span>], <span class=\"hljs-comment\">//使用props 接收路由参数</span><br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div&gt;用户id： &#123;&#123;id&#125;&#125; &lt;/div&gt;`</span>, <span class=\"hljs-comment\">//使用路由参数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>props 的值为对象类型</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VueRouter</span>(&#123;<br>  <span class=\"hljs-attr\">routes</span>: [<br>    <span class=\"hljs-comment\">//如果props 被设置为 true，route.params 将会被设置为组件</span><br>    &#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/user:id&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">User</span>, <span class=\"hljs-attr\">props</span>: &#123; <span class=\"hljs-attr\">uname</span>: <span class=\"hljs-string\">&quot;lisi&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">12</span> &#125; &#125;,<br>  ],<br>&#125;);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&quot;uname&quot;</span>, <span class=\"hljs-string\">&quot;age&quot;</span>], <span class=\"hljs-comment\">//使用props 接收路由参数</span><br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div&gt;uname + &#x27;----&#x27;+ age &lt;/div&gt;`</span>, <span class=\"hljs-comment\">//使用路由参数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>props 的值为函数类型</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VueRouter</span>(&#123;<br>    <span class=\"hljs-attr\">routes</span>: [<br>        <span class=\"hljs-comment\">//如果props 被设置为 true，route.params 将会被设置为组件</span><br>        &#123;<span class=\"hljs-attr\">path</span>:<span class=\"hljs-string\">&#x27;/user:id&#x27;</span>,<span class=\"hljs-attr\">component</span>:<span class=\"hljs-title class_\">User</span>,<br>         <span class=\"hljs-attr\">props</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;&#123;<span class=\"hljs-attr\">uname</span>:<span class=\"hljs-string\">&#x27;zs&#x27;</span>,<span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">20</span>,<span class=\"hljs-attr\">id</span>: route.<span class=\"hljs-property\">params</span>.<span class=\"hljs-property\">id</span>&#125;&#125;<br>    ]<br>&#125;)<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = &#123;<br>\t<span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;uname&#x27;</span>,<span class=\"hljs-string\">&#x27;age&#x27;</span>,<span class=\"hljs-string\">&#x27;id&#x27;</span>], <span class=\"hljs-comment\">//使用props 接收路由参数</span><br>    <span class=\"hljs-attr\">template</span>:<span class=\"hljs-string\">`&lt;div&gt;uname + &#x27;----&#x27;+ age +&#x27;-----&#x27;+ id &lt;/div&gt;`</span>  <span class=\"hljs-comment\">//使用路由参数</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-Vue-router-编程式导航\"><a href=\"#5-Vue-router-编程式导航\" class=\"headerlink\" title=\"5.Vue-router 编程式导航\"></a>5.Vue-router 编程式导航</h2><h4 id=\"5-1-页面导航的两种方式\"><a href=\"#5-1-页面导航的两种方式\" class=\"headerlink\" title=\"5.1 页面导航的两种方式\"></a>5.1 页面导航的两种方式</h4><ul>\n<li><p>声明式导航： 通过点击链接实现导航的方式，叫做声明式导航</p>\n<p>例如：普通网页的 a 链接</p>\n</li>\n<li><p>编程式导航： 通过调用 JavaScript 形式的 API 实现的导航的方式，叫做编程式导航</p>\n<p>例如：普通网页中的 location.href</p>\n</li>\n</ul>\n<h4 id=\"5-2-编程式导航基本用法\"><a href=\"#5-2-编程式导航基本用法\" class=\"headerlink\" title=\"5.2 编程式导航基本用法\"></a>5.2 编程式导航基本用法</h4><ul>\n<li>this,$router.push(‘hash 地址’)</li>\n<li>this.$router.gon(n)</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div&gt;&lt;button @click=&quot;goRegister&quot;&gt;跳转到页面&lt;/button&gt;&lt;/div&gt;`</span>,<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-title class_\">Register</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$router</span>.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&quot;/register&quot;</span>);<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>\n"},{"title":"Vue的虚拟DOM","date":"2023-06-07T13:48:43.000Z","index_img":"/img/render-DOM.png","banner_img":"/img/render-DOM.png","_content":"## Vue的渲染机制\n\n>  Vue 是如何将一份模板转换为真实的 DOM 节点的，又是如何高效地更新这些节点的呢？\n\n## 虚拟DOM\n\nVDOM（其实就是一个对象）是一种编程概念，意为将目标所需的 UI 通过数据结构“虚拟”地表示出来，保存在内存中，然后将真实的 DOM 与之保持同步。\n\n```js\nconst vnode = {\n  type: 'div',\n  props: {\n    id: 'hello'\n  },\n  children: [\n    /* 更多 vnode */\n  ]\n}\n```\n\n这里所说的 `vnode` 即一个纯 JavaScript 的对象 (一个“虚拟节点”)，它代表着一个 `<div>` 元素。它包含我们创建实际元素所需的所有信息。它还包含更多的子节点，这使它成为虚拟 DOM 树的根节点。\n\n一个运行时渲染器将会遍历整个虚拟 DOM 树，并据此构建真实的 DOM 树。这个过程被称为**挂载** (mount)。\n\n如果我们有两份虚拟 DOM 树，渲染器将会有比较地遍历它们，找出它们之间的区别，并应用这其中的变化到真实的 DOM 上。这个过程被称为**更新** (patch)，又被称为“比对”(diffing) 或“协调”(reconciliation)。\n\n## [渲染管线](https://cn.vuejs.org/guide/extras/rendering-mechanism.html#render-pipeline)\n\n从高层面的视角看，Vue 组件挂载时会发生如下几件事：\n\n1. **编译**：Vue 模板被编译为**渲染函数**（render）：即用来返回虚拟 DOM 树的函数。这一步骤可以通过构建步骤提前完成，也可以通过使用运行时编译器即时完成。\n2. **挂载**：运行时渲染器调用渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。这一步会作为[响应式副作用](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html)执行，因此它会追踪其中所用到的所有响应式依赖。\n3. **更新**（diff算法）：当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟 DOM 树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。\n\n![render pipeline](https://cn.vuejs.org/assets/render-pipeline.03805016.png)\n\n## 创建VNode\n\n```js\nimport {h} from 'vue'\n\nconst vnode = h(\n  'div', // type\n  { id: 'foo', class: 'bar' }, // props\n  [\n    /* children */\n  ]\n)\n```\n\n`h()` 是 **hyperscript** 的简称——意思是“能生成 HTML (超文本标记语言) 的 JavaScript”。这个名字来源于许多虚拟 DOM 实现默认形成的约定。一个更准确的名称应该是 `createVnode()`，但当你需要多次使用渲染函数时，一个简短的名字会更省力。\n\n```js\n// 除了类型必填以外，其他的参数都是可选的\nh('div')\nh('div', { id: 'foo' })\n\n// attribute 和 property 都能在 prop 中书写\n// Vue 会自动将它们分配到正确的位置\nh('div', { class: 'bar', innerHTML: 'hello' })\n\n// 像 `.prop` 和 `.attr` 这样的的属性修饰符\n// 可以分别通过 `.` 和 `^` 前缀来添加\nh('div', { '.name': 'some-name', '^width': '100' })\n\n// 类与样式可以像在模板中一样\n// 用数组或对象的形式书写\nh('div', { class: [foo, { bar }], style: { color: 'red' } })\n\n// 事件监听器应以 onXxx 的形式书写\nh('div', { onClick: () => {} })\n\n// children 可以是一个字符串\nh('div', { id: 'foo' }, 'hello')\n\n// 没有 props 时可以省略不写\nh('div', 'hello')\nh('div', [h('span', 'hello')])\n\n// children 数组可以同时包含 vnodes 与字符串\nh('div', ['hello', h('span', 'hello')])\n```\n\n\n\n## [Vnodes 必须唯一](https://cn.vuejs.org/guide/extras/render-function.html#vnodes-must-be-unique)\n\n组件树中的 vnodes 必须是唯一的。下面是错误示范：\n\njs\n\n```js\nfunction render() {\n  const p = h('p', 'hi')\n  return h('div', [\n    // 啊哦，重复的 vnodes 是无效的\n    p,\n    p\n  ])\n}\n```\n\n如果你真的非常想在页面上渲染多个重复的元素或者组件，你可以使用一个工厂函数来做这件事。比如下面的这个渲染函数就可以完美渲染出 20 个相同的段落：\n\njs\n\n```js\nfunction render() {\n  return h(\n    'div',\n    Array.from({ length: 20 }).map(() => {\n      return h('p', 'hi')\n    })\n  )\n}\n```\n\n\n\n### [`v-if`](https://cn.vuejs.org/guide/extras/render-function.html#v-if)\n\n模板：\n\n```html\n<div>\n  <div v-if=\"ok\">yes</div>\n  <span v-else>no</span>\n</div>\n```\n\n等价于使用如下渲染函数语法：\n\n```js\nh('div', [ok.value ? h('div', 'yes') : h('span', 'no')])\n```\n\nJSX语法：\n\n```jsx\n<div>{ok.value ? <div>yes</div> : <span>no</span>}</div>\n```\n\n\n\n## render函数\n\n> createVNode(),h(),render()三者的联系与区别\n>\n> 干：h() 就是 createVNode()的简称，但是createVNode()函数的功能比h()函数要多且做了性能优化，渲染节点的速度也更快\n>\n>\n> render —— 渲染虚拟 DOM 变成 真实dom\n> @param 参数1 要被渲染的虚拟 DOM，必选\n> @param 参数2 要渲染的位置，必选\n> @description 虚拟 DOM 创建完成后，需要使用 render 函数，才能在页面中渲染\n> render(testDiv, document.body);\n\n用于编程式地创建组件虚拟 DOM 树的函数。\n\n- **类型**\n\n\t```ts\n\tinterface ComponentOptions {\n\t  render?(this: ComponentPublicInstance) => VNodeChild\n\t}\n\t\n\ttype VNodeChild = VNodeChildAtom | VNodeArrayChildren\n\t\n\ttype VNodeChildAtom =\n\t  | VNode\n\t  | string\n\t  | number\n\t  | boolean\n\t  | null\n\t  | undefined\n\t  | void\n\t\n\ttype VNodeArrayChildren = (VNodeArrayChildren | VNodeChildAtom)[]\n\t```\n\n\t\n\n\t1. 先创建虚拟DOM\n\t2. 用render函数将  虚拟DOM变成 真实DOM\n\t3. 插入到body中","source":"_posts/Vue的虚拟DOM.md","raw":"---\ntitle: Vue的虚拟DOM\ndate: 2023-06-07 21:48:43\ntags: Vue\ncategories: 前端\nindex_img: /img/render-DOM.png\nbanner_img: /img/render-DOM.png\n---\n## Vue的渲染机制\n\n>  Vue 是如何将一份模板转换为真实的 DOM 节点的，又是如何高效地更新这些节点的呢？\n\n## 虚拟DOM\n\nVDOM（其实就是一个对象）是一种编程概念，意为将目标所需的 UI 通过数据结构“虚拟”地表示出来，保存在内存中，然后将真实的 DOM 与之保持同步。\n\n```js\nconst vnode = {\n  type: 'div',\n  props: {\n    id: 'hello'\n  },\n  children: [\n    /* 更多 vnode */\n  ]\n}\n```\n\n这里所说的 `vnode` 即一个纯 JavaScript 的对象 (一个“虚拟节点”)，它代表着一个 `<div>` 元素。它包含我们创建实际元素所需的所有信息。它还包含更多的子节点，这使它成为虚拟 DOM 树的根节点。\n\n一个运行时渲染器将会遍历整个虚拟 DOM 树，并据此构建真实的 DOM 树。这个过程被称为**挂载** (mount)。\n\n如果我们有两份虚拟 DOM 树，渲染器将会有比较地遍历它们，找出它们之间的区别，并应用这其中的变化到真实的 DOM 上。这个过程被称为**更新** (patch)，又被称为“比对”(diffing) 或“协调”(reconciliation)。\n\n## [渲染管线](https://cn.vuejs.org/guide/extras/rendering-mechanism.html#render-pipeline)\n\n从高层面的视角看，Vue 组件挂载时会发生如下几件事：\n\n1. **编译**：Vue 模板被编译为**渲染函数**（render）：即用来返回虚拟 DOM 树的函数。这一步骤可以通过构建步骤提前完成，也可以通过使用运行时编译器即时完成。\n2. **挂载**：运行时渲染器调用渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。这一步会作为[响应式副作用](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html)执行，因此它会追踪其中所用到的所有响应式依赖。\n3. **更新**（diff算法）：当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟 DOM 树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。\n\n![render pipeline](https://cn.vuejs.org/assets/render-pipeline.03805016.png)\n\n## 创建VNode\n\n```js\nimport {h} from 'vue'\n\nconst vnode = h(\n  'div', // type\n  { id: 'foo', class: 'bar' }, // props\n  [\n    /* children */\n  ]\n)\n```\n\n`h()` 是 **hyperscript** 的简称——意思是“能生成 HTML (超文本标记语言) 的 JavaScript”。这个名字来源于许多虚拟 DOM 实现默认形成的约定。一个更准确的名称应该是 `createVnode()`，但当你需要多次使用渲染函数时，一个简短的名字会更省力。\n\n```js\n// 除了类型必填以外，其他的参数都是可选的\nh('div')\nh('div', { id: 'foo' })\n\n// attribute 和 property 都能在 prop 中书写\n// Vue 会自动将它们分配到正确的位置\nh('div', { class: 'bar', innerHTML: 'hello' })\n\n// 像 `.prop` 和 `.attr` 这样的的属性修饰符\n// 可以分别通过 `.` 和 `^` 前缀来添加\nh('div', { '.name': 'some-name', '^width': '100' })\n\n// 类与样式可以像在模板中一样\n// 用数组或对象的形式书写\nh('div', { class: [foo, { bar }], style: { color: 'red' } })\n\n// 事件监听器应以 onXxx 的形式书写\nh('div', { onClick: () => {} })\n\n// children 可以是一个字符串\nh('div', { id: 'foo' }, 'hello')\n\n// 没有 props 时可以省略不写\nh('div', 'hello')\nh('div', [h('span', 'hello')])\n\n// children 数组可以同时包含 vnodes 与字符串\nh('div', ['hello', h('span', 'hello')])\n```\n\n\n\n## [Vnodes 必须唯一](https://cn.vuejs.org/guide/extras/render-function.html#vnodes-must-be-unique)\n\n组件树中的 vnodes 必须是唯一的。下面是错误示范：\n\njs\n\n```js\nfunction render() {\n  const p = h('p', 'hi')\n  return h('div', [\n    // 啊哦，重复的 vnodes 是无效的\n    p,\n    p\n  ])\n}\n```\n\n如果你真的非常想在页面上渲染多个重复的元素或者组件，你可以使用一个工厂函数来做这件事。比如下面的这个渲染函数就可以完美渲染出 20 个相同的段落：\n\njs\n\n```js\nfunction render() {\n  return h(\n    'div',\n    Array.from({ length: 20 }).map(() => {\n      return h('p', 'hi')\n    })\n  )\n}\n```\n\n\n\n### [`v-if`](https://cn.vuejs.org/guide/extras/render-function.html#v-if)\n\n模板：\n\n```html\n<div>\n  <div v-if=\"ok\">yes</div>\n  <span v-else>no</span>\n</div>\n```\n\n等价于使用如下渲染函数语法：\n\n```js\nh('div', [ok.value ? h('div', 'yes') : h('span', 'no')])\n```\n\nJSX语法：\n\n```jsx\n<div>{ok.value ? <div>yes</div> : <span>no</span>}</div>\n```\n\n\n\n## render函数\n\n> createVNode(),h(),render()三者的联系与区别\n>\n> 干：h() 就是 createVNode()的简称，但是createVNode()函数的功能比h()函数要多且做了性能优化，渲染节点的速度也更快\n>\n>\n> render —— 渲染虚拟 DOM 变成 真实dom\n> @param 参数1 要被渲染的虚拟 DOM，必选\n> @param 参数2 要渲染的位置，必选\n> @description 虚拟 DOM 创建完成后，需要使用 render 函数，才能在页面中渲染\n> render(testDiv, document.body);\n\n用于编程式地创建组件虚拟 DOM 树的函数。\n\n- **类型**\n\n\t```ts\n\tinterface ComponentOptions {\n\t  render?(this: ComponentPublicInstance) => VNodeChild\n\t}\n\t\n\ttype VNodeChild = VNodeChildAtom | VNodeArrayChildren\n\t\n\ttype VNodeChildAtom =\n\t  | VNode\n\t  | string\n\t  | number\n\t  | boolean\n\t  | null\n\t  | undefined\n\t  | void\n\t\n\ttype VNodeArrayChildren = (VNodeArrayChildren | VNodeChildAtom)[]\n\t```\n\n\t\n\n\t1. 先创建虚拟DOM\n\t2. 用render函数将  虚拟DOM变成 真实DOM\n\t3. 插入到body中","slug":"Vue的虚拟DOM","published":1,"updated":"2024-11-17T13:58:10.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxph000h73t3gaaub20j","content":"<h2 id=\"Vue的渲染机制\"><a href=\"#Vue的渲染机制\" class=\"headerlink\" title=\"Vue的渲染机制\"></a>Vue的渲染机制</h2><blockquote>\n<p> Vue 是如何将一份模板转换为真实的 DOM 节点的，又是如何高效地更新这些节点的呢？</p>\n</blockquote>\n<h2 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h2><p>VDOM（其实就是一个对象）是一种编程概念，意为将目标所需的 UI 通过数据结构“虚拟”地表示出来，保存在内存中，然后将真实的 DOM 与之保持同步。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> vnode = &#123;<br>  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;div&#x27;</span>,<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">children</span>: [<br>    <span class=\"hljs-comment\">/* 更多 vnode */</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里所说的 <code>vnode</code> 即一个纯 JavaScript 的对象 (一个“虚拟节点”)，它代表着一个 <code>&lt;div&gt;</code> 元素。它包含我们创建实际元素所需的所有信息。它还包含更多的子节点，这使它成为虚拟 DOM 树的根节点。</p>\n<p>一个运行时渲染器将会遍历整个虚拟 DOM 树，并据此构建真实的 DOM 树。这个过程被称为<strong>挂载</strong> (mount)。</p>\n<p>如果我们有两份虚拟 DOM 树，渲染器将会有比较地遍历它们，找出它们之间的区别，并应用这其中的变化到真实的 DOM 上。这个过程被称为<strong>更新</strong> (patch)，又被称为“比对”(diffing) 或“协调”(reconciliation)。</p>\n<h2 id=\"渲染管线\"><a href=\"#渲染管线\" class=\"headerlink\" title=\"渲染管线\"></a><a href=\"https://cn.vuejs.org/guide/extras/rendering-mechanism.html#render-pipeline\">渲染管线</a></h2><p>从高层面的视角看，Vue 组件挂载时会发生如下几件事：</p>\n<ol>\n<li><strong>编译</strong>：Vue 模板被编译为<strong>渲染函数</strong>（render）：即用来返回虚拟 DOM 树的函数。这一步骤可以通过构建步骤提前完成，也可以通过使用运行时编译器即时完成。</li>\n<li><strong>挂载</strong>：运行时渲染器调用渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。这一步会作为<a href=\"https://cn.vuejs.org/guide/extras/reactivity-in-depth.html\">响应式副作用</a>执行，因此它会追踪其中所用到的所有响应式依赖。</li>\n<li><strong>更新</strong>（diff算法）：当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟 DOM 树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。</li>\n</ol>\n<p><img src=\"https://cn.vuejs.org/assets/render-pipeline.03805016.png\" alt=\"render pipeline\"></p>\n<h2 id=\"创建VNode\"><a href=\"#创建VNode\" class=\"headerlink\" title=\"创建VNode\"></a>创建VNode</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123;h&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> vnode = <span class=\"hljs-title function_\">h</span>(<br>  <span class=\"hljs-string\">&#x27;div&#x27;</span>, <span class=\"hljs-comment\">// type</span><br>  &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span> &#125;, <span class=\"hljs-comment\">// props</span><br>  [<br>    <span class=\"hljs-comment\">/* children */</span><br>  ]<br>)<br></code></pre></td></tr></table></figure>\n\n<p><code>h()</code> 是 <strong>hyperscript</strong> 的简称——意思是“能生成 HTML (超文本标记语言) 的 JavaScript”。这个名字来源于许多虚拟 DOM 实现默认形成的约定。一个更准确的名称应该是 <code>createVnode()</code>，但当你需要多次使用渲染函数时，一个简短的名字会更省力。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 除了类型必填以外，其他的参数都是可选的</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>)<br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span> &#125;)<br><br><span class=\"hljs-comment\">// attribute 和 property 都能在 prop 中书写</span><br><span class=\"hljs-comment\">// Vue 会自动将它们分配到正确的位置</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, &#123; <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">innerHTML</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span> &#125;)<br><br><span class=\"hljs-comment\">// 像 `.prop` 和 `.attr` 这样的的属性修饰符</span><br><span class=\"hljs-comment\">// 可以分别通过 `.` 和 `^` 前缀来添加</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, &#123; <span class=\"hljs-string\">&#x27;.name&#x27;</span>: <span class=\"hljs-string\">&#x27;some-name&#x27;</span>, <span class=\"hljs-string\">&#x27;^width&#x27;</span>: <span class=\"hljs-string\">&#x27;100&#x27;</span> &#125;)<br><br><span class=\"hljs-comment\">// 类与样式可以像在模板中一样</span><br><span class=\"hljs-comment\">// 用数组或对象的形式书写</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, &#123; <span class=\"hljs-attr\">class</span>: [foo, &#123; bar &#125;], <span class=\"hljs-attr\">style</span>: &#123; <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span> &#125; &#125;)<br><br><span class=\"hljs-comment\">// 事件监听器应以 onXxx 的形式书写</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, &#123; <span class=\"hljs-attr\">onClick</span>: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125; &#125;)<br><br><span class=\"hljs-comment\">// children 可以是一个字符串</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span> &#125;, <span class=\"hljs-string\">&#x27;hello&#x27;</span>)<br><br><span class=\"hljs-comment\">// 没有 props 时可以省略不写</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, <span class=\"hljs-string\">&#x27;hello&#x27;</span>)<br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, [<span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;span&#x27;</span>, <span class=\"hljs-string\">&#x27;hello&#x27;</span>)])<br><br><span class=\"hljs-comment\">// children 数组可以同时包含 vnodes 与字符串</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, [<span class=\"hljs-string\">&#x27;hello&#x27;</span>, <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;span&#x27;</span>, <span class=\"hljs-string\">&#x27;hello&#x27;</span>)])<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Vnodes-必须唯一\"><a href=\"#Vnodes-必须唯一\" class=\"headerlink\" title=\"Vnodes 必须唯一\"></a><a href=\"https://cn.vuejs.org/guide/extras/render-function.html#vnodes-must-be-unique\">Vnodes 必须唯一</a></h2><p>组件树中的 vnodes 必须是唯一的。下面是错误示范：</p>\n<p>js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;p&#x27;</span>, <span class=\"hljs-string\">&#x27;hi&#x27;</span>)<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, [<br>    <span class=\"hljs-comment\">// 啊哦，重复的 vnodes 是无效的</span><br>    p,<br>    p<br>  ])<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果你真的非常想在页面上渲染多个重复的元素或者组件，你可以使用一个工厂函数来做这件事。比如下面的这个渲染函数就可以完美渲染出 20 个相同的段落：</p>\n<p>js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">h</span>(<br>    <span class=\"hljs-string\">&#x27;div&#x27;</span>,<br>    <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(&#123; <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">20</span> &#125;).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;p&#x27;</span>, <span class=\"hljs-string\">&#x27;hi&#x27;</span>)<br>    &#125;)<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a><a href=\"https://cn.vuejs.org/guide/extras/render-function.html#v-if\"><code>v-if</code></a></h3><p>模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;ok&quot;</span>&gt;</span>yes<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>no<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>等价于使用如下渲染函数语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, [ok.<span class=\"hljs-property\">value</span> ? <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, <span class=\"hljs-string\">&#x27;yes&#x27;</span>) : <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;span&#x27;</span>, <span class=\"hljs-string\">&#x27;no&#x27;</span>)])<br></code></pre></td></tr></table></figure>\n\n<p>JSX语法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\">&lt;div&gt;&#123;ok.<span class=\"hljs-property\">value</span> ? <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>yes<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span> : <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>no<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"render函数\"><a href=\"#render函数\" class=\"headerlink\" title=\"render函数\"></a>render函数</h2><blockquote>\n<p>createVNode(),h(),render()三者的联系与区别</p>\n<p>干：h() 就是 createVNode()的简称，但是createVNode()函数的功能比h()函数要多且做了性能优化，渲染节点的速度也更快</p>\n<p>render —— 渲染虚拟 DOM 变成 真实dom<br>@param 参数1 要被渲染的虚拟 DOM，必选<br>@param 参数2 要渲染的位置，必选<br>@description 虚拟 DOM 创建完成后，需要使用 render 函数，才能在页面中渲染<br>render(testDiv, document.body);</p>\n</blockquote>\n<p>用于编程式地创建组件虚拟 DOM 树的函数。</p>\n<ul>\n<li><p><strong>类型</strong></p>\n  <figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ComponentOptions</span> &#123;<br>  render?<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">this</span>: <span class=\"hljs-title class_\">ComponentPublicInstance</span></span>) =&gt;</span> <span class=\"hljs-title class_\">VNodeChild</span><br>&#125;<br><br><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">VNodeChild</span> = <span class=\"hljs-title class_\">VNodeChildAtom</span> | <span class=\"hljs-title class_\">VNodeArrayChildren</span><br><br><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">VNodeChildAtom</span> =<br>  | <span class=\"hljs-title class_\">VNode</span><br>  | <span class=\"hljs-built_in\">string</span><br>  | <span class=\"hljs-built_in\">number</span><br>  | <span class=\"hljs-built_in\">boolean</span><br>  | <span class=\"hljs-literal\">null</span><br>  | <span class=\"hljs-literal\">undefined</span><br>  | <span class=\"hljs-built_in\">void</span><br><br><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">VNodeArrayChildren</span> = (<span class=\"hljs-title class_\">VNodeArrayChildren</span> | <span class=\"hljs-title class_\">VNodeChildAtom</span>)[]<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>先创建虚拟DOM</li>\n<li>用render函数将  虚拟DOM变成 真实DOM</li>\n<li>插入到body中</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"wordcount":3306,"excerpt":"","more":"<h2 id=\"Vue的渲染机制\"><a href=\"#Vue的渲染机制\" class=\"headerlink\" title=\"Vue的渲染机制\"></a>Vue的渲染机制</h2><blockquote>\n<p> Vue 是如何将一份模板转换为真实的 DOM 节点的，又是如何高效地更新这些节点的呢？</p>\n</blockquote>\n<h2 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h2><p>VDOM（其实就是一个对象）是一种编程概念，意为将目标所需的 UI 通过数据结构“虚拟”地表示出来，保存在内存中，然后将真实的 DOM 与之保持同步。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> vnode = &#123;<br>  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;div&#x27;</span>,<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">children</span>: [<br>    <span class=\"hljs-comment\">/* 更多 vnode */</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里所说的 <code>vnode</code> 即一个纯 JavaScript 的对象 (一个“虚拟节点”)，它代表着一个 <code>&lt;div&gt;</code> 元素。它包含我们创建实际元素所需的所有信息。它还包含更多的子节点，这使它成为虚拟 DOM 树的根节点。</p>\n<p>一个运行时渲染器将会遍历整个虚拟 DOM 树，并据此构建真实的 DOM 树。这个过程被称为<strong>挂载</strong> (mount)。</p>\n<p>如果我们有两份虚拟 DOM 树，渲染器将会有比较地遍历它们，找出它们之间的区别，并应用这其中的变化到真实的 DOM 上。这个过程被称为<strong>更新</strong> (patch)，又被称为“比对”(diffing) 或“协调”(reconciliation)。</p>\n<h2 id=\"渲染管线\"><a href=\"#渲染管线\" class=\"headerlink\" title=\"渲染管线\"></a><a href=\"https://cn.vuejs.org/guide/extras/rendering-mechanism.html#render-pipeline\">渲染管线</a></h2><p>从高层面的视角看，Vue 组件挂载时会发生如下几件事：</p>\n<ol>\n<li><strong>编译</strong>：Vue 模板被编译为<strong>渲染函数</strong>（render）：即用来返回虚拟 DOM 树的函数。这一步骤可以通过构建步骤提前完成，也可以通过使用运行时编译器即时完成。</li>\n<li><strong>挂载</strong>：运行时渲染器调用渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。这一步会作为<a href=\"https://cn.vuejs.org/guide/extras/reactivity-in-depth.html\">响应式副作用</a>执行，因此它会追踪其中所用到的所有响应式依赖。</li>\n<li><strong>更新</strong>（diff算法）：当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟 DOM 树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。</li>\n</ol>\n<p><img src=\"https://cn.vuejs.org/assets/render-pipeline.03805016.png\" alt=\"render pipeline\"></p>\n<h2 id=\"创建VNode\"><a href=\"#创建VNode\" class=\"headerlink\" title=\"创建VNode\"></a>创建VNode</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123;h&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> vnode = <span class=\"hljs-title function_\">h</span>(<br>  <span class=\"hljs-string\">&#x27;div&#x27;</span>, <span class=\"hljs-comment\">// type</span><br>  &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span> &#125;, <span class=\"hljs-comment\">// props</span><br>  [<br>    <span class=\"hljs-comment\">/* children */</span><br>  ]<br>)<br></code></pre></td></tr></table></figure>\n\n<p><code>h()</code> 是 <strong>hyperscript</strong> 的简称——意思是“能生成 HTML (超文本标记语言) 的 JavaScript”。这个名字来源于许多虚拟 DOM 实现默认形成的约定。一个更准确的名称应该是 <code>createVnode()</code>，但当你需要多次使用渲染函数时，一个简短的名字会更省力。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 除了类型必填以外，其他的参数都是可选的</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>)<br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span> &#125;)<br><br><span class=\"hljs-comment\">// attribute 和 property 都能在 prop 中书写</span><br><span class=\"hljs-comment\">// Vue 会自动将它们分配到正确的位置</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, &#123; <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">innerHTML</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span> &#125;)<br><br><span class=\"hljs-comment\">// 像 `.prop` 和 `.attr` 这样的的属性修饰符</span><br><span class=\"hljs-comment\">// 可以分别通过 `.` 和 `^` 前缀来添加</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, &#123; <span class=\"hljs-string\">&#x27;.name&#x27;</span>: <span class=\"hljs-string\">&#x27;some-name&#x27;</span>, <span class=\"hljs-string\">&#x27;^width&#x27;</span>: <span class=\"hljs-string\">&#x27;100&#x27;</span> &#125;)<br><br><span class=\"hljs-comment\">// 类与样式可以像在模板中一样</span><br><span class=\"hljs-comment\">// 用数组或对象的形式书写</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, &#123; <span class=\"hljs-attr\">class</span>: [foo, &#123; bar &#125;], <span class=\"hljs-attr\">style</span>: &#123; <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span> &#125; &#125;)<br><br><span class=\"hljs-comment\">// 事件监听器应以 onXxx 的形式书写</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, &#123; <span class=\"hljs-attr\">onClick</span>: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125; &#125;)<br><br><span class=\"hljs-comment\">// children 可以是一个字符串</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span> &#125;, <span class=\"hljs-string\">&#x27;hello&#x27;</span>)<br><br><span class=\"hljs-comment\">// 没有 props 时可以省略不写</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, <span class=\"hljs-string\">&#x27;hello&#x27;</span>)<br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, [<span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;span&#x27;</span>, <span class=\"hljs-string\">&#x27;hello&#x27;</span>)])<br><br><span class=\"hljs-comment\">// children 数组可以同时包含 vnodes 与字符串</span><br><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, [<span class=\"hljs-string\">&#x27;hello&#x27;</span>, <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;span&#x27;</span>, <span class=\"hljs-string\">&#x27;hello&#x27;</span>)])<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Vnodes-必须唯一\"><a href=\"#Vnodes-必须唯一\" class=\"headerlink\" title=\"Vnodes 必须唯一\"></a><a href=\"https://cn.vuejs.org/guide/extras/render-function.html#vnodes-must-be-unique\">Vnodes 必须唯一</a></h2><p>组件树中的 vnodes 必须是唯一的。下面是错误示范：</p>\n<p>js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;p&#x27;</span>, <span class=\"hljs-string\">&#x27;hi&#x27;</span>)<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, [<br>    <span class=\"hljs-comment\">// 啊哦，重复的 vnodes 是无效的</span><br>    p,<br>    p<br>  ])<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果你真的非常想在页面上渲染多个重复的元素或者组件，你可以使用一个工厂函数来做这件事。比如下面的这个渲染函数就可以完美渲染出 20 个相同的段落：</p>\n<p>js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">h</span>(<br>    <span class=\"hljs-string\">&#x27;div&#x27;</span>,<br>    <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(&#123; <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">20</span> &#125;).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;p&#x27;</span>, <span class=\"hljs-string\">&#x27;hi&#x27;</span>)<br>    &#125;)<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a><a href=\"https://cn.vuejs.org/guide/extras/render-function.html#v-if\"><code>v-if</code></a></h3><p>模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;ok&quot;</span>&gt;</span>yes<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>no<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>等价于使用如下渲染函数语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, [ok.<span class=\"hljs-property\">value</span> ? <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>, <span class=\"hljs-string\">&#x27;yes&#x27;</span>) : <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-string\">&#x27;span&#x27;</span>, <span class=\"hljs-string\">&#x27;no&#x27;</span>)])<br></code></pre></td></tr></table></figure>\n\n<p>JSX语法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\">&lt;div&gt;&#123;ok.<span class=\"hljs-property\">value</span> ? <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>yes<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span> : <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>no<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"render函数\"><a href=\"#render函数\" class=\"headerlink\" title=\"render函数\"></a>render函数</h2><blockquote>\n<p>createVNode(),h(),render()三者的联系与区别</p>\n<p>干：h() 就是 createVNode()的简称，但是createVNode()函数的功能比h()函数要多且做了性能优化，渲染节点的速度也更快</p>\n<p>render —— 渲染虚拟 DOM 变成 真实dom<br>@param 参数1 要被渲染的虚拟 DOM，必选<br>@param 参数2 要渲染的位置，必选<br>@description 虚拟 DOM 创建完成后，需要使用 render 函数，才能在页面中渲染<br>render(testDiv, document.body);</p>\n</blockquote>\n<p>用于编程式地创建组件虚拟 DOM 树的函数。</p>\n<ul>\n<li><p><strong>类型</strong></p>\n  <figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ComponentOptions</span> &#123;<br>  render?<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">this</span>: <span class=\"hljs-title class_\">ComponentPublicInstance</span></span>) =&gt;</span> <span class=\"hljs-title class_\">VNodeChild</span><br>&#125;<br><br><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">VNodeChild</span> = <span class=\"hljs-title class_\">VNodeChildAtom</span> | <span class=\"hljs-title class_\">VNodeArrayChildren</span><br><br><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">VNodeChildAtom</span> =<br>  | <span class=\"hljs-title class_\">VNode</span><br>  | <span class=\"hljs-built_in\">string</span><br>  | <span class=\"hljs-built_in\">number</span><br>  | <span class=\"hljs-built_in\">boolean</span><br>  | <span class=\"hljs-literal\">null</span><br>  | <span class=\"hljs-literal\">undefined</span><br>  | <span class=\"hljs-built_in\">void</span><br><br><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">VNodeArrayChildren</span> = (<span class=\"hljs-title class_\">VNodeArrayChildren</span> | <span class=\"hljs-title class_\">VNodeChildAtom</span>)[]<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>先创建虚拟DOM</li>\n<li>用render函数将  虚拟DOM变成 真实DOM</li>\n<li>插入到body中</li>\n</ol>\n</li>\n</ul>\n"},{"title":"Vue组件化","date":"2021-05-25T07:03:37.000Z","index_img":"/img/Vue.jpg","banner_img":null,"_content":"## 1.组件注册\n\n#### 1.1 全局组件注册语法\n\n```javascript\nVUe.component(组件名称,{\n    data: 组件数据,\n    template: 组件模板内容\n})\n```\n\n```javascript\n//定义一个名为 button-counter的新组件\nVUe.component('button-counter',{\n    data:function(){\n        return {\n\t\t\tcount: 0\n        }\n    },\n    template: '<button v-on:click=\"count++\">点击了{{count}}次.</button>'\n})\n```\n\n#### 1.2 组件的用法\n\n```html\n<div id=\"app\">\n    <button-counter></button-coumter>\n</div>\n```\n\n#### 1.3 组件的注意事项\n\n1. data必须是一个函数\n\t* 分析函数与普通对象的对比\n2. 组件模板内容必须是单个根元素\n\t* 分析演示实际的效果\n3. 组件模板内容可以是模板字符串\n\t* 模板字符串需要浏览器提供支持（ES6语法）\n\n#### 1.4组件命名方式\n\n* 短横线方式\n\n\t```javascript\n\tVue.component('my-component',{/*.............*/})\n\t```\n\n* 驼峰方式\n\n\t```javascript\n\tVue.component('MyCompoonent',{/*.............*/})\n\t```\n\n\t#### 1.5局部组件注册\n\n\t```javascript\n\tvar ComponentA = {/*.........*/}\n\tvar ComponentB = {/*.........*/}\n\tvar ComponentC = {/*.........*/}\n\t\n\tnew Vue({\n\t\tel: '#app'\n\t    component: {\n\t    'component-a': ComponentA,\n\t    'component-a': ComponentB,\n\t    'component-a': ComponentC,\n\t}\n\t})\n\t```\n\n\t## 2.组件间数据交互\n\n\t#### 2.1 父组件向子组件传值\n\n\t* 组件内部通过props接收传递过来的值\n\n\t```javascript\n\tVue.component('menu-item',{\n\t    props: ['title'],\n\t    template: '<div>{{title}}</div>'\n\t})\n\t```\n\n#### 2.2 父组件通过属性将值传递给子组件\n\n```html\n\t<menu-item title=\"来自父组件的数据\"></menu-item>\n\t<menu-item :title=\"title\"></menu-item>\n    ```\n#### 2.3 props属性名规则\n\n* 在props中使用驼峰形式，模板中需要使用短横线的形式\n* 字符串形式的模板中没有这个限制\n\n#### 2.4 props属性值类型\n\n* 字符串 String\n* 数值 Number\n* 布尔值 Boolean\n* 数组 Array\n* 对象 Object\n\n#### 2.5 子组件向父组件传值\n\n> props 传递数据原则： 单向数据流\n\n**子组件通过自定义事件向父组件传递信息**\n\n```html\n<button v-on:click='$emit(\"enlarge-text\")'>\n    扩大字体\n</button>\n```\n\n**父组件监听子组件的事件**\n\n```html\n<menu-item v-on:enlarge-text='fontSize += 0.1'></menu-item>\n```\n\n## 3.组件插槽\n\n#### 3.1 组件插槽的作用\n\n* 父组件向子组件传递内容\n\n**插槽位置**\n\n```javascript\nVue.component('alert-box',{\n\ttemplate: `\n\t<div class=\"demon-alert-box\">\n\t<strong>Error</strong>\n\t<slot></slot>\n`\n})\n```\n\n**插槽内容**\n\n```javascript\n<alert-box>someting is happen</alert-box>\n```\n\n#### 3.2 作用域插槽\n\n* 应用场景： 父组件对子组件的内容进行加工和处理","source":"_posts/Vue组件化.md","raw":"---\ntitle: Vue组件化\ndate: 2021-05-25 15:03:37\ntags: Vue\ncategories: 前端\nindex_img: /img/Vue.jpg\nbanner_img: \n---\n## 1.组件注册\n\n#### 1.1 全局组件注册语法\n\n```javascript\nVUe.component(组件名称,{\n    data: 组件数据,\n    template: 组件模板内容\n})\n```\n\n```javascript\n//定义一个名为 button-counter的新组件\nVUe.component('button-counter',{\n    data:function(){\n        return {\n\t\t\tcount: 0\n        }\n    },\n    template: '<button v-on:click=\"count++\">点击了{{count}}次.</button>'\n})\n```\n\n#### 1.2 组件的用法\n\n```html\n<div id=\"app\">\n    <button-counter></button-coumter>\n</div>\n```\n\n#### 1.3 组件的注意事项\n\n1. data必须是一个函数\n\t* 分析函数与普通对象的对比\n2. 组件模板内容必须是单个根元素\n\t* 分析演示实际的效果\n3. 组件模板内容可以是模板字符串\n\t* 模板字符串需要浏览器提供支持（ES6语法）\n\n#### 1.4组件命名方式\n\n* 短横线方式\n\n\t```javascript\n\tVue.component('my-component',{/*.............*/})\n\t```\n\n* 驼峰方式\n\n\t```javascript\n\tVue.component('MyCompoonent',{/*.............*/})\n\t```\n\n\t#### 1.5局部组件注册\n\n\t```javascript\n\tvar ComponentA = {/*.........*/}\n\tvar ComponentB = {/*.........*/}\n\tvar ComponentC = {/*.........*/}\n\t\n\tnew Vue({\n\t\tel: '#app'\n\t    component: {\n\t    'component-a': ComponentA,\n\t    'component-a': ComponentB,\n\t    'component-a': ComponentC,\n\t}\n\t})\n\t```\n\n\t## 2.组件间数据交互\n\n\t#### 2.1 父组件向子组件传值\n\n\t* 组件内部通过props接收传递过来的值\n\n\t```javascript\n\tVue.component('menu-item',{\n\t    props: ['title'],\n\t    template: '<div>{{title}}</div>'\n\t})\n\t```\n\n#### 2.2 父组件通过属性将值传递给子组件\n\n```html\n\t<menu-item title=\"来自父组件的数据\"></menu-item>\n\t<menu-item :title=\"title\"></menu-item>\n    ```\n#### 2.3 props属性名规则\n\n* 在props中使用驼峰形式，模板中需要使用短横线的形式\n* 字符串形式的模板中没有这个限制\n\n#### 2.4 props属性值类型\n\n* 字符串 String\n* 数值 Number\n* 布尔值 Boolean\n* 数组 Array\n* 对象 Object\n\n#### 2.5 子组件向父组件传值\n\n> props 传递数据原则： 单向数据流\n\n**子组件通过自定义事件向父组件传递信息**\n\n```html\n<button v-on:click='$emit(\"enlarge-text\")'>\n    扩大字体\n</button>\n```\n\n**父组件监听子组件的事件**\n\n```html\n<menu-item v-on:enlarge-text='fontSize += 0.1'></menu-item>\n```\n\n## 3.组件插槽\n\n#### 3.1 组件插槽的作用\n\n* 父组件向子组件传递内容\n\n**插槽位置**\n\n```javascript\nVue.component('alert-box',{\n\ttemplate: `\n\t<div class=\"demon-alert-box\">\n\t<strong>Error</strong>\n\t<slot></slot>\n`\n})\n```\n\n**插槽内容**\n\n```javascript\n<alert-box>someting is happen</alert-box>\n```\n\n#### 3.2 作用域插槽\n\n* 应用场景： 父组件对子组件的内容进行加工和处理","slug":"Vue组件化","published":1,"updated":"2024-11-17T13:58:10.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxph000k73t30gdjgd0u","content":"<h2 id=\"1-组件注册\"><a href=\"#1-组件注册\" class=\"headerlink\" title=\"1.组件注册\"></a>1.组件注册</h2><h4 id=\"1-1-全局组件注册语法\"><a href=\"#1-1-全局组件注册语法\" class=\"headerlink\" title=\"1.1 全局组件注册语法\"></a>1.1 全局组件注册语法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">VUe</span>.<span class=\"hljs-title function_\">component</span>(组件名称,&#123;<br>    <span class=\"hljs-attr\">data</span>: 组件数据,<br>    <span class=\"hljs-attr\">template</span>: 组件模板内容<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//定义一个名为 button-counter的新组件</span><br><span class=\"hljs-title class_\">VUe</span>.<span class=\"hljs-title function_\">component</span>(<span class=\"hljs-string\">&#x27;button-counter&#x27;</span>,&#123;<br>    <span class=\"hljs-attr\">data</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;<br>\t\t\t<span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span><br>        &#125;<br>    &#125;,<br>    <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;点击了&#123;&#123;count&#125;&#125;次.&lt;/button&gt;&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-组件的用法\"><a href=\"#1-2-组件的用法\" class=\"headerlink\" title=\"1.2 组件的用法\"></a>1.2 组件的用法</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button-counter</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button-coumter</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-组件的注意事项\"><a href=\"#1-3-组件的注意事项\" class=\"headerlink\" title=\"1.3 组件的注意事项\"></a>1.3 组件的注意事项</h4><ol>\n<li>data必须是一个函数<ul>\n<li>分析函数与普通对象的对比</li>\n</ul>\n</li>\n<li>组件模板内容必须是单个根元素<ul>\n<li>分析演示实际的效果</li>\n</ul>\n</li>\n<li>组件模板内容可以是模板字符串<ul>\n<li>模板字符串需要浏览器提供支持（ES6语法）</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-4组件命名方式\"><a href=\"#1-4组件命名方式\" class=\"headerlink\" title=\"1.4组件命名方式\"></a>1.4组件命名方式</h4><ul>\n<li><p>短横线方式</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">component</span>(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>,&#123;<span class=\"hljs-comment\">/*.............*/</span>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>驼峰方式</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">component</span>(<span class=\"hljs-string\">&#x27;MyCompoonent&#x27;</span>,&#123;<span class=\"hljs-comment\">/*.............*/</span>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-5局部组件注册\"><a href=\"#1-5局部组件注册\" class=\"headerlink\" title=\"1.5局部组件注册\"></a>1.5局部组件注册</h4>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">ComponentA</span> = &#123;<span class=\"hljs-comment\">/*.........*/</span>&#125;<br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">ComponentB</span> = &#123;<span class=\"hljs-comment\">/*.........*/</span>&#125;<br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">ComponentC</span> = &#123;<span class=\"hljs-comment\">/*.........*/</span>&#125;<br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vue</span>(&#123;<br>\t<span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">&#x27;#app&#x27;</span><br>    <span class=\"hljs-attr\">component</span>: &#123;<br>    <span class=\"hljs-string\">&#x27;component-a&#x27;</span>: <span class=\"hljs-title class_\">ComponentA</span>,<br>    <span class=\"hljs-string\">&#x27;component-a&#x27;</span>: <span class=\"hljs-title class_\">ComponentB</span>,<br>    <span class=\"hljs-string\">&#x27;component-a&#x27;</span>: <span class=\"hljs-title class_\">ComponentC</span>,<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-组件间数据交互\"><a href=\"#2-组件间数据交互\" class=\"headerlink\" title=\"2.组件间数据交互\"></a>2.组件间数据交互</h2><h4 id=\"2-1-父组件向子组件传值\"><a href=\"#2-1-父组件向子组件传值\" class=\"headerlink\" title=\"2.1 父组件向子组件传值\"></a>2.1 父组件向子组件传值</h4><ul>\n<li>组件内部通过props接收传递过来的值</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">component</span>(<span class=\"hljs-string\">&#x27;menu-item&#x27;</span>,&#123;<br>    <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;title&#x27;</span>],<br>    <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"2-2-父组件通过属性将值传递给子组件\"><a href=\"#2-2-父组件通过属性将值传递给子组件\" class=\"headerlink\" title=\"2.2 父组件通过属性将值传递给子组件\"></a>2.2 父组件通过属性将值传递给子组件</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">menu-item</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;来自父组件的数据&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">menu-item</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">menu-item</span> <span class=\"hljs-attr\">:title</span>=<span class=\"hljs-string\">&quot;title&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">menu-item</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"2-3-props属性名规则\"><a href=\"#2-3-props属性名规则\" class=\"headerlink\" title=\"2.3 props属性名规则\"></a>2.3 props属性名规则</h4><ul>\n<li>在props中使用驼峰形式，模板中需要使用短横线的形式</li>\n<li>字符串形式的模板中没有这个限制</li>\n</ul>\n<h4 id=\"2-4-props属性值类型\"><a href=\"#2-4-props属性值类型\" class=\"headerlink\" title=\"2.4 props属性值类型\"></a>2.4 props属性值类型</h4><ul>\n<li>字符串 String</li>\n<li>数值 Number</li>\n<li>布尔值 Boolean</li>\n<li>数组 Array</li>\n<li>对象 Object</li>\n</ul>\n<h4 id=\"2-5-子组件向父组件传值\"><a href=\"#2-5-子组件向父组件传值\" class=\"headerlink\" title=\"2.5 子组件向父组件传值\"></a>2.5 子组件向父组件传值</h4><blockquote>\n<p>props 传递数据原则： 单向数据流</p>\n</blockquote>\n<p><strong>子组件通过自定义事件向父组件传递信息</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">&#x27;$emit(&quot;enlarge-text&quot;)&#x27;</span>&gt;</span><br>    扩大字体<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>父组件监听子组件的事件</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">menu-item</span> <span class=\"hljs-attr\">v-on:enlarge-text</span>=<span class=\"hljs-string\">&#x27;fontSize += 0.1&#x27;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">menu-item</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-组件插槽\"><a href=\"#3-组件插槽\" class=\"headerlink\" title=\"3.组件插槽\"></a>3.组件插槽</h2><h4 id=\"3-1-组件插槽的作用\"><a href=\"#3-1-组件插槽的作用\" class=\"headerlink\" title=\"3.1 组件插槽的作用\"></a>3.1 组件插槽的作用</h4><ul>\n<li>父组件向子组件传递内容</li>\n</ul>\n<p><strong>插槽位置</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">component</span>(<span class=\"hljs-string\">&#x27;alert-box&#x27;</span>,&#123;<br>\t<span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">\t&lt;div class=&quot;demon-alert-box&quot;&gt;</span><br><span class=\"hljs-string\">\t&lt;strong&gt;Error&lt;/strong&gt;</span><br><span class=\"hljs-string\">\t&lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"hljs-string\">`</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p><strong>插槽内容</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;alert-box&gt;someting is happen&lt;/alert-box&gt;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-作用域插槽\"><a href=\"#3-2-作用域插槽\" class=\"headerlink\" title=\"3.2 作用域插槽\"></a>3.2 作用域插槽</h4><ul>\n<li>应用场景： 父组件对子组件的内容进行加工和处理</li>\n</ul>\n","site":{"data":{}},"wordcount":1943,"excerpt":"","more":"<h2 id=\"1-组件注册\"><a href=\"#1-组件注册\" class=\"headerlink\" title=\"1.组件注册\"></a>1.组件注册</h2><h4 id=\"1-1-全局组件注册语法\"><a href=\"#1-1-全局组件注册语法\" class=\"headerlink\" title=\"1.1 全局组件注册语法\"></a>1.1 全局组件注册语法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">VUe</span>.<span class=\"hljs-title function_\">component</span>(组件名称,&#123;<br>    <span class=\"hljs-attr\">data</span>: 组件数据,<br>    <span class=\"hljs-attr\">template</span>: 组件模板内容<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//定义一个名为 button-counter的新组件</span><br><span class=\"hljs-title class_\">VUe</span>.<span class=\"hljs-title function_\">component</span>(<span class=\"hljs-string\">&#x27;button-counter&#x27;</span>,&#123;<br>    <span class=\"hljs-attr\">data</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;<br>\t\t\t<span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span><br>        &#125;<br>    &#125;,<br>    <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;点击了&#123;&#123;count&#125;&#125;次.&lt;/button&gt;&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-组件的用法\"><a href=\"#1-2-组件的用法\" class=\"headerlink\" title=\"1.2 组件的用法\"></a>1.2 组件的用法</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button-counter</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button-coumter</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-组件的注意事项\"><a href=\"#1-3-组件的注意事项\" class=\"headerlink\" title=\"1.3 组件的注意事项\"></a>1.3 组件的注意事项</h4><ol>\n<li>data必须是一个函数<ul>\n<li>分析函数与普通对象的对比</li>\n</ul>\n</li>\n<li>组件模板内容必须是单个根元素<ul>\n<li>分析演示实际的效果</li>\n</ul>\n</li>\n<li>组件模板内容可以是模板字符串<ul>\n<li>模板字符串需要浏览器提供支持（ES6语法）</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-4组件命名方式\"><a href=\"#1-4组件命名方式\" class=\"headerlink\" title=\"1.4组件命名方式\"></a>1.4组件命名方式</h4><ul>\n<li><p>短横线方式</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">component</span>(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>,&#123;<span class=\"hljs-comment\">/*.............*/</span>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>驼峰方式</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">component</span>(<span class=\"hljs-string\">&#x27;MyCompoonent&#x27;</span>,&#123;<span class=\"hljs-comment\">/*.............*/</span>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-5局部组件注册\"><a href=\"#1-5局部组件注册\" class=\"headerlink\" title=\"1.5局部组件注册\"></a>1.5局部组件注册</h4>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">ComponentA</span> = &#123;<span class=\"hljs-comment\">/*.........*/</span>&#125;<br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">ComponentB</span> = &#123;<span class=\"hljs-comment\">/*.........*/</span>&#125;<br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">ComponentC</span> = &#123;<span class=\"hljs-comment\">/*.........*/</span>&#125;<br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vue</span>(&#123;<br>\t<span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">&#x27;#app&#x27;</span><br>    <span class=\"hljs-attr\">component</span>: &#123;<br>    <span class=\"hljs-string\">&#x27;component-a&#x27;</span>: <span class=\"hljs-title class_\">ComponentA</span>,<br>    <span class=\"hljs-string\">&#x27;component-a&#x27;</span>: <span class=\"hljs-title class_\">ComponentB</span>,<br>    <span class=\"hljs-string\">&#x27;component-a&#x27;</span>: <span class=\"hljs-title class_\">ComponentC</span>,<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-组件间数据交互\"><a href=\"#2-组件间数据交互\" class=\"headerlink\" title=\"2.组件间数据交互\"></a>2.组件间数据交互</h2><h4 id=\"2-1-父组件向子组件传值\"><a href=\"#2-1-父组件向子组件传值\" class=\"headerlink\" title=\"2.1 父组件向子组件传值\"></a>2.1 父组件向子组件传值</h4><ul>\n<li>组件内部通过props接收传递过来的值</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">component</span>(<span class=\"hljs-string\">&#x27;menu-item&#x27;</span>,&#123;<br>    <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;title&#x27;</span>],<br>    <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"2-2-父组件通过属性将值传递给子组件\"><a href=\"#2-2-父组件通过属性将值传递给子组件\" class=\"headerlink\" title=\"2.2 父组件通过属性将值传递给子组件\"></a>2.2 父组件通过属性将值传递给子组件</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">menu-item</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;来自父组件的数据&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">menu-item</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">menu-item</span> <span class=\"hljs-attr\">:title</span>=<span class=\"hljs-string\">&quot;title&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">menu-item</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"2-3-props属性名规则\"><a href=\"#2-3-props属性名规则\" class=\"headerlink\" title=\"2.3 props属性名规则\"></a>2.3 props属性名规则</h4><ul>\n<li>在props中使用驼峰形式，模板中需要使用短横线的形式</li>\n<li>字符串形式的模板中没有这个限制</li>\n</ul>\n<h4 id=\"2-4-props属性值类型\"><a href=\"#2-4-props属性值类型\" class=\"headerlink\" title=\"2.4 props属性值类型\"></a>2.4 props属性值类型</h4><ul>\n<li>字符串 String</li>\n<li>数值 Number</li>\n<li>布尔值 Boolean</li>\n<li>数组 Array</li>\n<li>对象 Object</li>\n</ul>\n<h4 id=\"2-5-子组件向父组件传值\"><a href=\"#2-5-子组件向父组件传值\" class=\"headerlink\" title=\"2.5 子组件向父组件传值\"></a>2.5 子组件向父组件传值</h4><blockquote>\n<p>props 传递数据原则： 单向数据流</p>\n</blockquote>\n<p><strong>子组件通过自定义事件向父组件传递信息</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">&#x27;$emit(&quot;enlarge-text&quot;)&#x27;</span>&gt;</span><br>    扩大字体<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>父组件监听子组件的事件</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">menu-item</span> <span class=\"hljs-attr\">v-on:enlarge-text</span>=<span class=\"hljs-string\">&#x27;fontSize += 0.1&#x27;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">menu-item</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-组件插槽\"><a href=\"#3-组件插槽\" class=\"headerlink\" title=\"3.组件插槽\"></a>3.组件插槽</h2><h4 id=\"3-1-组件插槽的作用\"><a href=\"#3-1-组件插槽的作用\" class=\"headerlink\" title=\"3.1 组件插槽的作用\"></a>3.1 组件插槽的作用</h4><ul>\n<li>父组件向子组件传递内容</li>\n</ul>\n<p><strong>插槽位置</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">component</span>(<span class=\"hljs-string\">&#x27;alert-box&#x27;</span>,&#123;<br>\t<span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">\t&lt;div class=&quot;demon-alert-box&quot;&gt;</span><br><span class=\"hljs-string\">\t&lt;strong&gt;Error&lt;/strong&gt;</span><br><span class=\"hljs-string\">\t&lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"hljs-string\">`</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p><strong>插槽内容</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;alert-box&gt;someting is happen&lt;/alert-box&gt;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-作用域插槽\"><a href=\"#3-2-作用域插槽\" class=\"headerlink\" title=\"3.2 作用域插槽\"></a>3.2 作用域插槽</h4><ul>\n<li>应用场景： 父组件对子组件的内容进行加工和处理</li>\n</ul>\n"},{"title":"c语言求阶乘的两种办法","date":"2020-08-02T02:26:13.000Z","index_img":"/img/ctext.jpg","banner_img":"/img/d.jpg","_content":"## 循环法\n循环法还是比较简单的，就先输入你要求的阶乘n，然后一直自减\n\n```c\n#include <stdio.h>\nmain()\n{\n\tlong n,sum=1;//10 以上的阶乘就比较大了\n\tint i;\n\tprintf(\"请输入你要求的阶乘：\");\n\tscanf(\"%d\",&n);//先输入要求的数\n\tfor(i=n;i>0;i--)//乘到1为止\n\t{\n\t\tsum*=i;\n\t}\n\tprintf(\"%d  !=  %d\",n,sum);\n\treturn 0;\n\t}\n```\n完成后的结果是这样子的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200203133655288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n## 递归法\n编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。递归函数不能定义为内联函数。\n就像我和你说：“从前有座山，山上有座庙，庙里有个小和尚，老和尚和小和尚说：从前有座山，山上有座庙，庙里有个小和尚，老和尚和小和尚说：巴拉巴拉的”\n\n```c\n#include<stdio.h>\nint fun(int n)\n{\nif(n==1||n==0) return 1;//如果参数是0或者1返回1\nreturn n*fun(n-1);//否则返回n和下次递归的积\n}\n\nint main()\n{\nint n;\nscanf(\"%d\",&n);\nprintf(\"%d\\n\",fun(n));\nreturn 0;\n}\n\n```\n完成的结果就是这样子的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200203134553365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n\n***使用递归要注意的就是关于结束的条件，不然程序会崩溃的***\n","source":"_posts/c.md","raw":"---\ntitle: c语言求阶乘的两种办法\ndate: 2020-08-2 10:26:13\ntags: c语言\ncategories: 技术\nindex_img: /img/ctext.jpg\nbanner_img: /img/d.jpg\n---\n## 循环法\n循环法还是比较简单的，就先输入你要求的阶乘n，然后一直自减\n\n```c\n#include <stdio.h>\nmain()\n{\n\tlong n,sum=1;//10 以上的阶乘就比较大了\n\tint i;\n\tprintf(\"请输入你要求的阶乘：\");\n\tscanf(\"%d\",&n);//先输入要求的数\n\tfor(i=n;i>0;i--)//乘到1为止\n\t{\n\t\tsum*=i;\n\t}\n\tprintf(\"%d  !=  %d\",n,sum);\n\treturn 0;\n\t}\n```\n完成后的结果是这样子的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200203133655288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n## 递归法\n编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。递归函数不能定义为内联函数。\n就像我和你说：“从前有座山，山上有座庙，庙里有个小和尚，老和尚和小和尚说：从前有座山，山上有座庙，庙里有个小和尚，老和尚和小和尚说：巴拉巴拉的”\n\n```c\n#include<stdio.h>\nint fun(int n)\n{\nif(n==1||n==0) return 1;//如果参数是0或者1返回1\nreturn n*fun(n-1);//否则返回n和下次递归的积\n}\n\nint main()\n{\nint n;\nscanf(\"%d\",&n);\nprintf(\"%d\\n\",fun(n));\nreturn 0;\n}\n\n```\n完成的结果就是这样子的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200203134553365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n\n***使用递归要注意的就是关于结束的条件，不然程序会崩溃的***\n","slug":"c","published":1,"updated":"2024-11-17T13:58:10.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpi000n73t3gocw4fi5","content":"<h2 id=\"循环法\"><a href=\"#循环法\" class=\"headerlink\" title=\"循环法\"></a>循环法</h2><p>循环法还是比较简单的，就先输入你要求的阶乘n，然后一直自减</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br>main()<br>&#123;<br>\t<span class=\"hljs-type\">long</span> n,sum=<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//10 以上的阶乘就比较大了</span><br>\t<span class=\"hljs-type\">int</span> i;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;请输入你要求的阶乘：&quot;</span>);<br>\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>,&amp;n);<span class=\"hljs-comment\">//先输入要求的数</span><br>\t<span class=\"hljs-keyword\">for</span>(i=n;i&gt;<span class=\"hljs-number\">0</span>;i--)<span class=\"hljs-comment\">//乘到1为止</span><br>\t&#123;<br>\t\tsum*=i;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d  !=  %d&quot;</span>,n,sum);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t&#125;<br></code></pre></td></tr></table></figure>\n<p>完成后的结果是这样子的<br><img src=\"https://img-blog.csdnimg.cn/20200203133655288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"递归法\"><a href=\"#递归法\" class=\"headerlink\" title=\"递归法\"></a>递归法</h2><p>编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。递归函数不能定义为内联函数。<br>就像我和你说：“从前有座山，山上有座庙，庙里有个小和尚，老和尚和小和尚说：从前有座山，山上有座庙，庙里有个小和尚，老和尚和小和尚说：巴拉巴拉的”</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span><br>&#123;<br><span class=\"hljs-keyword\">if</span>(n==<span class=\"hljs-number\">1</span>||n==<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//如果参数是0或者1返回1</span><br><span class=\"hljs-keyword\">return</span> n*fun(n<span class=\"hljs-number\">-1</span>);<span class=\"hljs-comment\">//否则返回n和下次递归的积</span><br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>&#123;<br><span class=\"hljs-type\">int</span> n;<br><span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>,&amp;n);<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>,fun(n));<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>完成的结果就是这样子的<br><img src=\"https://img-blog.csdnimg.cn/20200203134553365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p><em><strong>使用递归要注意的就是关于结束的条件，不然程序会崩溃的</strong></em></p>\n","site":{"data":{}},"wordcount":690,"excerpt":"","more":"<h2 id=\"循环法\"><a href=\"#循环法\" class=\"headerlink\" title=\"循环法\"></a>循环法</h2><p>循环法还是比较简单的，就先输入你要求的阶乘n，然后一直自减</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br>main()<br>&#123;<br>\t<span class=\"hljs-type\">long</span> n,sum=<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//10 以上的阶乘就比较大了</span><br>\t<span class=\"hljs-type\">int</span> i;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;请输入你要求的阶乘：&quot;</span>);<br>\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>,&amp;n);<span class=\"hljs-comment\">//先输入要求的数</span><br>\t<span class=\"hljs-keyword\">for</span>(i=n;i&gt;<span class=\"hljs-number\">0</span>;i--)<span class=\"hljs-comment\">//乘到1为止</span><br>\t&#123;<br>\t\tsum*=i;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d  !=  %d&quot;</span>,n,sum);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t&#125;<br></code></pre></td></tr></table></figure>\n<p>完成后的结果是这样子的<br><img src=\"https://img-blog.csdnimg.cn/20200203133655288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"递归法\"><a href=\"#递归法\" class=\"headerlink\" title=\"递归法\"></a>递归法</h2><p>编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。递归函数不能定义为内联函数。<br>就像我和你说：“从前有座山，山上有座庙，庙里有个小和尚，老和尚和小和尚说：从前有座山，山上有座庙，庙里有个小和尚，老和尚和小和尚说：巴拉巴拉的”</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span><br>&#123;<br><span class=\"hljs-keyword\">if</span>(n==<span class=\"hljs-number\">1</span>||n==<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//如果参数是0或者1返回1</span><br><span class=\"hljs-keyword\">return</span> n*fun(n<span class=\"hljs-number\">-1</span>);<span class=\"hljs-comment\">//否则返回n和下次递归的积</span><br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>&#123;<br><span class=\"hljs-type\">int</span> n;<br><span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>,&amp;n);<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>,fun(n));<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>完成的结果就是这样子的<br><img src=\"https://img-blog.csdnimg.cn/20200203134553365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p><em><strong>使用递归要注意的就是关于结束的条件，不然程序会崩溃的</strong></em></p>\n"},{"title":"小艾的CSS笔记下","date":"2020-08-27T02:26:13.000Z","index_img":"/img/top6.jpg","banner_img":"/img/3.jpg","_content":"##  三种布局方式：\n- 标准流\n- 浮动\n- 定位\n\n###  浮动\n浮动可以改变元素默认的排列方式，最典型的应用就是可以让多个块级元素一行内排列，**多个块级元素纵向排列找标准流。多个块级元素横向排列找浮动**\n选择器 {float：属性值}\n属性值：\n- none 不浮动\n- left 左浮动\n- right 右浮动\n脱离标准普通流的控制移动到指定位置（俗称脱标）\n浮动的盒子不再保留原先的位置\n\n### 定位\n将盒子定在某一个位置，所以定位也在摆盒子\n定位=定位模式+边偏移\n**定位模式**\n属性position 值：\nstatic 静态定位          relative 相对定位  absolute绝对定位     fixed 固定定位\n**边偏移**\n边偏移就是定位盒子移动到最终位置  ，有top  right left bottom\n\n\n**静态定位**\n元素默认的定位方式，为定位的意思，没有边偏移\n选择器 {position ：static}\n\n**相对定位**\n相对定位就是在元素移动位置的时候，是相对于他原来的位置来说的\n选择器 {position：relative}\n原来的位置还是保留的，下面的盒子不会升上去\n\n**绝对定位**\n绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的\n选择器 {position ：absolute}\n1.如果没有祖元素或者祖元素没有定位，则以浏览器为标准\n2.如果父元素有定位，则以父级为参考点移动位置\n3.不在占有原来的位置\n（ 子绝父相）\n\n**固定定位**\n固定定位可以固定于浏览器可视区域的位置，页面在滚动的时候位置不会改变\n1.以浏览器的可视窗口为参考页面\n2.和父元素没有关系\n\n**粘性定位**\n粘性定位可以被认为是相对定位和固定定位的混合，sticky粘性的\n选择器 {position ：sticky；top：10px}\n\n1.以浏览器的可视窗口为参考点\n2.必须添加 top right left bottom其中一个\n3.占有原来的位置\n\n定位的叠放次序：\nz-index(z轴）\n选择器{z-index:1;}\n数值越打盒子越靠上\n只有定位的盒子才有的属性\n\n\n绝对定位的盒子居中：\n1.left走  50% 父容器的一半\n2.margin  负值  往左走一半  margin-left：\n\n\n浮动的元素只会压住下面的盒子不会压住下面的文字\n绝对定位或者固定定位会压住下面的所有东西\n\n\n- 鼠标样式\n```\nli {cursor:pointer}\n```\ndefault  默认的\npointer  小手\nmove     移动\ntext     文字\nnot-allowed  禁止的\n\n- 轮廓线\noutline  ：none\n- 文本域防止拖拉 \ntextarea {resize ：none}\n\n- 垂直对齐\nvertical-align： bottom  /middle/top/  baseline（默认的）\n\n- 溢出文字用省略号代替\n1.单行文本溢出\n先强制一行内显示\nwhite-space：normal； 如果文字显示不开，自动换行   nowrap 如果显示不开，强制一行显示\n超出部分隐藏起来\noverflow：hidden；\n超出部分用省略号代替\ntext-overflow：ellipsis；\n2.多行文本溢出用省略号代替\noverflow：hidden；\ntext-overflow：ellipsis；\n弹性伸缩盒子模型显示\ndisplay：-webkit-box；\n限制在一个块元素显示的文本的行数\n-webkit-line-clamp：2\n设置或检索伸缩盒子对象的子元素的排列方式\n-webkit-box-orient：vertical；\n","source":"_posts/css.md","raw":"---\ntitle: 小艾的CSS笔记下\ndate: 2020-08-27 10:26:13\ntags: css\ncategories: 前端\nindex_img: /img/top6.jpg\nbanner_img: /img/3.jpg\n---\n##  三种布局方式：\n- 标准流\n- 浮动\n- 定位\n\n###  浮动\n浮动可以改变元素默认的排列方式，最典型的应用就是可以让多个块级元素一行内排列，**多个块级元素纵向排列找标准流。多个块级元素横向排列找浮动**\n选择器 {float：属性值}\n属性值：\n- none 不浮动\n- left 左浮动\n- right 右浮动\n脱离标准普通流的控制移动到指定位置（俗称脱标）\n浮动的盒子不再保留原先的位置\n\n### 定位\n将盒子定在某一个位置，所以定位也在摆盒子\n定位=定位模式+边偏移\n**定位模式**\n属性position 值：\nstatic 静态定位          relative 相对定位  absolute绝对定位     fixed 固定定位\n**边偏移**\n边偏移就是定位盒子移动到最终位置  ，有top  right left bottom\n\n\n**静态定位**\n元素默认的定位方式，为定位的意思，没有边偏移\n选择器 {position ：static}\n\n**相对定位**\n相对定位就是在元素移动位置的时候，是相对于他原来的位置来说的\n选择器 {position：relative}\n原来的位置还是保留的，下面的盒子不会升上去\n\n**绝对定位**\n绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的\n选择器 {position ：absolute}\n1.如果没有祖元素或者祖元素没有定位，则以浏览器为标准\n2.如果父元素有定位，则以父级为参考点移动位置\n3.不在占有原来的位置\n（ 子绝父相）\n\n**固定定位**\n固定定位可以固定于浏览器可视区域的位置，页面在滚动的时候位置不会改变\n1.以浏览器的可视窗口为参考页面\n2.和父元素没有关系\n\n**粘性定位**\n粘性定位可以被认为是相对定位和固定定位的混合，sticky粘性的\n选择器 {position ：sticky；top：10px}\n\n1.以浏览器的可视窗口为参考点\n2.必须添加 top right left bottom其中一个\n3.占有原来的位置\n\n定位的叠放次序：\nz-index(z轴）\n选择器{z-index:1;}\n数值越打盒子越靠上\n只有定位的盒子才有的属性\n\n\n绝对定位的盒子居中：\n1.left走  50% 父容器的一半\n2.margin  负值  往左走一半  margin-left：\n\n\n浮动的元素只会压住下面的盒子不会压住下面的文字\n绝对定位或者固定定位会压住下面的所有东西\n\n\n- 鼠标样式\n```\nli {cursor:pointer}\n```\ndefault  默认的\npointer  小手\nmove     移动\ntext     文字\nnot-allowed  禁止的\n\n- 轮廓线\noutline  ：none\n- 文本域防止拖拉 \ntextarea {resize ：none}\n\n- 垂直对齐\nvertical-align： bottom  /middle/top/  baseline（默认的）\n\n- 溢出文字用省略号代替\n1.单行文本溢出\n先强制一行内显示\nwhite-space：normal； 如果文字显示不开，自动换行   nowrap 如果显示不开，强制一行显示\n超出部分隐藏起来\noverflow：hidden；\n超出部分用省略号代替\ntext-overflow：ellipsis；\n2.多行文本溢出用省略号代替\noverflow：hidden；\ntext-overflow：ellipsis；\n弹性伸缩盒子模型显示\ndisplay：-webkit-box；\n限制在一个块元素显示的文本的行数\n-webkit-line-clamp：2\n设置或检索伸缩盒子对象的子元素的排列方式\n-webkit-box-orient：vertical；\n","slug":"css","published":1,"updated":"2024-11-17T13:58:10.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpi000q73t3fpqc24b0","content":"<h2 id=\"三种布局方式：\"><a href=\"#三种布局方式：\" class=\"headerlink\" title=\"三种布局方式：\"></a>三种布局方式：</h2><ul>\n<li>标准流</li>\n<li>浮动</li>\n<li>定位</li>\n</ul>\n<h3 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h3><p>浮动可以改变元素默认的排列方式，最典型的应用就是可以让多个块级元素一行内排列，<strong>多个块级元素纵向排列找标准流。多个块级元素横向排列找浮动</strong><br>选择器 {float：属性值}<br>属性值：</p>\n<ul>\n<li>none 不浮动</li>\n<li>left 左浮动</li>\n<li>right 右浮动<br>脱离标准普通流的控制移动到指定位置（俗称脱标）<br>浮动的盒子不再保留原先的位置</li>\n</ul>\n<h3 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h3><p>将盒子定在某一个位置，所以定位也在摆盒子<br>定位=定位模式+边偏移<br><strong>定位模式</strong><br>属性position 值：<br>static 静态定位          relative 相对定位  absolute绝对定位     fixed 固定定位<br><strong>边偏移</strong><br>边偏移就是定位盒子移动到最终位置  ，有top  right left bottom</p>\n<p><strong>静态定位</strong><br>元素默认的定位方式，为定位的意思，没有边偏移<br>选择器 {position ：static}</p>\n<p><strong>相对定位</strong><br>相对定位就是在元素移动位置的时候，是相对于他原来的位置来说的<br>选择器 {position：relative}<br>原来的位置还是保留的，下面的盒子不会升上去</p>\n<p><strong>绝对定位</strong><br>绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的<br>选择器 {position ：absolute}<br>1.如果没有祖元素或者祖元素没有定位，则以浏览器为标准<br>2.如果父元素有定位，则以父级为参考点移动位置<br>3.不在占有原来的位置<br>（ 子绝父相）</p>\n<p><strong>固定定位</strong><br>固定定位可以固定于浏览器可视区域的位置，页面在滚动的时候位置不会改变<br>1.以浏览器的可视窗口为参考页面<br>2.和父元素没有关系</p>\n<p><strong>粘性定位</strong><br>粘性定位可以被认为是相对定位和固定定位的混合，sticky粘性的<br>选择器 {position ：sticky；top：10px}</p>\n<p>1.以浏览器的可视窗口为参考点<br>2.必须添加 top right left bottom其中一个<br>3.占有原来的位置</p>\n<p>定位的叠放次序：<br>z-index(z轴）<br>选择器{z-index:1;}<br>数值越打盒子越靠上<br>只有定位的盒子才有的属性</p>\n<p>绝对定位的盒子居中：<br>1.left走  50% 父容器的一半<br>2.margin  负值  往左走一半  margin-left：</p>\n<p>浮动的元素只会压住下面的盒子不会压住下面的文字<br>绝对定位或者固定定位会压住下面的所有东西</p>\n<ul>\n<li><p>鼠标样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">li</span> &#123;<span class=\"hljs-attribute\">cursor</span>:pointer&#125;<br></code></pre></td></tr></table></figure>\n<p>default  默认的<br>pointer  小手<br>move     移动<br>text     文字<br>not-allowed  禁止的</p>\n</li>\n<li><p>轮廓线<br>outline  ：none</p>\n</li>\n<li><p>文本域防止拖拉<br>textarea {resize ：none}</p>\n</li>\n<li><p>垂直对齐<br>vertical-align： bottom  /middle/top/  baseline（默认的）</p>\n</li>\n<li><p>溢出文字用省略号代替</p>\n</li>\n</ul>\n<p>1.单行文本溢出<br>先强制一行内显示<br>white-space：normal； 如果文字显示不开，自动换行   nowrap 如果显示不开，强制一行显示<br>超出部分隐藏起来<br>overflow：hidden；<br>超出部分用省略号代替<br>text-overflow：ellipsis；<br>2.多行文本溢出用省略号代替<br>overflow：hidden；<br>text-overflow：ellipsis；<br>弹性伸缩盒子模型显示<br>display：-webkit-box；<br>限制在一个块元素显示的文本的行数<br>-webkit-line-clamp：2<br>设置或检索伸缩盒子对象的子元素的排列方式<br>-webkit-box-orient：vertical；</p>\n","site":{"data":{}},"wordcount":1339,"excerpt":"","more":"<h2 id=\"三种布局方式：\"><a href=\"#三种布局方式：\" class=\"headerlink\" title=\"三种布局方式：\"></a>三种布局方式：</h2><ul>\n<li>标准流</li>\n<li>浮动</li>\n<li>定位</li>\n</ul>\n<h3 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h3><p>浮动可以改变元素默认的排列方式，最典型的应用就是可以让多个块级元素一行内排列，<strong>多个块级元素纵向排列找标准流。多个块级元素横向排列找浮动</strong><br>选择器 {float：属性值}<br>属性值：</p>\n<ul>\n<li>none 不浮动</li>\n<li>left 左浮动</li>\n<li>right 右浮动<br>脱离标准普通流的控制移动到指定位置（俗称脱标）<br>浮动的盒子不再保留原先的位置</li>\n</ul>\n<h3 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h3><p>将盒子定在某一个位置，所以定位也在摆盒子<br>定位=定位模式+边偏移<br><strong>定位模式</strong><br>属性position 值：<br>static 静态定位          relative 相对定位  absolute绝对定位     fixed 固定定位<br><strong>边偏移</strong><br>边偏移就是定位盒子移动到最终位置  ，有top  right left bottom</p>\n<p><strong>静态定位</strong><br>元素默认的定位方式，为定位的意思，没有边偏移<br>选择器 {position ：static}</p>\n<p><strong>相对定位</strong><br>相对定位就是在元素移动位置的时候，是相对于他原来的位置来说的<br>选择器 {position：relative}<br>原来的位置还是保留的，下面的盒子不会升上去</p>\n<p><strong>绝对定位</strong><br>绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的<br>选择器 {position ：absolute}<br>1.如果没有祖元素或者祖元素没有定位，则以浏览器为标准<br>2.如果父元素有定位，则以父级为参考点移动位置<br>3.不在占有原来的位置<br>（ 子绝父相）</p>\n<p><strong>固定定位</strong><br>固定定位可以固定于浏览器可视区域的位置，页面在滚动的时候位置不会改变<br>1.以浏览器的可视窗口为参考页面<br>2.和父元素没有关系</p>\n<p><strong>粘性定位</strong><br>粘性定位可以被认为是相对定位和固定定位的混合，sticky粘性的<br>选择器 {position ：sticky；top：10px}</p>\n<p>1.以浏览器的可视窗口为参考点<br>2.必须添加 top right left bottom其中一个<br>3.占有原来的位置</p>\n<p>定位的叠放次序：<br>z-index(z轴）<br>选择器{z-index:1;}<br>数值越打盒子越靠上<br>只有定位的盒子才有的属性</p>\n<p>绝对定位的盒子居中：<br>1.left走  50% 父容器的一半<br>2.margin  负值  往左走一半  margin-left：</p>\n<p>浮动的元素只会压住下面的盒子不会压住下面的文字<br>绝对定位或者固定定位会压住下面的所有东西</p>\n<ul>\n<li><p>鼠标样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">li</span> &#123;<span class=\"hljs-attribute\">cursor</span>:pointer&#125;<br></code></pre></td></tr></table></figure>\n<p>default  默认的<br>pointer  小手<br>move     移动<br>text     文字<br>not-allowed  禁止的</p>\n</li>\n<li><p>轮廓线<br>outline  ：none</p>\n</li>\n<li><p>文本域防止拖拉<br>textarea {resize ：none}</p>\n</li>\n<li><p>垂直对齐<br>vertical-align： bottom  /middle/top/  baseline（默认的）</p>\n</li>\n<li><p>溢出文字用省略号代替</p>\n</li>\n</ul>\n<p>1.单行文本溢出<br>先强制一行内显示<br>white-space：normal； 如果文字显示不开，自动换行   nowrap 如果显示不开，强制一行显示<br>超出部分隐藏起来<br>overflow：hidden；<br>超出部分用省略号代替<br>text-overflow：ellipsis；<br>2.多行文本溢出用省略号代替<br>overflow：hidden；<br>text-overflow：ellipsis；<br>弹性伸缩盒子模型显示<br>display：-webkit-box；<br>限制在一个块元素显示的文本的行数<br>-webkit-line-clamp：2<br>设置或检索伸缩盒子对象的子元素的排列方式<br>-webkit-box-orient：vertical；</p>\n"},{"title":"小艾的CSS3笔记","date":"2020-09-22T08:14:42.000Z","index_img":"/img/0922.jpg","banner_img":"/img/school.jpg","_content":"## css是在```<head></head>```之间写入的\n\n\n\n### css引入样式有三种，分别是：\n- 内部样式表：\n把CSS全部写到html内部，也就是<style></style>中\n- 行内样式表：\n适合修改一些简单样式，不是特别多的修改\n直接在标签上面修改\n```<div style=\"color: pink;\">xxxxxxxxxxx<div>```\n- 外部样式表：\n适合样式特别多的情况，单独建一个CSS文件\n```<link rel=\"stylesheet\" href=\"css文件路径\">```\n\ncss是由两部分组成的：\n- **选择器以及一条或者多条声明**\n- 选择器是用于指定css样式的HTML标签，花括号是对该对象设置的具体样式\n- 属性和属性值以键值对出现，属性和属性值之间用“：”分开，以“；”结尾\n- css基础选择器是由单个选择器组成的包括：\n（1）标签选择器=====以标签名作为选择器\n标签名{属性：属性值；}\n（2）类选择器=====单独选择一个或者几个\n.类名{属性：属性值；}\n需要用class来调用\n```<div class=\"类名\">```\n(3)id 选择器====只能调用一次\n#id名{属性：属性值；}\n```<div id=\"id名\">```\n（4）通配符选择器\n*{属性：属性值；}  可以把所有的标签都改变\n\n\n复合选择器：由两个或者更多的基础选择器组合而成的，包括：\n**后代选择器，子代选择器，并集选择器，伪类选择器**\n- 后代选择器（重要） ：\n```元素1   元素2{样式xxxxxx}=======元素2必定是元素1 的孩子```\n- 子代选择器：\n只能选择作为某元素的最近一级子元素\n```元素1>元素2 {样式xxxxx}```\n- 并集选择器：\n\t可以选择多组标签，同时为他们定义相同的样式\n\t```div,\n\tp{\n\txxxxxxxxxx\n\t}\n\t```\n- 伪类选择器：\n\t```\n    给链接添加特殊效果\n\ta:link     （选择所有未被访问过的链接）\n\ta: visited      (选择所有已经被访问过的链接）\n\ta:hover       （选择鼠标指针位于起上的链接）\n\ta:active        （选择活动链接，鼠标正在点着的，还没有放开的）\n    ```\n- focus 伪类选择器\n```\n    用于选取获得光标的表单元素\n\tinput ：focus\n    {bg-color:pink}\n```\n\n\n\n\n\n- CSS字体属性\n字体：标签  { font-family :\"微软雅黑\";}\n字体大小： 谷歌默认显示：16px,px（像素）大小是我们网页最常用的单位\nP{ font-size :20px;}         \n- 对齐文本-----只能是水平对齐\n```\ndiv \n{text-align:center}\n```\n\n- 文本缩进\n```\ntext-index   /*给首行进行缩进*/\ndiv {\n    text-indent:19px;\n}\nem是一个相对单位，就是相对于当前元素的一个文字的大小\ndiv {\n    text-indent:2em\n}\n```\n- 行间距------文字和文字行之间的距离\n```\np{\n    line-height: 26px\n}\n```\n\n\n\n### HTML元素一般分为  块元素和行元素\n<h4>*块元素</h4>\n\n```<h1></h1>,<p>,<div>,<ul>,<ol>,<li>```等等\n**特点：**\n- 独占一行\n- 可以设置高度宽度，以及内外边距\n- 是一个容器以及盒子，里面可以放行内或者块级元素\n\n**注意：文字类的元素内不能使用块级元素**\n例如```<p>```里面不能放```<div>,<h1>~~~~<h6>```等都是文字类块级标签，里面也不能放其他块级元素\n\n<h4>*行内元素</h4>\n\n``` <a>,<strong>,<b>,<em>```等等\n**特点：**\n- 相邻行内元素在一行上，一行可以显示多个\n- 宽和高直接设置是无效的\n- 默认宽度就是本身内容的宽度\n- 行内元素只能容纳文本或者其他行内元素\n**注意：链接里面不能再放链接了，特殊情况下```<a>```里面可以放块级元素，但是给```<a>```转换一下块级模式最安全**\n<h4>*行内块元素</h4>\n\n同时具有块级元素和行内元素的特点，```<img/>,<input/>,<td>```\n**特点：**\n- 一行可以显示多个\n- 可以设置宽和高以及边距\n\n\n<h4>*元素显示模式转换</h4>\ndisplay:block ； =====行内元素转换为块链接\ndisplay:inline;  =====块元素转换为行内元素\ndisplay:inline-block;  =====转换为行内块元素\n\n- 背景图像固定（背景附着）\nbackfground-attachment : scroll 滚动 /fixed  固定\n\n- 背景复合写法\n背景颜色  背景图片地址  背景平铺 背景图像滚动 背景  背景位置\nbackground： black url(url)  no-repeat fixed center top\n\n- 背景颜色半透明\nbackground :rgba(0,0,0,0.3)\n最后一个参数是透明度大小，区间是0~1；\n\n\n**重点**\n### css的三大特性\n- 层叠性\n样式冲突：遵循就近原则，以最后的为准，覆盖掉前面的\n样式不冲突，不会层叠\n- 继承性\ncss中的继承：子标签会继承父标签的某些样式，如文本颜色和字号（text- ,font- ,line- ,元素开头的以及color)\n行高的继承：如果行高没有带单位，就是当前元素文字大小的n倍\n- 优先级\n当同一个元素指定多个选择器，就会有优先级的产生\n选择器如果相同，则执行层叠性\n如果是复合选择器，则会由权重叠加\n\n### css盒子模型\n- 盒子模型的组成\nborder 边框\ncontent  内容\npadding 内边距\nmargin   外边距\n\n**边框**\n组成：边框粗细 ，边框样式，边框颜色\n\n<h5>边框的复合写法：</h5>\nborder：1px  solid red; 没有先后顺序\n边框可以分开写：\nborder-top;或者 border-left; 或者 border-bottom; 或者 border-right;\n如果只需要改一条边框，可以利用层叠性来改变\n表格的细线边框\nborder-collapse:collapse;   表示相邻的边框合并在一起\n边框会影响盒子实际大小\n\n**内边距**\npadding属性用于设置内边距\npadding-left： 20px  左边距   等等\n复合写法：\n- padding： 5px； 代表上下左右都是5像素\n- padding： 5px  10px； 代表上下边距是5像素   左右内边距是10像素\n-  padding：5px 10px  20px ； 代表上边距5像素  左右边距10像素  下边距20像素\n- padding ：5px  10px 20px  30px；  代表上是5像素 右边距10像素 下是20像素 左是30像素\n如果一个盒子本身没有指定width /height属性，padding则不会挤开盒子\n\n**外边距**\n盒子和盒子之间的距离：\nmargin-left\nmargin-right\nmargin-top\nmargin-bottom\nmargin的复合写法和padding的一样\n\n\n**外边距可以让块级盒子水平居中，但是必须满足两个条件：*\n- 盒子必须指定了width\n- 盒子左右的外边距都设置为auto\nmargin：auto；\nmargin： 0 auto；\nmargin-left：auto；margin-right：auto；\n\n**行内元素或者行内块元素水平居中给其父元素添加text-align: center就可以了**\n","source":"_posts/css3.md","raw":"---\ntitle: 小艾的CSS3笔记\ndate: 2020-09-22 16:14:42\ntags: css3\ncategories: 前端\nindex_img: /img/0922.jpg\nbanner_img: /img/school.jpg\n---\n## css是在```<head></head>```之间写入的\n\n\n\n### css引入样式有三种，分别是：\n- 内部样式表：\n把CSS全部写到html内部，也就是<style></style>中\n- 行内样式表：\n适合修改一些简单样式，不是特别多的修改\n直接在标签上面修改\n```<div style=\"color: pink;\">xxxxxxxxxxx<div>```\n- 外部样式表：\n适合样式特别多的情况，单独建一个CSS文件\n```<link rel=\"stylesheet\" href=\"css文件路径\">```\n\ncss是由两部分组成的：\n- **选择器以及一条或者多条声明**\n- 选择器是用于指定css样式的HTML标签，花括号是对该对象设置的具体样式\n- 属性和属性值以键值对出现，属性和属性值之间用“：”分开，以“；”结尾\n- css基础选择器是由单个选择器组成的包括：\n（1）标签选择器=====以标签名作为选择器\n标签名{属性：属性值；}\n（2）类选择器=====单独选择一个或者几个\n.类名{属性：属性值；}\n需要用class来调用\n```<div class=\"类名\">```\n(3)id 选择器====只能调用一次\n#id名{属性：属性值；}\n```<div id=\"id名\">```\n（4）通配符选择器\n*{属性：属性值；}  可以把所有的标签都改变\n\n\n复合选择器：由两个或者更多的基础选择器组合而成的，包括：\n**后代选择器，子代选择器，并集选择器，伪类选择器**\n- 后代选择器（重要） ：\n```元素1   元素2{样式xxxxxx}=======元素2必定是元素1 的孩子```\n- 子代选择器：\n只能选择作为某元素的最近一级子元素\n```元素1>元素2 {样式xxxxx}```\n- 并集选择器：\n\t可以选择多组标签，同时为他们定义相同的样式\n\t```div,\n\tp{\n\txxxxxxxxxx\n\t}\n\t```\n- 伪类选择器：\n\t```\n    给链接添加特殊效果\n\ta:link     （选择所有未被访问过的链接）\n\ta: visited      (选择所有已经被访问过的链接）\n\ta:hover       （选择鼠标指针位于起上的链接）\n\ta:active        （选择活动链接，鼠标正在点着的，还没有放开的）\n    ```\n- focus 伪类选择器\n```\n    用于选取获得光标的表单元素\n\tinput ：focus\n    {bg-color:pink}\n```\n\n\n\n\n\n- CSS字体属性\n字体：标签  { font-family :\"微软雅黑\";}\n字体大小： 谷歌默认显示：16px,px（像素）大小是我们网页最常用的单位\nP{ font-size :20px;}         \n- 对齐文本-----只能是水平对齐\n```\ndiv \n{text-align:center}\n```\n\n- 文本缩进\n```\ntext-index   /*给首行进行缩进*/\ndiv {\n    text-indent:19px;\n}\nem是一个相对单位，就是相对于当前元素的一个文字的大小\ndiv {\n    text-indent:2em\n}\n```\n- 行间距------文字和文字行之间的距离\n```\np{\n    line-height: 26px\n}\n```\n\n\n\n### HTML元素一般分为  块元素和行元素\n<h4>*块元素</h4>\n\n```<h1></h1>,<p>,<div>,<ul>,<ol>,<li>```等等\n**特点：**\n- 独占一行\n- 可以设置高度宽度，以及内外边距\n- 是一个容器以及盒子，里面可以放行内或者块级元素\n\n**注意：文字类的元素内不能使用块级元素**\n例如```<p>```里面不能放```<div>,<h1>~~~~<h6>```等都是文字类块级标签，里面也不能放其他块级元素\n\n<h4>*行内元素</h4>\n\n``` <a>,<strong>,<b>,<em>```等等\n**特点：**\n- 相邻行内元素在一行上，一行可以显示多个\n- 宽和高直接设置是无效的\n- 默认宽度就是本身内容的宽度\n- 行内元素只能容纳文本或者其他行内元素\n**注意：链接里面不能再放链接了，特殊情况下```<a>```里面可以放块级元素，但是给```<a>```转换一下块级模式最安全**\n<h4>*行内块元素</h4>\n\n同时具有块级元素和行内元素的特点，```<img/>,<input/>,<td>```\n**特点：**\n- 一行可以显示多个\n- 可以设置宽和高以及边距\n\n\n<h4>*元素显示模式转换</h4>\ndisplay:block ； =====行内元素转换为块链接\ndisplay:inline;  =====块元素转换为行内元素\ndisplay:inline-block;  =====转换为行内块元素\n\n- 背景图像固定（背景附着）\nbackfground-attachment : scroll 滚动 /fixed  固定\n\n- 背景复合写法\n背景颜色  背景图片地址  背景平铺 背景图像滚动 背景  背景位置\nbackground： black url(url)  no-repeat fixed center top\n\n- 背景颜色半透明\nbackground :rgba(0,0,0,0.3)\n最后一个参数是透明度大小，区间是0~1；\n\n\n**重点**\n### css的三大特性\n- 层叠性\n样式冲突：遵循就近原则，以最后的为准，覆盖掉前面的\n样式不冲突，不会层叠\n- 继承性\ncss中的继承：子标签会继承父标签的某些样式，如文本颜色和字号（text- ,font- ,line- ,元素开头的以及color)\n行高的继承：如果行高没有带单位，就是当前元素文字大小的n倍\n- 优先级\n当同一个元素指定多个选择器，就会有优先级的产生\n选择器如果相同，则执行层叠性\n如果是复合选择器，则会由权重叠加\n\n### css盒子模型\n- 盒子模型的组成\nborder 边框\ncontent  内容\npadding 内边距\nmargin   外边距\n\n**边框**\n组成：边框粗细 ，边框样式，边框颜色\n\n<h5>边框的复合写法：</h5>\nborder：1px  solid red; 没有先后顺序\n边框可以分开写：\nborder-top;或者 border-left; 或者 border-bottom; 或者 border-right;\n如果只需要改一条边框，可以利用层叠性来改变\n表格的细线边框\nborder-collapse:collapse;   表示相邻的边框合并在一起\n边框会影响盒子实际大小\n\n**内边距**\npadding属性用于设置内边距\npadding-left： 20px  左边距   等等\n复合写法：\n- padding： 5px； 代表上下左右都是5像素\n- padding： 5px  10px； 代表上下边距是5像素   左右内边距是10像素\n-  padding：5px 10px  20px ； 代表上边距5像素  左右边距10像素  下边距20像素\n- padding ：5px  10px 20px  30px；  代表上是5像素 右边距10像素 下是20像素 左是30像素\n如果一个盒子本身没有指定width /height属性，padding则不会挤开盒子\n\n**外边距**\n盒子和盒子之间的距离：\nmargin-left\nmargin-right\nmargin-top\nmargin-bottom\nmargin的复合写法和padding的一样\n\n\n**外边距可以让块级盒子水平居中，但是必须满足两个条件：*\n- 盒子必须指定了width\n- 盒子左右的外边距都设置为auto\nmargin：auto；\nmargin： 0 auto；\nmargin-left：auto；margin-right：auto；\n\n**行内元素或者行内块元素水平居中给其父元素添加text-align: center就可以了**\n","slug":"css3","published":1,"updated":"2024-11-17T13:58:10.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpj000u73t3f5hzan5i","content":"<h2 id=\"css是在-lt-head-gt-lt-head-gt-之间写入的\"><a href=\"#css是在-lt-head-gt-lt-head-gt-之间写入的\" class=\"headerlink\" title=\"css是在&lt;head&gt;&lt;/head&gt;之间写入的\"></a>css是在<code>&lt;head&gt;&lt;/head&gt;</code>之间写入的</h2><h3 id=\"css引入样式有三种，分别是：\"><a href=\"#css引入样式有三种，分别是：\" class=\"headerlink\" title=\"css引入样式有三种，分别是：\"></a>css引入样式有三种，分别是：</h3><ul>\n<li>内部样式表：<br>把CSS全部写到html内部，也就是<style></style>中</li>\n<li>行内样式表：<br>适合修改一些简单样式，不是特别多的修改<br>直接在标签上面修改<br><code>&lt;div style=&quot;color: pink;&quot;&gt;xxxxxxxxxxx&lt;div&gt;</code></li>\n<li>外部样式表：<br>适合样式特别多的情况，单独建一个CSS文件<br><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css文件路径&quot;&gt;</code></li>\n</ul>\n<p>css是由两部分组成的：</p>\n<ul>\n<li><strong>选择器以及一条或者多条声明</strong></li>\n<li>选择器是用于指定css样式的HTML标签，花括号是对该对象设置的具体样式</li>\n<li>属性和属性值以键值对出现，属性和属性值之间用“：”分开，以“；”结尾</li>\n<li>css基础选择器是由单个选择器组成的包括：<br>（1）标签选择器=====以标签名作为选择器<br>标签名{属性：属性值；}<br>（2）类选择器=====单独选择一个或者几个<br>.类名{属性：属性值；}<br>需要用class来调用<br><code>&lt;div class=&quot;类名&quot;&gt;</code><br>(3)id 选择器====只能调用一次<br>#id名{属性：属性值；}<br><code>&lt;div id=&quot;id名&quot;&gt;</code><br>（4）通配符选择器</li>\n</ul>\n<p>*{属性：属性值；}  可以把所有的标签都改变</p>\n<p>复合选择器：由两个或者更多的基础选择器组合而成的，包括：<br><strong>后代选择器，子代选择器，并集选择器，伪类选择器</strong></p>\n<ul>\n<li>后代选择器（重要） ：<br><code>元素1   元素2&#123;样式xxxxxx&#125;=======元素2必定是元素1 的孩子</code></li>\n<li>子代选择器：<br>只能选择作为某元素的最近一级子元素<br><code>元素1&gt;元素2 &#123;样式xxxxx&#125;</code></li>\n<li>并集选择器：<br>  可以选择多组标签，同时为他们定义相同的样式  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs div,\">p&#123;<br>xxxxxxxxxx<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>伪类选择器：  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">   给链接添加特殊效果<br><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:link</span>     （选择所有未被访问过的链接）<br><span class=\"hljs-selector-tag\">a</span>: visited      (选择所有已经被访问过的链接）<br><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span>       （选择鼠标指针位于起上的链接）<br><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:active</span>        （选择活动链接，鼠标正在点着的，还没有放开的）<br></code></pre></td></tr></table></figure></li>\n<li>focus 伪类选择器<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">   用于选取获得光标的表单元素<br><span class=\"hljs-selector-tag\">input</span> ：focus<br>   &#123;bg-<span class=\"hljs-attribute\">color</span>:pink&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li><p>CSS字体属性<br>字体：标签  { font-family :”微软雅黑”;}<br>字体大小： 谷歌默认显示：16px,px（像素）大小是我们网页最常用的单位<br>P{ font-size :20px;}         </p>\n</li>\n<li><p>对齐文本—–只能是水平对齐</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">div</span> <br>&#123;<span class=\"hljs-attribute\">text-align</span>:center&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>文本缩进</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">text</span>-index   <span class=\"hljs-comment\">/*给首行进行缩进*/</span><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">text-indent</span>:<span class=\"hljs-number\">19px</span>;<br>&#125;<br><span class=\"hljs-selector-tag\">em</span>是一个相对单位，就是相对于当前元素的一个文字的大小<br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">text-indent</span>:<span class=\"hljs-number\">2em</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>行间距——文字和文字行之间的距离</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">p</span>&#123;<br>    <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">26px</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"HTML元素一般分为-块元素和行元素\"><a href=\"#HTML元素一般分为-块元素和行元素\" class=\"headerlink\" title=\"HTML元素一般分为  块元素和行元素\"></a>HTML元素一般分为  块元素和行元素</h3><h4>*块元素</h4>\n\n<p><code>&lt;h1&gt;&lt;/h1&gt;,&lt;p&gt;,&lt;div&gt;,&lt;ul&gt;,&lt;ol&gt;,&lt;li&gt;</code>等等<br><strong>特点：</strong></p>\n<ul>\n<li>独占一行</li>\n<li>可以设置高度宽度，以及内外边距</li>\n<li>是一个容器以及盒子，里面可以放行内或者块级元素</li>\n</ul>\n<p><strong>注意：文字类的元素内不能使用块级元素</strong><br>例如<code>&lt;p&gt;</code>里面不能放<code>&lt;div&gt;,&lt;h1&gt;~~~~&lt;h6&gt;</code>等都是文字类块级标签，里面也不能放其他块级元素</p>\n<h4>*行内元素</h4>\n\n<p><code> &lt;a&gt;,&lt;strong&gt;,&lt;b&gt;,&lt;em&gt;</code>等等<br><strong>特点：</strong></p>\n<ul>\n<li>相邻行内元素在一行上，一行可以显示多个</li>\n<li>宽和高直接设置是无效的</li>\n<li>默认宽度就是本身内容的宽度</li>\n<li>行内元素只能容纳文本或者其他行内元素</li>\n</ul>\n<p><strong>注意：链接里面不能再放链接了，特殊情况下<code>&lt;a&gt;</code>里面可以放块级元素，但是给<code>&lt;a&gt;</code>转换一下块级模式最安全</strong></p>\n<h4>*行内块元素</h4>\n\n<p>同时具有块级元素和行内元素的特点，<code>&lt;img/&gt;,&lt;input/&gt;,&lt;td&gt;</code><br><strong>特点：</strong></p>\n<ul>\n<li>一行可以显示多个</li>\n<li>可以设置宽和高以及边距</li>\n</ul>\n<h4>*元素显示模式转换</h4>\ndisplay:block ； =====行内元素转换为块链接\ndisplay:inline;  =====块元素转换为行内元素\ndisplay:inline-block;  =====转换为行内块元素\n\n<ul>\n<li><p>背景图像固定（背景附着）<br>backfground-attachment : scroll 滚动 /fixed  固定</p>\n</li>\n<li><p>背景复合写法<br>背景颜色  背景图片地址  背景平铺 背景图像滚动 背景  背景位置<br>background： black url(url)  no-repeat fixed center top</p>\n</li>\n<li><p>背景颜色半透明<br>background :rgba(0,0,0,0.3)<br>最后一个参数是透明度大小，区间是0~1；</p>\n</li>\n</ul>\n<p><strong>重点</strong></p>\n<h3 id=\"css的三大特性\"><a href=\"#css的三大特性\" class=\"headerlink\" title=\"css的三大特性\"></a>css的三大特性</h3><ul>\n<li>层叠性<br>样式冲突：遵循就近原则，以最后的为准，覆盖掉前面的<br>样式不冲突，不会层叠</li>\n<li>继承性<br>css中的继承：子标签会继承父标签的某些样式，如文本颜色和字号（text- ,font- ,line- ,元素开头的以及color)<br>行高的继承：如果行高没有带单位，就是当前元素文字大小的n倍</li>\n<li>优先级<br>当同一个元素指定多个选择器，就会有优先级的产生<br>选择器如果相同，则执行层叠性<br>如果是复合选择器，则会由权重叠加</li>\n</ul>\n<h3 id=\"css盒子模型\"><a href=\"#css盒子模型\" class=\"headerlink\" title=\"css盒子模型\"></a>css盒子模型</h3><ul>\n<li>盒子模型的组成<br>border 边框<br>content  内容<br>padding 内边距<br>margin   外边距</li>\n</ul>\n<p><strong>边框</strong><br>组成：边框粗细 ，边框样式，边框颜色</p>\n<h5>边框的复合写法：</h5>\nborder：1px  solid red; 没有先后顺序\n边框可以分开写：\nborder-top;或者 border-left; 或者 border-bottom; 或者 border-right;\n如果只需要改一条边框，可以利用层叠性来改变\n表格的细线边框\nborder-collapse:collapse;   表示相邻的边框合并在一起\n边框会影响盒子实际大小\n\n<p><strong>内边距</strong><br>padding属性用于设置内边距<br>padding-left： 20px  左边距   等等<br>复合写法：</p>\n<ul>\n<li>padding： 5px； 代表上下左右都是5像素</li>\n<li>padding： 5px  10px； 代表上下边距是5像素   左右内边距是10像素</li>\n<li> padding：5px 10px  20px ； 代表上边距5像素  左右边距10像素  下边距20像素</li>\n<li>padding ：5px  10px 20px  30px；  代表上是5像素 右边距10像素 下是20像素 左是30像素<br>如果一个盒子本身没有指定width /height属性，padding则不会挤开盒子</li>\n</ul>\n<p><strong>外边距</strong><br>盒子和盒子之间的距离：<br>margin-left<br>margin-right<br>margin-top<br>margin-bottom<br>margin的复合写法和padding的一样</p>\n<p>*<em>外边距可以让块级盒子水平居中，但是必须满足两个条件：</em></p>\n<ul>\n<li>盒子必须指定了width</li>\n<li>盒子左右的外边距都设置为auto<br>margin：auto；<br>margin： 0 auto；<br>margin-left：auto；margin-right：auto；</li>\n</ul>\n<p><strong>行内元素或者行内块元素水平居中给其父元素添加text-align: center就可以了</strong></p>\n","site":{"data":{}},"wordcount":2973,"excerpt":"","more":"<h2 id=\"css是在-lt-head-gt-lt-head-gt-之间写入的\"><a href=\"#css是在-lt-head-gt-lt-head-gt-之间写入的\" class=\"headerlink\" title=\"css是在&lt;head&gt;&lt;/head&gt;之间写入的\"></a>css是在<code>&lt;head&gt;&lt;/head&gt;</code>之间写入的</h2><h3 id=\"css引入样式有三种，分别是：\"><a href=\"#css引入样式有三种，分别是：\" class=\"headerlink\" title=\"css引入样式有三种，分别是：\"></a>css引入样式有三种，分别是：</h3><ul>\n<li>内部样式表：<br>把CSS全部写到html内部，也就是<style></style>中</li>\n<li>行内样式表：<br>适合修改一些简单样式，不是特别多的修改<br>直接在标签上面修改<br><code>&lt;div style=&quot;color: pink;&quot;&gt;xxxxxxxxxxx&lt;div&gt;</code></li>\n<li>外部样式表：<br>适合样式特别多的情况，单独建一个CSS文件<br><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css文件路径&quot;&gt;</code></li>\n</ul>\n<p>css是由两部分组成的：</p>\n<ul>\n<li><strong>选择器以及一条或者多条声明</strong></li>\n<li>选择器是用于指定css样式的HTML标签，花括号是对该对象设置的具体样式</li>\n<li>属性和属性值以键值对出现，属性和属性值之间用“：”分开，以“；”结尾</li>\n<li>css基础选择器是由单个选择器组成的包括：<br>（1）标签选择器=====以标签名作为选择器<br>标签名{属性：属性值；}<br>（2）类选择器=====单独选择一个或者几个<br>.类名{属性：属性值；}<br>需要用class来调用<br><code>&lt;div class=&quot;类名&quot;&gt;</code><br>(3)id 选择器====只能调用一次<br>#id名{属性：属性值；}<br><code>&lt;div id=&quot;id名&quot;&gt;</code><br>（4）通配符选择器</li>\n</ul>\n<p>*{属性：属性值；}  可以把所有的标签都改变</p>\n<p>复合选择器：由两个或者更多的基础选择器组合而成的，包括：<br><strong>后代选择器，子代选择器，并集选择器，伪类选择器</strong></p>\n<ul>\n<li>后代选择器（重要） ：<br><code>元素1   元素2&#123;样式xxxxxx&#125;=======元素2必定是元素1 的孩子</code></li>\n<li>子代选择器：<br>只能选择作为某元素的最近一级子元素<br><code>元素1&gt;元素2 &#123;样式xxxxx&#125;</code></li>\n<li>并集选择器：<br>  可以选择多组标签，同时为他们定义相同的样式  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs div,\">p&#123;<br>xxxxxxxxxx<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>伪类选择器：  <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">   给链接添加特殊效果<br><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:link</span>     （选择所有未被访问过的链接）<br><span class=\"hljs-selector-tag\">a</span>: visited      (选择所有已经被访问过的链接）<br><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span>       （选择鼠标指针位于起上的链接）<br><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:active</span>        （选择活动链接，鼠标正在点着的，还没有放开的）<br></code></pre></td></tr></table></figure></li>\n<li>focus 伪类选择器<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">   用于选取获得光标的表单元素<br><span class=\"hljs-selector-tag\">input</span> ：focus<br>   &#123;bg-<span class=\"hljs-attribute\">color</span>:pink&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li><p>CSS字体属性<br>字体：标签  { font-family :”微软雅黑”;}<br>字体大小： 谷歌默认显示：16px,px（像素）大小是我们网页最常用的单位<br>P{ font-size :20px;}         </p>\n</li>\n<li><p>对齐文本—–只能是水平对齐</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">div</span> <br>&#123;<span class=\"hljs-attribute\">text-align</span>:center&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>文本缩进</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">text</span>-index   <span class=\"hljs-comment\">/*给首行进行缩进*/</span><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">text-indent</span>:<span class=\"hljs-number\">19px</span>;<br>&#125;<br><span class=\"hljs-selector-tag\">em</span>是一个相对单位，就是相对于当前元素的一个文字的大小<br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">text-indent</span>:<span class=\"hljs-number\">2em</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>行间距——文字和文字行之间的距离</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">p</span>&#123;<br>    <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">26px</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"HTML元素一般分为-块元素和行元素\"><a href=\"#HTML元素一般分为-块元素和行元素\" class=\"headerlink\" title=\"HTML元素一般分为  块元素和行元素\"></a>HTML元素一般分为  块元素和行元素</h3><h4>*块元素</h4>\n\n<p><code>&lt;h1&gt;&lt;/h1&gt;,&lt;p&gt;,&lt;div&gt;,&lt;ul&gt;,&lt;ol&gt;,&lt;li&gt;</code>等等<br><strong>特点：</strong></p>\n<ul>\n<li>独占一行</li>\n<li>可以设置高度宽度，以及内外边距</li>\n<li>是一个容器以及盒子，里面可以放行内或者块级元素</li>\n</ul>\n<p><strong>注意：文字类的元素内不能使用块级元素</strong><br>例如<code>&lt;p&gt;</code>里面不能放<code>&lt;div&gt;,&lt;h1&gt;~~~~&lt;h6&gt;</code>等都是文字类块级标签，里面也不能放其他块级元素</p>\n<h4>*行内元素</h4>\n\n<p><code> &lt;a&gt;,&lt;strong&gt;,&lt;b&gt;,&lt;em&gt;</code>等等<br><strong>特点：</strong></p>\n<ul>\n<li>相邻行内元素在一行上，一行可以显示多个</li>\n<li>宽和高直接设置是无效的</li>\n<li>默认宽度就是本身内容的宽度</li>\n<li>行内元素只能容纳文本或者其他行内元素</li>\n</ul>\n<p><strong>注意：链接里面不能再放链接了，特殊情况下<code>&lt;a&gt;</code>里面可以放块级元素，但是给<code>&lt;a&gt;</code>转换一下块级模式最安全</strong></p>\n<h4>*行内块元素</h4>\n\n<p>同时具有块级元素和行内元素的特点，<code>&lt;img/&gt;,&lt;input/&gt;,&lt;td&gt;</code><br><strong>特点：</strong></p>\n<ul>\n<li>一行可以显示多个</li>\n<li>可以设置宽和高以及边距</li>\n</ul>\n<h4>*元素显示模式转换</h4>\ndisplay:block ； =====行内元素转换为块链接\ndisplay:inline;  =====块元素转换为行内元素\ndisplay:inline-block;  =====转换为行内块元素\n\n<ul>\n<li><p>背景图像固定（背景附着）<br>backfground-attachment : scroll 滚动 /fixed  固定</p>\n</li>\n<li><p>背景复合写法<br>背景颜色  背景图片地址  背景平铺 背景图像滚动 背景  背景位置<br>background： black url(url)  no-repeat fixed center top</p>\n</li>\n<li><p>背景颜色半透明<br>background :rgba(0,0,0,0.3)<br>最后一个参数是透明度大小，区间是0~1；</p>\n</li>\n</ul>\n<p><strong>重点</strong></p>\n<h3 id=\"css的三大特性\"><a href=\"#css的三大特性\" class=\"headerlink\" title=\"css的三大特性\"></a>css的三大特性</h3><ul>\n<li>层叠性<br>样式冲突：遵循就近原则，以最后的为准，覆盖掉前面的<br>样式不冲突，不会层叠</li>\n<li>继承性<br>css中的继承：子标签会继承父标签的某些样式，如文本颜色和字号（text- ,font- ,line- ,元素开头的以及color)<br>行高的继承：如果行高没有带单位，就是当前元素文字大小的n倍</li>\n<li>优先级<br>当同一个元素指定多个选择器，就会有优先级的产生<br>选择器如果相同，则执行层叠性<br>如果是复合选择器，则会由权重叠加</li>\n</ul>\n<h3 id=\"css盒子模型\"><a href=\"#css盒子模型\" class=\"headerlink\" title=\"css盒子模型\"></a>css盒子模型</h3><ul>\n<li>盒子模型的组成<br>border 边框<br>content  内容<br>padding 内边距<br>margin   外边距</li>\n</ul>\n<p><strong>边框</strong><br>组成：边框粗细 ，边框样式，边框颜色</p>\n<h5>边框的复合写法：</h5>\nborder：1px  solid red; 没有先后顺序\n边框可以分开写：\nborder-top;或者 border-left; 或者 border-bottom; 或者 border-right;\n如果只需要改一条边框，可以利用层叠性来改变\n表格的细线边框\nborder-collapse:collapse;   表示相邻的边框合并在一起\n边框会影响盒子实际大小\n\n<p><strong>内边距</strong><br>padding属性用于设置内边距<br>padding-left： 20px  左边距   等等<br>复合写法：</p>\n<ul>\n<li>padding： 5px； 代表上下左右都是5像素</li>\n<li>padding： 5px  10px； 代表上下边距是5像素   左右内边距是10像素</li>\n<li> padding：5px 10px  20px ； 代表上边距5像素  左右边距10像素  下边距20像素</li>\n<li>padding ：5px  10px 20px  30px；  代表上是5像素 右边距10像素 下是20像素 左是30像素<br>如果一个盒子本身没有指定width /height属性，padding则不会挤开盒子</li>\n</ul>\n<p><strong>外边距</strong><br>盒子和盒子之间的距离：<br>margin-left<br>margin-right<br>margin-top<br>margin-bottom<br>margin的复合写法和padding的一样</p>\n<p>*<em>外边距可以让块级盒子水平居中，但是必须满足两个条件：</em></p>\n<ul>\n<li>盒子必须指定了width</li>\n<li>盒子左右的外边距都设置为auto<br>margin：auto；<br>margin： 0 auto；<br>margin-left：auto；margin-right：auto；</li>\n</ul>\n<p><strong>行内元素或者行内块元素水平居中给其父元素添加text-align: center就可以了</strong></p>\n"},{"title":"数据库原理","date":"2020-11-16T12:54:39.000Z","index_img":"/img/dog.jpg","banner_img":"/img/sql.jpg","_content":"<h1>1.关系模型的一些术语</h1>\n<ul>\n    <li>关系 ：一张二维表，二维表的名字就是关系的名字</li>\n    <li>属性 ： 二维表当中的列称为属性，列的个数称为元数，如果一个二维表有n列就是n元关系</li>\n    <li>元组 ： 二维表当中的行称为元组</li>\n    <li>分量 : 元组的每一个属性称为分量</li>\n</ul>\n\n\n<h1>2.关系的码</h1>\n<b>2.1--候选码:</b> 如果一个关系的某属性或属性集的值可以唯一确定一个元组，则称该属性或属性集为候选码<br>\n<b>2.2--主码：</b> 如果一个关系有多个候选码，可以从中选出一个作为元组的标识，称为主码或者主键<br>\n<i><b>(主码是关系模型中的一个很重要的概念，每个关系必须选择一个主码，选定之后不可以随便更改)</b></i><br>\n<b>2.3--主属性与非主属性：</b> 包含在任一候选码中的属性称为主属性，不包含在任一候选码的属性称为非主属性<br>\n<b>2.4--外码：</b>如果一个关系R1中的主码所对应的属性或属性集X还存在于另一个关系R2中，则称这个属性或属性集X为R2的外码\n\n\n<h1>3.关系模式的完整性约束</h1>\n<b>2.1 实体完整性 ：</b>\n每个关系都有主码，且主码对应的所有属性值不为空<br>\n<br>2.2 参照完整性 ：</br>\n如果关系R2的外码X与关系R1的主码对应，则X的值或等于R1的主码的某一个值<br>\n<br>2.3 用户自定义完整性 ：</br>\n用户根据自己的需求而定义的数据库约束条件<br>\n\n\n<h1 style=\"text-align: center; color: brown;\">关系数据库设计理论</h1>\n<h3>6.1--规范化理论：关系数据库设计理论也叫规范化理论</h3>\n<b>主要包括： 函数依赖 ，范式 ，模式设计\n</b><br>\n<b>不合理的关系模式存在的问题</b>\n<ul>\n    <li>删除异常</li>\n    <li>数据冗余</li>\n    <li>插入异常</li>\n    <li>更新异常</li>\n</ul>\n\n<h3>6.2--函数依赖概述</h3>\n<b>什么是函数依赖？</b>\n<b>函数依赖就是关系模式中属性之间的依赖关系</b><br>\n函数依赖与属性之间的联系有关：只有当属于X与属性Y之间存在1：1，m：1才存在函数依赖\n当属性X与属性Y之间的是m:n时，不存在函数依赖\n\n<b>逻辑蕴含的定义：</b>","source":"_posts/database.md","raw":"---\ntitle: 数据库原理\ndate: 2020-11-16 20:54:39\ntags: 数据库\ncategories: 技术\nindex_img: /img/dog.jpg\nbanner_img: /img/sql.jpg\n---\n<h1>1.关系模型的一些术语</h1>\n<ul>\n    <li>关系 ：一张二维表，二维表的名字就是关系的名字</li>\n    <li>属性 ： 二维表当中的列称为属性，列的个数称为元数，如果一个二维表有n列就是n元关系</li>\n    <li>元组 ： 二维表当中的行称为元组</li>\n    <li>分量 : 元组的每一个属性称为分量</li>\n</ul>\n\n\n<h1>2.关系的码</h1>\n<b>2.1--候选码:</b> 如果一个关系的某属性或属性集的值可以唯一确定一个元组，则称该属性或属性集为候选码<br>\n<b>2.2--主码：</b> 如果一个关系有多个候选码，可以从中选出一个作为元组的标识，称为主码或者主键<br>\n<i><b>(主码是关系模型中的一个很重要的概念，每个关系必须选择一个主码，选定之后不可以随便更改)</b></i><br>\n<b>2.3--主属性与非主属性：</b> 包含在任一候选码中的属性称为主属性，不包含在任一候选码的属性称为非主属性<br>\n<b>2.4--外码：</b>如果一个关系R1中的主码所对应的属性或属性集X还存在于另一个关系R2中，则称这个属性或属性集X为R2的外码\n\n\n<h1>3.关系模式的完整性约束</h1>\n<b>2.1 实体完整性 ：</b>\n每个关系都有主码，且主码对应的所有属性值不为空<br>\n<br>2.2 参照完整性 ：</br>\n如果关系R2的外码X与关系R1的主码对应，则X的值或等于R1的主码的某一个值<br>\n<br>2.3 用户自定义完整性 ：</br>\n用户根据自己的需求而定义的数据库约束条件<br>\n\n\n<h1 style=\"text-align: center; color: brown;\">关系数据库设计理论</h1>\n<h3>6.1--规范化理论：关系数据库设计理论也叫规范化理论</h3>\n<b>主要包括： 函数依赖 ，范式 ，模式设计\n</b><br>\n<b>不合理的关系模式存在的问题</b>\n<ul>\n    <li>删除异常</li>\n    <li>数据冗余</li>\n    <li>插入异常</li>\n    <li>更新异常</li>\n</ul>\n\n<h3>6.2--函数依赖概述</h3>\n<b>什么是函数依赖？</b>\n<b>函数依赖就是关系模式中属性之间的依赖关系</b><br>\n函数依赖与属性之间的联系有关：只有当属于X与属性Y之间存在1：1，m：1才存在函数依赖\n当属性X与属性Y之间的是m:n时，不存在函数依赖\n\n<b>逻辑蕴含的定义：</b>","slug":"database","published":1,"updated":"2024-11-17T13:58:10.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpj000x73t33wt88a86","content":"<h1>1.关系模型的一些术语</h1>\n<ul>\n    <li>关系 ：一张二维表，二维表的名字就是关系的名字</li>\n    <li>属性 ： 二维表当中的列称为属性，列的个数称为元数，如果一个二维表有n列就是n元关系</li>\n    <li>元组 ： 二维表当中的行称为元组</li>\n    <li>分量 : 元组的每一个属性称为分量</li>\n</ul>\n\n\n<h1>2.关系的码</h1>\n<b>2.1--候选码:</b> 如果一个关系的某属性或属性集的值可以唯一确定一个元组，则称该属性或属性集为候选码<br>\n<b>2.2--主码：</b> 如果一个关系有多个候选码，可以从中选出一个作为元组的标识，称为主码或者主键<br>\n<i><b>(主码是关系模型中的一个很重要的概念，每个关系必须选择一个主码，选定之后不可以随便更改)</b></i><br>\n<b>2.3--主属性与非主属性：</b> 包含在任一候选码中的属性称为主属性，不包含在任一候选码的属性称为非主属性<br>\n<b>2.4--外码：</b>如果一个关系R1中的主码所对应的属性或属性集X还存在于另一个关系R2中，则称这个属性或属性集X为R2的外码\n\n\n<h1>3.关系模式的完整性约束</h1>\n<b>2.1 实体完整性 ：</b>\n每个关系都有主码，且主码对应的所有属性值不为空<br>\n<br>2.2 参照完整性 ：<br>\n如果关系R2的外码X与关系R1的主码对应，则X的值或等于R1的主码的某一个值<br>\n<br>2.3 用户自定义完整性 ：<br>\n用户根据自己的需求而定义的数据库约束条件<br>\n\n\n<h1 style=\"text-align: center; color: brown;\">关系数据库设计理论</h1>\n<h3>6.1--规范化理论：关系数据库设计理论也叫规范化理论</h3>\n<b>主要包括： 函数依赖 ，范式 ，模式设计\n</b><br>\n<b>不合理的关系模式存在的问题</b>\n<ul>\n    <li>删除异常</li>\n    <li>数据冗余</li>\n    <li>插入异常</li>\n    <li>更新异常</li>\n</ul>\n\n<h3>6.2--函数依赖概述</h3>\n<b>什么是函数依赖？</b>\n<b>函数依赖就是关系模式中属性之间的依赖关系</b><br>\n函数依赖与属性之间的联系有关：只有当属于X与属性Y之间存在1：1，m：1才存在函数依赖\n当属性X与属性Y之间的是m:n时，不存在函数依赖\n\n<p><b>逻辑蕴含的定义：</b></p>\n","site":{"data":{}},"wordcount":676,"excerpt":"","more":"<h1>1.关系模型的一些术语</h1>\n<ul>\n    <li>关系 ：一张二维表，二维表的名字就是关系的名字</li>\n    <li>属性 ： 二维表当中的列称为属性，列的个数称为元数，如果一个二维表有n列就是n元关系</li>\n    <li>元组 ： 二维表当中的行称为元组</li>\n    <li>分量 : 元组的每一个属性称为分量</li>\n</ul>\n\n\n<h1>2.关系的码</h1>\n<b>2.1--候选码:</b> 如果一个关系的某属性或属性集的值可以唯一确定一个元组，则称该属性或属性集为候选码<br>\n<b>2.2--主码：</b> 如果一个关系有多个候选码，可以从中选出一个作为元组的标识，称为主码或者主键<br>\n<i><b>(主码是关系模型中的一个很重要的概念，每个关系必须选择一个主码，选定之后不可以随便更改)</b></i><br>\n<b>2.3--主属性与非主属性：</b> 包含在任一候选码中的属性称为主属性，不包含在任一候选码的属性称为非主属性<br>\n<b>2.4--外码：</b>如果一个关系R1中的主码所对应的属性或属性集X还存在于另一个关系R2中，则称这个属性或属性集X为R2的外码\n\n\n<h1>3.关系模式的完整性约束</h1>\n<b>2.1 实体完整性 ：</b>\n每个关系都有主码，且主码对应的所有属性值不为空<br>\n<br>2.2 参照完整性 ：<br>\n如果关系R2的外码X与关系R1的主码对应，则X的值或等于R1的主码的某一个值<br>\n<br>2.3 用户自定义完整性 ：<br>\n用户根据自己的需求而定义的数据库约束条件<br>\n\n\n<h1 style=\"text-align: center; color: brown;\">关系数据库设计理论</h1>\n<h3>6.1--规范化理论：关系数据库设计理论也叫规范化理论</h3>\n<b>主要包括： 函数依赖 ，范式 ，模式设计\n</b><br>\n<b>不合理的关系模式存在的问题</b>\n<ul>\n    <li>删除异常</li>\n    <li>数据冗余</li>\n    <li>插入异常</li>\n    <li>更新异常</li>\n</ul>\n\n<h3>6.2--函数依赖概述</h3>\n<b>什么是函数依赖？</b>\n<b>函数依赖就是关系模式中属性之间的依赖关系</b><br>\n函数依赖与属性之间的联系有关：只有当属于X与属性Y之间存在1：1，m：1才存在函数依赖\n当属性X与属性Y之间的是m:n时，不存在函数依赖\n\n<p><b>逻辑蕴含的定义：</b></p>\n"},{"title":"dify 工作流二次开发","date":"2024-07-24T14:32:12.000Z","index_img":"/img/post/dify.png","_content":"\n### 前言\n\n[dify](https://github.com/langgenius/dify/tree/main/web) 的前端是用 next 来编写的(一个 react 的框架)，而其工作流使用了[react-flow](https://github.com/xyflow/xyflow)这个插件,最新版本名为 xyflow。我们需要参考其 workflow 定制一个属于自己的 ai 工作流，是一个有向无环图。\n\n![](https://img.badspider.top/%E5%8D%9A%E5%AE%A2/dify.jpg?e=1729933704&token=O5FexAXMDVkC96l0JKtw-Lt-5pW8odocO8uOerZ4:HZrH0ICHd9dPoIvbKMuiHwNCwyA=)\n\n### 困难\n\n1.需要在短时间内理解dify的工作流架构以及其封装的大量hooks的使用\n\n2.刚刚上手react\n\n3.配置项比较多，时间紧\n\n### 开发\n\n首先让我们来分析一下一个工作流中包含的元素：\n\n- **node节点**\n\n这是整个工作流的核心也是难点，基于不同的节点可以执行不同的操作，dify内置了多种节点`Http`,  `LLM`,`Code`,`\n\n1. 需要对不同的节点使用不同的配置项（也就是右侧的panel）\n\n2. 每个节点都可以有output 变量，要在输入的时候拿到你前面连接的节点的output变量作为自己的input变量，最后输出的时候判断哪些是临时变量， 就进行舍弃\n\n这个地方的难点就是如何拿到当前节点连接的前后节点，判断你这个节点可以使用的变量，其他都是一些力气活了。\n\n其中需要注意的，开始节点是不能删除的，dify的工作流对react-flow的删除节点操作进行了重写，采用了右键和del删除，这样子可操作性就很高了，而如果你不想改写的话，可以在<mark>applyNodeChanges</mark>的时候添加一个属性进行判断，我看官方是建议使用<mark>onBeforeDelete</mark>这个，但是这个返回的是整个nodes节点，拿不到当前删除的节点，同时react-flow删除的逻辑好像有点问题，有时候会出现删错的现象。\n\n- **edges边**\n\n在dify中一个节点只能连接一条边，除非使用了IF-ELSE节点来走不同的逻辑，而我们需要改造成一对多或者多对一的情况，在hooks中有一个对前后可连接节点的判断，可以在每次连接的时候判断是否可以连接\n\n- **workflow**\n\n这是对一整个工作流中数据的整合，有一个**use-workflow** hooks，在这里进行了数据的初始化，节点的操作和更新以及draft的一些操作，一开始写的时候，我还想着不按照他的来，写到后面发现这个是统筹全局，必不可少的一部分，然后又重新理解了一下。\n\n### 总结\n\n因为之前是一直用的Vue，这次对React中的hooks和zustand都有了更深的了解，最主要的是学习到了一个复杂的组件如何进一步合理和有逻辑的封装。在最初看一个大型的项目无从下手的时候，我觉得应该要从大的方向开始，先不看其内部的详细实现，当你理解了大致的逻辑之后，在分别详细的去看一大块里面的实现。看不明白的时候也不用急躁，可以休息一下或者转移方向，之后再回来看都是可以的。\n\n<mark>同时也不能只关注代码，需要大致的了解一下业务逻辑，特别是前端，很多时候只需要知道你需要什么样子的效果，那ok我实现出来就可以了，对业务的了解可以说是没有的。</mark>\n\n这个workflow对node和panel，utils，types，constants，operation，hooks都进行了很大的封装，大大降低了耦合度。\n\n还是得多看一些大型的开源项目，从他们中学习比较系统的封装和架构，这个是日常中很难去学习到的。\n\n以及如何才能提升自己的开发效率，我对接的那个后端大哥写接口是真快，我还在想怎么构建页面的时候他就把大部分的接口写完了。\n\n我的想法是1.对自己使用技术的熟练程度;2.对所开发项目的代码和业务理解程度。","source":"_posts/dify工作流的二次开发.md","raw":"---\ntitle: dify 工作流二次开发\ndate: 2024-7-24 22:32:12\ntags: 总结\ncategory: 前端\nindex_img: /img/post/dify.png\n---\n\n### 前言\n\n[dify](https://github.com/langgenius/dify/tree/main/web) 的前端是用 next 来编写的(一个 react 的框架)，而其工作流使用了[react-flow](https://github.com/xyflow/xyflow)这个插件,最新版本名为 xyflow。我们需要参考其 workflow 定制一个属于自己的 ai 工作流，是一个有向无环图。\n\n![](https://img.badspider.top/%E5%8D%9A%E5%AE%A2/dify.jpg?e=1729933704&token=O5FexAXMDVkC96l0JKtw-Lt-5pW8odocO8uOerZ4:HZrH0ICHd9dPoIvbKMuiHwNCwyA=)\n\n### 困难\n\n1.需要在短时间内理解dify的工作流架构以及其封装的大量hooks的使用\n\n2.刚刚上手react\n\n3.配置项比较多，时间紧\n\n### 开发\n\n首先让我们来分析一下一个工作流中包含的元素：\n\n- **node节点**\n\n这是整个工作流的核心也是难点，基于不同的节点可以执行不同的操作，dify内置了多种节点`Http`,  `LLM`,`Code`,`\n\n1. 需要对不同的节点使用不同的配置项（也就是右侧的panel）\n\n2. 每个节点都可以有output 变量，要在输入的时候拿到你前面连接的节点的output变量作为自己的input变量，最后输出的时候判断哪些是临时变量， 就进行舍弃\n\n这个地方的难点就是如何拿到当前节点连接的前后节点，判断你这个节点可以使用的变量，其他都是一些力气活了。\n\n其中需要注意的，开始节点是不能删除的，dify的工作流对react-flow的删除节点操作进行了重写，采用了右键和del删除，这样子可操作性就很高了，而如果你不想改写的话，可以在<mark>applyNodeChanges</mark>的时候添加一个属性进行判断，我看官方是建议使用<mark>onBeforeDelete</mark>这个，但是这个返回的是整个nodes节点，拿不到当前删除的节点，同时react-flow删除的逻辑好像有点问题，有时候会出现删错的现象。\n\n- **edges边**\n\n在dify中一个节点只能连接一条边，除非使用了IF-ELSE节点来走不同的逻辑，而我们需要改造成一对多或者多对一的情况，在hooks中有一个对前后可连接节点的判断，可以在每次连接的时候判断是否可以连接\n\n- **workflow**\n\n这是对一整个工作流中数据的整合，有一个**use-workflow** hooks，在这里进行了数据的初始化，节点的操作和更新以及draft的一些操作，一开始写的时候，我还想着不按照他的来，写到后面发现这个是统筹全局，必不可少的一部分，然后又重新理解了一下。\n\n### 总结\n\n因为之前是一直用的Vue，这次对React中的hooks和zustand都有了更深的了解，最主要的是学习到了一个复杂的组件如何进一步合理和有逻辑的封装。在最初看一个大型的项目无从下手的时候，我觉得应该要从大的方向开始，先不看其内部的详细实现，当你理解了大致的逻辑之后，在分别详细的去看一大块里面的实现。看不明白的时候也不用急躁，可以休息一下或者转移方向，之后再回来看都是可以的。\n\n<mark>同时也不能只关注代码，需要大致的了解一下业务逻辑，特别是前端，很多时候只需要知道你需要什么样子的效果，那ok我实现出来就可以了，对业务的了解可以说是没有的。</mark>\n\n这个workflow对node和panel，utils，types，constants，operation，hooks都进行了很大的封装，大大降低了耦合度。\n\n还是得多看一些大型的开源项目，从他们中学习比较系统的封装和架构，这个是日常中很难去学习到的。\n\n以及如何才能提升自己的开发效率，我对接的那个后端大哥写接口是真快，我还在想怎么构建页面的时候他就把大部分的接口写完了。\n\n我的想法是1.对自己使用技术的熟练程度;2.对所开发项目的代码和业务理解程度。","slug":"dify工作流的二次开发","published":1,"updated":"2024-11-17T13:58:10.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpk000z73t3aj7v38ha","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><a href=\"https://github.com/langgenius/dify/tree/main/web\">dify</a> 的前端是用 next 来编写的(一个 react 的框架)，而其工作流使用了<a href=\"https://github.com/xyflow/xyflow\">react-flow</a>这个插件,最新版本名为 xyflow。我们需要参考其 workflow 定制一个属于自己的 ai 工作流，是一个有向无环图。</p>\n<p><img src=\"https://img.badspider.top/%E5%8D%9A%E5%AE%A2/dify.jpg?e=1729933704&token=O5FexAXMDVkC96l0JKtw-Lt-5pW8odocO8uOerZ4:HZrH0ICHd9dPoIvbKMuiHwNCwyA=\"></p>\n<h3 id=\"困难\"><a href=\"#困难\" class=\"headerlink\" title=\"困难\"></a>困难</h3><p>1.需要在短时间内理解dify的工作流架构以及其封装的大量hooks的使用</p>\n<p>2.刚刚上手react</p>\n<p>3.配置项比较多，时间紧</p>\n<h3 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h3><p>首先让我们来分析一下一个工作流中包含的元素：</p>\n<ul>\n<li><strong>node节点</strong></li>\n</ul>\n<p>这是整个工作流的核心也是难点，基于不同的节点可以执行不同的操作，dify内置了多种节点<code>Http</code>,  <code>LLM</code>,<code>Code</code>,`</p>\n<ol>\n<li><p>需要对不同的节点使用不同的配置项（也就是右侧的panel）</p>\n</li>\n<li><p>每个节点都可以有output 变量，要在输入的时候拿到你前面连接的节点的output变量作为自己的input变量，最后输出的时候判断哪些是临时变量， 就进行舍弃</p>\n</li>\n</ol>\n<p>这个地方的难点就是如何拿到当前节点连接的前后节点，判断你这个节点可以使用的变量，其他都是一些力气活了。</p>\n<p>其中需要注意的，开始节点是不能删除的，dify的工作流对react-flow的删除节点操作进行了重写，采用了右键和del删除，这样子可操作性就很高了，而如果你不想改写的话，可以在<mark>applyNodeChanges</mark>的时候添加一个属性进行判断，我看官方是建议使用<mark>onBeforeDelete</mark>这个，但是这个返回的是整个nodes节点，拿不到当前删除的节点，同时react-flow删除的逻辑好像有点问题，有时候会出现删错的现象。</p>\n<ul>\n<li><strong>edges边</strong></li>\n</ul>\n<p>在dify中一个节点只能连接一条边，除非使用了IF-ELSE节点来走不同的逻辑，而我们需要改造成一对多或者多对一的情况，在hooks中有一个对前后可连接节点的判断，可以在每次连接的时候判断是否可以连接</p>\n<ul>\n<li><strong>workflow</strong></li>\n</ul>\n<p>这是对一整个工作流中数据的整合，有一个<strong>use-workflow</strong> hooks，在这里进行了数据的初始化，节点的操作和更新以及draft的一些操作，一开始写的时候，我还想着不按照他的来，写到后面发现这个是统筹全局，必不可少的一部分，然后又重新理解了一下。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>因为之前是一直用的Vue，这次对React中的hooks和zustand都有了更深的了解，最主要的是学习到了一个复杂的组件如何进一步合理和有逻辑的封装。在最初看一个大型的项目无从下手的时候，我觉得应该要从大的方向开始，先不看其内部的详细实现，当你理解了大致的逻辑之后，在分别详细的去看一大块里面的实现。看不明白的时候也不用急躁，可以休息一下或者转移方向，之后再回来看都是可以的。</p>\n<p><mark>同时也不能只关注代码，需要大致的了解一下业务逻辑，特别是前端，很多时候只需要知道你需要什么样子的效果，那ok我实现出来就可以了，对业务的了解可以说是没有的。</mark></p>\n<p>这个workflow对node和panel，utils，types，constants，operation，hooks都进行了很大的封装，大大降低了耦合度。</p>\n<p>还是得多看一些大型的开源项目，从他们中学习比较系统的封装和架构，这个是日常中很难去学习到的。</p>\n<p>以及如何才能提升自己的开发效率，我对接的那个后端大哥写接口是真快，我还在想怎么构建页面的时候他就把大部分的接口写完了。</p>\n<p>我的想法是1.对自己使用技术的熟练程度;2.对所开发项目的代码和业务理解程度。</p>\n","site":{"data":{}},"wordcount":1354,"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><a href=\"https://github.com/langgenius/dify/tree/main/web\">dify</a> 的前端是用 next 来编写的(一个 react 的框架)，而其工作流使用了<a href=\"https://github.com/xyflow/xyflow\">react-flow</a>这个插件,最新版本名为 xyflow。我们需要参考其 workflow 定制一个属于自己的 ai 工作流，是一个有向无环图。</p>\n<p><img src=\"https://img.badspider.top/%E5%8D%9A%E5%AE%A2/dify.jpg?e=1729933704&token=O5FexAXMDVkC96l0JKtw-Lt-5pW8odocO8uOerZ4:HZrH0ICHd9dPoIvbKMuiHwNCwyA=\"></p>\n<h3 id=\"困难\"><a href=\"#困难\" class=\"headerlink\" title=\"困难\"></a>困难</h3><p>1.需要在短时间内理解dify的工作流架构以及其封装的大量hooks的使用</p>\n<p>2.刚刚上手react</p>\n<p>3.配置项比较多，时间紧</p>\n<h3 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h3><p>首先让我们来分析一下一个工作流中包含的元素：</p>\n<ul>\n<li><strong>node节点</strong></li>\n</ul>\n<p>这是整个工作流的核心也是难点，基于不同的节点可以执行不同的操作，dify内置了多种节点<code>Http</code>,  <code>LLM</code>,<code>Code</code>,`</p>\n<ol>\n<li><p>需要对不同的节点使用不同的配置项（也就是右侧的panel）</p>\n</li>\n<li><p>每个节点都可以有output 变量，要在输入的时候拿到你前面连接的节点的output变量作为自己的input变量，最后输出的时候判断哪些是临时变量， 就进行舍弃</p>\n</li>\n</ol>\n<p>这个地方的难点就是如何拿到当前节点连接的前后节点，判断你这个节点可以使用的变量，其他都是一些力气活了。</p>\n<p>其中需要注意的，开始节点是不能删除的，dify的工作流对react-flow的删除节点操作进行了重写，采用了右键和del删除，这样子可操作性就很高了，而如果你不想改写的话，可以在<mark>applyNodeChanges</mark>的时候添加一个属性进行判断，我看官方是建议使用<mark>onBeforeDelete</mark>这个，但是这个返回的是整个nodes节点，拿不到当前删除的节点，同时react-flow删除的逻辑好像有点问题，有时候会出现删错的现象。</p>\n<ul>\n<li><strong>edges边</strong></li>\n</ul>\n<p>在dify中一个节点只能连接一条边，除非使用了IF-ELSE节点来走不同的逻辑，而我们需要改造成一对多或者多对一的情况，在hooks中有一个对前后可连接节点的判断，可以在每次连接的时候判断是否可以连接</p>\n<ul>\n<li><strong>workflow</strong></li>\n</ul>\n<p>这是对一整个工作流中数据的整合，有一个<strong>use-workflow</strong> hooks，在这里进行了数据的初始化，节点的操作和更新以及draft的一些操作，一开始写的时候，我还想着不按照他的来，写到后面发现这个是统筹全局，必不可少的一部分，然后又重新理解了一下。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>因为之前是一直用的Vue，这次对React中的hooks和zustand都有了更深的了解，最主要的是学习到了一个复杂的组件如何进一步合理和有逻辑的封装。在最初看一个大型的项目无从下手的时候，我觉得应该要从大的方向开始，先不看其内部的详细实现，当你理解了大致的逻辑之后，在分别详细的去看一大块里面的实现。看不明白的时候也不用急躁，可以休息一下或者转移方向，之后再回来看都是可以的。</p>\n<p><mark>同时也不能只关注代码，需要大致的了解一下业务逻辑，特别是前端，很多时候只需要知道你需要什么样子的效果，那ok我实现出来就可以了，对业务的了解可以说是没有的。</mark></p>\n<p>这个workflow对node和panel，utils，types，constants，operation，hooks都进行了很大的封装，大大降低了耦合度。</p>\n<p>还是得多看一些大型的开源项目，从他们中学习比较系统的封装和架构，这个是日常中很难去学习到的。</p>\n<p>以及如何才能提升自己的开发效率，我对接的那个后端大哥写接口是真快，我还在想怎么构建页面的时候他就把大部分的接口写完了。</p>\n<p>我的想法是1.对自己使用技术的熟练程度;2.对所开发项目的代码和业务理解程度。</p>\n"},{"title":"Hello World","date":"2020-08-02T02:26:13.000Z","index_img":"/img/hello.jpg","banner_img":"/img/a.jpg","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2020-08-2 10:26:13\ntags: hello world\ncategories: blog\nindex_img: /img/hello.jpg\nbanner_img: /img/a.jpg\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2024-11-17T13:58:10.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpk001373t375js8tes","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"wordcount":367,"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"关于用hexo和GitHub搭建自己的免费博客","date":"2020-08-12T02:26:13.000Z","index_img":"/img/hexo.jpg","banner_img":"/img/3.jpg","_content":"@[TOC]( )\n# 前言\n##  1.为什么要搭建博客\n* 暑假在家没什么事情，就想着自己可以搭建一个有自己个性，好看点的网站，但是技术又不够，刚好看到hexo这个框架，主打的就是依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架，**平时可以记下自己的笔记，以后遇到同样的问题就不用到处去找了**\n##  2.搭建博客的作用\n1、发布个人博客网站，不受平台约束，充分发表个人态度。\n\n2、平台改版也不会影响到博客内容的发布\n\n3、不会出现博客内容丢失的情况\n\n4、个人博客网站交互性更强\n\n5、更利于博客网站的优化和推广\n#   需要准备的搭建环境\n##   1.Node.js\n### 1.1下载node.js\n- Node.js 的实质是一个JavaScript运行环境,在这里我们使用它来生成我们博客的静态页面------- ==Node.js==[官网](http://nodejs.cn/).\n- 根据你的电脑下载对应的版本就可以了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810214856831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n**（注意下载的是msi）**\n###   1.2 搭建node.js的环境\n- 这里直接就一直点==next==就ok了，不用点别的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810215147363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n- 当你安装完成之后，查看一下是否安装成功\n- 用win+R输入cmd打开电脑的终端，输入node -v，查看是否安装成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810215458159.png)\n**如果出现版本号就说明安装成功了**\n\n##  2.Git\n###  2.1 下载Git\nGit的 [官网](https://git-scm.com/) 根据自己的电脑下载对应的版本就可以了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810215945900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n###  2.2 安装Git\n- 和上面安装一样，一直==next==就可以了\n**当然如果你不安装在c盘的话就自己选一个别的盘安装（最好不要安装在c盘）**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810220035692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n###  2.3判断git安装成功\n在桌面鼠标点击右键，有Git GUI Here和Git Bash Here，则安装成功![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810220527448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n\n\n\n或者你看看新安装的程序里面有没有这三个\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810220516596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n##  3.安装淘宝镜像\n- 在桌面鼠标右键或者任意一个地方，选择Git Bash Here\n- 输入下面的代码，静静等待就可以了\n\n```\ncnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n##  4.安装hexo博客\n###  1.在你喜欢的盘下面新建一个文件夹\n- （你可以起名为myblog）然后进入这个文件夹，右键==Git Bash Here==打开Git终端输入以下代码\n```javascript\nnpm install hexo-cli -g\nnpm install hexo-deployer-git --save\n```\n可以用`hexo -v`来检查是否安装成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810221842905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n### 2.初始化博客\n进入该文件夹右键 Git Bash Here，输入以下命令\n- 输入  ```hexo  init ```初始化自己的博客\n- 然后你就可以看到你的myblog文件夹里面多了好多文件，其中有一个_config.yml文件![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810222427595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n这个就是你的基本配置文件\n\n#  在本地安装完成了\n- 在文件夹右键Git Bash Here执行以下命令，执行完即可点击[http://localhost:4000/](http://localhost:4000/) 查看效果\n```javascript\n$ hexo generate\n$ hexo server\n```\n- 如果出现了以下信息就说明成功了\n```j\nINFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810224147173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n#  将博客部署到 GitHub上面去\n- 到目前为止，我们的本地博客就成功搭建了，但是现在我们只能通过本地连接查看博客，我们要做的是让其他人也能够访问我们的博客，这就需要我们将博客部署到Github Pages上\n##  1.注册GitHub账户：\n[点击此处](https://github.com/) 访问官网，点击 sign up 注册账户\n\n##  2.创建项目代码库\n点击 ==New repository==开始创建\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810224738547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n##  3.配置==ssh==密匙\n- 只有配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步，在你第一次新建的文件夹里面（如：我的文件夹为：D\\blog） Git Bash Here 输入以下命令\n```j\n$ ssh-keygen -t rsa -C \"your email@qq.com\"\n//引号里面填写你的邮箱地址\n```\n- 然后就会有\n```jEnter passphrase (empty for no passphrase):\n//不要输入直接回车就行\nEnter same passphrase again\n```\n- 接下来就会有\n```jYour identification has been saved in /c/Users/you/.ssh/id_rsa.\nYour public key has been saved in /c/Users/you/.ssh/id_rsa.pub.\nThe key fingerprint is:\n这里是各种字母数字组成的字符串，结尾是你的邮箱\nThe key's randomart image is:\n这里也是各种字母数字符号组成的字符串\n```\n- 运行以下命令，将公钥的内容复制到系统粘贴板上\n```j\n$ clip < ~/.ssh/id_rsa.pub\n```\n\n##  4.在GitHub中添加你的公匙\n###  4.1登陆 GitHub，进入 Settings：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810225604719.png)\n###  4.2点击 ==SHH and GPG Keys==\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810225700749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n###  4.3选择 ==New SSH Key：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810225800165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n###  4.4粘贴密匙：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810225739776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n###  4.5测试\n输入以下命令：\n```j\n$ ssh -T git@github.com\n```\n- 看到（yes/no）之后输入yes会显示：\n```j\nHi xxx!You've successfully ..............\n```\n就说明设置正确\n###  4.6配置Git个人信息\n- Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致\n```j\n$ git config --global user.name \"此处填你的用户名\"\n$ git config --global user.email \"此处填你的邮箱\"\n```\n到此为止 SSH Key 配置成功，本机已成功连接到 Github\n\n##  5.将本地的 Hexo 文件更新到 Github 的库中\n- 一、登录 Github 打开自己的项目 yourname.github.io\n- 二、鼠标移到 Clone or download 按钮，选择 Use SSH\n- 三、一键复制地址\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810230750561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n\n- 四、打开你创建的 Hexo 文件夹（如：D:\\\\myblog），右键打开该文件夹下的 _config.yml 文件，在文件的最下面有==deploy==\n**改成如下的样子：**\n\n```j\ndeploy:\n\ttype: git #注意冒号后面都有一个空\n\trepository: #刚刚复制的内容\n\tbranch: master\n```\n##  6.在 Hexo 文件夹下分别执行以下命令\n\n```c\n$ hexo g\n$ hexo d\n```\n或者直接执行\n\n```c\n$ hexo g -d\n```\n执行完之后会让你输入你的 Github 的账号和密码，如果此时报以下错误，说明你的 deployer 没有安装成功\n\n```c\nERROR Deployer not found: git\n```\n需要执行以下命令再安装一次\n\n```c\nnpm install hexo-deployer-git --save\n```\n再执行 ```j\nhexo g -d```你的博客就会部署到 Github 上了\n##  7.访问博客\n==你的博客地址：https://你的用户名.github.io==","source":"_posts/hexo.md","raw":"---\ntitle: 关于用hexo和GitHub搭建自己的免费博客\ndate: 2020-08-12 10:26:13\ntags: hexo\ncategories: blog\nindex_img: /img/hexo.jpg\nbanner_img: /img/3.jpg\n---\n@[TOC]( )\n# 前言\n##  1.为什么要搭建博客\n* 暑假在家没什么事情，就想着自己可以搭建一个有自己个性，好看点的网站，但是技术又不够，刚好看到hexo这个框架，主打的就是依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架，**平时可以记下自己的笔记，以后遇到同样的问题就不用到处去找了**\n##  2.搭建博客的作用\n1、发布个人博客网站，不受平台约束，充分发表个人态度。\n\n2、平台改版也不会影响到博客内容的发布\n\n3、不会出现博客内容丢失的情况\n\n4、个人博客网站交互性更强\n\n5、更利于博客网站的优化和推广\n#   需要准备的搭建环境\n##   1.Node.js\n### 1.1下载node.js\n- Node.js 的实质是一个JavaScript运行环境,在这里我们使用它来生成我们博客的静态页面------- ==Node.js==[官网](http://nodejs.cn/).\n- 根据你的电脑下载对应的版本就可以了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810214856831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n**（注意下载的是msi）**\n###   1.2 搭建node.js的环境\n- 这里直接就一直点==next==就ok了，不用点别的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810215147363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n- 当你安装完成之后，查看一下是否安装成功\n- 用win+R输入cmd打开电脑的终端，输入node -v，查看是否安装成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810215458159.png)\n**如果出现版本号就说明安装成功了**\n\n##  2.Git\n###  2.1 下载Git\nGit的 [官网](https://git-scm.com/) 根据自己的电脑下载对应的版本就可以了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810215945900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n###  2.2 安装Git\n- 和上面安装一样，一直==next==就可以了\n**当然如果你不安装在c盘的话就自己选一个别的盘安装（最好不要安装在c盘）**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810220035692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n###  2.3判断git安装成功\n在桌面鼠标点击右键，有Git GUI Here和Git Bash Here，则安装成功![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810220527448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n\n\n\n或者你看看新安装的程序里面有没有这三个\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810220516596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n##  3.安装淘宝镜像\n- 在桌面鼠标右键或者任意一个地方，选择Git Bash Here\n- 输入下面的代码，静静等待就可以了\n\n```\ncnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n##  4.安装hexo博客\n###  1.在你喜欢的盘下面新建一个文件夹\n- （你可以起名为myblog）然后进入这个文件夹，右键==Git Bash Here==打开Git终端输入以下代码\n```javascript\nnpm install hexo-cli -g\nnpm install hexo-deployer-git --save\n```\n可以用`hexo -v`来检查是否安装成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810221842905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n### 2.初始化博客\n进入该文件夹右键 Git Bash Here，输入以下命令\n- 输入  ```hexo  init ```初始化自己的博客\n- 然后你就可以看到你的myblog文件夹里面多了好多文件，其中有一个_config.yml文件![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810222427595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n这个就是你的基本配置文件\n\n#  在本地安装完成了\n- 在文件夹右键Git Bash Here执行以下命令，执行完即可点击[http://localhost:4000/](http://localhost:4000/) 查看效果\n```javascript\n$ hexo generate\n$ hexo server\n```\n- 如果出现了以下信息就说明成功了\n```j\nINFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810224147173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n#  将博客部署到 GitHub上面去\n- 到目前为止，我们的本地博客就成功搭建了，但是现在我们只能通过本地连接查看博客，我们要做的是让其他人也能够访问我们的博客，这就需要我们将博客部署到Github Pages上\n##  1.注册GitHub账户：\n[点击此处](https://github.com/) 访问官网，点击 sign up 注册账户\n\n##  2.创建项目代码库\n点击 ==New repository==开始创建\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810224738547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n##  3.配置==ssh==密匙\n- 只有配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步，在你第一次新建的文件夹里面（如：我的文件夹为：D\\blog） Git Bash Here 输入以下命令\n```j\n$ ssh-keygen -t rsa -C \"your email@qq.com\"\n//引号里面填写你的邮箱地址\n```\n- 然后就会有\n```jEnter passphrase (empty for no passphrase):\n//不要输入直接回车就行\nEnter same passphrase again\n```\n- 接下来就会有\n```jYour identification has been saved in /c/Users/you/.ssh/id_rsa.\nYour public key has been saved in /c/Users/you/.ssh/id_rsa.pub.\nThe key fingerprint is:\n这里是各种字母数字组成的字符串，结尾是你的邮箱\nThe key's randomart image is:\n这里也是各种字母数字符号组成的字符串\n```\n- 运行以下命令，将公钥的内容复制到系统粘贴板上\n```j\n$ clip < ~/.ssh/id_rsa.pub\n```\n\n##  4.在GitHub中添加你的公匙\n###  4.1登陆 GitHub，进入 Settings：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810225604719.png)\n###  4.2点击 ==SHH and GPG Keys==\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810225700749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n###  4.3选择 ==New SSH Key：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810225800165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n###  4.4粘贴密匙：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810225739776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n###  4.5测试\n输入以下命令：\n```j\n$ ssh -T git@github.com\n```\n- 看到（yes/no）之后输入yes会显示：\n```j\nHi xxx!You've successfully ..............\n```\n就说明设置正确\n###  4.6配置Git个人信息\n- Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致\n```j\n$ git config --global user.name \"此处填你的用户名\"\n$ git config --global user.email \"此处填你的邮箱\"\n```\n到此为止 SSH Key 配置成功，本机已成功连接到 Github\n\n##  5.将本地的 Hexo 文件更新到 Github 的库中\n- 一、登录 Github 打开自己的项目 yourname.github.io\n- 二、鼠标移到 Clone or download 按钮，选择 Use SSH\n- 三、一键复制地址\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810230750561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70)\n\n- 四、打开你创建的 Hexo 文件夹（如：D:\\\\myblog），右键打开该文件夹下的 _config.yml 文件，在文件的最下面有==deploy==\n**改成如下的样子：**\n\n```j\ndeploy:\n\ttype: git #注意冒号后面都有一个空\n\trepository: #刚刚复制的内容\n\tbranch: master\n```\n##  6.在 Hexo 文件夹下分别执行以下命令\n\n```c\n$ hexo g\n$ hexo d\n```\n或者直接执行\n\n```c\n$ hexo g -d\n```\n执行完之后会让你输入你的 Github 的账号和密码，如果此时报以下错误，说明你的 deployer 没有安装成功\n\n```c\nERROR Deployer not found: git\n```\n需要执行以下命令再安装一次\n\n```c\nnpm install hexo-deployer-git --save\n```\n再执行 ```j\nhexo g -d```你的博客就会部署到 Github 上了\n##  7.访问博客\n==你的博客地址：https://你的用户名.github.io==","slug":"hexo","published":1,"updated":"2024-11-17T13:58:10.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpk001573t3a89v8zi5","content":"<p>@<a href>TOC</a></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><h2 id=\"1-为什么要搭建博客\"><a href=\"#1-为什么要搭建博客\" class=\"headerlink\" title=\"1.为什么要搭建博客\"></a>1.为什么要搭建博客</h2><ul>\n<li>暑假在家没什么事情，就想着自己可以搭建一个有自己个性，好看点的网站，但是技术又不够，刚好看到hexo这个框架，主打的就是依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架，<strong>平时可以记下自己的笔记，以后遇到同样的问题就不用到处去找了</strong><h2 id=\"2-搭建博客的作用\"><a href=\"#2-搭建博客的作用\" class=\"headerlink\" title=\"2.搭建博客的作用\"></a>2.搭建博客的作用</h2>1、发布个人博客网站，不受平台约束，充分发表个人态度。</li>\n</ul>\n<p>2、平台改版也不会影响到博客内容的发布</p>\n<p>3、不会出现博客内容丢失的情况</p>\n<p>4、个人博客网站交互性更强</p>\n<p>5、更利于博客网站的优化和推广</p>\n<h1 id=\"需要准备的搭建环境\"><a href=\"#需要准备的搭建环境\" class=\"headerlink\" title=\"需要准备的搭建环境\"></a>需要准备的搭建环境</h1><h2 id=\"1-Node-js\"><a href=\"#1-Node-js\" class=\"headerlink\" title=\"1.Node.js\"></a>1.Node.js</h2><h3 id=\"1-1下载node-js\"><a href=\"#1-1下载node-js\" class=\"headerlink\" title=\"1.1下载node.js\"></a>1.1下载node.js</h3><ul>\n<li>Node.js 的实质是一个JavaScript运行环境,在这里我们使用它来生成我们博客的静态页面——- ==Node.js==<a href=\"http://nodejs.cn/\">官网</a>.</li>\n<li>根据你的电脑下载对应的版本就可以了<br><img src=\"https://img-blog.csdnimg.cn/20200810214856831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<p><strong>（注意下载的是msi）</strong></p>\n<h3 id=\"1-2-搭建node-js的环境\"><a href=\"#1-2-搭建node-js的环境\" class=\"headerlink\" title=\"1.2 搭建node.js的环境\"></a>1.2 搭建node.js的环境</h3><ul>\n<li>这里直接就一直点==next==就ok了，不用点别的<br><img src=\"https://img-blog.csdnimg.cn/20200810215147363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n<li>当你安装完成之后，查看一下是否安装成功</li>\n<li>用win+R输入cmd打开电脑的终端，输入node -v，查看是否安装成功<br><img src=\"https://img-blog.csdnimg.cn/20200810215458159.png\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<p><strong>如果出现版本号就说明安装成功了</strong></p>\n<h2 id=\"2-Git\"><a href=\"#2-Git\" class=\"headerlink\" title=\"2.Git\"></a>2.Git</h2><h3 id=\"2-1-下载Git\"><a href=\"#2-1-下载Git\" class=\"headerlink\" title=\"2.1 下载Git\"></a>2.1 下载Git</h3><p>Git的 <a href=\"https://git-scm.com/\">官网</a> 根据自己的电脑下载对应的版本就可以了<br><img src=\"https://img-blog.csdnimg.cn/20200810215945900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-2-安装Git\"><a href=\"#2-2-安装Git\" class=\"headerlink\" title=\"2.2 安装Git\"></a>2.2 安装Git</h3><ul>\n<li>和上面安装一样，一直==next==就可以了</li>\n</ul>\n<p><strong>当然如果你不安装在c盘的话就自己选一个别的盘安装（最好不要安装在c盘）</strong><br><img src=\"https://img-blog.csdnimg.cn/20200810220035692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-3判断git安装成功\"><a href=\"#2-3判断git安装成功\" class=\"headerlink\" title=\"2.3判断git安装成功\"></a>2.3判断git安装成功</h3><p>在桌面鼠标点击右键，有Git GUI Here和Git Bash Here，则安装成功<img src=\"https://img-blog.csdnimg.cn/20200810220527448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>或者你看看新安装的程序里面有没有这三个<br><img src=\"https://img-blog.csdnimg.cn/20200810220516596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-安装淘宝镜像\"><a href=\"#3-安装淘宝镜像\" class=\"headerlink\" title=\"3.安装淘宝镜像\"></a>3.安装淘宝镜像</h2><ul>\n<li>在桌面鼠标右键或者任意一个地方，选择Git Bash Here</li>\n<li>输入下面的代码，静静等待就可以了</li>\n</ul>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">cnpm install -<span class=\"hljs-selector-tag\">g</span> cnpm <span class=\"hljs-attr\">--registry</span>=https:<span class=\"hljs-comment\">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"4-安装hexo博客\"><a href=\"#4-安装hexo博客\" class=\"headerlink\" title=\"4.安装hexo博客\"></a>4.安装hexo博客</h2><h3 id=\"1-在你喜欢的盘下面新建一个文件夹\"><a href=\"#1-在你喜欢的盘下面新建一个文件夹\" class=\"headerlink\" title=\"1.在你喜欢的盘下面新建一个文件夹\"></a>1.在你喜欢的盘下面新建一个文件夹</h3><ul>\n<li>（你可以起名为myblog）然后进入这个文件夹，右键==Git Bash Here==打开Git终端输入以下代码<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">npm install hexo-cli -g<br>npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure>\n可以用<code>hexo -v</code>来检查是否安装成功<br><img src=\"https://img-blog.csdnimg.cn/20200810221842905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><h3 id=\"2-初始化博客\"><a href=\"#2-初始化博客\" class=\"headerlink\" title=\"2.初始化博客\"></a>2.初始化博客</h3>进入该文件夹右键 Git Bash Here，输入以下命令</li>\n<li>输入  <code>hexo  init </code>初始化自己的博客</li>\n<li>然后你就可以看到你的myblog文件夹里面多了好多文件，其中有一个_config.yml文件<img src=\"https://img-blog.csdnimg.cn/20200810222427595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>这个就是你的基本配置文件</li>\n</ul>\n<h1 id=\"在本地安装完成了\"><a href=\"#在本地安装完成了\" class=\"headerlink\" title=\"在本地安装完成了\"></a>在本地安装完成了</h1><ul>\n<li>在文件夹右键Git Bash Here执行以下命令，执行完即可点击<a href=\"http://localhost:4000/\">http://localhost:4000/</a> 查看效果<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$ hexo generate<br>$ hexo server<br></code></pre></td></tr></table></figure></li>\n<li>如果出现了以下信息就说明成功了<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure>\n<img src=\"https://img-blog.csdnimg.cn/20200810224147173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><h1 id=\"将博客部署到-GitHub上面去\"><a href=\"#将博客部署到-GitHub上面去\" class=\"headerlink\" title=\"将博客部署到 GitHub上面去\"></a>将博客部署到 GitHub上面去</h1></li>\n<li>到目前为止，我们的本地博客就成功搭建了，但是现在我们只能通过本地连接查看博客，我们要做的是让其他人也能够访问我们的博客，这就需要我们将博客部署到Github Pages上<h2 id=\"1-注册GitHub账户：\"><a href=\"#1-注册GitHub账户：\" class=\"headerlink\" title=\"1.注册GitHub账户：\"></a>1.注册GitHub账户：</h2><a href=\"https://github.com/\">点击此处</a> 访问官网，点击 sign up 注册账户</li>\n</ul>\n<h2 id=\"2-创建项目代码库\"><a href=\"#2-创建项目代码库\" class=\"headerlink\" title=\"2.创建项目代码库\"></a>2.创建项目代码库</h2><p>点击 ==New repository==开始创建<br><img src=\"https://img-blog.csdnimg.cn/20200810224738547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-配置-ssh-密匙\"><a href=\"#3-配置-ssh-密匙\" class=\"headerlink\" title=\"3.配置==ssh==密匙\"></a>3.配置==ssh==密匙</h2><ul>\n<li>只有配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步，在你第一次新建的文件夹里面（如：我的文件夹为：D\\blog） Git Bash Here 输入以下命令<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">$ ssh-keygen -t rsa -C &quot;your email@qq.com&quot;<br>//引号里面填写你的邮箱地址<br></code></pre></td></tr></table></figure></li>\n<li>然后就会有<figure class=\"highlight plaintext\"><figcaption><span>passphrase (empty for no passphrase):</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jEnter\">//不要输入直接回车就行<br>Enter same passphrase again<br></code></pre></td></tr></table></figure></li>\n<li>接下来就会有<figure class=\"highlight plaintext\"><figcaption><span>identification has been saved in</span><a href=\"/c/Users/you/.ssh/id_rsa.\">link</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jYour\">Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>这里是各种字母数字组成的字符串，结尾是你的邮箱<br>The key&#x27;s randomart image is:<br>这里也是各种字母数字符号组成的字符串<br></code></pre></td></tr></table></figure></li>\n<li>运行以下命令，将公钥的内容复制到系统粘贴板上<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">$ clip &lt; ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"4-在GitHub中添加你的公匙\"><a href=\"#4-在GitHub中添加你的公匙\" class=\"headerlink\" title=\"4.在GitHub中添加你的公匙\"></a>4.在GitHub中添加你的公匙</h2><h3 id=\"4-1登陆-GitHub，进入-Settings：\"><a href=\"#4-1登陆-GitHub，进入-Settings：\" class=\"headerlink\" title=\"4.1登陆 GitHub，进入 Settings：\"></a>4.1登陆 GitHub，进入 Settings：</h3><p><img src=\"https://img-blog.csdnimg.cn/20200810225604719.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-2点击-SHH-and-GPG-Keys\"><a href=\"#4-2点击-SHH-and-GPG-Keys\" class=\"headerlink\" title=\"4.2点击 ==SHH and GPG Keys==\"></a>4.2点击 ==SHH and GPG Keys==</h3><p><img src=\"https://img-blog.csdnimg.cn/20200810225700749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-3选择-New-SSH-Key：\"><a href=\"#4-3选择-New-SSH-Key：\" class=\"headerlink\" title=\"4.3选择 ==New SSH Key：\"></a>4.3选择 ==New SSH Key：</h3><p><img src=\"https://img-blog.csdnimg.cn/20200810225800165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-4粘贴密匙：\"><a href=\"#4-4粘贴密匙：\" class=\"headerlink\" title=\"4.4粘贴密匙：\"></a>4.4粘贴密匙：</h3><p><img src=\"https://img-blog.csdnimg.cn/20200810225739776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-5测试\"><a href=\"#4-5测试\" class=\"headerlink\" title=\"4.5测试\"></a>4.5测试</h3><p>输入以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">$ ssh -T git@github.com<br></code></pre></td></tr></table></figure>\n<ul>\n<li>看到（yes/no）之后输入yes会显示：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">Hi xxx!You&#x27;ve successfully ..............<br></code></pre></td></tr></table></figure>\n就说明设置正确<h3 id=\"4-6配置Git个人信息\"><a href=\"#4-6配置Git个人信息\" class=\"headerlink\" title=\"4.6配置Git个人信息\"></a>4.6配置Git个人信息</h3></li>\n<li>Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">$ git config --global user.name &quot;此处填你的用户名&quot;<br>$ git config --global user.email &quot;此处填你的邮箱&quot;<br></code></pre></td></tr></table></figure>\n到此为止 SSH Key 配置成功，本机已成功连接到 Github</li>\n</ul>\n<h2 id=\"5-将本地的-Hexo-文件更新到-Github-的库中\"><a href=\"#5-将本地的-Hexo-文件更新到-Github-的库中\" class=\"headerlink\" title=\"5.将本地的 Hexo 文件更新到 Github 的库中\"></a>5.将本地的 Hexo 文件更新到 Github 的库中</h2><ul>\n<li><p>一、登录 Github 打开自己的项目 yourname.github.io</p>\n</li>\n<li><p>二、鼠标移到 Clone or download 按钮，选择 Use SSH</p>\n</li>\n<li><p>三、一键复制地址<br><img src=\"https://img-blog.csdnimg.cn/20200810230750561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>四、打开你创建的 Hexo 文件夹（如：D:\\myblog），右键打开该文件夹下的 _config.yml 文件，在文件的最下面有==deploy==</p>\n</li>\n</ul>\n<p><strong>改成如下的样子：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">deploy:<br>\ttype: git #注意冒号后面都有一个空<br>\trepository: #刚刚复制的内容<br>\tbranch: master<br></code></pre></td></tr></table></figure>\n<h2 id=\"6-在-Hexo-文件夹下分别执行以下命令\"><a href=\"#6-在-Hexo-文件夹下分别执行以下命令\" class=\"headerlink\" title=\"6.在 Hexo 文件夹下分别执行以下命令\"></a>6.在 Hexo 文件夹下分别执行以下命令</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">$ hexo g<br>$ hexo d<br></code></pre></td></tr></table></figure>\n<p>或者直接执行</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">$ hexo g -d<br></code></pre></td></tr></table></figure>\n<p>执行完之后会让你输入你的 Github 的账号和密码，如果此时报以下错误，说明你的 deployer 没有安装成功</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">ERROR Deployer not found: git<br></code></pre></td></tr></table></figure>\n<p>需要执行以下命令再安装一次</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure>\n<p>再执行 <code>j hexo g -d</code>你的博客就会部署到 Github 上了</p>\n<h2 id=\"7-访问博客\"><a href=\"#7-访问博客\" class=\"headerlink\" title=\"7.访问博客\"></a>7.访问博客</h2><p>==你的博客地址：https://你的用户名.github.io==</p>\n","site":{"data":{}},"wordcount":2763,"excerpt":"","more":"<p>@<a href>TOC</a></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><h2 id=\"1-为什么要搭建博客\"><a href=\"#1-为什么要搭建博客\" class=\"headerlink\" title=\"1.为什么要搭建博客\"></a>1.为什么要搭建博客</h2><ul>\n<li>暑假在家没什么事情，就想着自己可以搭建一个有自己个性，好看点的网站，但是技术又不够，刚好看到hexo这个框架，主打的就是依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架，<strong>平时可以记下自己的笔记，以后遇到同样的问题就不用到处去找了</strong><h2 id=\"2-搭建博客的作用\"><a href=\"#2-搭建博客的作用\" class=\"headerlink\" title=\"2.搭建博客的作用\"></a>2.搭建博客的作用</h2>1、发布个人博客网站，不受平台约束，充分发表个人态度。</li>\n</ul>\n<p>2、平台改版也不会影响到博客内容的发布</p>\n<p>3、不会出现博客内容丢失的情况</p>\n<p>4、个人博客网站交互性更强</p>\n<p>5、更利于博客网站的优化和推广</p>\n<h1 id=\"需要准备的搭建环境\"><a href=\"#需要准备的搭建环境\" class=\"headerlink\" title=\"需要准备的搭建环境\"></a>需要准备的搭建环境</h1><h2 id=\"1-Node-js\"><a href=\"#1-Node-js\" class=\"headerlink\" title=\"1.Node.js\"></a>1.Node.js</h2><h3 id=\"1-1下载node-js\"><a href=\"#1-1下载node-js\" class=\"headerlink\" title=\"1.1下载node.js\"></a>1.1下载node.js</h3><ul>\n<li>Node.js 的实质是一个JavaScript运行环境,在这里我们使用它来生成我们博客的静态页面——- ==Node.js==<a href=\"http://nodejs.cn/\">官网</a>.</li>\n<li>根据你的电脑下载对应的版本就可以了<br><img src=\"https://img-blog.csdnimg.cn/20200810214856831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<p><strong>（注意下载的是msi）</strong></p>\n<h3 id=\"1-2-搭建node-js的环境\"><a href=\"#1-2-搭建node-js的环境\" class=\"headerlink\" title=\"1.2 搭建node.js的环境\"></a>1.2 搭建node.js的环境</h3><ul>\n<li>这里直接就一直点==next==就ok了，不用点别的<br><img src=\"https://img-blog.csdnimg.cn/20200810215147363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n<li>当你安装完成之后，查看一下是否安装成功</li>\n<li>用win+R输入cmd打开电脑的终端，输入node -v，查看是否安装成功<br><img src=\"https://img-blog.csdnimg.cn/20200810215458159.png\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<p><strong>如果出现版本号就说明安装成功了</strong></p>\n<h2 id=\"2-Git\"><a href=\"#2-Git\" class=\"headerlink\" title=\"2.Git\"></a>2.Git</h2><h3 id=\"2-1-下载Git\"><a href=\"#2-1-下载Git\" class=\"headerlink\" title=\"2.1 下载Git\"></a>2.1 下载Git</h3><p>Git的 <a href=\"https://git-scm.com/\">官网</a> 根据自己的电脑下载对应的版本就可以了<br><img src=\"https://img-blog.csdnimg.cn/20200810215945900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-2-安装Git\"><a href=\"#2-2-安装Git\" class=\"headerlink\" title=\"2.2 安装Git\"></a>2.2 安装Git</h3><ul>\n<li>和上面安装一样，一直==next==就可以了</li>\n</ul>\n<p><strong>当然如果你不安装在c盘的话就自己选一个别的盘安装（最好不要安装在c盘）</strong><br><img src=\"https://img-blog.csdnimg.cn/20200810220035692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-3判断git安装成功\"><a href=\"#2-3判断git安装成功\" class=\"headerlink\" title=\"2.3判断git安装成功\"></a>2.3判断git安装成功</h3><p>在桌面鼠标点击右键，有Git GUI Here和Git Bash Here，则安装成功<img src=\"https://img-blog.csdnimg.cn/20200810220527448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>或者你看看新安装的程序里面有没有这三个<br><img src=\"https://img-blog.csdnimg.cn/20200810220516596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-安装淘宝镜像\"><a href=\"#3-安装淘宝镜像\" class=\"headerlink\" title=\"3.安装淘宝镜像\"></a>3.安装淘宝镜像</h2><ul>\n<li>在桌面鼠标右键或者任意一个地方，选择Git Bash Here</li>\n<li>输入下面的代码，静静等待就可以了</li>\n</ul>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">cnpm install -<span class=\"hljs-selector-tag\">g</span> cnpm <span class=\"hljs-attr\">--registry</span>=https:<span class=\"hljs-comment\">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"4-安装hexo博客\"><a href=\"#4-安装hexo博客\" class=\"headerlink\" title=\"4.安装hexo博客\"></a>4.安装hexo博客</h2><h3 id=\"1-在你喜欢的盘下面新建一个文件夹\"><a href=\"#1-在你喜欢的盘下面新建一个文件夹\" class=\"headerlink\" title=\"1.在你喜欢的盘下面新建一个文件夹\"></a>1.在你喜欢的盘下面新建一个文件夹</h3><ul>\n<li>（你可以起名为myblog）然后进入这个文件夹，右键==Git Bash Here==打开Git终端输入以下代码<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">npm install hexo-cli -g<br>npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure>\n可以用<code>hexo -v</code>来检查是否安装成功<br><img src=\"https://img-blog.csdnimg.cn/20200810221842905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><h3 id=\"2-初始化博客\"><a href=\"#2-初始化博客\" class=\"headerlink\" title=\"2.初始化博客\"></a>2.初始化博客</h3>进入该文件夹右键 Git Bash Here，输入以下命令</li>\n<li>输入  <code>hexo  init </code>初始化自己的博客</li>\n<li>然后你就可以看到你的myblog文件夹里面多了好多文件，其中有一个_config.yml文件<img src=\"https://img-blog.csdnimg.cn/20200810222427595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>这个就是你的基本配置文件</li>\n</ul>\n<h1 id=\"在本地安装完成了\"><a href=\"#在本地安装完成了\" class=\"headerlink\" title=\"在本地安装完成了\"></a>在本地安装完成了</h1><ul>\n<li>在文件夹右键Git Bash Here执行以下命令，执行完即可点击<a href=\"http://localhost:4000/\">http://localhost:4000/</a> 查看效果<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$ hexo generate<br>$ hexo server<br></code></pre></td></tr></table></figure></li>\n<li>如果出现了以下信息就说明成功了<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure>\n<img src=\"https://img-blog.csdnimg.cn/20200810224147173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><h1 id=\"将博客部署到-GitHub上面去\"><a href=\"#将博客部署到-GitHub上面去\" class=\"headerlink\" title=\"将博客部署到 GitHub上面去\"></a>将博客部署到 GitHub上面去</h1></li>\n<li>到目前为止，我们的本地博客就成功搭建了，但是现在我们只能通过本地连接查看博客，我们要做的是让其他人也能够访问我们的博客，这就需要我们将博客部署到Github Pages上<h2 id=\"1-注册GitHub账户：\"><a href=\"#1-注册GitHub账户：\" class=\"headerlink\" title=\"1.注册GitHub账户：\"></a>1.注册GitHub账户：</h2><a href=\"https://github.com/\">点击此处</a> 访问官网，点击 sign up 注册账户</li>\n</ul>\n<h2 id=\"2-创建项目代码库\"><a href=\"#2-创建项目代码库\" class=\"headerlink\" title=\"2.创建项目代码库\"></a>2.创建项目代码库</h2><p>点击 ==New repository==开始创建<br><img src=\"https://img-blog.csdnimg.cn/20200810224738547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-配置-ssh-密匙\"><a href=\"#3-配置-ssh-密匙\" class=\"headerlink\" title=\"3.配置==ssh==密匙\"></a>3.配置==ssh==密匙</h2><ul>\n<li>只有配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步，在你第一次新建的文件夹里面（如：我的文件夹为：D\\blog） Git Bash Here 输入以下命令<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">$ ssh-keygen -t rsa -C &quot;your email@qq.com&quot;<br>//引号里面填写你的邮箱地址<br></code></pre></td></tr></table></figure></li>\n<li>然后就会有<figure class=\"highlight plaintext\"><figcaption><span>passphrase (empty for no passphrase):</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jEnter\">//不要输入直接回车就行<br>Enter same passphrase again<br></code></pre></td></tr></table></figure></li>\n<li>接下来就会有<figure class=\"highlight plaintext\"><figcaption><span>identification has been saved in</span><a href=\"/c/Users/you/.ssh/id_rsa.\">link</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jYour\">Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>这里是各种字母数字组成的字符串，结尾是你的邮箱<br>The key&#x27;s randomart image is:<br>这里也是各种字母数字符号组成的字符串<br></code></pre></td></tr></table></figure></li>\n<li>运行以下命令，将公钥的内容复制到系统粘贴板上<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">$ clip &lt; ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"4-在GitHub中添加你的公匙\"><a href=\"#4-在GitHub中添加你的公匙\" class=\"headerlink\" title=\"4.在GitHub中添加你的公匙\"></a>4.在GitHub中添加你的公匙</h2><h3 id=\"4-1登陆-GitHub，进入-Settings：\"><a href=\"#4-1登陆-GitHub，进入-Settings：\" class=\"headerlink\" title=\"4.1登陆 GitHub，进入 Settings：\"></a>4.1登陆 GitHub，进入 Settings：</h3><p><img src=\"https://img-blog.csdnimg.cn/20200810225604719.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-2点击-SHH-and-GPG-Keys\"><a href=\"#4-2点击-SHH-and-GPG-Keys\" class=\"headerlink\" title=\"4.2点击 ==SHH and GPG Keys==\"></a>4.2点击 ==SHH and GPG Keys==</h3><p><img src=\"https://img-blog.csdnimg.cn/20200810225700749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-3选择-New-SSH-Key：\"><a href=\"#4-3选择-New-SSH-Key：\" class=\"headerlink\" title=\"4.3选择 ==New SSH Key：\"></a>4.3选择 ==New SSH Key：</h3><p><img src=\"https://img-blog.csdnimg.cn/20200810225800165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-4粘贴密匙：\"><a href=\"#4-4粘贴密匙：\" class=\"headerlink\" title=\"4.4粘贴密匙：\"></a>4.4粘贴密匙：</h3><p><img src=\"https://img-blog.csdnimg.cn/20200810225739776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-5测试\"><a href=\"#4-5测试\" class=\"headerlink\" title=\"4.5测试\"></a>4.5测试</h3><p>输入以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">$ ssh -T git@github.com<br></code></pre></td></tr></table></figure>\n<ul>\n<li>看到（yes/no）之后输入yes会显示：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">Hi xxx!You&#x27;ve successfully ..............<br></code></pre></td></tr></table></figure>\n就说明设置正确<h3 id=\"4-6配置Git个人信息\"><a href=\"#4-6配置Git个人信息\" class=\"headerlink\" title=\"4.6配置Git个人信息\"></a>4.6配置Git个人信息</h3></li>\n<li>Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">$ git config --global user.name &quot;此处填你的用户名&quot;<br>$ git config --global user.email &quot;此处填你的邮箱&quot;<br></code></pre></td></tr></table></figure>\n到此为止 SSH Key 配置成功，本机已成功连接到 Github</li>\n</ul>\n<h2 id=\"5-将本地的-Hexo-文件更新到-Github-的库中\"><a href=\"#5-将本地的-Hexo-文件更新到-Github-的库中\" class=\"headerlink\" title=\"5.将本地的 Hexo 文件更新到 Github 的库中\"></a>5.将本地的 Hexo 文件更新到 Github 的库中</h2><ul>\n<li><p>一、登录 Github 打开自己的项目 yourname.github.io</p>\n</li>\n<li><p>二、鼠标移到 Clone or download 按钮，选择 Use SSH</p>\n</li>\n<li><p>三、一键复制地址<br><img src=\"https://img-blog.csdnimg.cn/20200810230750561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JsYWNrX1NwaWRlckM=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>四、打开你创建的 Hexo 文件夹（如：D:\\myblog），右键打开该文件夹下的 _config.yml 文件，在文件的最下面有==deploy==</p>\n</li>\n</ul>\n<p><strong>改成如下的样子：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs j\">deploy:<br>\ttype: git #注意冒号后面都有一个空<br>\trepository: #刚刚复制的内容<br>\tbranch: master<br></code></pre></td></tr></table></figure>\n<h2 id=\"6-在-Hexo-文件夹下分别执行以下命令\"><a href=\"#6-在-Hexo-文件夹下分别执行以下命令\" class=\"headerlink\" title=\"6.在 Hexo 文件夹下分别执行以下命令\"></a>6.在 Hexo 文件夹下分别执行以下命令</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">$ hexo g<br>$ hexo d<br></code></pre></td></tr></table></figure>\n<p>或者直接执行</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">$ hexo g -d<br></code></pre></td></tr></table></figure>\n<p>执行完之后会让你输入你的 Github 的账号和密码，如果此时报以下错误，说明你的 deployer 没有安装成功</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">ERROR Deployer not found: git<br></code></pre></td></tr></table></figure>\n<p>需要执行以下命令再安装一次</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure>\n<p>再执行 <code>j hexo g -d</code>你的博客就会部署到 Github 上了</p>\n<h2 id=\"7-访问博客\"><a href=\"#7-访问博客\" class=\"headerlink\" title=\"7.访问博客\"></a>7.访问博客</h2><p>==你的博客地址：https://你的用户名.github.io==</p>\n"},{"title":"day 02 学习HTML（下）","date":"2020-08-18T08:18:19.000Z","index_img":"/img/html2.jpg","banner_img":"/img/g.jpg","_content":"{% note danger %}\n下面是我学HTML的一些笔记，零零碎碎的，你们可以看看这个[w3school](https://www.w3school.com.cn/)\n{% endnote %}\n\n## 表格标签\n~~~\n<table>\n\t<tr>\n\t\t<td>单元格的文字</td>(<th>表头单元格）\n\t\t……….\n\t</tr>\n\t\t……………\n<table>\n~~~\n\n###  (1)表格相关属性（这些属性要写到table中去才可以）\n位置： align    -------->       left,center,right \n 边框： border  ------>         1或者\"\"\ncellpadding(内容距离边框的距离）\ncellspacing (单元格之间的距离）\nwidth,height\n### (2)表格结构\n`<thead>` 表格的头部区域 ,内部一定要包含`<tr>`\n`<tbody>` 表格的主体区域\n以上两个标签都是在`<table>`中\n\n## 合并单元格\n- 跨行合并：rowspan=\"合并单元格的个数\"\n- 跨列合并：colspan=\"合并单元格的个数\"\n~~~\n<td rowspan=\"2\"></td>\n~~~\n目标单元格：\n跨行：写在最上侧为目标单元格\n跨列：写在最左侧为目标单元格\n## 列表标签\n- 无序列表（重点）\n```\n<ul>\n    <li>xxxxx</li>\n    <li>xxxxx</li>\n<ul>  \n<!-- <ul>中只能出现<li>，但是<li>里面可以放任何东西  -->\n```\n- 有序列表\n```\n<dl>\n\t<dt>大哥</dt>\n\t<dd>小弟</dd>\n\t<dd>小弟</dd>\n<dl>\n```\n## 表单标签\n分为：表单域，表单控件（表单元素），提示信息\n- `<form>` 把表单元素信息提交给服务器\n```\n<form action =\"URL地址\" method=\"提交方式\" name=\"name1\">\n</form>\n```\n- `<input>`用于收集用户信息\n```\n<input type='属性值'/>    单标签\ntype值的不同指定不同的控件\n```\n- name:\n```<input type=\"radio\"  name=\"xx\">单选按钮和复选框的名字必须相同``` \n- value:在方框中加入文字\n- checked=\"checked\" :当页面打开的时候默认打勾\n- maxlength  ：可输入的最多字符\n\n##  `<label>`标签\n~~~\n<label for =\"sex\"> 男</label>\n<input type =\"text\" id=\"sex\"> \n~~~\n\n## 下拉表单元素\n~~~html\n<select>\n\t<option>xxxxxx</option>\n\t<option>xxxxxx</option>\n\t<option>xxxxxx</option>\n</sele>\n~~~\n## textarea 文本域\n大量的书写文字，多行文本的输入","source":"_posts/html.md","raw":"---\ntitle: day 02 学习HTML（下）\ndate: 2020-08-18 16:18:19\ntags: HTML\ncategories: 前端\nindex_img: /img/html2.jpg\nbanner_img: /img/g.jpg\n---\n{% note danger %}\n下面是我学HTML的一些笔记，零零碎碎的，你们可以看看这个[w3school](https://www.w3school.com.cn/)\n{% endnote %}\n\n## 表格标签\n~~~\n<table>\n\t<tr>\n\t\t<td>单元格的文字</td>(<th>表头单元格）\n\t\t……….\n\t</tr>\n\t\t……………\n<table>\n~~~\n\n###  (1)表格相关属性（这些属性要写到table中去才可以）\n位置： align    -------->       left,center,right \n 边框： border  ------>         1或者\"\"\ncellpadding(内容距离边框的距离）\ncellspacing (单元格之间的距离）\nwidth,height\n### (2)表格结构\n`<thead>` 表格的头部区域 ,内部一定要包含`<tr>`\n`<tbody>` 表格的主体区域\n以上两个标签都是在`<table>`中\n\n## 合并单元格\n- 跨行合并：rowspan=\"合并单元格的个数\"\n- 跨列合并：colspan=\"合并单元格的个数\"\n~~~\n<td rowspan=\"2\"></td>\n~~~\n目标单元格：\n跨行：写在最上侧为目标单元格\n跨列：写在最左侧为目标单元格\n## 列表标签\n- 无序列表（重点）\n```\n<ul>\n    <li>xxxxx</li>\n    <li>xxxxx</li>\n<ul>  \n<!-- <ul>中只能出现<li>，但是<li>里面可以放任何东西  -->\n```\n- 有序列表\n```\n<dl>\n\t<dt>大哥</dt>\n\t<dd>小弟</dd>\n\t<dd>小弟</dd>\n<dl>\n```\n## 表单标签\n分为：表单域，表单控件（表单元素），提示信息\n- `<form>` 把表单元素信息提交给服务器\n```\n<form action =\"URL地址\" method=\"提交方式\" name=\"name1\">\n</form>\n```\n- `<input>`用于收集用户信息\n```\n<input type='属性值'/>    单标签\ntype值的不同指定不同的控件\n```\n- name:\n```<input type=\"radio\"  name=\"xx\">单选按钮和复选框的名字必须相同``` \n- value:在方框中加入文字\n- checked=\"checked\" :当页面打开的时候默认打勾\n- maxlength  ：可输入的最多字符\n\n##  `<label>`标签\n~~~\n<label for =\"sex\"> 男</label>\n<input type =\"text\" id=\"sex\"> \n~~~\n\n## 下拉表单元素\n~~~html\n<select>\n\t<option>xxxxxx</option>\n\t<option>xxxxxx</option>\n\t<option>xxxxxx</option>\n</sele>\n~~~\n## textarea 文本域\n大量的书写文字，多行文本的输入","slug":"html","published":1,"updated":"2024-11-17T13:58:10.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpk001973t33zke8fu1","content":"<div class=\"note note-danger\">\n            <p>下面是我学HTML的一些笔记，零零碎碎的，你们可以看看这个<a href=\"https://www.w3school.com.cn/\">w3school</a></p>\n          </div>\n\n<h2 id=\"表格标签\"><a href=\"#表格标签\" class=\"headerlink\" title=\"表格标签\"></a>表格标签</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>单元格的文字<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>(<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>表头单元格）<br>\t\t……….<br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br>\t\t……………<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-表格相关属性（这些属性要写到table中去才可以）\"><a href=\"#1-表格相关属性（这些属性要写到table中去才可以）\" class=\"headerlink\" title=\"(1)表格相关属性（这些属性要写到table中去才可以）\"></a>(1)表格相关属性（这些属性要写到table中去才可以）</h3><p>位置： align    ——–&gt;       left,center,right<br> 边框： border  ——&gt;         1或者””<br>cellpadding(内容距离边框的距离）<br>cellspacing (单元格之间的距离）<br>width,height</p>\n<h3 id=\"2-表格结构\"><a href=\"#2-表格结构\" class=\"headerlink\" title=\"(2)表格结构\"></a>(2)表格结构</h3><p><code>&lt;thead&gt;</code> 表格的头部区域 ,内部一定要包含<code>&lt;tr&gt;</code><br><code>&lt;tbody&gt;</code> 表格的主体区域<br>以上两个标签都是在<code>&lt;table&gt;</code>中</p>\n<h2 id=\"合并单元格\"><a href=\"#合并单元格\" class=\"headerlink\" title=\"合并单元格\"></a>合并单元格</h2><ul>\n<li>跨行合并：rowspan=”合并单元格的个数”</li>\n<li>跨列合并：colspan=”合并单元格的个数”<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">rowspan</span>=<span class=\"hljs-string\">&quot;2&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br></code></pre></td></tr></table></figure>\n目标单元格：<br>跨行：写在最上侧为目标单元格<br>跨列：写在最左侧为目标单元格<h2 id=\"列表标签\"><a href=\"#列表标签\" class=\"headerlink\" title=\"列表标签\"></a>列表标签</h2></li>\n<li>无序列表（重点）<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>xxxxx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>xxxxx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>  <br><span class=\"hljs-comment\">&lt;!-- &lt;ul&gt;中只能出现&lt;li&gt;，但是&lt;li&gt;里面可以放任何东西  --&gt;</span><br></code></pre></td></tr></table></figure></li>\n<li>有序列表<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dl</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dt</span>&gt;</span>大哥<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dt</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dd</span>&gt;</span>小弟<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dd</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dd</span>&gt;</span>小弟<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dd</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dl</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"表单标签\"><a href=\"#表单标签\" class=\"headerlink\" title=\"表单标签\"></a>表单标签</h2>分为：表单域，表单控件（表单元素），提示信息</li>\n<li><code>&lt;form&gt;</code> 把表单元素信息提交给服务器<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">&lt;form action <span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;URL地址&quot;</span> method<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;提交方式&quot;</span> name<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;name1&quot;</span>&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure></li>\n<li><code>&lt;input&gt;</code>用于收集用户信息<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elm\">&lt;input <span class=\"hljs-keyword\">type</span>=&#x27;属性值&#x27;/&gt;    单标签<br><span class=\"hljs-keyword\">type</span>值的不同指定不同的控件<br></code></pre></td></tr></table></figure></li>\n<li>name:<br><code>&lt;input type=&quot;radio&quot;  name=&quot;xx&quot;&gt;单选按钮和复选框的名字必须相同</code> </li>\n<li>value:在方框中加入文字</li>\n<li>checked=”checked” :当页面打开的时候默认打勾</li>\n<li>maxlength  ：可输入的最多字符</li>\n</ul>\n<h2 id=\"lt-label-gt-标签\"><a href=\"#lt-label-gt-标签\" class=\"headerlink\" title=\"&lt;label&gt;标签\"></a><code>&lt;label&gt;</code>标签</h2><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">&lt;<span class=\"hljs-keyword\">label</span> <span class=\"hljs-keyword\">for</span> =<span class=\"hljs-string\">&quot;sex&quot;</span>&gt; 男&lt;/<span class=\"hljs-keyword\">label</span>&gt;<br>&lt;<span class=\"hljs-keyword\">input</span> <span class=\"hljs-keyword\">type</span> =<span class=\"hljs-string\">&quot;text&quot;</span> id=<span class=\"hljs-string\">&quot;sex&quot;</span>&gt; <br></code></pre></td></tr></table></figure>\n\n<h2 id=\"下拉表单元素\"><a href=\"#下拉表单元素\" class=\"headerlink\" title=\"下拉表单元素\"></a>下拉表单元素</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>xxxxxx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>xxxxxx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>xxxxxx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sele</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"textarea-文本域\"><a href=\"#textarea-文本域\" class=\"headerlink\" title=\"textarea 文本域\"></a>textarea 文本域</h2><p>大量的书写文字，多行文本的输入</p>\n","site":{"data":{}},"wordcount":1389,"excerpt":"","more":"<div class=\"note note-danger\">\n            <p>下面是我学HTML的一些笔记，零零碎碎的，你们可以看看这个<a href=\"https://www.w3school.com.cn/\">w3school</a></p>\n          </div>\n\n<h2 id=\"表格标签\"><a href=\"#表格标签\" class=\"headerlink\" title=\"表格标签\"></a>表格标签</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>单元格的文字<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>(<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>表头单元格）<br>\t\t……….<br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br>\t\t……………<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-表格相关属性（这些属性要写到table中去才可以）\"><a href=\"#1-表格相关属性（这些属性要写到table中去才可以）\" class=\"headerlink\" title=\"(1)表格相关属性（这些属性要写到table中去才可以）\"></a>(1)表格相关属性（这些属性要写到table中去才可以）</h3><p>位置： align    ——–&gt;       left,center,right<br> 边框： border  ——&gt;         1或者””<br>cellpadding(内容距离边框的距离）<br>cellspacing (单元格之间的距离）<br>width,height</p>\n<h3 id=\"2-表格结构\"><a href=\"#2-表格结构\" class=\"headerlink\" title=\"(2)表格结构\"></a>(2)表格结构</h3><p><code>&lt;thead&gt;</code> 表格的头部区域 ,内部一定要包含<code>&lt;tr&gt;</code><br><code>&lt;tbody&gt;</code> 表格的主体区域<br>以上两个标签都是在<code>&lt;table&gt;</code>中</p>\n<h2 id=\"合并单元格\"><a href=\"#合并单元格\" class=\"headerlink\" title=\"合并单元格\"></a>合并单元格</h2><ul>\n<li>跨行合并：rowspan=”合并单元格的个数”</li>\n<li>跨列合并：colspan=”合并单元格的个数”<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">rowspan</span>=<span class=\"hljs-string\">&quot;2&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br></code></pre></td></tr></table></figure>\n目标单元格：<br>跨行：写在最上侧为目标单元格<br>跨列：写在最左侧为目标单元格<h2 id=\"列表标签\"><a href=\"#列表标签\" class=\"headerlink\" title=\"列表标签\"></a>列表标签</h2></li>\n<li>无序列表（重点）<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>xxxxx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>xxxxx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>  <br><span class=\"hljs-comment\">&lt;!-- &lt;ul&gt;中只能出现&lt;li&gt;，但是&lt;li&gt;里面可以放任何东西  --&gt;</span><br></code></pre></td></tr></table></figure></li>\n<li>有序列表<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dl</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dt</span>&gt;</span>大哥<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dt</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dd</span>&gt;</span>小弟<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dd</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dd</span>&gt;</span>小弟<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dd</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dl</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"表单标签\"><a href=\"#表单标签\" class=\"headerlink\" title=\"表单标签\"></a>表单标签</h2>分为：表单域，表单控件（表单元素），提示信息</li>\n<li><code>&lt;form&gt;</code> 把表单元素信息提交给服务器<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">&lt;form action <span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;URL地址&quot;</span> method<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;提交方式&quot;</span> name<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;name1&quot;</span>&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure></li>\n<li><code>&lt;input&gt;</code>用于收集用户信息<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elm\">&lt;input <span class=\"hljs-keyword\">type</span>=&#x27;属性值&#x27;/&gt;    单标签<br><span class=\"hljs-keyword\">type</span>值的不同指定不同的控件<br></code></pre></td></tr></table></figure></li>\n<li>name:<br><code>&lt;input type=&quot;radio&quot;  name=&quot;xx&quot;&gt;单选按钮和复选框的名字必须相同</code> </li>\n<li>value:在方框中加入文字</li>\n<li>checked=”checked” :当页面打开的时候默认打勾</li>\n<li>maxlength  ：可输入的最多字符</li>\n</ul>\n<h2 id=\"lt-label-gt-标签\"><a href=\"#lt-label-gt-标签\" class=\"headerlink\" title=\"&lt;label&gt;标签\"></a><code>&lt;label&gt;</code>标签</h2><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">&lt;<span class=\"hljs-keyword\">label</span> <span class=\"hljs-keyword\">for</span> =<span class=\"hljs-string\">&quot;sex&quot;</span>&gt; 男&lt;/<span class=\"hljs-keyword\">label</span>&gt;<br>&lt;<span class=\"hljs-keyword\">input</span> <span class=\"hljs-keyword\">type</span> =<span class=\"hljs-string\">&quot;text&quot;</span> id=<span class=\"hljs-string\">&quot;sex&quot;</span>&gt; <br></code></pre></td></tr></table></figure>\n\n<h2 id=\"下拉表单元素\"><a href=\"#下拉表单元素\" class=\"headerlink\" title=\"下拉表单元素\"></a>下拉表单元素</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>xxxxxx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>xxxxxx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>xxxxxx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sele</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"textarea-文本域\"><a href=\"#textarea-文本域\" class=\"headerlink\" title=\"textarea 文本域\"></a>textarea 文本域</h2><p>大量的书写文字，多行文本的输入</p>\n"},{"title":"mongoDB快速指南","date":"2021-12-12T06:59:07.000Z","index_img":"/img/小雪.png","banner_img":"/img/雨水.png","_content":"\n### 1.基础概念\n\n什么是集合，文档，字段？\n集合就是相当于 关系型数据库中的 **表(table)**\n\n文档就是 相当于 关系型数据库中的 **行(row)**\n\n字段就是  相当于 关系型数据库中的 **列(column)**\n\n主键就是  ==_id==\n\n一个数据库中可以有多个集合，也就是多个表，比如 一个文章数据库中可以有 User,article,Post,Course等等\n\n一个文档的_id是唯一的，也就是一个主键\n\n一个文档中的字段也不能重复 ，就是  name ，age 这些\n\n| _id                      | name      | age  |\n| ------------------------ | --------- | ---- |\n| 61b561e2fc16177e89714a68 | badspider | 12   |\n| 61b561e2fc16177e89714a44 | redspider | 18   |\n| 61b561e2fc16177e89714a21 | spiderman | 21   |\n\n### 2.连接数据库\n\n```js\nconst mongoose = require('mongoose')\n\nmongoose.connect(`mongodb://localhost/${数据库的名字}`)\n.then(res=>console.log(res),err=>console.log(err))\n```\n\n### 3.创建集合的规则\n\n```js\nconst UserSchema = new mongoose.Schema({\n\tname:\"String\",\n    age: \"Number\",\n    adress:\"String\"\n})\n```\n\n这个就是你的集合的规则，用来限制你这张表的数据\n\n### 4.使用规则创建集合\n\n```js\nconst User = mongoose.model('User',UserSchema)\n```\n\n### 5.创建集合对象实例\n\n```js\n 第一种办法\nUser.create({name:\"badspider\",age:12,adress:\"china\"}).then(res=>console.log(res),err=>console.log(err))\n\n第二种办法\nconst User = new User({name:\"badspider\",age:12,adress:\"china\"}).then(res=>console.log(res),err=>console.log(err))\n\n 第三种办法\nconst User = new User({name:\"badspider\",age:12,adress:\"china\"},(err,res)=>{\n    console.log(err)\n    console.log(res)                                                                 \n})\n  保存数据,将course文档(行)插入到文档\nUser.save\n```\n\n### 6.从文件夹导入数据到数据库\n\n> mongoimport -d 数据库名称 -c 集合名称 --file 要导入数据的文件\n\n### 7.查询数据\n\n#### 7.1 find()\n\n通过==find()**得到的数据返回的一个数组\n\n**查询User这个集合下的所有的数据**\n\n```js\nUser.find().then(res=>console.log(res))  \n```\n\n**根据条件查询数据**\n\n```js\nUser.find({name:\"badspiedr\"}).then(res=>console.log(res))  \n```\n\n#### 7.2 findOne()\n\n通过 ==findOne()** 查找单个数据,返回的是单个对象\n\n```js\nUser.findOne({age:\"23\"}).then(res=>console.log(res))  \n```\n\n#### 7.3 匹配大于小于\n\n查询年龄在 20 -- 40 之间的文档\n\n```js\nUser.find({age:{$gt:20,$lt:40}}).then(res=>console.log(res))  \n```\n\n#### 7.4 匹配包含\n\n```js\nUser.find({hobbies:{$in:['吃饭']}}).then(res=>console.log(res))  \n```\n\n#### 7.5 选择要查询的字段\n\n一定会包含 _id  ,要是不想要查询某字段的话，需要在前面加上 **-** ，`-_id`表示不需要查询\n\n```js\nUser.find().select('name age -_id').then(res=>console.log(res))  \n```\n\n#### 7.6 将数据进行 升序 排列\n\n```js\nUser.find().sort('age').then(res=>console.log(res))\n```\n\n#### 7.7 将数据进行 降序 排列\n\n```js\nUser.find().sort('-age').then(res=>console.log(res))\n```\n\n### 8.删除数据\n\n#### 8.1 删除单个数据\n\n删除单个文档，返回的值是删除的文档\n\n```js\nUser.findOneAndDelete({_id:\"61b54d87a4d771ff4c1ad2f9\"}).then(res=>console.log(res))\n```\n\n#### 8.4 删除多个数据\n\n```js\nUser.deleteMany({}).then(res=>console.log(res))\n```\n\n### 9. 更新文档\n\n#### 9.1 更新单个\n\n```js\nUser.updateOne({查询条件},{要修改的值}).then(res=>console.log(res))\n```\n\n#### 9.2 更新多个\n\n```js\nUser.updateMany({查询条件},{要修改的值}).then(res=>console.log(res))\n```\n\n### 10.mongoose 验证\n\n在创建集合的时候，可以设置当前字段的验证规则，验证失败则输入插入就失败\n\n```js\nrequrie: true 必传字段\n const postSchem = new mongoose.Schema({\n     title: {\n         type: String,\n         required: [true,'请传入文字标题'],\n         minlength: 2,\n         maxlength: 5\n     },\n     author: {\n         type: String,\n         required: true,\n          自定义验证规则\n         validate: {\n              返回布尔值\n             validator: v => {\n                 return v&&v.length> 7\n             },\n         },\n          自定义错误信息\n         message: '传入的值不符合验证规则'\n     }\n })\n\n```\n\n### 11.集合关联\n\n*通常 不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同的集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联*\n\n- 使用 id 对集合进行关联\n\n- 使用populate方法进行关联集合查询\n\n```js\nconst UserSchema = new mongoose.Schema({\n    name: {\n        type: String\n    }\n})\nconst PostSchema = new mongoose.Schema({\n    title: String,\n    author: {\n         要关联的集合的_id\n        type: mongoose.Schema.Types.ObjectId,\n         要关联的集合\n        ref:'User'\n    }\n})\nconst User = mongoose.model('User', UserSchema)\nconst Post = mongoose.model('Post', PostSchema)\n\n User.create({ name: \"badspider\" }).then(res => console.log(res))\n Post.create({title:'nodejs',author:'61b561b05904f504522d9d74'}).then(res => console.log(res))\n\n 联合查询\n 1.Post.find().then(res => console.log(res))\n 返回的数据\n [\n     {\n       _id: new ObjectId(\"61b561e2fc16177e89714a68\"),\n       title: 'nodejs',\n       author: new ObjectId(\"61b561b05904f504522d9d74\"),\n       __v: 0\n     }\n   ]\n\n 2.Post.find().populate('author').then(res=>console.log(res))\n 返回的数据\n [\n     {\n       _id: new ObjectId(\"61b561e2fc16177e89714a68\"),  \n       title: 'nodejs',\n       author: {\n         _id: new ObjectId(\"61b561b05904f504522d9d74\"),\n         name: 'badspider',\n         __v: 0\n       },\n       __v: 0\n     }\n   ]\n```\n\n","source":"_posts/mongoDB快速指南.md","raw":"---\ntitle: mongoDB快速指南\ndate: 2021-12-12 14:59:07\ntags: mongoDB\ncategories: 前端\nindex_img: /img/小雪.png\nbanner_img: /img/雨水.png\n---\n\n### 1.基础概念\n\n什么是集合，文档，字段？\n集合就是相当于 关系型数据库中的 **表(table)**\n\n文档就是 相当于 关系型数据库中的 **行(row)**\n\n字段就是  相当于 关系型数据库中的 **列(column)**\n\n主键就是  ==_id==\n\n一个数据库中可以有多个集合，也就是多个表，比如 一个文章数据库中可以有 User,article,Post,Course等等\n\n一个文档的_id是唯一的，也就是一个主键\n\n一个文档中的字段也不能重复 ，就是  name ，age 这些\n\n| _id                      | name      | age  |\n| ------------------------ | --------- | ---- |\n| 61b561e2fc16177e89714a68 | badspider | 12   |\n| 61b561e2fc16177e89714a44 | redspider | 18   |\n| 61b561e2fc16177e89714a21 | spiderman | 21   |\n\n### 2.连接数据库\n\n```js\nconst mongoose = require('mongoose')\n\nmongoose.connect(`mongodb://localhost/${数据库的名字}`)\n.then(res=>console.log(res),err=>console.log(err))\n```\n\n### 3.创建集合的规则\n\n```js\nconst UserSchema = new mongoose.Schema({\n\tname:\"String\",\n    age: \"Number\",\n    adress:\"String\"\n})\n```\n\n这个就是你的集合的规则，用来限制你这张表的数据\n\n### 4.使用规则创建集合\n\n```js\nconst User = mongoose.model('User',UserSchema)\n```\n\n### 5.创建集合对象实例\n\n```js\n 第一种办法\nUser.create({name:\"badspider\",age:12,adress:\"china\"}).then(res=>console.log(res),err=>console.log(err))\n\n第二种办法\nconst User = new User({name:\"badspider\",age:12,adress:\"china\"}).then(res=>console.log(res),err=>console.log(err))\n\n 第三种办法\nconst User = new User({name:\"badspider\",age:12,adress:\"china\"},(err,res)=>{\n    console.log(err)\n    console.log(res)                                                                 \n})\n  保存数据,将course文档(行)插入到文档\nUser.save\n```\n\n### 6.从文件夹导入数据到数据库\n\n> mongoimport -d 数据库名称 -c 集合名称 --file 要导入数据的文件\n\n### 7.查询数据\n\n#### 7.1 find()\n\n通过==find()**得到的数据返回的一个数组\n\n**查询User这个集合下的所有的数据**\n\n```js\nUser.find().then(res=>console.log(res))  \n```\n\n**根据条件查询数据**\n\n```js\nUser.find({name:\"badspiedr\"}).then(res=>console.log(res))  \n```\n\n#### 7.2 findOne()\n\n通过 ==findOne()** 查找单个数据,返回的是单个对象\n\n```js\nUser.findOne({age:\"23\"}).then(res=>console.log(res))  \n```\n\n#### 7.3 匹配大于小于\n\n查询年龄在 20 -- 40 之间的文档\n\n```js\nUser.find({age:{$gt:20,$lt:40}}).then(res=>console.log(res))  \n```\n\n#### 7.4 匹配包含\n\n```js\nUser.find({hobbies:{$in:['吃饭']}}).then(res=>console.log(res))  \n```\n\n#### 7.5 选择要查询的字段\n\n一定会包含 _id  ,要是不想要查询某字段的话，需要在前面加上 **-** ，`-_id`表示不需要查询\n\n```js\nUser.find().select('name age -_id').then(res=>console.log(res))  \n```\n\n#### 7.6 将数据进行 升序 排列\n\n```js\nUser.find().sort('age').then(res=>console.log(res))\n```\n\n#### 7.7 将数据进行 降序 排列\n\n```js\nUser.find().sort('-age').then(res=>console.log(res))\n```\n\n### 8.删除数据\n\n#### 8.1 删除单个数据\n\n删除单个文档，返回的值是删除的文档\n\n```js\nUser.findOneAndDelete({_id:\"61b54d87a4d771ff4c1ad2f9\"}).then(res=>console.log(res))\n```\n\n#### 8.4 删除多个数据\n\n```js\nUser.deleteMany({}).then(res=>console.log(res))\n```\n\n### 9. 更新文档\n\n#### 9.1 更新单个\n\n```js\nUser.updateOne({查询条件},{要修改的值}).then(res=>console.log(res))\n```\n\n#### 9.2 更新多个\n\n```js\nUser.updateMany({查询条件},{要修改的值}).then(res=>console.log(res))\n```\n\n### 10.mongoose 验证\n\n在创建集合的时候，可以设置当前字段的验证规则，验证失败则输入插入就失败\n\n```js\nrequrie: true 必传字段\n const postSchem = new mongoose.Schema({\n     title: {\n         type: String,\n         required: [true,'请传入文字标题'],\n         minlength: 2,\n         maxlength: 5\n     },\n     author: {\n         type: String,\n         required: true,\n          自定义验证规则\n         validate: {\n              返回布尔值\n             validator: v => {\n                 return v&&v.length> 7\n             },\n         },\n          自定义错误信息\n         message: '传入的值不符合验证规则'\n     }\n })\n\n```\n\n### 11.集合关联\n\n*通常 不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同的集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联*\n\n- 使用 id 对集合进行关联\n\n- 使用populate方法进行关联集合查询\n\n```js\nconst UserSchema = new mongoose.Schema({\n    name: {\n        type: String\n    }\n})\nconst PostSchema = new mongoose.Schema({\n    title: String,\n    author: {\n         要关联的集合的_id\n        type: mongoose.Schema.Types.ObjectId,\n         要关联的集合\n        ref:'User'\n    }\n})\nconst User = mongoose.model('User', UserSchema)\nconst Post = mongoose.model('Post', PostSchema)\n\n User.create({ name: \"badspider\" }).then(res => console.log(res))\n Post.create({title:'nodejs',author:'61b561b05904f504522d9d74'}).then(res => console.log(res))\n\n 联合查询\n 1.Post.find().then(res => console.log(res))\n 返回的数据\n [\n     {\n       _id: new ObjectId(\"61b561e2fc16177e89714a68\"),\n       title: 'nodejs',\n       author: new ObjectId(\"61b561b05904f504522d9d74\"),\n       __v: 0\n     }\n   ]\n\n 2.Post.find().populate('author').then(res=>console.log(res))\n 返回的数据\n [\n     {\n       _id: new ObjectId(\"61b561e2fc16177e89714a68\"),  \n       title: 'nodejs',\n       author: {\n         _id: new ObjectId(\"61b561b05904f504522d9d74\"),\n         name: 'badspider',\n         __v: 0\n       },\n       __v: 0\n     }\n   ]\n```\n\n","slug":"mongoDB快速指南","published":1,"updated":"2024-11-17T13:58:10.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpl001c73t3g3g1gksj","content":"<h3 id=\"1-基础概念\"><a href=\"#1-基础概念\" class=\"headerlink\" title=\"1.基础概念\"></a>1.基础概念</h3><p>什么是集合，文档，字段？<br>集合就是相当于 关系型数据库中的 <strong>表(table)</strong></p>\n<p>文档就是 相当于 关系型数据库中的 <strong>行(row)</strong></p>\n<p>字段就是  相当于 关系型数据库中的 <strong>列(column)</strong></p>\n<p>主键就是  ==_id==</p>\n<p>一个数据库中可以有多个集合，也就是多个表，比如 一个文章数据库中可以有 User,article,Post,Course等等</p>\n<p>一个文档的_id是唯一的，也就是一个主键</p>\n<p>一个文档中的字段也不能重复 ，就是  name ，age 这些</p>\n<table>\n<thead>\n<tr>\n<th>_id</th>\n<th>name</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>61b561e2fc16177e89714a68</td>\n<td>badspider</td>\n<td>12</td>\n</tr>\n<tr>\n<td>61b561e2fc16177e89714a44</td>\n<td>redspider</td>\n<td>18</td>\n</tr>\n<tr>\n<td>61b561e2fc16177e89714a21</td>\n<td>spiderman</td>\n<td>21</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-连接数据库\"><a href=\"#2-连接数据库\" class=\"headerlink\" title=\"2.连接数据库\"></a>2.连接数据库</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> mongoose = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;mongoose&#x27;</span>)<br><br>mongoose.<span class=\"hljs-title function_\">connect</span>(<span class=\"hljs-string\">`mongodb://localhost/<span class=\"hljs-subst\">$&#123;数据库的名字&#125;</span>`</span>)<br>.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res),<span class=\"hljs-function\"><span class=\"hljs-params\">err</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-创建集合的规则\"><a href=\"#3-创建集合的规则\" class=\"headerlink\" title=\"3.创建集合的规则\"></a>3.创建集合的规则</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UserSchema</span> = <span class=\"hljs-keyword\">new</span> mongoose.<span class=\"hljs-title class_\">Schema</span>(&#123;<br>\t<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;String&quot;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-string\">&quot;Number&quot;</span>,<br>    <span class=\"hljs-attr\">adress</span>:<span class=\"hljs-string\">&quot;String&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>这个就是你的集合的规则，用来限制你这张表的数据</p>\n<h3 id=\"4-使用规则创建集合\"><a href=\"#4-使用规则创建集合\" class=\"headerlink\" title=\"4.使用规则创建集合\"></a>4.使用规则创建集合</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = mongoose.<span class=\"hljs-title function_\">model</span>(<span class=\"hljs-string\">&#x27;User&#x27;</span>,<span class=\"hljs-title class_\">UserSchema</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-创建集合对象实例\"><a href=\"#5-创建集合对象实例\" class=\"headerlink\" title=\"5.创建集合对象实例\"></a>5.创建集合对象实例</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"> 第一种办法<br><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">create</span>(&#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;badspider&quot;</span>,<span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">12</span>,<span class=\"hljs-attr\">adress</span>:<span class=\"hljs-string\">&quot;china&quot;</span>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res),<span class=\"hljs-function\"><span class=\"hljs-params\">err</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err))<br><br>第二种办法<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>(&#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;badspider&quot;</span>,<span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">12</span>,<span class=\"hljs-attr\">adress</span>:<span class=\"hljs-string\">&quot;china&quot;</span>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res),<span class=\"hljs-function\"><span class=\"hljs-params\">err</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err))<br><br> 第三种办法<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>(&#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;badspider&quot;</span>,<span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">12</span>,<span class=\"hljs-attr\">adress</span>:<span class=\"hljs-string\">&quot;china&quot;</span>&#125;,<span class=\"hljs-function\">(<span class=\"hljs-params\">err,res</span>)=&gt;</span>&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err)<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res)                                                                 <br>&#125;)<br>  保存数据,将course文档(行)插入到文档<br><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-property\">save</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"6-从文件夹导入数据到数据库\"><a href=\"#6-从文件夹导入数据到数据库\" class=\"headerlink\" title=\"6.从文件夹导入数据到数据库\"></a>6.从文件夹导入数据到数据库</h3><blockquote>\n<p>mongoimport -d 数据库名称 -c 集合名称 –file 要导入数据的文件</p>\n</blockquote>\n<h3 id=\"7-查询数据\"><a href=\"#7-查询数据\" class=\"headerlink\" title=\"7.查询数据\"></a>7.查询数据</h3><h4 id=\"7-1-find\"><a href=\"#7-1-find\" class=\"headerlink\" title=\"7.1 find()\"></a>7.1 find()</h4><p>通过==find()**得到的数据返回的一个数组</p>\n<p><strong>查询User这个集合下的所有的数据</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))  <br></code></pre></td></tr></table></figure>\n\n<p><strong>根据条件查询数据</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>(&#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;badspiedr&quot;</span>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-2-findOne\"><a href=\"#7-2-findOne\" class=\"headerlink\" title=\"7.2 findOne()\"></a>7.2 findOne()</h4><p>通过 ==findOne()** 查找单个数据,返回的是单个对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">findOne</span>(&#123;<span class=\"hljs-attr\">age</span>:<span class=\"hljs-string\">&quot;23&quot;</span>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-3-匹配大于小于\"><a href=\"#7-3-匹配大于小于\" class=\"headerlink\" title=\"7.3 匹配大于小于\"></a>7.3 匹配大于小于</h4><p>查询年龄在 20 – 40 之间的文档</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>(&#123;<span class=\"hljs-attr\">age</span>:&#123;<span class=\"hljs-attr\">$gt</span>:<span class=\"hljs-number\">20</span>,<span class=\"hljs-attr\">$lt</span>:<span class=\"hljs-number\">40</span>&#125;&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-4-匹配包含\"><a href=\"#7-4-匹配包含\" class=\"headerlink\" title=\"7.4 匹配包含\"></a>7.4 匹配包含</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>(&#123;<span class=\"hljs-attr\">hobbies</span>:&#123;<span class=\"hljs-attr\">$in</span>:[<span class=\"hljs-string\">&#x27;吃饭&#x27;</span>]&#125;&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-5-选择要查询的字段\"><a href=\"#7-5-选择要查询的字段\" class=\"headerlink\" title=\"7.5 选择要查询的字段\"></a>7.5 选择要查询的字段</h4><p>一定会包含 _id  ,要是不想要查询某字段的话，需要在前面加上 <strong>-</strong> ，<code>-_id</code>表示不需要查询</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>().<span class=\"hljs-title function_\">select</span>(<span class=\"hljs-string\">&#x27;name age -_id&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-6-将数据进行-升序-排列\"><a href=\"#7-6-将数据进行-升序-排列\" class=\"headerlink\" title=\"7.6 将数据进行 升序 排列\"></a>7.6 将数据进行 升序 排列</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>().<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-string\">&#x27;age&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-7-将数据进行-降序-排列\"><a href=\"#7-7-将数据进行-降序-排列\" class=\"headerlink\" title=\"7.7 将数据进行 降序 排列\"></a>7.7 将数据进行 降序 排列</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>().<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-string\">&#x27;-age&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"8-删除数据\"><a href=\"#8-删除数据\" class=\"headerlink\" title=\"8.删除数据\"></a>8.删除数据</h3><h4 id=\"8-1-删除单个数据\"><a href=\"#8-1-删除单个数据\" class=\"headerlink\" title=\"8.1 删除单个数据\"></a>8.1 删除单个数据</h4><p>删除单个文档，返回的值是删除的文档</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">findOneAndDelete</span>(&#123;<span class=\"hljs-attr\">_id</span>:<span class=\"hljs-string\">&quot;61b54d87a4d771ff4c1ad2f9&quot;</span>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"8-4-删除多个数据\"><a href=\"#8-4-删除多个数据\" class=\"headerlink\" title=\"8.4 删除多个数据\"></a>8.4 删除多个数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">deleteMany</span>(&#123;&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"9-更新文档\"><a href=\"#9-更新文档\" class=\"headerlink\" title=\"9. 更新文档\"></a>9. 更新文档</h3><h4 id=\"9-1-更新单个\"><a href=\"#9-1-更新单个\" class=\"headerlink\" title=\"9.1 更新单个\"></a>9.1 更新单个</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">updateOne</span>(&#123;查询条件&#125;,&#123;要修改的值&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"9-2-更新多个\"><a href=\"#9-2-更新多个\" class=\"headerlink\" title=\"9.2 更新多个\"></a>9.2 更新多个</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">updateMany</span>(&#123;查询条件&#125;,&#123;要修改的值&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"10-mongoose-验证\"><a href=\"#10-mongoose-验证\" class=\"headerlink\" title=\"10.mongoose 验证\"></a>10.mongoose 验证</h3><p>在创建集合的时候，可以设置当前字段的验证规则，验证失败则输入插入就失败</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-attr\">requrie</span>: <span class=\"hljs-literal\">true</span> 必传字段<br> <span class=\"hljs-keyword\">const</span> postSchem = <span class=\"hljs-keyword\">new</span> mongoose.<span class=\"hljs-title class_\">Schema</span>(&#123;<br>     <span class=\"hljs-attr\">title</span>: &#123;<br>         <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span>,<br>         <span class=\"hljs-attr\">required</span>: [<span class=\"hljs-literal\">true</span>,<span class=\"hljs-string\">&#x27;请传入文字标题&#x27;</span>],<br>         <span class=\"hljs-attr\">minlength</span>: <span class=\"hljs-number\">2</span>,<br>         <span class=\"hljs-attr\">maxlength</span>: <span class=\"hljs-number\">5</span><br>     &#125;,<br>     <span class=\"hljs-attr\">author</span>: &#123;<br>         <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span>,<br>         <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>,<br>          自定义验证规则<br>         <span class=\"hljs-attr\">validate</span>: &#123;<br>              返回布尔值<br>             <span class=\"hljs-attr\">validator</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> &#123;<br>                 <span class=\"hljs-keyword\">return</span> v&amp;&amp;v.<span class=\"hljs-property\">length</span>&gt; <span class=\"hljs-number\">7</span><br>             &#125;,<br>         &#125;,<br>          自定义错误信息<br>         <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;传入的值不符合验证规则&#x27;</span><br>     &#125;<br> &#125;)<br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"11-集合关联\"><a href=\"#11-集合关联\" class=\"headerlink\" title=\"11.集合关联\"></a>11.集合关联</h3><p><em>通常 不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同的集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联</em></p>\n<ul>\n<li><p>使用 id 对集合进行关联</p>\n</li>\n<li><p>使用populate方法进行关联集合查询</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UserSchema</span> = <span class=\"hljs-keyword\">new</span> mongoose.<span class=\"hljs-title class_\">Schema</span>(&#123;<br>    <span class=\"hljs-attr\">name</span>: &#123;<br>        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span><br>    &#125;<br>&#125;)<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">PostSchema</span> = <span class=\"hljs-keyword\">new</span> mongoose.<span class=\"hljs-title class_\">Schema</span>(&#123;<br>    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span>,<br>    <span class=\"hljs-attr\">author</span>: &#123;<br>         要关联的集合的_id<br>        <span class=\"hljs-attr\">type</span>: mongoose.<span class=\"hljs-property\">Schema</span>.<span class=\"hljs-property\">Types</span>.<span class=\"hljs-property\">ObjectId</span>,<br>         要关联的集合<br>        <span class=\"hljs-attr\">ref</span>:<span class=\"hljs-string\">&#x27;User&#x27;</span><br>    &#125;<br>&#125;)<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = mongoose.<span class=\"hljs-title function_\">model</span>(<span class=\"hljs-string\">&#x27;User&#x27;</span>, <span class=\"hljs-title class_\">UserSchema</span>)<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Post</span> = mongoose.<span class=\"hljs-title function_\">model</span>(<span class=\"hljs-string\">&#x27;Post&#x27;</span>, <span class=\"hljs-title class_\">PostSchema</span>)<br><br> <span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">create</span>(&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;badspider&quot;</span> &#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br> <span class=\"hljs-title class_\">Post</span>.<span class=\"hljs-title function_\">create</span>(&#123;<span class=\"hljs-attr\">title</span>:<span class=\"hljs-string\">&#x27;nodejs&#x27;</span>,<span class=\"hljs-attr\">author</span>:<span class=\"hljs-string\">&#x27;61b561b05904f504522d9d74&#x27;</span>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br><br> 联合查询<br> <span class=\"hljs-number\">1.</span><span class=\"hljs-title class_\">Post</span>.<span class=\"hljs-title function_\">find</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br> 返回的数据<br> [<br>     &#123;<br>       <span class=\"hljs-attr\">_id</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectId</span>(<span class=\"hljs-string\">&quot;61b561e2fc16177e89714a68&quot;</span>),<br>       <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;nodejs&#x27;</span>,<br>       <span class=\"hljs-attr\">author</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectId</span>(<span class=\"hljs-string\">&quot;61b561b05904f504522d9d74&quot;</span>),<br>       <span class=\"hljs-attr\">__v</span>: <span class=\"hljs-number\">0</span><br>     &#125;<br>   ]<br><br> <span class=\"hljs-number\">2.</span><span class=\"hljs-title class_\">Post</span>.<span class=\"hljs-title function_\">find</span>().<span class=\"hljs-title function_\">populate</span>(<span class=\"hljs-string\">&#x27;author&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br> 返回的数据<br> [<br>     &#123;<br>       <span class=\"hljs-attr\">_id</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectId</span>(<span class=\"hljs-string\">&quot;61b561e2fc16177e89714a68&quot;</span>),  <br>       <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;nodejs&#x27;</span>,<br>       <span class=\"hljs-attr\">author</span>: &#123;<br>         <span class=\"hljs-attr\">_id</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectId</span>(<span class=\"hljs-string\">&quot;61b561b05904f504522d9d74&quot;</span>),<br>         <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;badspider&#x27;</span>,<br>         <span class=\"hljs-attr\">__v</span>: <span class=\"hljs-number\">0</span><br>       &#125;,<br>       <span class=\"hljs-attr\">__v</span>: <span class=\"hljs-number\">0</span><br>     &#125;<br>   ]<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"wordcount":4098,"excerpt":"","more":"<h3 id=\"1-基础概念\"><a href=\"#1-基础概念\" class=\"headerlink\" title=\"1.基础概念\"></a>1.基础概念</h3><p>什么是集合，文档，字段？<br>集合就是相当于 关系型数据库中的 <strong>表(table)</strong></p>\n<p>文档就是 相当于 关系型数据库中的 <strong>行(row)</strong></p>\n<p>字段就是  相当于 关系型数据库中的 <strong>列(column)</strong></p>\n<p>主键就是  ==_id==</p>\n<p>一个数据库中可以有多个集合，也就是多个表，比如 一个文章数据库中可以有 User,article,Post,Course等等</p>\n<p>一个文档的_id是唯一的，也就是一个主键</p>\n<p>一个文档中的字段也不能重复 ，就是  name ，age 这些</p>\n<table>\n<thead>\n<tr>\n<th>_id</th>\n<th>name</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>61b561e2fc16177e89714a68</td>\n<td>badspider</td>\n<td>12</td>\n</tr>\n<tr>\n<td>61b561e2fc16177e89714a44</td>\n<td>redspider</td>\n<td>18</td>\n</tr>\n<tr>\n<td>61b561e2fc16177e89714a21</td>\n<td>spiderman</td>\n<td>21</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-连接数据库\"><a href=\"#2-连接数据库\" class=\"headerlink\" title=\"2.连接数据库\"></a>2.连接数据库</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> mongoose = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;mongoose&#x27;</span>)<br><br>mongoose.<span class=\"hljs-title function_\">connect</span>(<span class=\"hljs-string\">`mongodb://localhost/<span class=\"hljs-subst\">$&#123;数据库的名字&#125;</span>`</span>)<br>.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res),<span class=\"hljs-function\"><span class=\"hljs-params\">err</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-创建集合的规则\"><a href=\"#3-创建集合的规则\" class=\"headerlink\" title=\"3.创建集合的规则\"></a>3.创建集合的规则</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UserSchema</span> = <span class=\"hljs-keyword\">new</span> mongoose.<span class=\"hljs-title class_\">Schema</span>(&#123;<br>\t<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;String&quot;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-string\">&quot;Number&quot;</span>,<br>    <span class=\"hljs-attr\">adress</span>:<span class=\"hljs-string\">&quot;String&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>这个就是你的集合的规则，用来限制你这张表的数据</p>\n<h3 id=\"4-使用规则创建集合\"><a href=\"#4-使用规则创建集合\" class=\"headerlink\" title=\"4.使用规则创建集合\"></a>4.使用规则创建集合</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = mongoose.<span class=\"hljs-title function_\">model</span>(<span class=\"hljs-string\">&#x27;User&#x27;</span>,<span class=\"hljs-title class_\">UserSchema</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-创建集合对象实例\"><a href=\"#5-创建集合对象实例\" class=\"headerlink\" title=\"5.创建集合对象实例\"></a>5.创建集合对象实例</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"> 第一种办法<br><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">create</span>(&#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;badspider&quot;</span>,<span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">12</span>,<span class=\"hljs-attr\">adress</span>:<span class=\"hljs-string\">&quot;china&quot;</span>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res),<span class=\"hljs-function\"><span class=\"hljs-params\">err</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err))<br><br>第二种办法<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>(&#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;badspider&quot;</span>,<span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">12</span>,<span class=\"hljs-attr\">adress</span>:<span class=\"hljs-string\">&quot;china&quot;</span>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res),<span class=\"hljs-function\"><span class=\"hljs-params\">err</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err))<br><br> 第三种办法<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>(&#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;badspider&quot;</span>,<span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">12</span>,<span class=\"hljs-attr\">adress</span>:<span class=\"hljs-string\">&quot;china&quot;</span>&#125;,<span class=\"hljs-function\">(<span class=\"hljs-params\">err,res</span>)=&gt;</span>&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err)<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res)                                                                 <br>&#125;)<br>  保存数据,将course文档(行)插入到文档<br><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-property\">save</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"6-从文件夹导入数据到数据库\"><a href=\"#6-从文件夹导入数据到数据库\" class=\"headerlink\" title=\"6.从文件夹导入数据到数据库\"></a>6.从文件夹导入数据到数据库</h3><blockquote>\n<p>mongoimport -d 数据库名称 -c 集合名称 –file 要导入数据的文件</p>\n</blockquote>\n<h3 id=\"7-查询数据\"><a href=\"#7-查询数据\" class=\"headerlink\" title=\"7.查询数据\"></a>7.查询数据</h3><h4 id=\"7-1-find\"><a href=\"#7-1-find\" class=\"headerlink\" title=\"7.1 find()\"></a>7.1 find()</h4><p>通过==find()**得到的数据返回的一个数组</p>\n<p><strong>查询User这个集合下的所有的数据</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))  <br></code></pre></td></tr></table></figure>\n\n<p><strong>根据条件查询数据</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>(&#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;badspiedr&quot;</span>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-2-findOne\"><a href=\"#7-2-findOne\" class=\"headerlink\" title=\"7.2 findOne()\"></a>7.2 findOne()</h4><p>通过 ==findOne()** 查找单个数据,返回的是单个对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">findOne</span>(&#123;<span class=\"hljs-attr\">age</span>:<span class=\"hljs-string\">&quot;23&quot;</span>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-3-匹配大于小于\"><a href=\"#7-3-匹配大于小于\" class=\"headerlink\" title=\"7.3 匹配大于小于\"></a>7.3 匹配大于小于</h4><p>查询年龄在 20 – 40 之间的文档</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>(&#123;<span class=\"hljs-attr\">age</span>:&#123;<span class=\"hljs-attr\">$gt</span>:<span class=\"hljs-number\">20</span>,<span class=\"hljs-attr\">$lt</span>:<span class=\"hljs-number\">40</span>&#125;&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-4-匹配包含\"><a href=\"#7-4-匹配包含\" class=\"headerlink\" title=\"7.4 匹配包含\"></a>7.4 匹配包含</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>(&#123;<span class=\"hljs-attr\">hobbies</span>:&#123;<span class=\"hljs-attr\">$in</span>:[<span class=\"hljs-string\">&#x27;吃饭&#x27;</span>]&#125;&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-5-选择要查询的字段\"><a href=\"#7-5-选择要查询的字段\" class=\"headerlink\" title=\"7.5 选择要查询的字段\"></a>7.5 选择要查询的字段</h4><p>一定会包含 _id  ,要是不想要查询某字段的话，需要在前面加上 <strong>-</strong> ，<code>-_id</code>表示不需要查询</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>().<span class=\"hljs-title function_\">select</span>(<span class=\"hljs-string\">&#x27;name age -_id&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-6-将数据进行-升序-排列\"><a href=\"#7-6-将数据进行-升序-排列\" class=\"headerlink\" title=\"7.6 将数据进行 升序 排列\"></a>7.6 将数据进行 升序 排列</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>().<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-string\">&#x27;age&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-7-将数据进行-降序-排列\"><a href=\"#7-7-将数据进行-降序-排列\" class=\"headerlink\" title=\"7.7 将数据进行 降序 排列\"></a>7.7 将数据进行 降序 排列</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">find</span>().<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-string\">&#x27;-age&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"8-删除数据\"><a href=\"#8-删除数据\" class=\"headerlink\" title=\"8.删除数据\"></a>8.删除数据</h3><h4 id=\"8-1-删除单个数据\"><a href=\"#8-1-删除单个数据\" class=\"headerlink\" title=\"8.1 删除单个数据\"></a>8.1 删除单个数据</h4><p>删除单个文档，返回的值是删除的文档</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">findOneAndDelete</span>(&#123;<span class=\"hljs-attr\">_id</span>:<span class=\"hljs-string\">&quot;61b54d87a4d771ff4c1ad2f9&quot;</span>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"8-4-删除多个数据\"><a href=\"#8-4-删除多个数据\" class=\"headerlink\" title=\"8.4 删除多个数据\"></a>8.4 删除多个数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">deleteMany</span>(&#123;&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"9-更新文档\"><a href=\"#9-更新文档\" class=\"headerlink\" title=\"9. 更新文档\"></a>9. 更新文档</h3><h4 id=\"9-1-更新单个\"><a href=\"#9-1-更新单个\" class=\"headerlink\" title=\"9.1 更新单个\"></a>9.1 更新单个</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">updateOne</span>(&#123;查询条件&#125;,&#123;要修改的值&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"9-2-更新多个\"><a href=\"#9-2-更新多个\" class=\"headerlink\" title=\"9.2 更新多个\"></a>9.2 更新多个</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">updateMany</span>(&#123;查询条件&#125;,&#123;要修改的值&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"10-mongoose-验证\"><a href=\"#10-mongoose-验证\" class=\"headerlink\" title=\"10.mongoose 验证\"></a>10.mongoose 验证</h3><p>在创建集合的时候，可以设置当前字段的验证规则，验证失败则输入插入就失败</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-attr\">requrie</span>: <span class=\"hljs-literal\">true</span> 必传字段<br> <span class=\"hljs-keyword\">const</span> postSchem = <span class=\"hljs-keyword\">new</span> mongoose.<span class=\"hljs-title class_\">Schema</span>(&#123;<br>     <span class=\"hljs-attr\">title</span>: &#123;<br>         <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span>,<br>         <span class=\"hljs-attr\">required</span>: [<span class=\"hljs-literal\">true</span>,<span class=\"hljs-string\">&#x27;请传入文字标题&#x27;</span>],<br>         <span class=\"hljs-attr\">minlength</span>: <span class=\"hljs-number\">2</span>,<br>         <span class=\"hljs-attr\">maxlength</span>: <span class=\"hljs-number\">5</span><br>     &#125;,<br>     <span class=\"hljs-attr\">author</span>: &#123;<br>         <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span>,<br>         <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>,<br>          自定义验证规则<br>         <span class=\"hljs-attr\">validate</span>: &#123;<br>              返回布尔值<br>             <span class=\"hljs-attr\">validator</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> &#123;<br>                 <span class=\"hljs-keyword\">return</span> v&amp;&amp;v.<span class=\"hljs-property\">length</span>&gt; <span class=\"hljs-number\">7</span><br>             &#125;,<br>         &#125;,<br>          自定义错误信息<br>         <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;传入的值不符合验证规则&#x27;</span><br>     &#125;<br> &#125;)<br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"11-集合关联\"><a href=\"#11-集合关联\" class=\"headerlink\" title=\"11.集合关联\"></a>11.集合关联</h3><p><em>通常 不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同的集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联</em></p>\n<ul>\n<li><p>使用 id 对集合进行关联</p>\n</li>\n<li><p>使用populate方法进行关联集合查询</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UserSchema</span> = <span class=\"hljs-keyword\">new</span> mongoose.<span class=\"hljs-title class_\">Schema</span>(&#123;<br>    <span class=\"hljs-attr\">name</span>: &#123;<br>        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span><br>    &#125;<br>&#125;)<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">PostSchema</span> = <span class=\"hljs-keyword\">new</span> mongoose.<span class=\"hljs-title class_\">Schema</span>(&#123;<br>    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span>,<br>    <span class=\"hljs-attr\">author</span>: &#123;<br>         要关联的集合的_id<br>        <span class=\"hljs-attr\">type</span>: mongoose.<span class=\"hljs-property\">Schema</span>.<span class=\"hljs-property\">Types</span>.<span class=\"hljs-property\">ObjectId</span>,<br>         要关联的集合<br>        <span class=\"hljs-attr\">ref</span>:<span class=\"hljs-string\">&#x27;User&#x27;</span><br>    &#125;<br>&#125;)<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">User</span> = mongoose.<span class=\"hljs-title function_\">model</span>(<span class=\"hljs-string\">&#x27;User&#x27;</span>, <span class=\"hljs-title class_\">UserSchema</span>)<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Post</span> = mongoose.<span class=\"hljs-title function_\">model</span>(<span class=\"hljs-string\">&#x27;Post&#x27;</span>, <span class=\"hljs-title class_\">PostSchema</span>)<br><br> <span class=\"hljs-title class_\">User</span>.<span class=\"hljs-title function_\">create</span>(&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;badspider&quot;</span> &#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br> <span class=\"hljs-title class_\">Post</span>.<span class=\"hljs-title function_\">create</span>(&#123;<span class=\"hljs-attr\">title</span>:<span class=\"hljs-string\">&#x27;nodejs&#x27;</span>,<span class=\"hljs-attr\">author</span>:<span class=\"hljs-string\">&#x27;61b561b05904f504522d9d74&#x27;</span>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br><br> 联合查询<br> <span class=\"hljs-number\">1.</span><span class=\"hljs-title class_\">Post</span>.<span class=\"hljs-title function_\">find</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br> 返回的数据<br> [<br>     &#123;<br>       <span class=\"hljs-attr\">_id</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectId</span>(<span class=\"hljs-string\">&quot;61b561e2fc16177e89714a68&quot;</span>),<br>       <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;nodejs&#x27;</span>,<br>       <span class=\"hljs-attr\">author</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectId</span>(<span class=\"hljs-string\">&quot;61b561b05904f504522d9d74&quot;</span>),<br>       <span class=\"hljs-attr\">__v</span>: <span class=\"hljs-number\">0</span><br>     &#125;<br>   ]<br><br> <span class=\"hljs-number\">2.</span><span class=\"hljs-title class_\">Post</span>.<span class=\"hljs-title function_\">find</span>().<span class=\"hljs-title function_\">populate</span>(<span class=\"hljs-string\">&#x27;author&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res))<br> 返回的数据<br> [<br>     &#123;<br>       <span class=\"hljs-attr\">_id</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectId</span>(<span class=\"hljs-string\">&quot;61b561e2fc16177e89714a68&quot;</span>),  <br>       <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;nodejs&#x27;</span>,<br>       <span class=\"hljs-attr\">author</span>: &#123;<br>         <span class=\"hljs-attr\">_id</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectId</span>(<span class=\"hljs-string\">&quot;61b561b05904f504522d9d74&quot;</span>),<br>         <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;badspider&#x27;</span>,<br>         <span class=\"hljs-attr\">__v</span>: <span class=\"hljs-number\">0</span><br>       &#125;,<br>       <span class=\"hljs-attr\">__v</span>: <span class=\"hljs-number\">0</span><br>     &#125;<br>   ]<br></code></pre></td></tr></table></figure>\n\n"},{"title":"关于在hexo中添加全局音乐","date":"2020-09-03T11:24:31.000Z","index_img":"/img/top7.jpg","banner_img":"/img/top9.jpg","_content":"<h3>使用音乐平台提供插件</h3>\n以网易云为例，网页端点击生成<b>外链播放器</b>即可生成外链代码，如我的某个歌单生成<a href=\"https://music.163.com/#/outchain/0/2205641361/\">外链</a>\n\n可以在自己博客页面中嵌入插件:\n```javascript\n<iframe \n frameborder=\"no\" border=\"0\" \n marginwidth=\"0\" marginheight=\"0\" \n width=530 height=310 \n src=\"//music.163.com/outchain/player?type=0&id=2205641361&auto=0&height=430\">\n</iframe>\n```\n**效果**：\n缺点非常明显，而最不能忍得是网易音乐有些音乐因为版权保护，没办法生成外链\n\n<h3>使用 hexo-tag-aplayer 插件</h3>\n搭建好自己的博客之后，想要在博客中添加音乐播放器。需要hexo-tag-aplayer插件。\n使用Git Bash进入本地hexo的文件夹。输入以下命令\n\n```javascript\nnpm install --save hexo-tag-aplayer\n```\n原先 hexo-tag-aplayer 不支持 MetingJS，使得需要图片url，音乐url等等参数，操作起来都很麻烦，需要去音乐网站扒音乐播放链接或者下载下来存储在七牛云或本地，要了解具体参数和使用可以查看其<a href=\"https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md\">中文文档</a>了解 \n然后在 Hexo 配置文件 _config.yml 中添加设置:\n\n```javascript\naplayer:\n    meting: true\n```\n接着就可以 在文章中使用 MetingJS 播放器了,打开网页版本的网页云，点开一首歌，找到最上面的网址栏的id，把id填到下面去那个meting之后\n\n```javascript\n{% meting \"id\" \"netease\" \"song\" \"theme:#555\" \"mutex:true\" \"listmaxheight:340px\" \"preload:auto\" %}\n```\n歌单模板\n\n```javascript\n{% meting \"627070825\" \"netease\" \"playlist\" \"theme:#555\" \"mutex:true\" \"listmaxheight:340px\" \"preload:auto\" %}\n```\n有关选项列表如下:\n<div class=\"table-box\"><table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td><strong>必须值</strong></td><td>歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td></tr><tr><td>server</td><td><strong>必须值</strong></td><td>音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td></tr><tr><td>type</td><td><strong>必须值</strong></td><td><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td></tr><tr><td>fixed</td><td><code>false</code></td><td>开启固定模式</td></tr><tr><td>mini</td><td><code>false</code></td><td>开启迷你模式</td></tr><tr><td>loop</td><td><code>all</code></td><td>列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td></tr><tr><td>order</td><td><code>list</code></td><td>列表播放模式： <code>list</code>, <code>random</code></td></tr><tr><td>volume</td><td>0.7</td><td>播放器音量</td></tr><tr><td>lrctype</td><td>0</td><td>歌词格式类型</td></tr><tr><td>listfolded</td><td><code>false</code></td><td>指定音乐播放列表是否折叠</td></tr><tr><td>storagename</td><td><code>metingjs</code></td><td>LocalStorage 中存储播放器设定的键名</td></tr><tr><td>autoplay</td><td><code>true</code></td><td>自动播放，移动端浏览器暂时不支持此功能</td></tr><tr><td>mutex</td><td><code>true</code></td><td>该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr><td>listmaxheight</td><td><code>340px</code></td><td>播放列表的最大长度</td></tr><tr><td>preload</td><td><code>auto</code></td><td>音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td></tr><tr><td>theme</td><td><code>#ad7a86</code></td><td>播放器风格色彩设置</td></tr></tbody></table></div>","source":"_posts/music.md","raw":"---\ntitle: 关于在hexo中添加全局音乐\ndate: 2020-09-03 19:24:31\ntags: aplyer\ncategories: hexo\nindex_img: /img/top7.jpg\nbanner_img: /img/top9.jpg\n---\n<h3>使用音乐平台提供插件</h3>\n以网易云为例，网页端点击生成<b>外链播放器</b>即可生成外链代码，如我的某个歌单生成<a href=\"https://music.163.com/#/outchain/0/2205641361/\">外链</a>\n\n可以在自己博客页面中嵌入插件:\n```javascript\n<iframe \n frameborder=\"no\" border=\"0\" \n marginwidth=\"0\" marginheight=\"0\" \n width=530 height=310 \n src=\"//music.163.com/outchain/player?type=0&id=2205641361&auto=0&height=430\">\n</iframe>\n```\n**效果**：\n缺点非常明显，而最不能忍得是网易音乐有些音乐因为版权保护，没办法生成外链\n\n<h3>使用 hexo-tag-aplayer 插件</h3>\n搭建好自己的博客之后，想要在博客中添加音乐播放器。需要hexo-tag-aplayer插件。\n使用Git Bash进入本地hexo的文件夹。输入以下命令\n\n```javascript\nnpm install --save hexo-tag-aplayer\n```\n原先 hexo-tag-aplayer 不支持 MetingJS，使得需要图片url，音乐url等等参数，操作起来都很麻烦，需要去音乐网站扒音乐播放链接或者下载下来存储在七牛云或本地，要了解具体参数和使用可以查看其<a href=\"https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md\">中文文档</a>了解 \n然后在 Hexo 配置文件 _config.yml 中添加设置:\n\n```javascript\naplayer:\n    meting: true\n```\n接着就可以 在文章中使用 MetingJS 播放器了,打开网页版本的网页云，点开一首歌，找到最上面的网址栏的id，把id填到下面去那个meting之后\n\n```javascript\n{% meting \"id\" \"netease\" \"song\" \"theme:#555\" \"mutex:true\" \"listmaxheight:340px\" \"preload:auto\" %}\n```\n歌单模板\n\n```javascript\n{% meting \"627070825\" \"netease\" \"playlist\" \"theme:#555\" \"mutex:true\" \"listmaxheight:340px\" \"preload:auto\" %}\n```\n有关选项列表如下:\n<div class=\"table-box\"><table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td><strong>必须值</strong></td><td>歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td></tr><tr><td>server</td><td><strong>必须值</strong></td><td>音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td></tr><tr><td>type</td><td><strong>必须值</strong></td><td><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td></tr><tr><td>fixed</td><td><code>false</code></td><td>开启固定模式</td></tr><tr><td>mini</td><td><code>false</code></td><td>开启迷你模式</td></tr><tr><td>loop</td><td><code>all</code></td><td>列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td></tr><tr><td>order</td><td><code>list</code></td><td>列表播放模式： <code>list</code>, <code>random</code></td></tr><tr><td>volume</td><td>0.7</td><td>播放器音量</td></tr><tr><td>lrctype</td><td>0</td><td>歌词格式类型</td></tr><tr><td>listfolded</td><td><code>false</code></td><td>指定音乐播放列表是否折叠</td></tr><tr><td>storagename</td><td><code>metingjs</code></td><td>LocalStorage 中存储播放器设定的键名</td></tr><tr><td>autoplay</td><td><code>true</code></td><td>自动播放，移动端浏览器暂时不支持此功能</td></tr><tr><td>mutex</td><td><code>true</code></td><td>该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr><td>listmaxheight</td><td><code>340px</code></td><td>播放列表的最大长度</td></tr><tr><td>preload</td><td><code>auto</code></td><td>音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td></tr><tr><td>theme</td><td><code>#ad7a86</code></td><td>播放器风格色彩设置</td></tr></tbody></table></div>","slug":"music","published":1,"updated":"2024-11-17T13:58:10.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpl001f73t36l0s6nln","content":"<h3>使用音乐平台提供插件</h3>\n以网易云为例，网页端点击生成<b>外链播放器</b>即可生成外链代码，如我的某个歌单生成<a href=\"https://music.163.com/#/outchain/0/2205641361/\">外链</a>\n\n<p>可以在自己博客页面中嵌入插件:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;iframe <br> frameborder=<span class=\"hljs-string\">&quot;no&quot;</span> border=<span class=\"hljs-string\">&quot;0&quot;</span> <br> marginwidth=<span class=\"hljs-string\">&quot;0&quot;</span> marginheight=<span class=\"hljs-string\">&quot;0&quot;</span> <br> width=<span class=\"hljs-number\">530</span> height=<span class=\"hljs-number\">310</span> <br> src=<span class=\"hljs-string\">&quot;//music.163.com/outchain/player?type=0&amp;id=2205641361&amp;auto=0&amp;height=430&quot;</span>&gt;<br>&lt;/iframe&gt;<br></code></pre></td></tr></table></figure>\n<p><strong>效果</strong>：<br>缺点非常明显，而最不能忍得是网易音乐有些音乐因为版权保护，没办法生成外链</p>\n<h3>使用 hexo-tag-aplayer 插件</h3>\n搭建好自己的博客之后，想要在博客中添加音乐播放器。需要hexo-tag-aplayer插件。\n使用Git Bash进入本地hexo的文件夹。输入以下命令\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">npm install --save hexo-tag-aplayer<br></code></pre></td></tr></table></figure>\n<p>原先 hexo-tag-aplayer 不支持 MetingJS，使得需要图片url，音乐url等等参数，操作起来都很麻烦，需要去音乐网站扒音乐播放链接或者下载下来存储在七牛云或本地，要了解具体参数和使用可以查看其<a href=\"https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md\">中文文档</a>了解<br>然后在 Hexo 配置文件 _config.yml 中添加设置:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">aplayer</span>:<br>    <span class=\"hljs-attr\">meting</span>: <span class=\"hljs-literal\">true</span><br></code></pre></td></tr></table></figure>\n<p>接着就可以 在文章中使用 MetingJS 播放器了,打开网页版本的网页云，点开一首歌，找到最上面的网址栏的id，把id填到下面去那个meting之后</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;% meting <span class=\"hljs-string\">&quot;id&quot;</span> <span class=\"hljs-string\">&quot;netease&quot;</span> <span class=\"hljs-string\">&quot;song&quot;</span> <span class=\"hljs-string\">&quot;theme:#555&quot;</span> <span class=\"hljs-string\">&quot;mutex:true&quot;</span> <span class=\"hljs-string\">&quot;listmaxheight:340px&quot;</span> <span class=\"hljs-string\">&quot;preload:auto&quot;</span> %&#125;<br></code></pre></td></tr></table></figure>\n<p>歌单模板</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;% meting <span class=\"hljs-string\">&quot;627070825&quot;</span> <span class=\"hljs-string\">&quot;netease&quot;</span> <span class=\"hljs-string\">&quot;playlist&quot;</span> <span class=\"hljs-string\">&quot;theme:#555&quot;</span> <span class=\"hljs-string\">&quot;mutex:true&quot;</span> <span class=\"hljs-string\">&quot;listmaxheight:340px&quot;</span> <span class=\"hljs-string\">&quot;preload:auto&quot;</span> %&#125;<br></code></pre></td></tr></table></figure>\n<p>有关选项列表如下:</p>\n<div class=\"table-box\"><table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td><strong>必须值</strong></td><td>歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td></tr><tr><td>server</td><td><strong>必须值</strong></td><td>音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td></tr><tr><td>type</td><td><strong>必须值</strong></td><td><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td></tr><tr><td>fixed</td><td><code>false</code></td><td>开启固定模式</td></tr><tr><td>mini</td><td><code>false</code></td><td>开启迷你模式</td></tr><tr><td>loop</td><td><code>all</code></td><td>列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td></tr><tr><td>order</td><td><code>list</code></td><td>列表播放模式： <code>list</code>, <code>random</code></td></tr><tr><td>volume</td><td>0.7</td><td>播放器音量</td></tr><tr><td>lrctype</td><td>0</td><td>歌词格式类型</td></tr><tr><td>listfolded</td><td><code>false</code></td><td>指定音乐播放列表是否折叠</td></tr><tr><td>storagename</td><td><code>metingjs</code></td><td>LocalStorage 中存储播放器设定的键名</td></tr><tr><td>autoplay</td><td><code>true</code></td><td>自动播放，移动端浏览器暂时不支持此功能</td></tr><tr><td>mutex</td><td><code>true</code></td><td>该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr><td>listmaxheight</td><td><code>340px</code></td><td>播放列表的最大长度</td></tr><tr><td>preload</td><td><code>auto</code></td><td>音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td></tr><tr><td>theme</td><td><code>#ad7a86</code></td><td>播放器风格色彩设置</td></tr></tbody></table></div>","site":{"data":{}},"wordcount":1537,"excerpt":"","more":"<h3>使用音乐平台提供插件</h3>\n以网易云为例，网页端点击生成<b>外链播放器</b>即可生成外链代码，如我的某个歌单生成<a href=\"https://music.163.com/#/outchain/0/2205641361/\">外链</a>\n\n<p>可以在自己博客页面中嵌入插件:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;iframe <br> frameborder=<span class=\"hljs-string\">&quot;no&quot;</span> border=<span class=\"hljs-string\">&quot;0&quot;</span> <br> marginwidth=<span class=\"hljs-string\">&quot;0&quot;</span> marginheight=<span class=\"hljs-string\">&quot;0&quot;</span> <br> width=<span class=\"hljs-number\">530</span> height=<span class=\"hljs-number\">310</span> <br> src=<span class=\"hljs-string\">&quot;//music.163.com/outchain/player?type=0&amp;id=2205641361&amp;auto=0&amp;height=430&quot;</span>&gt;<br>&lt;/iframe&gt;<br></code></pre></td></tr></table></figure>\n<p><strong>效果</strong>：<br>缺点非常明显，而最不能忍得是网易音乐有些音乐因为版权保护，没办法生成外链</p>\n<h3>使用 hexo-tag-aplayer 插件</h3>\n搭建好自己的博客之后，想要在博客中添加音乐播放器。需要hexo-tag-aplayer插件。\n使用Git Bash进入本地hexo的文件夹。输入以下命令\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">npm install --save hexo-tag-aplayer<br></code></pre></td></tr></table></figure>\n<p>原先 hexo-tag-aplayer 不支持 MetingJS，使得需要图片url，音乐url等等参数，操作起来都很麻烦，需要去音乐网站扒音乐播放链接或者下载下来存储在七牛云或本地，要了解具体参数和使用可以查看其<a href=\"https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md\">中文文档</a>了解<br>然后在 Hexo 配置文件 _config.yml 中添加设置:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">aplayer</span>:<br>    <span class=\"hljs-attr\">meting</span>: <span class=\"hljs-literal\">true</span><br></code></pre></td></tr></table></figure>\n<p>接着就可以 在文章中使用 MetingJS 播放器了,打开网页版本的网页云，点开一首歌，找到最上面的网址栏的id，把id填到下面去那个meting之后</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;% meting <span class=\"hljs-string\">&quot;id&quot;</span> <span class=\"hljs-string\">&quot;netease&quot;</span> <span class=\"hljs-string\">&quot;song&quot;</span> <span class=\"hljs-string\">&quot;theme:#555&quot;</span> <span class=\"hljs-string\">&quot;mutex:true&quot;</span> <span class=\"hljs-string\">&quot;listmaxheight:340px&quot;</span> <span class=\"hljs-string\">&quot;preload:auto&quot;</span> %&#125;<br></code></pre></td></tr></table></figure>\n<p>歌单模板</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;% meting <span class=\"hljs-string\">&quot;627070825&quot;</span> <span class=\"hljs-string\">&quot;netease&quot;</span> <span class=\"hljs-string\">&quot;playlist&quot;</span> <span class=\"hljs-string\">&quot;theme:#555&quot;</span> <span class=\"hljs-string\">&quot;mutex:true&quot;</span> <span class=\"hljs-string\">&quot;listmaxheight:340px&quot;</span> <span class=\"hljs-string\">&quot;preload:auto&quot;</span> %&#125;<br></code></pre></td></tr></table></figure>\n<p>有关选项列表如下:</p>\n<div class=\"table-box\"><table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td><strong>必须值</strong></td><td>歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td></tr><tr><td>server</td><td><strong>必须值</strong></td><td>音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td></tr><tr><td>type</td><td><strong>必须值</strong></td><td><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td></tr><tr><td>fixed</td><td><code>false</code></td><td>开启固定模式</td></tr><tr><td>mini</td><td><code>false</code></td><td>开启迷你模式</td></tr><tr><td>loop</td><td><code>all</code></td><td>列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td></tr><tr><td>order</td><td><code>list</code></td><td>列表播放模式： <code>list</code>, <code>random</code></td></tr><tr><td>volume</td><td>0.7</td><td>播放器音量</td></tr><tr><td>lrctype</td><td>0</td><td>歌词格式类型</td></tr><tr><td>listfolded</td><td><code>false</code></td><td>指定音乐播放列表是否折叠</td></tr><tr><td>storagename</td><td><code>metingjs</code></td><td>LocalStorage 中存储播放器设定的键名</td></tr><tr><td>autoplay</td><td><code>true</code></td><td>自动播放，移动端浏览器暂时不支持此功能</td></tr><tr><td>mutex</td><td><code>true</code></td><td>该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr><td>listmaxheight</td><td><code>340px</code></td><td>播放列表的最大长度</td></tr><tr><td>preload</td><td><code>auto</code></td><td>音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td></tr><tr><td>theme</td><td><code>#ad7a86</code></td><td>播放器风格色彩设置</td></tr></tbody></table></div>"},{"title":"Node","date":"2021-03-29T11:06:07.000Z","index_img":"/img/node.jpeg","banner_img":"/img/top8.jpg","_content":"\n#### 1.能学到啥\n\n- B/S 编程模型\n  - Browser - Server\n- 模块化编程\n- Node 常用 api\n- 异步编程\n- Express Web 开发框架\n- Ecmascript6\n\n#### 1.1 读取文件\n\nfs 是 file-system 的简写，就是文件系统的意思，在 node 中如果想要进行文件操作，就必须引入 fs 这个核心模块\n\n在 fs 这个核心模块中，就提供了所有的文件操作相关的 API 例如： fs.readFile 就是用来读取文件的\n\n```javascript\nvar fs = require(\"fs\");\nfs.readFile(\"../data/indexx.html\", function (error, data) {\n  if (error) {\n    console.log(\"读取文件失败\");\n  } else {\n    console.log(data.toString);\n  }\n});\n```\n\n> 第一个参数就是 要读取的文件路径\n>\n> 第二个参数就是 一个回调函数\n>\n> ​ 成功\n>\n> ​ data 数据\n>\n> ​ error null\n>\n> ​ 失败\n>\n> ​ data undefined\n>\n> ​ error 错误对象\n\n#### 1.2 写入文件\n\n```javascript\nvar fs = require(\"fs\");\nfs.writeFile(\"../data/ss.md\", \"我是要写入的内容\", function (error) {\n  //console.log('文件写入成功')\n  if (error) {\n    console.log(\"读取文件失败\");\n  } else {\n    console.log(\"写入成功了\");\n  }\n});\n```\n\n> 第一个参数：文件路径\n>\n> 第二个参数： 文件内容\n>\n> 第三个参数： 回调函数 error\n>\n> ​ 成功\n>\n> ​ 文件写入成功\n>\n> ​ error 是 null\n>\n> ​ 失败\n>\n> ​ 文件写入失败\n>\n> ​ error 就是错误对象\n\n#### 2.1 创建 http 服务\n\n```javascript\n//1.加载 http 核心模块\nvar http = require(\"http\");\n//2.使用 http.createSever() 方法创建一个 web 服务器\n//返回一个 Server 实例\nvar server = http.createServer();\n//3.服务器提供对数据的服务\n//  发请求\n//  接收请求   处理请求   发送响应\n\n//注册 request 请求事件\n// 当客户端请求过来，就会自动触发服务器的 request 请求事件，然后执行第二个参数 ：回调处理\nserver.on(\"request\", function (request, response) {\n  console.log(\"收到客户端的请求了，请求路径是：\" + request.url);\n\n  //response 对象有一个方法： write 可以用来给客户端发送响应数据\n  //write 可以使用多次，但是最后一定要使用 end 来结束响应，否则客户端会一直等待\n  response.write(\"hello\");\n  response.write(\"sss\");\n  //告诉客户端，我的话说完了,你可以给用户了\n  response.end();\n});\n\n//4.绑定端口号，启动服务器\nserver.listen(3000, function () {\n  console.log(\"服务器启动成功啦，可以通过 http://127.0.0.1:3000/ 来进行访问\");\n});\n```\n\n> request 请求事件处理函数 需要接收两个参数：\n>\n> ​ Request 请求对象\n>\n> ​ 请求对象可以用来获取客户端的一些请求消息，例如请求路径\n>\n> ​ Response 响应对象\n>\n> ​ 响应对象可以用来给客户端发送响应消息\n\n#### 3.用户自定义模块\n\n**require 是一个方法**\n\n- 它的作用就是用来加载模块的\n\n**在 Node 中，模块有三种**\n\n- 具名的核心模块，例如 fs，http\n- 用户自己编写的文件模块\n\n> 相对路径必须加 ./ require(./b.js)\n\n- 在 Node 中，没有全局作用域，只有模块作用域(外部访问不到内部，内部访问不到外部)\n\n_有时候我们加载文件模块的目的不是为了简简单单的执行里面的代码，更重要的是为了使用里面的变量_\n\n**require 方法有两个作用**\n\n1.加载文件模块并执行里面的代码\n\n2.拿到被加载文件模块导出的接口对象\n\nexports 默认是一个==空对象==，在每个文件模块中都提供了一个对象：exports\n\n```javascript\n//a.js\nvar ret = require(\"./b.js\");\n//ret ==exports\nconsole.log(ret.foo);\n\n//b.js\nvar foo = \"bbb\";\n\nexports.foo = \"hello world\";\n```\n\n#### ip 地址和端口号\n\nip 地址用来定位计算机\n\n端口号用来定位具体的应用程序（所有需要联网通信的软件都必须具有端口号）\n\n> 所有联网的程序都需要进行网络通信\n>\n> 计算机中只有一个物理网卡，而且同一个局域网中，网卡的地址必须是唯一的\n>\n> 网卡是通过唯一的 ip 地址来进行定位的\n\n端口号的范围从 0~~65536 之间\n\n可以同时开启多个服务，但是一定要确保不同服务占用的端口号不一样\n","source":"_posts/node.md","raw":"---\ntitle: Node\ndate: 2021-03-29 19:06:07\ntags: Node\ncategories: 后端\nindex_img: /img/node.jpeg\nbanner_img: /img/top8.jpg\n---\n\n#### 1.能学到啥\n\n- B/S 编程模型\n  - Browser - Server\n- 模块化编程\n- Node 常用 api\n- 异步编程\n- Express Web 开发框架\n- Ecmascript6\n\n#### 1.1 读取文件\n\nfs 是 file-system 的简写，就是文件系统的意思，在 node 中如果想要进行文件操作，就必须引入 fs 这个核心模块\n\n在 fs 这个核心模块中，就提供了所有的文件操作相关的 API 例如： fs.readFile 就是用来读取文件的\n\n```javascript\nvar fs = require(\"fs\");\nfs.readFile(\"../data/indexx.html\", function (error, data) {\n  if (error) {\n    console.log(\"读取文件失败\");\n  } else {\n    console.log(data.toString);\n  }\n});\n```\n\n> 第一个参数就是 要读取的文件路径\n>\n> 第二个参数就是 一个回调函数\n>\n> ​ 成功\n>\n> ​ data 数据\n>\n> ​ error null\n>\n> ​ 失败\n>\n> ​ data undefined\n>\n> ​ error 错误对象\n\n#### 1.2 写入文件\n\n```javascript\nvar fs = require(\"fs\");\nfs.writeFile(\"../data/ss.md\", \"我是要写入的内容\", function (error) {\n  //console.log('文件写入成功')\n  if (error) {\n    console.log(\"读取文件失败\");\n  } else {\n    console.log(\"写入成功了\");\n  }\n});\n```\n\n> 第一个参数：文件路径\n>\n> 第二个参数： 文件内容\n>\n> 第三个参数： 回调函数 error\n>\n> ​ 成功\n>\n> ​ 文件写入成功\n>\n> ​ error 是 null\n>\n> ​ 失败\n>\n> ​ 文件写入失败\n>\n> ​ error 就是错误对象\n\n#### 2.1 创建 http 服务\n\n```javascript\n//1.加载 http 核心模块\nvar http = require(\"http\");\n//2.使用 http.createSever() 方法创建一个 web 服务器\n//返回一个 Server 实例\nvar server = http.createServer();\n//3.服务器提供对数据的服务\n//  发请求\n//  接收请求   处理请求   发送响应\n\n//注册 request 请求事件\n// 当客户端请求过来，就会自动触发服务器的 request 请求事件，然后执行第二个参数 ：回调处理\nserver.on(\"request\", function (request, response) {\n  console.log(\"收到客户端的请求了，请求路径是：\" + request.url);\n\n  //response 对象有一个方法： write 可以用来给客户端发送响应数据\n  //write 可以使用多次，但是最后一定要使用 end 来结束响应，否则客户端会一直等待\n  response.write(\"hello\");\n  response.write(\"sss\");\n  //告诉客户端，我的话说完了,你可以给用户了\n  response.end();\n});\n\n//4.绑定端口号，启动服务器\nserver.listen(3000, function () {\n  console.log(\"服务器启动成功啦，可以通过 http://127.0.0.1:3000/ 来进行访问\");\n});\n```\n\n> request 请求事件处理函数 需要接收两个参数：\n>\n> ​ Request 请求对象\n>\n> ​ 请求对象可以用来获取客户端的一些请求消息，例如请求路径\n>\n> ​ Response 响应对象\n>\n> ​ 响应对象可以用来给客户端发送响应消息\n\n#### 3.用户自定义模块\n\n**require 是一个方法**\n\n- 它的作用就是用来加载模块的\n\n**在 Node 中，模块有三种**\n\n- 具名的核心模块，例如 fs，http\n- 用户自己编写的文件模块\n\n> 相对路径必须加 ./ require(./b.js)\n\n- 在 Node 中，没有全局作用域，只有模块作用域(外部访问不到内部，内部访问不到外部)\n\n_有时候我们加载文件模块的目的不是为了简简单单的执行里面的代码，更重要的是为了使用里面的变量_\n\n**require 方法有两个作用**\n\n1.加载文件模块并执行里面的代码\n\n2.拿到被加载文件模块导出的接口对象\n\nexports 默认是一个==空对象==，在每个文件模块中都提供了一个对象：exports\n\n```javascript\n//a.js\nvar ret = require(\"./b.js\");\n//ret ==exports\nconsole.log(ret.foo);\n\n//b.js\nvar foo = \"bbb\";\n\nexports.foo = \"hello world\";\n```\n\n#### ip 地址和端口号\n\nip 地址用来定位计算机\n\n端口号用来定位具体的应用程序（所有需要联网通信的软件都必须具有端口号）\n\n> 所有联网的程序都需要进行网络通信\n>\n> 计算机中只有一个物理网卡，而且同一个局域网中，网卡的地址必须是唯一的\n>\n> 网卡是通过唯一的 ip 地址来进行定位的\n\n端口号的范围从 0~~65536 之间\n\n可以同时开启多个服务，但是一定要确保不同服务占用的端口号不一样\n","slug":"node","published":1,"updated":"2024-11-17T13:58:10.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpl001j73t3b35z5lg8","content":"<h4 id=\"1-能学到啥\"><a href=\"#1-能学到啥\" class=\"headerlink\" title=\"1.能学到啥\"></a>1.能学到啥</h4><ul>\n<li>B/S 编程模型<ul>\n<li>Browser - Server</li>\n</ul>\n</li>\n<li>模块化编程</li>\n<li>Node 常用 api</li>\n<li>异步编程</li>\n<li>Express Web 开发框架</li>\n<li>Ecmascript6</li>\n</ul>\n<h4 id=\"1-1-读取文件\"><a href=\"#1-1-读取文件\" class=\"headerlink\" title=\"1.1 读取文件\"></a>1.1 读取文件</h4><p>fs 是 file-system 的简写，就是文件系统的意思，在 node 中如果想要进行文件操作，就必须引入 fs 这个核心模块</p>\n<p>在 fs 这个核心模块中，就提供了所有的文件操作相关的 API 例如： fs.readFile 就是用来读取文件的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;fs&quot;</span>);<br>fs.<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;../data/indexx.html&quot;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">error, data</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;读取文件失败&quot;</span>);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data.<span class=\"hljs-property\">toString</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>第一个参数就是 要读取的文件路径</p>\n<p>第二个参数就是 一个回调函数</p>\n<p>​ 成功</p>\n<p>​ data 数据</p>\n<p>​ error null</p>\n<p>​ 失败</p>\n<p>​ data undefined</p>\n<p>​ error 错误对象</p>\n</blockquote>\n<h4 id=\"1-2-写入文件\"><a href=\"#1-2-写入文件\" class=\"headerlink\" title=\"1.2 写入文件\"></a>1.2 写入文件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;fs&quot;</span>);<br>fs.<span class=\"hljs-title function_\">writeFile</span>(<span class=\"hljs-string\">&quot;../data/ss.md&quot;</span>, <span class=\"hljs-string\">&quot;我是要写入的内容&quot;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">error</span>) &#123;<br>  <span class=\"hljs-comment\">//console.log(&#x27;文件写入成功&#x27;)</span><br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;读取文件失败&quot;</span>);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;写入成功了&quot;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>第一个参数：文件路径</p>\n<p>第二个参数： 文件内容</p>\n<p>第三个参数： 回调函数 error</p>\n<p>​ 成功</p>\n<p>​ 文件写入成功</p>\n<p>​ error 是 null</p>\n<p>​ 失败</p>\n<p>​ 文件写入失败</p>\n<p>​ error 就是错误对象</p>\n</blockquote>\n<h4 id=\"2-1-创建-http-服务\"><a href=\"#2-1-创建-http-服务\" class=\"headerlink\" title=\"2.1 创建 http 服务\"></a>2.1 创建 http 服务</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//1.加载 http 核心模块</span><br><span class=\"hljs-keyword\">var</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;http&quot;</span>);<br><span class=\"hljs-comment\">//2.使用 http.createSever() 方法创建一个 web 服务器</span><br><span class=\"hljs-comment\">//返回一个 Server 实例</span><br><span class=\"hljs-keyword\">var</span> server = http.<span class=\"hljs-title function_\">createServer</span>();<br><span class=\"hljs-comment\">//3.服务器提供对数据的服务</span><br><span class=\"hljs-comment\">//  发请求</span><br><span class=\"hljs-comment\">//  接收请求   处理请求   发送响应</span><br><br><span class=\"hljs-comment\">//注册 request 请求事件</span><br><span class=\"hljs-comment\">// 当客户端请求过来，就会自动触发服务器的 request 请求事件，然后执行第二个参数 ：回调处理</span><br>server.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">request, response</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;收到客户端的请求了，请求路径是：&quot;</span> + request.<span class=\"hljs-property\">url</span>);<br><br>  <span class=\"hljs-comment\">//response 对象有一个方法： write 可以用来给客户端发送响应数据</span><br>  <span class=\"hljs-comment\">//write 可以使用多次，但是最后一定要使用 end 来结束响应，否则客户端会一直等待</span><br>  response.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>  response.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&quot;sss&quot;</span>);<br>  <span class=\"hljs-comment\">//告诉客户端，我的话说完了,你可以给用户了</span><br>  response.<span class=\"hljs-title function_\">end</span>();<br>&#125;);<br><br><span class=\"hljs-comment\">//4.绑定端口号，启动服务器</span><br>server.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;服务器启动成功啦，可以通过 http://127.0.0.1:3000/ 来进行访问&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>request 请求事件处理函数 需要接收两个参数：</p>\n<p>​ Request 请求对象</p>\n<p>​ 请求对象可以用来获取客户端的一些请求消息，例如请求路径</p>\n<p>​ Response 响应对象</p>\n<p>​ 响应对象可以用来给客户端发送响应消息</p>\n</blockquote>\n<h4 id=\"3-用户自定义模块\"><a href=\"#3-用户自定义模块\" class=\"headerlink\" title=\"3.用户自定义模块\"></a>3.用户自定义模块</h4><p><strong>require 是一个方法</strong></p>\n<ul>\n<li>它的作用就是用来加载模块的</li>\n</ul>\n<p><strong>在 Node 中，模块有三种</strong></p>\n<ul>\n<li>具名的核心模块，例如 fs，http</li>\n<li>用户自己编写的文件模块</li>\n</ul>\n<blockquote>\n<p>相对路径必须加 ./ require(./b.js)</p>\n</blockquote>\n<ul>\n<li>在 Node 中，没有全局作用域，只有模块作用域(外部访问不到内部，内部访问不到外部)</li>\n</ul>\n<p><em>有时候我们加载文件模块的目的不是为了简简单单的执行里面的代码，更重要的是为了使用里面的变量</em></p>\n<p><strong>require 方法有两个作用</strong></p>\n<p>1.加载文件模块并执行里面的代码</p>\n<p>2.拿到被加载文件模块导出的接口对象</p>\n<p>exports 默认是一个==空对象==，在每个文件模块中都提供了一个对象：exports</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//a.js</span><br><span class=\"hljs-keyword\">var</span> ret = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./b.js&quot;</span>);<br><span class=\"hljs-comment\">//ret ==exports</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(ret.<span class=\"hljs-property\">foo</span>);<br><br><span class=\"hljs-comment\">//b.js</span><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">&quot;bbb&quot;</span>;<br><br><span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-string\">&quot;hello world&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"ip-地址和端口号\"><a href=\"#ip-地址和端口号\" class=\"headerlink\" title=\"ip 地址和端口号\"></a>ip 地址和端口号</h4><p>ip 地址用来定位计算机</p>\n<p>端口号用来定位具体的应用程序（所有需要联网通信的软件都必须具有端口号）</p>\n<blockquote>\n<p>所有联网的程序都需要进行网络通信</p>\n<p>计算机中只有一个物理网卡，而且同一个局域网中，网卡的地址必须是唯一的</p>\n<p>网卡是通过唯一的 ip 地址来进行定位的</p>\n</blockquote>\n<p>端口号的范围从 0~~65536 之间</p>\n<p>可以同时开启多个服务，但是一定要确保不同服务占用的端口号不一样</p>\n","site":{"data":{}},"wordcount":2218,"excerpt":"","more":"<h4 id=\"1-能学到啥\"><a href=\"#1-能学到啥\" class=\"headerlink\" title=\"1.能学到啥\"></a>1.能学到啥</h4><ul>\n<li>B/S 编程模型<ul>\n<li>Browser - Server</li>\n</ul>\n</li>\n<li>模块化编程</li>\n<li>Node 常用 api</li>\n<li>异步编程</li>\n<li>Express Web 开发框架</li>\n<li>Ecmascript6</li>\n</ul>\n<h4 id=\"1-1-读取文件\"><a href=\"#1-1-读取文件\" class=\"headerlink\" title=\"1.1 读取文件\"></a>1.1 读取文件</h4><p>fs 是 file-system 的简写，就是文件系统的意思，在 node 中如果想要进行文件操作，就必须引入 fs 这个核心模块</p>\n<p>在 fs 这个核心模块中，就提供了所有的文件操作相关的 API 例如： fs.readFile 就是用来读取文件的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;fs&quot;</span>);<br>fs.<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;../data/indexx.html&quot;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">error, data</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;读取文件失败&quot;</span>);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data.<span class=\"hljs-property\">toString</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>第一个参数就是 要读取的文件路径</p>\n<p>第二个参数就是 一个回调函数</p>\n<p>​ 成功</p>\n<p>​ data 数据</p>\n<p>​ error null</p>\n<p>​ 失败</p>\n<p>​ data undefined</p>\n<p>​ error 错误对象</p>\n</blockquote>\n<h4 id=\"1-2-写入文件\"><a href=\"#1-2-写入文件\" class=\"headerlink\" title=\"1.2 写入文件\"></a>1.2 写入文件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;fs&quot;</span>);<br>fs.<span class=\"hljs-title function_\">writeFile</span>(<span class=\"hljs-string\">&quot;../data/ss.md&quot;</span>, <span class=\"hljs-string\">&quot;我是要写入的内容&quot;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">error</span>) &#123;<br>  <span class=\"hljs-comment\">//console.log(&#x27;文件写入成功&#x27;)</span><br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;读取文件失败&quot;</span>);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;写入成功了&quot;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>第一个参数：文件路径</p>\n<p>第二个参数： 文件内容</p>\n<p>第三个参数： 回调函数 error</p>\n<p>​ 成功</p>\n<p>​ 文件写入成功</p>\n<p>​ error 是 null</p>\n<p>​ 失败</p>\n<p>​ 文件写入失败</p>\n<p>​ error 就是错误对象</p>\n</blockquote>\n<h4 id=\"2-1-创建-http-服务\"><a href=\"#2-1-创建-http-服务\" class=\"headerlink\" title=\"2.1 创建 http 服务\"></a>2.1 创建 http 服务</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//1.加载 http 核心模块</span><br><span class=\"hljs-keyword\">var</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;http&quot;</span>);<br><span class=\"hljs-comment\">//2.使用 http.createSever() 方法创建一个 web 服务器</span><br><span class=\"hljs-comment\">//返回一个 Server 实例</span><br><span class=\"hljs-keyword\">var</span> server = http.<span class=\"hljs-title function_\">createServer</span>();<br><span class=\"hljs-comment\">//3.服务器提供对数据的服务</span><br><span class=\"hljs-comment\">//  发请求</span><br><span class=\"hljs-comment\">//  接收请求   处理请求   发送响应</span><br><br><span class=\"hljs-comment\">//注册 request 请求事件</span><br><span class=\"hljs-comment\">// 当客户端请求过来，就会自动触发服务器的 request 请求事件，然后执行第二个参数 ：回调处理</span><br>server.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">request, response</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;收到客户端的请求了，请求路径是：&quot;</span> + request.<span class=\"hljs-property\">url</span>);<br><br>  <span class=\"hljs-comment\">//response 对象有一个方法： write 可以用来给客户端发送响应数据</span><br>  <span class=\"hljs-comment\">//write 可以使用多次，但是最后一定要使用 end 来结束响应，否则客户端会一直等待</span><br>  response.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>  response.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&quot;sss&quot;</span>);<br>  <span class=\"hljs-comment\">//告诉客户端，我的话说完了,你可以给用户了</span><br>  response.<span class=\"hljs-title function_\">end</span>();<br>&#125;);<br><br><span class=\"hljs-comment\">//4.绑定端口号，启动服务器</span><br>server.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;服务器启动成功啦，可以通过 http://127.0.0.1:3000/ 来进行访问&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>request 请求事件处理函数 需要接收两个参数：</p>\n<p>​ Request 请求对象</p>\n<p>​ 请求对象可以用来获取客户端的一些请求消息，例如请求路径</p>\n<p>​ Response 响应对象</p>\n<p>​ 响应对象可以用来给客户端发送响应消息</p>\n</blockquote>\n<h4 id=\"3-用户自定义模块\"><a href=\"#3-用户自定义模块\" class=\"headerlink\" title=\"3.用户自定义模块\"></a>3.用户自定义模块</h4><p><strong>require 是一个方法</strong></p>\n<ul>\n<li>它的作用就是用来加载模块的</li>\n</ul>\n<p><strong>在 Node 中，模块有三种</strong></p>\n<ul>\n<li>具名的核心模块，例如 fs，http</li>\n<li>用户自己编写的文件模块</li>\n</ul>\n<blockquote>\n<p>相对路径必须加 ./ require(./b.js)</p>\n</blockquote>\n<ul>\n<li>在 Node 中，没有全局作用域，只有模块作用域(外部访问不到内部，内部访问不到外部)</li>\n</ul>\n<p><em>有时候我们加载文件模块的目的不是为了简简单单的执行里面的代码，更重要的是为了使用里面的变量</em></p>\n<p><strong>require 方法有两个作用</strong></p>\n<p>1.加载文件模块并执行里面的代码</p>\n<p>2.拿到被加载文件模块导出的接口对象</p>\n<p>exports 默认是一个==空对象==，在每个文件模块中都提供了一个对象：exports</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//a.js</span><br><span class=\"hljs-keyword\">var</span> ret = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./b.js&quot;</span>);<br><span class=\"hljs-comment\">//ret ==exports</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(ret.<span class=\"hljs-property\">foo</span>);<br><br><span class=\"hljs-comment\">//b.js</span><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">&quot;bbb&quot;</span>;<br><br><span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-string\">&quot;hello world&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"ip-地址和端口号\"><a href=\"#ip-地址和端口号\" class=\"headerlink\" title=\"ip 地址和端口号\"></a>ip 地址和端口号</h4><p>ip 地址用来定位计算机</p>\n<p>端口号用来定位具体的应用程序（所有需要联网通信的软件都必须具有端口号）</p>\n<blockquote>\n<p>所有联网的程序都需要进行网络通信</p>\n<p>计算机中只有一个物理网卡，而且同一个局域网中，网卡的地址必须是唯一的</p>\n<p>网卡是通过唯一的 ip 地址来进行定位的</p>\n</blockquote>\n<p>端口号的范围从 0~~65536 之间</p>\n<p>可以同时开启多个服务，但是一定要确保不同服务占用的端口号不一样</p>\n"},{"title":"node的简单爬虫","date":"2021-12-19T14:29:35.000Z","index_img":"/img/spider.jpg","banner_img":null,"_content":"\n> 你们看到这个封面可能以为我是用的**playwright**，其实不是，只是一个简单的小功能\n\n关于爬虫呢，就是可以代替人去做一些本来是人可以做的东西，但是会很繁琐和麻烦。\n\n**!!! 有些数据是不能爬取滴**\n\n我们的互联网就是一张超级大的蜘蛛网，而每一个你想要了解的知识就是一个个食物，爬虫呢就是那只蜘蛛，可以通过每条特定的线路去获取食物，这个特定的线路就是每个url（网址）\n\n我所知道到的爬虫工具有**puppeteer**、**playwright**、**selenium**、**scrapy**\n\n------\n\n爬虫大概有四个步骤\n\n1. 获取目标网页数据\n2. 分析目标网页得到想要的数据\n3. 下载数据\n4. 保存数据\n\n\n\n例子：\n\n就拿我的网站https://badspider.top  来做个例子吧\n\n首先要`npm init -y` 初始化一个node项目，然后需要下载一些必须的包\n\n*cnpm i axios download cheerio --save*\n\n```javascript\nconst axios = require('axios') \t\t// 发送 http 请求\nconst cheerio = require('cheerio')   // 解析 HTML 代码\nconst download = require('download')  // 下载文件\n\nconst HOST = 'https://badspider.top'\nlet arr = []\n\nconst req = axios.create({\n    method: 'get',\n    baseURL:\"https://badspider.top/\"\n})\n\nasync function getInfo() {\n    const { data } = await req()\n    const $ = cheerio.load(data)\n    let imgs = $('.index-card .index-img a>img') // 获取到图片的具体dom结构\n    imgs.each((index, el) => {\n        let imgUrl = el.attribs.src   // 获取到图片的url\n        let pics = ''\n        // 因为我的有些图片是外链，所以需要判断一下\n        if (imgUrl.slice(0, 4) == 'http') {\n             pics = `${imgUrl}`\n        }\n        else {\n             pics = `${HOST}/${imgUrl}`\n        }\n     \n        arr.push(pics)\n    })\n    // 下载图片到文件夹\n    await Promise.all(arr.map(url => download(url, 'picture')));\n    console.log(arr);\n}\n\ngetInfo()\n```\n\n**最后console.log(arr)出来的数据**\n\n- 总结：\n\n​\t学习到了**cheerio**这个库的使用，服务器端的JQuery，可以很方便的操作DOM，同时也小小的体验了一下爬虫的乐趣哈哈哈哈，最开始学网页就是因为python里面的爬虫要学一丢丢的网页知识才学的前端，结果学着学着就喜欢上了前端，觉得在计算机里面有很多有趣的事情可以靠自己去实现，只需要一点点的时间就可以了，还是很nice的，接下来就是看playwright的文档了\n\n#### 小彩蛋：\n\n> windows 下面自带的表情里面居然也有这个🎭哈哈哈哈，playwright的图标，很喜欢这个风格，还有sails.js的风格也蛮不错的\n\n\n\n\n\n","source":"_posts/node实现简易爬虫.md","raw":"---\ntitle: node的简单爬虫\ndate: 2021-12-19 22:29:35\ntags: 后端\nindex_img: /img/spider.jpg\nbanner_img:\n---\n\n> 你们看到这个封面可能以为我是用的**playwright**，其实不是，只是一个简单的小功能\n\n关于爬虫呢，就是可以代替人去做一些本来是人可以做的东西，但是会很繁琐和麻烦。\n\n**!!! 有些数据是不能爬取滴**\n\n我们的互联网就是一张超级大的蜘蛛网，而每一个你想要了解的知识就是一个个食物，爬虫呢就是那只蜘蛛，可以通过每条特定的线路去获取食物，这个特定的线路就是每个url（网址）\n\n我所知道到的爬虫工具有**puppeteer**、**playwright**、**selenium**、**scrapy**\n\n------\n\n爬虫大概有四个步骤\n\n1. 获取目标网页数据\n2. 分析目标网页得到想要的数据\n3. 下载数据\n4. 保存数据\n\n\n\n例子：\n\n就拿我的网站https://badspider.top  来做个例子吧\n\n首先要`npm init -y` 初始化一个node项目，然后需要下载一些必须的包\n\n*cnpm i axios download cheerio --save*\n\n```javascript\nconst axios = require('axios') \t\t// 发送 http 请求\nconst cheerio = require('cheerio')   // 解析 HTML 代码\nconst download = require('download')  // 下载文件\n\nconst HOST = 'https://badspider.top'\nlet arr = []\n\nconst req = axios.create({\n    method: 'get',\n    baseURL:\"https://badspider.top/\"\n})\n\nasync function getInfo() {\n    const { data } = await req()\n    const $ = cheerio.load(data)\n    let imgs = $('.index-card .index-img a>img') // 获取到图片的具体dom结构\n    imgs.each((index, el) => {\n        let imgUrl = el.attribs.src   // 获取到图片的url\n        let pics = ''\n        // 因为我的有些图片是外链，所以需要判断一下\n        if (imgUrl.slice(0, 4) == 'http') {\n             pics = `${imgUrl}`\n        }\n        else {\n             pics = `${HOST}/${imgUrl}`\n        }\n     \n        arr.push(pics)\n    })\n    // 下载图片到文件夹\n    await Promise.all(arr.map(url => download(url, 'picture')));\n    console.log(arr);\n}\n\ngetInfo()\n```\n\n**最后console.log(arr)出来的数据**\n\n- 总结：\n\n​\t学习到了**cheerio**这个库的使用，服务器端的JQuery，可以很方便的操作DOM，同时也小小的体验了一下爬虫的乐趣哈哈哈哈，最开始学网页就是因为python里面的爬虫要学一丢丢的网页知识才学的前端，结果学着学着就喜欢上了前端，觉得在计算机里面有很多有趣的事情可以靠自己去实现，只需要一点点的时间就可以了，还是很nice的，接下来就是看playwright的文档了\n\n#### 小彩蛋：\n\n> windows 下面自带的表情里面居然也有这个🎭哈哈哈哈，playwright的图标，很喜欢这个风格，还有sails.js的风格也蛮不错的\n\n\n\n\n\n","slug":"node实现简易爬虫","published":1,"updated":"2024-11-17T13:58:10.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpm001m73t32smfb9h2","content":"<blockquote>\n<p>你们看到这个封面可能以为我是用的<strong>playwright</strong>，其实不是，只是一个简单的小功能</p>\n</blockquote>\n<p>关于爬虫呢，就是可以代替人去做一些本来是人可以做的东西，但是会很繁琐和麻烦。</p>\n<p><strong>!!! 有些数据是不能爬取滴</strong></p>\n<p>我们的互联网就是一张超级大的蜘蛛网，而每一个你想要了解的知识就是一个个食物，爬虫呢就是那只蜘蛛，可以通过每条特定的线路去获取食物，这个特定的线路就是每个url（网址）</p>\n<p>我所知道到的爬虫工具有<strong>puppeteer</strong>、<strong>playwright</strong>、<strong>selenium</strong>、<strong>scrapy</strong></p>\n<hr>\n<p>爬虫大概有四个步骤</p>\n<ol>\n<li>获取目标网页数据</li>\n<li>分析目标网页得到想要的数据</li>\n<li>下载数据</li>\n<li>保存数据</li>\n</ol>\n<p>例子：</p>\n<p>就拿我的网站<a href=\"https://badspider.top/\">https://badspider.top</a>  来做个例子吧</p>\n<p>首先要<code>npm init -y</code> 初始化一个node项目，然后需要下载一些必须的包</p>\n<p><em>cnpm i axios download cheerio –save</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> axios = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;axios&#x27;</span>) \t\t<span class=\"hljs-comment\">// 发送 http 请求</span><br><span class=\"hljs-keyword\">const</span> cheerio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;cheerio&#x27;</span>)   <span class=\"hljs-comment\">// 解析 HTML 代码</span><br><span class=\"hljs-keyword\">const</span> download = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;download&#x27;</span>)  <span class=\"hljs-comment\">// 下载文件</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">HOST</span> = <span class=\"hljs-string\">&#x27;https://badspider.top&#x27;</span><br><span class=\"hljs-keyword\">let</span> arr = []<br><br><span class=\"hljs-keyword\">const</span> req = axios.<span class=\"hljs-title function_\">create</span>(&#123;<br>    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;get&#x27;</span>,<br>    <span class=\"hljs-attr\">baseURL</span>:<span class=\"hljs-string\">&quot;https://badspider.top/&quot;</span><br>&#125;)<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getInfo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123; data &#125; = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">req</span>()<br>    <span class=\"hljs-keyword\">const</span> $ = cheerio.<span class=\"hljs-title function_\">load</span>(data)<br>    <span class=\"hljs-keyword\">let</span> imgs = $(<span class=\"hljs-string\">&#x27;.index-card .index-img a&gt;img&#x27;</span>) <span class=\"hljs-comment\">// 获取到图片的具体dom结构</span><br>    imgs.<span class=\"hljs-title function_\">each</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">index, el</span>) =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">let</span> imgUrl = el.<span class=\"hljs-property\">attribs</span>.<span class=\"hljs-property\">src</span>   <span class=\"hljs-comment\">// 获取到图片的url</span><br>        <span class=\"hljs-keyword\">let</span> pics = <span class=\"hljs-string\">&#x27;&#x27;</span><br>        <span class=\"hljs-comment\">// 因为我的有些图片是外链，所以需要判断一下</span><br>        <span class=\"hljs-keyword\">if</span> (imgUrl.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-string\">&#x27;http&#x27;</span>) &#123;<br>             pics = <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;imgUrl&#125;</span>`</span><br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>             pics = <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;HOST&#125;</span>/<span class=\"hljs-subst\">$&#123;imgUrl&#125;</span>`</span><br>        &#125;<br>     <br>        arr.<span class=\"hljs-title function_\">push</span>(pics)<br>    &#125;)<br>    <span class=\"hljs-comment\">// 下载图片到文件夹</span><br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(arr.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">url</span> =&gt;</span> <span class=\"hljs-title function_\">download</span>(url, <span class=\"hljs-string\">&#x27;picture&#x27;</span>)));<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr);<br>&#125;<br><br><span class=\"hljs-title function_\">getInfo</span>()<br></code></pre></td></tr></table></figure>\n\n<p><strong>最后console.log(arr)出来的数据</strong></p>\n<ul>\n<li>总结：</li>\n</ul>\n<p>​    学习到了<strong>cheerio</strong>这个库的使用，服务器端的JQuery，可以很方便的操作DOM，同时也小小的体验了一下爬虫的乐趣哈哈哈哈，最开始学网页就是因为python里面的爬虫要学一丢丢的网页知识才学的前端，结果学着学着就喜欢上了前端，觉得在计算机里面有很多有趣的事情可以靠自己去实现，只需要一点点的时间就可以了，还是很nice的，接下来就是看playwright的文档了</p>\n<h4 id=\"小彩蛋：\"><a href=\"#小彩蛋：\" class=\"headerlink\" title=\"小彩蛋：\"></a>小彩蛋：</h4><blockquote>\n<p>windows 下面自带的表情里面居然也有这个🎭哈哈哈哈，playwright的图标，很喜欢这个风格，还有sails.js的风格也蛮不错的</p>\n</blockquote>\n","site":{"data":{}},"wordcount":1534,"excerpt":"","more":"<blockquote>\n<p>你们看到这个封面可能以为我是用的<strong>playwright</strong>，其实不是，只是一个简单的小功能</p>\n</blockquote>\n<p>关于爬虫呢，就是可以代替人去做一些本来是人可以做的东西，但是会很繁琐和麻烦。</p>\n<p><strong>!!! 有些数据是不能爬取滴</strong></p>\n<p>我们的互联网就是一张超级大的蜘蛛网，而每一个你想要了解的知识就是一个个食物，爬虫呢就是那只蜘蛛，可以通过每条特定的线路去获取食物，这个特定的线路就是每个url（网址）</p>\n<p>我所知道到的爬虫工具有<strong>puppeteer</strong>、<strong>playwright</strong>、<strong>selenium</strong>、<strong>scrapy</strong></p>\n<hr>\n<p>爬虫大概有四个步骤</p>\n<ol>\n<li>获取目标网页数据</li>\n<li>分析目标网页得到想要的数据</li>\n<li>下载数据</li>\n<li>保存数据</li>\n</ol>\n<p>例子：</p>\n<p>就拿我的网站<a href=\"https://badspider.top/\">https://badspider.top</a>  来做个例子吧</p>\n<p>首先要<code>npm init -y</code> 初始化一个node项目，然后需要下载一些必须的包</p>\n<p><em>cnpm i axios download cheerio –save</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> axios = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;axios&#x27;</span>) \t\t<span class=\"hljs-comment\">// 发送 http 请求</span><br><span class=\"hljs-keyword\">const</span> cheerio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;cheerio&#x27;</span>)   <span class=\"hljs-comment\">// 解析 HTML 代码</span><br><span class=\"hljs-keyword\">const</span> download = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;download&#x27;</span>)  <span class=\"hljs-comment\">// 下载文件</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">HOST</span> = <span class=\"hljs-string\">&#x27;https://badspider.top&#x27;</span><br><span class=\"hljs-keyword\">let</span> arr = []<br><br><span class=\"hljs-keyword\">const</span> req = axios.<span class=\"hljs-title function_\">create</span>(&#123;<br>    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;get&#x27;</span>,<br>    <span class=\"hljs-attr\">baseURL</span>:<span class=\"hljs-string\">&quot;https://badspider.top/&quot;</span><br>&#125;)<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getInfo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123; data &#125; = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">req</span>()<br>    <span class=\"hljs-keyword\">const</span> $ = cheerio.<span class=\"hljs-title function_\">load</span>(data)<br>    <span class=\"hljs-keyword\">let</span> imgs = $(<span class=\"hljs-string\">&#x27;.index-card .index-img a&gt;img&#x27;</span>) <span class=\"hljs-comment\">// 获取到图片的具体dom结构</span><br>    imgs.<span class=\"hljs-title function_\">each</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">index, el</span>) =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">let</span> imgUrl = el.<span class=\"hljs-property\">attribs</span>.<span class=\"hljs-property\">src</span>   <span class=\"hljs-comment\">// 获取到图片的url</span><br>        <span class=\"hljs-keyword\">let</span> pics = <span class=\"hljs-string\">&#x27;&#x27;</span><br>        <span class=\"hljs-comment\">// 因为我的有些图片是外链，所以需要判断一下</span><br>        <span class=\"hljs-keyword\">if</span> (imgUrl.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-string\">&#x27;http&#x27;</span>) &#123;<br>             pics = <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;imgUrl&#125;</span>`</span><br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>             pics = <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;HOST&#125;</span>/<span class=\"hljs-subst\">$&#123;imgUrl&#125;</span>`</span><br>        &#125;<br>     <br>        arr.<span class=\"hljs-title function_\">push</span>(pics)<br>    &#125;)<br>    <span class=\"hljs-comment\">// 下载图片到文件夹</span><br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(arr.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">url</span> =&gt;</span> <span class=\"hljs-title function_\">download</span>(url, <span class=\"hljs-string\">&#x27;picture&#x27;</span>)));<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr);<br>&#125;<br><br><span class=\"hljs-title function_\">getInfo</span>()<br></code></pre></td></tr></table></figure>\n\n<p><strong>最后console.log(arr)出来的数据</strong></p>\n<ul>\n<li>总结：</li>\n</ul>\n<p>​    学习到了<strong>cheerio</strong>这个库的使用，服务器端的JQuery，可以很方便的操作DOM，同时也小小的体验了一下爬虫的乐趣哈哈哈哈，最开始学网页就是因为python里面的爬虫要学一丢丢的网页知识才学的前端，结果学着学着就喜欢上了前端，觉得在计算机里面有很多有趣的事情可以靠自己去实现，只需要一点点的时间就可以了，还是很nice的，接下来就是看playwright的文档了</p>\n<h4 id=\"小彩蛋：\"><a href=\"#小彩蛋：\" class=\"headerlink\" title=\"小彩蛋：\"></a>小彩蛋：</h4><blockquote>\n<p>windows 下面自带的表情里面居然也有这个🎭哈哈哈哈，playwright的图标，很喜欢这个风格，还有sails.js的风格也蛮不错的</p>\n</blockquote>\n"},{"title":"哈希算法（python）","date":"2020-08-31T08:18:19.000Z","index_img":"/img/python.jpg","banner_img":"/img/g.jpg","_content":"","source":"_posts/shuangfa.md","raw":"---\ntitle: 哈希算法（python）\ndate: 2020-08-31 16:18:19\ntags: 哈希算法\ncategories: 算法\nindex_img: /img/python.jpg\nbanner_img: /img/g.jpg\n---\n","slug":"shuangfa","published":1,"updated":"2024-11-17T13:58:10.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpm001q73t34nnc9mij","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"day 01  学习HTML（上）","date":"2020-08-14T14:56:54.000Z","index_img":"/img/html.jpg","banner_img":"/img/g.jpg","_content":"{% note success %}\n今天开始正式学习前端了，python还在进行中，感觉还是喜欢前端一些，当然python也不能落下\n{% endnote %}\n\n{% note danger %}\n下面是我学HTML的一些笔记，都是很基础的一些，资料可以看看[w3school](https://www.w3school.com.cn/)\n{% endnote %}\n\n##  1.前言：\n  网站是每一个网页的集合，而网页是构成网站的基本元素，由图片，文字，声音，视频，链接等等，网页也称为**HTML文件**\n  html（英语：HyperText Markup Language）是一种超文本标记语言，不是编程语言\n **HTML**文档的后缀名\n  - .html\n  - .htm\n\n**HTML标签**\n- HTML 标签是由尖括号包围的关键词，比如 `<html>`\n- HTML 标签通常是成对出现的，比如 `<b>` 和 `</b>`\n- 标签对中的第一个标签是开始标签，第二个标签是结束标签\n- 开始和结束标签也被称为开放标签和闭合标签\n## 2.基本框架\n~~~\n<html>\n\t<head>\n\t\t<title> 标题</title>\n\t</head>\n\t<body>\n\t主体\n\t</body>\n</html>\n~~~\n1.所有的标签都必须包含在<>中，成双成对出现，称为双标签，例如：\n`<html>(开始标签）</html>(结束标签）`\n也会出现特殊的单标签，例如\n`<br />`\n2.其中又包含这两种关系\n包含关系： \n`<head>`\n        `<title></title>`\n`</head> `\n\n\n并列关系：\n`<head> </head>`\n`<body> </body>`\n\n基本结构标签\n`<html></html`>HTML标签（ 根标签）\n`<head></head>`文档的头部\n`<title></title>` 文档的标题\n`<body></body>`文档的主体\n\n\n## 2.HTML标签\n~~~\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    \n</body>\n</html>\n~~~\n### (1)HTML语法规范\n1.`<!DOCTYPE>`doctype 声明是不区分大小写的,在整个页面的最前面的，作用是告诉浏览器用的HTML是哪个版本的\n2.lang=\"en\"是网页的语言为英文 （zh-CN 是中文  fr是法语）\n3.`<meta chasrset = \"UTF-8\"/>`是字符编码,是防止乱码的\n4.**`<h1>这个是一级标签</h1>`**\n<h1>这是一级标签</h1>\n\n `<h2>这个是二级标签</h2>`\n **<h2>这是二级标签</h2>**\n\n ..................................\n ..................................\n ..................................\n `<h6>这是最小的一级标签</h6>`\n <h6>这是最小的一级标签</h6>\n>一共有6级标签，依据重要性递减，加了标题的文字会变的粗\n\n5.段落和换行标签\n`<p>我是一个段落标签</p>`\n`<br />` <b>换行标签</b>，<b>/</b> 可写可不写\n6.文本格式化标签\n加粗------`<strong></strong> 或者 <b></b>`\n倾斜------`<em></em> 或者  <i></i>`\n删除------`<del></-------> 或者 <s></s>`\n下划线------`<ins></ins> 或者 <u></u>`\n(每一行前面的语气会比较强烈，建议用前面一个)\n7.`<div>`和`<span>`不是标签，是用来装内容的\n`<div>这是头部</div>`一行里面只能放一个`<div>`\n8.图像标签和路径\n`<img src=\"图像URL\"/>`\n`<img src=\"图像URL\"  alt=\"图像显示不出来时候的文字\"/>`\n`<img src=\"图像URL\"  alt=\"图像显示不出来时候的文字\"  title=\"提示文本，鼠标放在图片上面时显示的文字\"/>`\n9.width图像的宽度   height图像的高度    border（css)图像的边框\n`<img  src = \"img.jpg\" width=\"500\" height=\"100\" border= \"15\"/>`\n10.路径\n(1)相对路径：图片相对于你的html的位置，如果在同一个位置直接引用它的文件名就可以了\n(2)绝对路径：文件的全部路径，网络连接\n11.超链接标签 \n`<a></a>`\n`<a href=\"跳转目标\"  target=\"跳出目标窗口的方式\">文字</a>`\ntarget---->其中_self为默认值，在当前页面打开，_blank新开一个窗口打开\n（1）.外部链接`<a href=\"http://www.baidu.com\">百度 </a>`\n（2）内部链接`<a href= \"index.html\">内部</a>`\n（3）空链接 `<a href=\"#\"> </a>`\n (4）下载链接 `<a href=\"img.zip\"> </a>`\n（5）网页元素的链接`<a href = \"http://xxxxx\"><img src=\"img.jpg\"></a>`\n (6) 锚点链接 `<a href=\"#xxx\">锚点链接</a> 在你需要跳转的地方前面写上<id = \"xxx\">`\n 12.注释标签\n `<!--这是注释，是不会被执行的-->`  快捷键  {% btn https://qs62rd.coding-pages.com/,CTRL +/, 千万不要点我%}\n 13.特殊字符\n 有些字符比如 {% btn url, 空格,不要点，点就是error%}空格，`<p>`都是不能和平常一样的，这个时候就需要特殊字符来实现，只需要记住平常的两三个就可以了，到需要用到时候可以去查，见下方链接\n<a href=\"https://tool.lu/htmlentity/\" target=\"_blank\">点击跳转到特殊字符页面</a>\n {% note info %}\n **陆续还会更新上的，目前还在学习中🎮**\n{% endnote %}","source":"_posts/web.md","raw":"---\ntitle: day 01  学习HTML（上）\ndate: 2020-08-14 22:56:54\ntags: HTML\ncategories: 前端\nindex_img: /img/html.jpg\nbanner_img: /img/g.jpg\n---\n{% note success %}\n今天开始正式学习前端了，python还在进行中，感觉还是喜欢前端一些，当然python也不能落下\n{% endnote %}\n\n{% note danger %}\n下面是我学HTML的一些笔记，都是很基础的一些，资料可以看看[w3school](https://www.w3school.com.cn/)\n{% endnote %}\n\n##  1.前言：\n  网站是每一个网页的集合，而网页是构成网站的基本元素，由图片，文字，声音，视频，链接等等，网页也称为**HTML文件**\n  html（英语：HyperText Markup Language）是一种超文本标记语言，不是编程语言\n **HTML**文档的后缀名\n  - .html\n  - .htm\n\n**HTML标签**\n- HTML 标签是由尖括号包围的关键词，比如 `<html>`\n- HTML 标签通常是成对出现的，比如 `<b>` 和 `</b>`\n- 标签对中的第一个标签是开始标签，第二个标签是结束标签\n- 开始和结束标签也被称为开放标签和闭合标签\n## 2.基本框架\n~~~\n<html>\n\t<head>\n\t\t<title> 标题</title>\n\t</head>\n\t<body>\n\t主体\n\t</body>\n</html>\n~~~\n1.所有的标签都必须包含在<>中，成双成对出现，称为双标签，例如：\n`<html>(开始标签）</html>(结束标签）`\n也会出现特殊的单标签，例如\n`<br />`\n2.其中又包含这两种关系\n包含关系： \n`<head>`\n        `<title></title>`\n`</head> `\n\n\n并列关系：\n`<head> </head>`\n`<body> </body>`\n\n基本结构标签\n`<html></html`>HTML标签（ 根标签）\n`<head></head>`文档的头部\n`<title></title>` 文档的标题\n`<body></body>`文档的主体\n\n\n## 2.HTML标签\n~~~\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    \n</body>\n</html>\n~~~\n### (1)HTML语法规范\n1.`<!DOCTYPE>`doctype 声明是不区分大小写的,在整个页面的最前面的，作用是告诉浏览器用的HTML是哪个版本的\n2.lang=\"en\"是网页的语言为英文 （zh-CN 是中文  fr是法语）\n3.`<meta chasrset = \"UTF-8\"/>`是字符编码,是防止乱码的\n4.**`<h1>这个是一级标签</h1>`**\n<h1>这是一级标签</h1>\n\n `<h2>这个是二级标签</h2>`\n **<h2>这是二级标签</h2>**\n\n ..................................\n ..................................\n ..................................\n `<h6>这是最小的一级标签</h6>`\n <h6>这是最小的一级标签</h6>\n>一共有6级标签，依据重要性递减，加了标题的文字会变的粗\n\n5.段落和换行标签\n`<p>我是一个段落标签</p>`\n`<br />` <b>换行标签</b>，<b>/</b> 可写可不写\n6.文本格式化标签\n加粗------`<strong></strong> 或者 <b></b>`\n倾斜------`<em></em> 或者  <i></i>`\n删除------`<del></-------> 或者 <s></s>`\n下划线------`<ins></ins> 或者 <u></u>`\n(每一行前面的语气会比较强烈，建议用前面一个)\n7.`<div>`和`<span>`不是标签，是用来装内容的\n`<div>这是头部</div>`一行里面只能放一个`<div>`\n8.图像标签和路径\n`<img src=\"图像URL\"/>`\n`<img src=\"图像URL\"  alt=\"图像显示不出来时候的文字\"/>`\n`<img src=\"图像URL\"  alt=\"图像显示不出来时候的文字\"  title=\"提示文本，鼠标放在图片上面时显示的文字\"/>`\n9.width图像的宽度   height图像的高度    border（css)图像的边框\n`<img  src = \"img.jpg\" width=\"500\" height=\"100\" border= \"15\"/>`\n10.路径\n(1)相对路径：图片相对于你的html的位置，如果在同一个位置直接引用它的文件名就可以了\n(2)绝对路径：文件的全部路径，网络连接\n11.超链接标签 \n`<a></a>`\n`<a href=\"跳转目标\"  target=\"跳出目标窗口的方式\">文字</a>`\ntarget---->其中_self为默认值，在当前页面打开，_blank新开一个窗口打开\n（1）.外部链接`<a href=\"http://www.baidu.com\">百度 </a>`\n（2）内部链接`<a href= \"index.html\">内部</a>`\n（3）空链接 `<a href=\"#\"> </a>`\n (4）下载链接 `<a href=\"img.zip\"> </a>`\n（5）网页元素的链接`<a href = \"http://xxxxx\"><img src=\"img.jpg\"></a>`\n (6) 锚点链接 `<a href=\"#xxx\">锚点链接</a> 在你需要跳转的地方前面写上<id = \"xxx\">`\n 12.注释标签\n `<!--这是注释，是不会被执行的-->`  快捷键  {% btn https://qs62rd.coding-pages.com/,CTRL +/, 千万不要点我%}\n 13.特殊字符\n 有些字符比如 {% btn url, 空格,不要点，点就是error%}空格，`<p>`都是不能和平常一样的，这个时候就需要特殊字符来实现，只需要记住平常的两三个就可以了，到需要用到时候可以去查，见下方链接\n<a href=\"https://tool.lu/htmlentity/\" target=\"_blank\">点击跳转到特殊字符页面</a>\n {% note info %}\n **陆续还会更新上的，目前还在学习中🎮**\n{% endnote %}","slug":"web","published":1,"updated":"2024-11-17T13:58:10.671Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpn001u73t378x494ca","content":"<div class=\"note note-success\">\n            <p>今天开始正式学习前端了，python还在进行中，感觉还是喜欢前端一些，当然python也不能落下</p>\n          </div>\n\n<div class=\"note note-danger\">\n            <p>下面是我学HTML的一些笔记，都是很基础的一些，资料可以看看<a href=\"https://www.w3school.com.cn/\">w3school</a></p>\n          </div>\n\n<h2 id=\"1-前言：\"><a href=\"#1-前言：\" class=\"headerlink\" title=\"1.前言：\"></a>1.前言：</h2><p>  网站是每一个网页的集合，而网页是构成网站的基本元素，由图片，文字，声音，视频，链接等等，网页也称为<strong>HTML文件</strong><br>  html（英语：HyperText Markup Language）是一种超文本标记语言，不是编程语言<br> <strong>HTML</strong>文档的后缀名</p>\n<ul>\n<li>.html</li>\n<li>.htm</li>\n</ul>\n<p><strong>HTML标签</strong></p>\n<ul>\n<li>HTML 标签是由尖括号包围的关键词，比如 <code>&lt;html&gt;</code></li>\n<li>HTML 标签通常是成对出现的，比如 <code>&lt;b&gt;</code> 和 <code>&lt;/b&gt;</code></li>\n<li>标签对中的第一个标签是开始标签，第二个标签是结束标签</li>\n<li>开始和结束标签也被称为开放标签和闭合标签<h2 id=\"2-基本框架\"><a href=\"#2-基本框架\" class=\"headerlink\" title=\"2.基本框架\"></a>2.基本框架</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span> 标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t主体<br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>1.所有的标签都必须包含在&lt;&gt;中，成双成对出现，称为双标签，例如：<br><code>&lt;html&gt;(开始标签）&lt;/html&gt;(结束标签）</code><br>也会出现特殊的单标签，例如<br><code>&lt;br /&gt;</code><br>2.其中又包含这两种关系<br>包含关系：<br><code>&lt;head&gt;</code><br>        <code>&lt;title&gt;&lt;/title&gt;</code><br><code>&lt;/head&gt; </code></p>\n<p>并列关系：<br><code>&lt;head&gt; &lt;/head&gt;</code><br><code>&lt;body&gt; &lt;/body&gt;</code></p>\n<p>基本结构标签<br><code>&lt;html&gt;&lt;/html</code>&gt;HTML标签（ 根标签）<br><code>&lt;head&gt;&lt;/head&gt;</code>文档的头部<br><code>&lt;title&gt;&lt;/title&gt;</code> 文档的标题<br><code>&lt;body&gt;&lt;/body&gt;</code>文档的主体</p>\n<h2 id=\"2-HTML标签\"><a href=\"#2-HTML标签\" class=\"headerlink\" title=\"2.HTML标签\"></a>2.HTML标签</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"1-HTML语法规范\"><a href=\"#1-HTML语法规范\" class=\"headerlink\" title=\"(1)HTML语法规范\"></a>(1)HTML语法规范</h3><p>1.<code>&lt;!DOCTYPE&gt;</code>doctype 声明是不区分大小写的,在整个页面的最前面的，作用是告诉浏览器用的HTML是哪个版本的<br>2.lang=”en”是网页的语言为英文 （zh-CN 是中文  fr是法语）<br>3.<code>&lt;meta chasrset = &quot;UTF-8&quot;/&gt;</code>是字符编码,是防止乱码的<br>4.<strong><code>&lt;h1&gt;这个是一级标签&lt;/h1&gt;</code></strong></p>\n<h1>这是一级标签</h1>\n\n<p> <code>&lt;h2&gt;这个是二级标签&lt;/h2&gt;</code><br> <strong><h2>这是二级标签</h2></strong></p>\n<p> …………………………….<br> …………………………….<br> …………………………….<br> <code>&lt;h6&gt;这是最小的一级标签&lt;/h6&gt;</code><br> </p><h6>这是最小的一级标签</h6><p></p>\n<blockquote>\n<p>一共有6级标签，依据重要性递减，加了标题的文字会变的粗</p>\n</blockquote>\n<p>5.段落和换行标签<br><code>&lt;p&gt;我是一个段落标签&lt;/p&gt;</code><br><code>&lt;br /&gt;</code> <b>换行标签</b>，<b>/</b> 可写可不写<br>6.文本格式化标签<br>加粗——<code>&lt;strong&gt;&lt;/strong&gt; 或者 &lt;b&gt;&lt;/b&gt;</code><br>倾斜——<code>&lt;em&gt;&lt;/em&gt; 或者  &lt;i&gt;&lt;/i&gt;</code><br>删除——<code>&lt;del&gt;&lt;/-------&gt; 或者 &lt;s&gt;&lt;/s&gt;</code><br>下划线——<code>&lt;ins&gt;&lt;/ins&gt; 或者 &lt;u&gt;&lt;/u&gt;</code><br>(每一行前面的语气会比较强烈，建议用前面一个)<br>7.<code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>不是标签，是用来装内容的<br><code>&lt;div&gt;这是头部&lt;/div&gt;</code>一行里面只能放一个<code>&lt;div&gt;</code><br>8.图像标签和路径<br><code>&lt;img src=&quot;图像URL&quot;/&gt;</code><br><code>&lt;img src=&quot;图像URL&quot;  alt=&quot;图像显示不出来时候的文字&quot;/&gt;</code><br><code>&lt;img src=&quot;图像URL&quot;  alt=&quot;图像显示不出来时候的文字&quot;  title=&quot;提示文本，鼠标放在图片上面时显示的文字&quot;/&gt;</code><br>9.width图像的宽度   height图像的高度    border（css)图像的边框<br><code>&lt;img  src = &quot;img.jpg&quot; width=&quot;500&quot; height=&quot;100&quot; border= &quot;15&quot;/&gt;</code><br>10.路径<br>(1)相对路径：图片相对于你的html的位置，如果在同一个位置直接引用它的文件名就可以了<br>(2)绝对路径：文件的全部路径，网络连接<br>11.超链接标签<br><code>&lt;a&gt;&lt;/a&gt;</code><br><code>&lt;a href=&quot;跳转目标&quot;  target=&quot;跳出目标窗口的方式&quot;&gt;文字&lt;/a&gt;</code><br>target—-&gt;其中_self为默认值，在当前页面打开，_blank新开一个窗口打开<br>（1）.外部链接<code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度 &lt;/a&gt;</code><br>（2）内部链接<code>&lt;a href= &quot;index.html&quot;&gt;内部&lt;/a&gt;</code><br>（3）空链接 <code>&lt;a href=&quot;#&quot;&gt; &lt;/a&gt;</code><br> (4）下载链接 <code>&lt;a href=&quot;img.zip&quot;&gt; &lt;/a&gt;</code><br>（5）网页元素的链接<code>&lt;a href = &quot;http://xxxxx&quot;&gt;&lt;img src=&quot;img.jpg&quot;&gt;&lt;/a&gt;</code><br> (6) 锚点链接 <code>&lt;a href=&quot;#xxx&quot;&gt;锚点链接&lt;/a&gt; 在你需要跳转的地方前面写上&lt;id = &quot;xxx&quot;&gt;</code><br> 12.注释标签<br> <code>&lt;!--这是注释，是不会被执行的--&gt;</code>  快捷键  <a class=\"btn\" href=\"https://qs62rd.coding-pages.com/\" title=\"千万不要点我\" target=\"_blank\">CTRL +/</a><br> 13.特殊字符<br> 有些字符比如 <a class=\"btn\" href=\"url\" title=\"不要点，点就是error\" target=\"_blank\">空格</a>空格，<code>&lt;p&gt;</code>都是不能和平常一样的，这个时候就需要特殊字符来实现，只需要记住平常的两三个就可以了，到需要用到时候可以去查，见下方链接<br><a href=\"https://tool.lu/htmlentity/\" target=\"_blank\">点击跳转到特殊字符页面</a><br> <div class=\"note note-info\">\n            <p><strong>陆续还会更新上的，目前还在学习中🎮</strong></p>\n          </div></p>\n","site":{"data":{}},"wordcount":2930,"excerpt":"","more":"<div class=\"note note-success\">\n            <p>今天开始正式学习前端了，python还在进行中，感觉还是喜欢前端一些，当然python也不能落下</p>\n          </div>\n\n<div class=\"note note-danger\">\n            <p>下面是我学HTML的一些笔记，都是很基础的一些，资料可以看看<a href=\"https://www.w3school.com.cn/\">w3school</a></p>\n          </div>\n\n<h2 id=\"1-前言：\"><a href=\"#1-前言：\" class=\"headerlink\" title=\"1.前言：\"></a>1.前言：</h2><p>  网站是每一个网页的集合，而网页是构成网站的基本元素，由图片，文字，声音，视频，链接等等，网页也称为<strong>HTML文件</strong><br>  html（英语：HyperText Markup Language）是一种超文本标记语言，不是编程语言<br> <strong>HTML</strong>文档的后缀名</p>\n<ul>\n<li>.html</li>\n<li>.htm</li>\n</ul>\n<p><strong>HTML标签</strong></p>\n<ul>\n<li>HTML 标签是由尖括号包围的关键词，比如 <code>&lt;html&gt;</code></li>\n<li>HTML 标签通常是成对出现的，比如 <code>&lt;b&gt;</code> 和 <code>&lt;/b&gt;</code></li>\n<li>标签对中的第一个标签是开始标签，第二个标签是结束标签</li>\n<li>开始和结束标签也被称为开放标签和闭合标签<h2 id=\"2-基本框架\"><a href=\"#2-基本框架\" class=\"headerlink\" title=\"2.基本框架\"></a>2.基本框架</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span> 标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t主体<br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>1.所有的标签都必须包含在&lt;&gt;中，成双成对出现，称为双标签，例如：<br><code>&lt;html&gt;(开始标签）&lt;/html&gt;(结束标签）</code><br>也会出现特殊的单标签，例如<br><code>&lt;br /&gt;</code><br>2.其中又包含这两种关系<br>包含关系：<br><code>&lt;head&gt;</code><br>        <code>&lt;title&gt;&lt;/title&gt;</code><br><code>&lt;/head&gt; </code></p>\n<p>并列关系：<br><code>&lt;head&gt; &lt;/head&gt;</code><br><code>&lt;body&gt; &lt;/body&gt;</code></p>\n<p>基本结构标签<br><code>&lt;html&gt;&lt;/html</code>&gt;HTML标签（ 根标签）<br><code>&lt;head&gt;&lt;/head&gt;</code>文档的头部<br><code>&lt;title&gt;&lt;/title&gt;</code> 文档的标题<br><code>&lt;body&gt;&lt;/body&gt;</code>文档的主体</p>\n<h2 id=\"2-HTML标签\"><a href=\"#2-HTML标签\" class=\"headerlink\" title=\"2.HTML标签\"></a>2.HTML标签</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"1-HTML语法规范\"><a href=\"#1-HTML语法规范\" class=\"headerlink\" title=\"(1)HTML语法规范\"></a>(1)HTML语法规范</h3><p>1.<code>&lt;!DOCTYPE&gt;</code>doctype 声明是不区分大小写的,在整个页面的最前面的，作用是告诉浏览器用的HTML是哪个版本的<br>2.lang=”en”是网页的语言为英文 （zh-CN 是中文  fr是法语）<br>3.<code>&lt;meta chasrset = &quot;UTF-8&quot;/&gt;</code>是字符编码,是防止乱码的<br>4.<strong><code>&lt;h1&gt;这个是一级标签&lt;/h1&gt;</code></strong></p>\n<h1>这是一级标签</h1>\n\n<p> <code>&lt;h2&gt;这个是二级标签&lt;/h2&gt;</code><br> <strong><h2>这是二级标签</h2></strong></p>\n<p> …………………………….<br> …………………………….<br> …………………………….<br> <code>&lt;h6&gt;这是最小的一级标签&lt;/h6&gt;</code><br> </p><h6>这是最小的一级标签</h6><p></p>\n<blockquote>\n<p>一共有6级标签，依据重要性递减，加了标题的文字会变的粗</p>\n</blockquote>\n<p>5.段落和换行标签<br><code>&lt;p&gt;我是一个段落标签&lt;/p&gt;</code><br><code>&lt;br /&gt;</code> <b>换行标签</b>，<b>/</b> 可写可不写<br>6.文本格式化标签<br>加粗——<code>&lt;strong&gt;&lt;/strong&gt; 或者 &lt;b&gt;&lt;/b&gt;</code><br>倾斜——<code>&lt;em&gt;&lt;/em&gt; 或者  &lt;i&gt;&lt;/i&gt;</code><br>删除——<code>&lt;del&gt;&lt;/-------&gt; 或者 &lt;s&gt;&lt;/s&gt;</code><br>下划线——<code>&lt;ins&gt;&lt;/ins&gt; 或者 &lt;u&gt;&lt;/u&gt;</code><br>(每一行前面的语气会比较强烈，建议用前面一个)<br>7.<code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>不是标签，是用来装内容的<br><code>&lt;div&gt;这是头部&lt;/div&gt;</code>一行里面只能放一个<code>&lt;div&gt;</code><br>8.图像标签和路径<br><code>&lt;img src=&quot;图像URL&quot;/&gt;</code><br><code>&lt;img src=&quot;图像URL&quot;  alt=&quot;图像显示不出来时候的文字&quot;/&gt;</code><br><code>&lt;img src=&quot;图像URL&quot;  alt=&quot;图像显示不出来时候的文字&quot;  title=&quot;提示文本，鼠标放在图片上面时显示的文字&quot;/&gt;</code><br>9.width图像的宽度   height图像的高度    border（css)图像的边框<br><code>&lt;img  src = &quot;img.jpg&quot; width=&quot;500&quot; height=&quot;100&quot; border= &quot;15&quot;/&gt;</code><br>10.路径<br>(1)相对路径：图片相对于你的html的位置，如果在同一个位置直接引用它的文件名就可以了<br>(2)绝对路径：文件的全部路径，网络连接<br>11.超链接标签<br><code>&lt;a&gt;&lt;/a&gt;</code><br><code>&lt;a href=&quot;跳转目标&quot;  target=&quot;跳出目标窗口的方式&quot;&gt;文字&lt;/a&gt;</code><br>target—-&gt;其中_self为默认值，在当前页面打开，_blank新开一个窗口打开<br>（1）.外部链接<code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度 &lt;/a&gt;</code><br>（2）内部链接<code>&lt;a href= &quot;index.html&quot;&gt;内部&lt;/a&gt;</code><br>（3）空链接 <code>&lt;a href=&quot;#&quot;&gt; &lt;/a&gt;</code><br> (4）下载链接 <code>&lt;a href=&quot;img.zip&quot;&gt; &lt;/a&gt;</code><br>（5）网页元素的链接<code>&lt;a href = &quot;http://xxxxx&quot;&gt;&lt;img src=&quot;img.jpg&quot;&gt;&lt;/a&gt;</code><br> (6) 锚点链接 <code>&lt;a href=&quot;#xxx&quot;&gt;锚点链接&lt;/a&gt; 在你需要跳转的地方前面写上&lt;id = &quot;xxx&quot;&gt;</code><br> 12.注释标签<br> <code>&lt;!--这是注释，是不会被执行的--&gt;</code>  快捷键  <a class=\"btn\" href=\"https://qs62rd.coding-pages.com/\" title=\"千万不要点我\" target=\"_blank\">CTRL +/</a><br> 13.特殊字符<br> 有些字符比如 <a class=\"btn\" href=\"url\" title=\"不要点，点就是error\" target=\"_blank\">空格</a>空格，<code>&lt;p&gt;</code>都是不能和平常一样的，这个时候就需要特殊字符来实现，只需要记住平常的两三个就可以了，到需要用到时候可以去查，见下方链接<br><a href=\"https://tool.lu/htmlentity/\" target=\"_blank\">点击跳转到特殊字符页面</a><br> <div class=\"note note-info\">\n            <p><strong>陆续还会更新上的，目前还在学习中🎮</strong></p>\n          </div></p>\n"},{"title":"前后端交互模式","date":"2021-05-25T06:51:07.000Z","index_img":"/img/fontBanner.jpg","banner_img":"/img/font-index.jpg","_content":"\n## 1.前后端交互模式\n\n### 1.1 接口调用方式\n\n- 原生 ajax\n- 基于 jQuery 的 ajax\n- fetch\n- axios\n\n![QQ截图20210522200707](../前后端交互模式/1.png)\n\n### 1.2 URL 地址格式\n\n#### 1.2.1 传统形式的 URL\n\n![QQ截图20210522201043](../前后端交互模式/2.png)\n\n#### 1.2.2 Restful 形式的 URL\n\n- HTTP 请求方式\n  - GET 查询\n  - POST 添加\n  - PUT 修改\n  - DELETE 删除\n\n## 2.Promise 用法\n\n#### 2.1 异步调用\n\n- 异步效果分析\n  - 定时任务\n  - Ajax\n  - 事件函数\n- 多次异步调用的依赖分析\n  - 多次异步调用的结果顺序不确定\n  - 异步调用结果如果存在依赖需要嵌套\n\n#### 2.2 Promise 概述\n\nPromise 是异步编程的一种解决方案，从语法上讲，Promise 是一个对象，从它可以获取异步操作的消息\n\n使用 Promise 主要有以下好处：\n\n- 可以避免多层异步调用嵌套问题（回调地狱）\n- Promise 对象提供了简洁的 API，使得控制异步操作更加容易\n\n#### 2.3 Promise 基本用法\n\n- 实例化==Promise==对象，构造函数中传递函数，该函数用于处理异步任务\n- ==resolve==和==reject==两个参数用于处理成功和失败两种情况，并通过==p.then==获取处理结果\n\n```javascript\nvar p = new Promise(function(resolve,reject){\n    //成功时调用  resolve()\n    //失败时调用  reject()\n});\n\np.then(function(ret){\n\t//从resolve得到正常结果\n})，function(ret){\n\t//从reject得到错误信息\n}\n```\n\n#### 2.4 Promise 常用的 API\n\n- p.then() 得到异步任务的正确结果\n- p.catch() 获取异常信息\n- p.finally() 成功与否都会执行（尚且不是正式标准）\n\n#### 2.5 Promise 对象方法\n\n- Promise.all() 并发处理多个异步任务，所有任务都执行完成才能得到结果\n- Promise.race() 并发处理多个异步任务，只要有一个任务完成就能得到结果\n\n## 3.fetch\n\n#### 3.1 fetch 概述\n\n1. 基本特性\n\n- 更加简单的数据获取方式，功能更加强大，更灵活，可以看作是 xhr 的升级版\n- 基于 promise 实现\n\n2. 语法结构\n\n```javascript\nfetch(url).then(fn2)\n\t\t.then(fn3)\n\t\t......\n\n        .catch(fn)\n```\n\n#### 3.2 fetch 的基本用法\n\n```javascript\nfetch(\"/abc\")\n  .then((data) => {\n    return data.text();\n  })\n  .then((ret) => {\n    //注意这里得到的才是最终的数据\n    console.log(ret);\n  });\n```\n\n#### 3.3 fetch 请求参数\n\n- method：HTTP 请求方法，默认为 GET（GET,POST,PUT,DELETE)\n- body:HTTP 的请求参数\n- headers：HTTP 的请求头，默认为{}\n\n```javascript\nfetch(\"/abc\", {\n  method: \"get\",\n})\n  .then((data) => {\n    return data.text();\n  })\n  .then((ret) => {\n    //注意这里得到的才是最终的数据\n    console.log(ret);\n  });\n```\n\n#### 3.4 fetch 响应结果\n\n响应数据格式\n\n- text(): 将返回体处理成字符串类型\n- json(): 返回结果和 JSON.parse(responseText) 一样\n\n## 4.axios\n\n#### 4.1 axios 的基本特征\n\n- 支持浏览器和 node.js\n- 支持 promise\n- 能拦截请求和响应\n- 自动转换 JSON 数据\n\n#### 4.2 axios 的基本用法\n\n```javascript\naxois.get(\"/data\").then((ret) => {\n  //data属性名称是固定的，用于获取后台响应的数据\n  console.log(ret.data);\n});\n```\n\n#### 4.3 axios 的常用 API\n\n- get: 查询数据\n- post： 添加数据\n- put： 修改数据\n- delete： 删除数据\n\n#### 4.4 axios 的响应结果\n\n- data： 实际响应回来的结果\n- headers： 响应头信息\n- status： 响应状态码\n- statusText： 响应状态信息\n\n#### 4.5 axios 的全局配置\n\n- axios.defaults.timeout = 3000 //超出时间\n- axios.defaults.baseURL = 'http://localhost:3000/app' //默认地址\n- axios.defaults.headers['mytoken'] = 'aqwerwqwerqwer2ewrwe23eresdf23' //设置请求头\n\n#### 4.6 axios 拦截器\n\n1. 请求拦截器\n\n在请求发出之前设置一些信息\n\n![屏幕截图 2021-05-25 101638](C:\\Users\\yellowapple\\Desktop\\屏幕截图 2021-05-25 101638.png)\n\n```javascript\n//添加一个请求拦截器\naxios.interceptors.request.use(\n  function (config) {\n    //在请求发出之前进行一些信息设置\n    return config;\n  },\n  function (err) {\n    //处理响应的错误信息\n  }\n);\n```\n\n2. 响应拦截器\n\n在获取数据之前对数据做一些加工处理\n\n```javascript\n//添加一个请求拦截器\naxios.interceptors.response.use(\n  function (res) {\n    //在请求发出之前进行一些信息设置\n    return res;\n  },\n  function (err) {\n    //处理响应的错误信息\n  }\n);\n```\n\n## 5.async/await 用法\n\n- async/await 是 ES7 引入的新语法，可以更加方便的进行异步操作\n- async 关键字用于函数上(async 函数的返回值是 Promise 实例对象)\n- await 关键字用于 async 函数当中（await 可以得到异步的结果）\n\n```javascript\nasync function queryData(id) {\n  const ret = await axios.get(\"/data\");\n  return ret;\n}\nqueryData.then((ret) => {\n  console.log(ret);\n});\n```\n","source":"_posts/前后端交互模式.md","raw":"---\ntitle: 前后端交互模式\ndate: 2021-05-25 14:51:07\ntags: 前端\ncategories: 前端\nindex_img: /img/fontBanner.jpg\nbanner_img: /img/font-index.jpg\n---\n\n## 1.前后端交互模式\n\n### 1.1 接口调用方式\n\n- 原生 ajax\n- 基于 jQuery 的 ajax\n- fetch\n- axios\n\n![QQ截图20210522200707](../前后端交互模式/1.png)\n\n### 1.2 URL 地址格式\n\n#### 1.2.1 传统形式的 URL\n\n![QQ截图20210522201043](../前后端交互模式/2.png)\n\n#### 1.2.2 Restful 形式的 URL\n\n- HTTP 请求方式\n  - GET 查询\n  - POST 添加\n  - PUT 修改\n  - DELETE 删除\n\n## 2.Promise 用法\n\n#### 2.1 异步调用\n\n- 异步效果分析\n  - 定时任务\n  - Ajax\n  - 事件函数\n- 多次异步调用的依赖分析\n  - 多次异步调用的结果顺序不确定\n  - 异步调用结果如果存在依赖需要嵌套\n\n#### 2.2 Promise 概述\n\nPromise 是异步编程的一种解决方案，从语法上讲，Promise 是一个对象，从它可以获取异步操作的消息\n\n使用 Promise 主要有以下好处：\n\n- 可以避免多层异步调用嵌套问题（回调地狱）\n- Promise 对象提供了简洁的 API，使得控制异步操作更加容易\n\n#### 2.3 Promise 基本用法\n\n- 实例化==Promise==对象，构造函数中传递函数，该函数用于处理异步任务\n- ==resolve==和==reject==两个参数用于处理成功和失败两种情况，并通过==p.then==获取处理结果\n\n```javascript\nvar p = new Promise(function(resolve,reject){\n    //成功时调用  resolve()\n    //失败时调用  reject()\n});\n\np.then(function(ret){\n\t//从resolve得到正常结果\n})，function(ret){\n\t//从reject得到错误信息\n}\n```\n\n#### 2.4 Promise 常用的 API\n\n- p.then() 得到异步任务的正确结果\n- p.catch() 获取异常信息\n- p.finally() 成功与否都会执行（尚且不是正式标准）\n\n#### 2.5 Promise 对象方法\n\n- Promise.all() 并发处理多个异步任务，所有任务都执行完成才能得到结果\n- Promise.race() 并发处理多个异步任务，只要有一个任务完成就能得到结果\n\n## 3.fetch\n\n#### 3.1 fetch 概述\n\n1. 基本特性\n\n- 更加简单的数据获取方式，功能更加强大，更灵活，可以看作是 xhr 的升级版\n- 基于 promise 实现\n\n2. 语法结构\n\n```javascript\nfetch(url).then(fn2)\n\t\t.then(fn3)\n\t\t......\n\n        .catch(fn)\n```\n\n#### 3.2 fetch 的基本用法\n\n```javascript\nfetch(\"/abc\")\n  .then((data) => {\n    return data.text();\n  })\n  .then((ret) => {\n    //注意这里得到的才是最终的数据\n    console.log(ret);\n  });\n```\n\n#### 3.3 fetch 请求参数\n\n- method：HTTP 请求方法，默认为 GET（GET,POST,PUT,DELETE)\n- body:HTTP 的请求参数\n- headers：HTTP 的请求头，默认为{}\n\n```javascript\nfetch(\"/abc\", {\n  method: \"get\",\n})\n  .then((data) => {\n    return data.text();\n  })\n  .then((ret) => {\n    //注意这里得到的才是最终的数据\n    console.log(ret);\n  });\n```\n\n#### 3.4 fetch 响应结果\n\n响应数据格式\n\n- text(): 将返回体处理成字符串类型\n- json(): 返回结果和 JSON.parse(responseText) 一样\n\n## 4.axios\n\n#### 4.1 axios 的基本特征\n\n- 支持浏览器和 node.js\n- 支持 promise\n- 能拦截请求和响应\n- 自动转换 JSON 数据\n\n#### 4.2 axios 的基本用法\n\n```javascript\naxois.get(\"/data\").then((ret) => {\n  //data属性名称是固定的，用于获取后台响应的数据\n  console.log(ret.data);\n});\n```\n\n#### 4.3 axios 的常用 API\n\n- get: 查询数据\n- post： 添加数据\n- put： 修改数据\n- delete： 删除数据\n\n#### 4.4 axios 的响应结果\n\n- data： 实际响应回来的结果\n- headers： 响应头信息\n- status： 响应状态码\n- statusText： 响应状态信息\n\n#### 4.5 axios 的全局配置\n\n- axios.defaults.timeout = 3000 //超出时间\n- axios.defaults.baseURL = 'http://localhost:3000/app' //默认地址\n- axios.defaults.headers['mytoken'] = 'aqwerwqwerqwer2ewrwe23eresdf23' //设置请求头\n\n#### 4.6 axios 拦截器\n\n1. 请求拦截器\n\n在请求发出之前设置一些信息\n\n![屏幕截图 2021-05-25 101638](C:\\Users\\yellowapple\\Desktop\\屏幕截图 2021-05-25 101638.png)\n\n```javascript\n//添加一个请求拦截器\naxios.interceptors.request.use(\n  function (config) {\n    //在请求发出之前进行一些信息设置\n    return config;\n  },\n  function (err) {\n    //处理响应的错误信息\n  }\n);\n```\n\n2. 响应拦截器\n\n在获取数据之前对数据做一些加工处理\n\n```javascript\n//添加一个请求拦截器\naxios.interceptors.response.use(\n  function (res) {\n    //在请求发出之前进行一些信息设置\n    return res;\n  },\n  function (err) {\n    //处理响应的错误信息\n  }\n);\n```\n\n## 5.async/await 用法\n\n- async/await 是 ES7 引入的新语法，可以更加方便的进行异步操作\n- async 关键字用于函数上(async 函数的返回值是 Promise 实例对象)\n- await 关键字用于 async 函数当中（await 可以得到异步的结果）\n\n```javascript\nasync function queryData(id) {\n  const ret = await axios.get(\"/data\");\n  return ret;\n}\nqueryData.then((ret) => {\n  console.log(ret);\n});\n```\n","slug":"前后端交互模式","published":1,"updated":"2024-11-17T13:58:10.671Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpn001y73t3c5e7grst","content":"<h2 id=\"1-前后端交互模式\"><a href=\"#1-前后端交互模式\" class=\"headerlink\" title=\"1.前后端交互模式\"></a>1.前后端交互模式</h2><h3 id=\"1-1-接口调用方式\"><a href=\"#1-1-接口调用方式\" class=\"headerlink\" title=\"1.1 接口调用方式\"></a>1.1 接口调用方式</h3><ul>\n<li>原生 ajax</li>\n<li>基于 jQuery 的 ajax</li>\n<li>fetch</li>\n<li>axios</li>\n</ul>\n<p><img src=\"/2021/05/25/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F/1.png\" alt=\"QQ截图20210522200707\"></p>\n<h3 id=\"1-2-URL-地址格式\"><a href=\"#1-2-URL-地址格式\" class=\"headerlink\" title=\"1.2 URL 地址格式\"></a>1.2 URL 地址格式</h3><h4 id=\"1-2-1-传统形式的-URL\"><a href=\"#1-2-1-传统形式的-URL\" class=\"headerlink\" title=\"1.2.1 传统形式的 URL\"></a>1.2.1 传统形式的 URL</h4><p><img src=\"/2021/05/25/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F/2.png\" alt=\"QQ截图20210522201043\"></p>\n<h4 id=\"1-2-2-Restful-形式的-URL\"><a href=\"#1-2-2-Restful-形式的-URL\" class=\"headerlink\" title=\"1.2.2 Restful 形式的 URL\"></a>1.2.2 Restful 形式的 URL</h4><ul>\n<li>HTTP 请求方式<ul>\n<li>GET 查询</li>\n<li>POST 添加</li>\n<li>PUT 修改</li>\n<li>DELETE 删除</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-Promise-用法\"><a href=\"#2-Promise-用法\" class=\"headerlink\" title=\"2.Promise 用法\"></a>2.Promise 用法</h2><h4 id=\"2-1-异步调用\"><a href=\"#2-1-异步调用\" class=\"headerlink\" title=\"2.1 异步调用\"></a>2.1 异步调用</h4><ul>\n<li>异步效果分析<ul>\n<li>定时任务</li>\n<li>Ajax</li>\n<li>事件函数</li>\n</ul>\n</li>\n<li>多次异步调用的依赖分析<ul>\n<li>多次异步调用的结果顺序不确定</li>\n<li>异步调用结果如果存在依赖需要嵌套</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-2-Promise-概述\"><a href=\"#2-2-Promise-概述\" class=\"headerlink\" title=\"2.2 Promise 概述\"></a>2.2 Promise 概述</h4><p>Promise 是异步编程的一种解决方案，从语法上讲，Promise 是一个对象，从它可以获取异步操作的消息</p>\n<p>使用 Promise 主要有以下好处：</p>\n<ul>\n<li>可以避免多层异步调用嵌套问题（回调地狱）</li>\n<li>Promise 对象提供了简洁的 API，使得控制异步操作更加容易</li>\n</ul>\n<h4 id=\"2-3-Promise-基本用法\"><a href=\"#2-3-Promise-基本用法\" class=\"headerlink\" title=\"2.3 Promise 基本用法\"></a>2.3 Promise 基本用法</h4><ul>\n<li>实例化==Promise==对象，构造函数中传递函数，该函数用于处理异步任务</li>\n<li>==resolve==和==reject==两个参数用于处理成功和失败两种情况，并通过==p.then==获取处理结果</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)&#123;<br>    <span class=\"hljs-comment\">//成功时调用  resolve()</span><br>    <span class=\"hljs-comment\">//失败时调用  reject()</span><br>&#125;);<br><br>p.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ret</span>)&#123;<br>\t<span class=\"hljs-comment\">//从resolve得到正常结果</span><br>&#125;)，<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ret</span>)&#123;<br>\t<span class=\"hljs-comment\">//从reject得到错误信息</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-Promise-常用的-API\"><a href=\"#2-4-Promise-常用的-API\" class=\"headerlink\" title=\"2.4 Promise 常用的 API\"></a>2.4 Promise 常用的 API</h4><ul>\n<li>p.then() 得到异步任务的正确结果</li>\n<li>p.catch() 获取异常信息</li>\n<li>p.finally() 成功与否都会执行（尚且不是正式标准）</li>\n</ul>\n<h4 id=\"2-5-Promise-对象方法\"><a href=\"#2-5-Promise-对象方法\" class=\"headerlink\" title=\"2.5 Promise 对象方法\"></a>2.5 Promise 对象方法</h4><ul>\n<li>Promise.all() 并发处理多个异步任务，所有任务都执行完成才能得到结果</li>\n<li>Promise.race() 并发处理多个异步任务，只要有一个任务完成就能得到结果</li>\n</ul>\n<h2 id=\"3-fetch\"><a href=\"#3-fetch\" class=\"headerlink\" title=\"3.fetch\"></a>3.fetch</h2><h4 id=\"3-1-fetch-概述\"><a href=\"#3-1-fetch-概述\" class=\"headerlink\" title=\"3.1 fetch 概述\"></a>3.1 fetch 概述</h4><ol>\n<li>基本特性</li>\n</ol>\n<ul>\n<li>更加简单的数据获取方式，功能更加强大，更灵活，可以看作是 xhr 的升级版</li>\n<li>基于 promise 实现</li>\n</ul>\n<ol start=\"2\">\n<li>语法结构</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">fetch</span>(url).<span class=\"hljs-title function_\">then</span>(fn2)<br>\t\t.<span class=\"hljs-title function_\">then</span>(fn3)<br>\t\t......<br><br>        .<span class=\"hljs-title function_\">catch</span>(fn)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-fetch-的基本用法\"><a href=\"#3-2-fetch-的基本用法\" class=\"headerlink\" title=\"3.2 fetch 的基本用法\"></a>3.2 fetch 的基本用法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&quot;/abc&quot;</span>)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> data.<span class=\"hljs-title function_\">text</span>();<br>  &#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">ret</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-comment\">//注意这里得到的才是最终的数据</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(ret);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-fetch-请求参数\"><a href=\"#3-3-fetch-请求参数\" class=\"headerlink\" title=\"3.3 fetch 请求参数\"></a>3.3 fetch 请求参数</h4><ul>\n<li>method：HTTP 请求方法，默认为 GET（GET,POST,PUT,DELETE)</li>\n<li>body:HTTP 的请求参数</li>\n<li>headers：HTTP 的请求头，默认为{}</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&quot;/abc&quot;</span>, &#123;<br>  <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&quot;get&quot;</span>,<br>&#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> data.<span class=\"hljs-title function_\">text</span>();<br>  &#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">ret</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-comment\">//注意这里得到的才是最终的数据</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(ret);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-4-fetch-响应结果\"><a href=\"#3-4-fetch-响应结果\" class=\"headerlink\" title=\"3.4 fetch 响应结果\"></a>3.4 fetch 响应结果</h4><p>响应数据格式</p>\n<ul>\n<li>text(): 将返回体处理成字符串类型</li>\n<li>json(): 返回结果和 JSON.parse(responseText) 一样</li>\n</ul>\n<h2 id=\"4-axios\"><a href=\"#4-axios\" class=\"headerlink\" title=\"4.axios\"></a>4.axios</h2><h4 id=\"4-1-axios-的基本特征\"><a href=\"#4-1-axios-的基本特征\" class=\"headerlink\" title=\"4.1 axios 的基本特征\"></a>4.1 axios 的基本特征</h4><ul>\n<li>支持浏览器和 node.js</li>\n<li>支持 promise</li>\n<li>能拦截请求和响应</li>\n<li>自动转换 JSON 数据</li>\n</ul>\n<h4 id=\"4-2-axios-的基本用法\"><a href=\"#4-2-axios-的基本用法\" class=\"headerlink\" title=\"4.2 axios 的基本用法\"></a>4.2 axios 的基本用法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">axois.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;/data&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">ret</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">//data属性名称是固定的，用于获取后台响应的数据</span><br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(ret.<span class=\"hljs-property\">data</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-axios-的常用-API\"><a href=\"#4-3-axios-的常用-API\" class=\"headerlink\" title=\"4.3 axios 的常用 API\"></a>4.3 axios 的常用 API</h4><ul>\n<li>get: 查询数据</li>\n<li>post： 添加数据</li>\n<li>put： 修改数据</li>\n<li>delete： 删除数据</li>\n</ul>\n<h4 id=\"4-4-axios-的响应结果\"><a href=\"#4-4-axios-的响应结果\" class=\"headerlink\" title=\"4.4 axios 的响应结果\"></a>4.4 axios 的响应结果</h4><ul>\n<li>data： 实际响应回来的结果</li>\n<li>headers： 响应头信息</li>\n<li>status： 响应状态码</li>\n<li>statusText： 响应状态信息</li>\n</ul>\n<h4 id=\"4-5-axios-的全局配置\"><a href=\"#4-5-axios-的全局配置\" class=\"headerlink\" title=\"4.5 axios 的全局配置\"></a>4.5 axios 的全局配置</h4><ul>\n<li>axios.defaults.timeout = 3000 //超出时间</li>\n<li>axios.defaults.baseURL = ‘<a href=\"http://localhost:3000/app&#39;\">http://localhost:3000/app&#39;</a> //默认地址</li>\n<li>axios.defaults.headers[‘mytoken’] = ‘aqwerwqwerqwer2ewrwe23eresdf23’ //设置请求头</li>\n</ul>\n<h4 id=\"4-6-axios-拦截器\"><a href=\"#4-6-axios-拦截器\" class=\"headerlink\" title=\"4.6 axios 拦截器\"></a>4.6 axios 拦截器</h4><ol>\n<li>请求拦截器</li>\n</ol>\n<p>在请求发出之前设置一些信息</p>\n<p>![屏幕截图 2021-05-25 101638](C:\\Users\\yellowapple\\Desktop\\屏幕截图 2021-05-25 101638.png)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//添加一个请求拦截器</span><br>axios.<span class=\"hljs-property\">interceptors</span>.<span class=\"hljs-property\">request</span>.<span class=\"hljs-title function_\">use</span>(<br>  <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">config</span>) &#123;<br>    <span class=\"hljs-comment\">//在请求发出之前进行一些信息设置</span><br>    <span class=\"hljs-keyword\">return</span> config;<br>  &#125;,<br>  <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) &#123;<br>    <span class=\"hljs-comment\">//处理响应的错误信息</span><br>  &#125;<br>);<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>响应拦截器</li>\n</ol>\n<p>在获取数据之前对数据做一些加工处理</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//添加一个请求拦截器</span><br>axios.<span class=\"hljs-property\">interceptors</span>.<span class=\"hljs-property\">response</span>.<span class=\"hljs-title function_\">use</span>(<br>  <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">res</span>) &#123;<br>    <span class=\"hljs-comment\">//在请求发出之前进行一些信息设置</span><br>    <span class=\"hljs-keyword\">return</span> res;<br>  &#125;,<br>  <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) &#123;<br>    <span class=\"hljs-comment\">//处理响应的错误信息</span><br>  &#125;<br>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-async-await-用法\"><a href=\"#5-async-await-用法\" class=\"headerlink\" title=\"5.async/await 用法\"></a>5.async/await 用法</h2><ul>\n<li>async/await 是 ES7 引入的新语法，可以更加方便的进行异步操作</li>\n<li>async 关键字用于函数上(async 函数的返回值是 Promise 实例对象)</li>\n<li>await 关键字用于 async 函数当中（await 可以得到异步的结果）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">queryData</span>(<span class=\"hljs-params\">id</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> ret = <span class=\"hljs-keyword\">await</span> axios.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;/data&quot;</span>);<br>  <span class=\"hljs-keyword\">return</span> ret;<br>&#125;<br>queryData.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">ret</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(ret);<br>&#125;);<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":2604,"excerpt":"","more":"<h2 id=\"1-前后端交互模式\"><a href=\"#1-前后端交互模式\" class=\"headerlink\" title=\"1.前后端交互模式\"></a>1.前后端交互模式</h2><h3 id=\"1-1-接口调用方式\"><a href=\"#1-1-接口调用方式\" class=\"headerlink\" title=\"1.1 接口调用方式\"></a>1.1 接口调用方式</h3><ul>\n<li>原生 ajax</li>\n<li>基于 jQuery 的 ajax</li>\n<li>fetch</li>\n<li>axios</li>\n</ul>\n<p><img src=\"/2021/05/25/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F/1.png\" alt=\"QQ截图20210522200707\"></p>\n<h3 id=\"1-2-URL-地址格式\"><a href=\"#1-2-URL-地址格式\" class=\"headerlink\" title=\"1.2 URL 地址格式\"></a>1.2 URL 地址格式</h3><h4 id=\"1-2-1-传统形式的-URL\"><a href=\"#1-2-1-传统形式的-URL\" class=\"headerlink\" title=\"1.2.1 传统形式的 URL\"></a>1.2.1 传统形式的 URL</h4><p><img src=\"/2021/05/25/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F/2.png\" alt=\"QQ截图20210522201043\"></p>\n<h4 id=\"1-2-2-Restful-形式的-URL\"><a href=\"#1-2-2-Restful-形式的-URL\" class=\"headerlink\" title=\"1.2.2 Restful 形式的 URL\"></a>1.2.2 Restful 形式的 URL</h4><ul>\n<li>HTTP 请求方式<ul>\n<li>GET 查询</li>\n<li>POST 添加</li>\n<li>PUT 修改</li>\n<li>DELETE 删除</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-Promise-用法\"><a href=\"#2-Promise-用法\" class=\"headerlink\" title=\"2.Promise 用法\"></a>2.Promise 用法</h2><h4 id=\"2-1-异步调用\"><a href=\"#2-1-异步调用\" class=\"headerlink\" title=\"2.1 异步调用\"></a>2.1 异步调用</h4><ul>\n<li>异步效果分析<ul>\n<li>定时任务</li>\n<li>Ajax</li>\n<li>事件函数</li>\n</ul>\n</li>\n<li>多次异步调用的依赖分析<ul>\n<li>多次异步调用的结果顺序不确定</li>\n<li>异步调用结果如果存在依赖需要嵌套</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-2-Promise-概述\"><a href=\"#2-2-Promise-概述\" class=\"headerlink\" title=\"2.2 Promise 概述\"></a>2.2 Promise 概述</h4><p>Promise 是异步编程的一种解决方案，从语法上讲，Promise 是一个对象，从它可以获取异步操作的消息</p>\n<p>使用 Promise 主要有以下好处：</p>\n<ul>\n<li>可以避免多层异步调用嵌套问题（回调地狱）</li>\n<li>Promise 对象提供了简洁的 API，使得控制异步操作更加容易</li>\n</ul>\n<h4 id=\"2-3-Promise-基本用法\"><a href=\"#2-3-Promise-基本用法\" class=\"headerlink\" title=\"2.3 Promise 基本用法\"></a>2.3 Promise 基本用法</h4><ul>\n<li>实例化==Promise==对象，构造函数中传递函数，该函数用于处理异步任务</li>\n<li>==resolve==和==reject==两个参数用于处理成功和失败两种情况，并通过==p.then==获取处理结果</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)&#123;<br>    <span class=\"hljs-comment\">//成功时调用  resolve()</span><br>    <span class=\"hljs-comment\">//失败时调用  reject()</span><br>&#125;);<br><br>p.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ret</span>)&#123;<br>\t<span class=\"hljs-comment\">//从resolve得到正常结果</span><br>&#125;)，<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ret</span>)&#123;<br>\t<span class=\"hljs-comment\">//从reject得到错误信息</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-Promise-常用的-API\"><a href=\"#2-4-Promise-常用的-API\" class=\"headerlink\" title=\"2.4 Promise 常用的 API\"></a>2.4 Promise 常用的 API</h4><ul>\n<li>p.then() 得到异步任务的正确结果</li>\n<li>p.catch() 获取异常信息</li>\n<li>p.finally() 成功与否都会执行（尚且不是正式标准）</li>\n</ul>\n<h4 id=\"2-5-Promise-对象方法\"><a href=\"#2-5-Promise-对象方法\" class=\"headerlink\" title=\"2.5 Promise 对象方法\"></a>2.5 Promise 对象方法</h4><ul>\n<li>Promise.all() 并发处理多个异步任务，所有任务都执行完成才能得到结果</li>\n<li>Promise.race() 并发处理多个异步任务，只要有一个任务完成就能得到结果</li>\n</ul>\n<h2 id=\"3-fetch\"><a href=\"#3-fetch\" class=\"headerlink\" title=\"3.fetch\"></a>3.fetch</h2><h4 id=\"3-1-fetch-概述\"><a href=\"#3-1-fetch-概述\" class=\"headerlink\" title=\"3.1 fetch 概述\"></a>3.1 fetch 概述</h4><ol>\n<li>基本特性</li>\n</ol>\n<ul>\n<li>更加简单的数据获取方式，功能更加强大，更灵活，可以看作是 xhr 的升级版</li>\n<li>基于 promise 实现</li>\n</ul>\n<ol start=\"2\">\n<li>语法结构</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">fetch</span>(url).<span class=\"hljs-title function_\">then</span>(fn2)<br>\t\t.<span class=\"hljs-title function_\">then</span>(fn3)<br>\t\t......<br><br>        .<span class=\"hljs-title function_\">catch</span>(fn)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-fetch-的基本用法\"><a href=\"#3-2-fetch-的基本用法\" class=\"headerlink\" title=\"3.2 fetch 的基本用法\"></a>3.2 fetch 的基本用法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&quot;/abc&quot;</span>)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> data.<span class=\"hljs-title function_\">text</span>();<br>  &#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">ret</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-comment\">//注意这里得到的才是最终的数据</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(ret);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-fetch-请求参数\"><a href=\"#3-3-fetch-请求参数\" class=\"headerlink\" title=\"3.3 fetch 请求参数\"></a>3.3 fetch 请求参数</h4><ul>\n<li>method：HTTP 请求方法，默认为 GET（GET,POST,PUT,DELETE)</li>\n<li>body:HTTP 的请求参数</li>\n<li>headers：HTTP 的请求头，默认为{}</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&quot;/abc&quot;</span>, &#123;<br>  <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&quot;get&quot;</span>,<br>&#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> data.<span class=\"hljs-title function_\">text</span>();<br>  &#125;)<br>  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">ret</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-comment\">//注意这里得到的才是最终的数据</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(ret);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-4-fetch-响应结果\"><a href=\"#3-4-fetch-响应结果\" class=\"headerlink\" title=\"3.4 fetch 响应结果\"></a>3.4 fetch 响应结果</h4><p>响应数据格式</p>\n<ul>\n<li>text(): 将返回体处理成字符串类型</li>\n<li>json(): 返回结果和 JSON.parse(responseText) 一样</li>\n</ul>\n<h2 id=\"4-axios\"><a href=\"#4-axios\" class=\"headerlink\" title=\"4.axios\"></a>4.axios</h2><h4 id=\"4-1-axios-的基本特征\"><a href=\"#4-1-axios-的基本特征\" class=\"headerlink\" title=\"4.1 axios 的基本特征\"></a>4.1 axios 的基本特征</h4><ul>\n<li>支持浏览器和 node.js</li>\n<li>支持 promise</li>\n<li>能拦截请求和响应</li>\n<li>自动转换 JSON 数据</li>\n</ul>\n<h4 id=\"4-2-axios-的基本用法\"><a href=\"#4-2-axios-的基本用法\" class=\"headerlink\" title=\"4.2 axios 的基本用法\"></a>4.2 axios 的基本用法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">axois.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;/data&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">ret</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">//data属性名称是固定的，用于获取后台响应的数据</span><br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(ret.<span class=\"hljs-property\">data</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-axios-的常用-API\"><a href=\"#4-3-axios-的常用-API\" class=\"headerlink\" title=\"4.3 axios 的常用 API\"></a>4.3 axios 的常用 API</h4><ul>\n<li>get: 查询数据</li>\n<li>post： 添加数据</li>\n<li>put： 修改数据</li>\n<li>delete： 删除数据</li>\n</ul>\n<h4 id=\"4-4-axios-的响应结果\"><a href=\"#4-4-axios-的响应结果\" class=\"headerlink\" title=\"4.4 axios 的响应结果\"></a>4.4 axios 的响应结果</h4><ul>\n<li>data： 实际响应回来的结果</li>\n<li>headers： 响应头信息</li>\n<li>status： 响应状态码</li>\n<li>statusText： 响应状态信息</li>\n</ul>\n<h4 id=\"4-5-axios-的全局配置\"><a href=\"#4-5-axios-的全局配置\" class=\"headerlink\" title=\"4.5 axios 的全局配置\"></a>4.5 axios 的全局配置</h4><ul>\n<li>axios.defaults.timeout = 3000 //超出时间</li>\n<li>axios.defaults.baseURL = ‘<a href=\"http://localhost:3000/app&#39;\">http://localhost:3000/app&#39;</a> //默认地址</li>\n<li>axios.defaults.headers[‘mytoken’] = ‘aqwerwqwerqwer2ewrwe23eresdf23’ //设置请求头</li>\n</ul>\n<h4 id=\"4-6-axios-拦截器\"><a href=\"#4-6-axios-拦截器\" class=\"headerlink\" title=\"4.6 axios 拦截器\"></a>4.6 axios 拦截器</h4><ol>\n<li>请求拦截器</li>\n</ol>\n<p>在请求发出之前设置一些信息</p>\n<p>![屏幕截图 2021-05-25 101638](C:\\Users\\yellowapple\\Desktop\\屏幕截图 2021-05-25 101638.png)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//添加一个请求拦截器</span><br>axios.<span class=\"hljs-property\">interceptors</span>.<span class=\"hljs-property\">request</span>.<span class=\"hljs-title function_\">use</span>(<br>  <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">config</span>) &#123;<br>    <span class=\"hljs-comment\">//在请求发出之前进行一些信息设置</span><br>    <span class=\"hljs-keyword\">return</span> config;<br>  &#125;,<br>  <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) &#123;<br>    <span class=\"hljs-comment\">//处理响应的错误信息</span><br>  &#125;<br>);<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>响应拦截器</li>\n</ol>\n<p>在获取数据之前对数据做一些加工处理</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//添加一个请求拦截器</span><br>axios.<span class=\"hljs-property\">interceptors</span>.<span class=\"hljs-property\">response</span>.<span class=\"hljs-title function_\">use</span>(<br>  <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">res</span>) &#123;<br>    <span class=\"hljs-comment\">//在请求发出之前进行一些信息设置</span><br>    <span class=\"hljs-keyword\">return</span> res;<br>  &#125;,<br>  <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) &#123;<br>    <span class=\"hljs-comment\">//处理响应的错误信息</span><br>  &#125;<br>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-async-await-用法\"><a href=\"#5-async-await-用法\" class=\"headerlink\" title=\"5.async/await 用法\"></a>5.async/await 用法</h2><ul>\n<li>async/await 是 ES7 引入的新语法，可以更加方便的进行异步操作</li>\n<li>async 关键字用于函数上(async 函数的返回值是 Promise 实例对象)</li>\n<li>await 关键字用于 async 函数当中（await 可以得到异步的结果）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">queryData</span>(<span class=\"hljs-params\">id</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> ret = <span class=\"hljs-keyword\">await</span> axios.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;/data&quot;</span>);<br>  <span class=\"hljs-keyword\">return</span> ret;<br>&#125;<br>queryData.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">ret</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(ret);<br>&#125;);<br></code></pre></td></tr></table></figure>\n"},{"title":"前端解决跨域的几种方法","date":"2021-12-07T12:33:16.000Z","index_img":"/img/font-index.jpg","banner_img":"/img/CORS_banner.jpeg","_content":"\n> 跨域这个问题还是比较常见的，下面我们来讨论一下几种解决跨域的办法\n\n### HTTP中的请求方法\n\n**HTTP/1.1协议定义了八种方法**\n\n| 方法    | 描述                                                   | 是否包含主体 |\n| ------- | ------------------------------------------------------ | ------------ |\n| GET     | 请求指定的页面，并返回实体主体                         | 否           |\n| POST    | 向服务器发送带要处理的数据                             | 是           |\n| DELETE  | 从服务器上删除一份文档                                 | 否           |\n| PUT     | 将请求的主体部分存储在服务器上                         | 是           |\n| HEAD    | 只从服务器获取文档的首部                               | 否           |\n| OPTIONS | 决定可以在服务器上执行哪些方法                         | 否           |\n| TRACE   | 对可能经过代理服务器传送到服务器上去的报文进行追踪     | 否           |\n| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器 | 否           |\n\n\n\n### 1. 什么是跨域\n\n在我们向一个接口发送请求的时候，也就是你的==请求的url==的**协议**、**域名**\n\n、**端口**三者之间任意一个与当前页面的url不同就是  **跨域**\n\n| 当前页面                    | 被请求页面            | 是否跨域 | 原因                                      |\n| --------------------------- | --------------------- | -------- | ----------------------------------------- |\n| http://localhost            | https://localhost     | 是       | 协议不同，一个是http协议，一个是https协议 |\n| http://localhsot            | http://www.baidu.com  | 是       | 域名不同                                  |\n| http://localhost:3000       | http://localhost:8080 | 是       | 端口号不同                                |\n| http://localhsot/index.html | http://localhost      | 否       | 同源                                      |\n\n### 2.为什么会产生跨域\n\n跨域是出于浏览器的同源策略限制，**同源策略**是一个重要的安全策略，它能够帮助阻隔恶意文档，减少可能被攻击的媒介\n\n>服务端响应数据返回给浏览器的时候，浏览器根据响应头的Access-Control-Allow-Origin字段的值来判断是否有权限获取数据\n>\n\n### 3.跨域请求的分类\n\n下面是在阮一峰博客摘抄的，详情可见[跨域资源共享 CORS 详解 - 阮一峰的网络日志 (ruanyifeng.com)](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n\n>什么是域呢？\n>\n>Origin 表示本域，也就是浏览器当前页面的域，当JavaScript向外域（如sina.com）\n>发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，\n>如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。\n>\n>假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，或者是*，本次请求就可以成功。\n>\n>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。\n\n**两种请求**(简单请求和复杂请求)\n\n#### 3.1 简单请求\n\n只要同时满足以下两个条件的就是简单请求\n\n```http\n1.请求方法是以下三种方法之一：\n   -HEAD\n   -GET\n   -POST\n2.HTPTP的头信息不超过以下几种字段\n   -Accept\n   -Accept-Language\n   -Content-Language\n   -Last-Event-ID\n   -Content-Type: 只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n```\n\n对于简单请求，浏览器会直接发送CORS请求，也就是在头信息中增加一个==Origin==字段\n\n```http\nGET /cors HTTP/1.1\nOrigin: http://api.bob.com\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n```\n\n上面的头信息中，`Origin`字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。\n\n如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段（详见下文），就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。\n\n如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。\n\n> ```http\n> Access-Control-Allow-Origin: http://api.bob.com\n> Access-Control-Allow-Credentials: true\n> Access-Control-Expose-Headers: FooBar\n> Content-Type: text/html; charset=utf-8\n> ```\n\n上面的头信息之中，有三个与CORS请求相关的字段，都以`Access-Control-`开头。\n\n**（1）Access-Control-Allow-Origin**\n\n该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。\n\n**（2）Access-Control-Allow-Credentials**\n\n该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为`true`，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为`true`，如果服务器不要浏览器发送Cookie，删除该字段即可。\n\n**（3）Access-Control-Expose-Headers**\n\n该字段可选。CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。上面的例子指定，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值。\n\n#### 3.2 withCredentials 属性\n\n上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定`Access-Control-Allow-Credentials`字段。\n\n> ```http\n> Access-Control-Allow-Credentials: true\n> ```\n\n另一方面，开发者必须在AJAX请求中打开`withCredentials`属性。\n\n> ```javascript\n> var xhr = new XMLHttpRequest();\n> xhr.withCredentials = true;\n> ```\n\n否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。\n\n但是，如果省略`withCredentials`设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭`withCredentials`。\n\n> ```javascript\n> xhr.withCredentials = false;\n> ```\n\n需要注意的是，如果要发送Cookie，`Access-Control-Allow-Origin`就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的`document.cookie`也无法读取服务器域名下的Cookie。\n\n#### 3.3复杂请求\n\n简单请求是直接发送的，而复杂请求会在实际请求之前发送一个==预检请求(preflight)==预检请求通过访问控制检查后才会发送需要的请求。\n\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。 \n\n浏览器发现，这是一个非简单请求，就自动发出一个\"预检\"请求，要求服务器确认可以这样请求。下面是这个\"预检\"请求的HTTP头信息。\n\n> ```http\n> OPTIONS /cors HTTP/1.1\n> Origin: http://api.bob.com\n> Access-Control-Request-Method: PUT\n> Access-Control-Request-Headers: X-Custom-Header\n> Host: api.alice.com\n> Accept-Language: en-US\n> Connection: keep-alive\n> User-Agent: Mozilla/5.0...\n> ```\n\n预检请求的方法是==OPTIONS==\n\n### 4.解决跨域问题\n\n1. JSONP\n\n​\t利用的是 ==script== 标签可以任意跨域，这样子的标签还有 ==img== ==link==,\t\n\n​\t优点是兼容性特别好，但是只能发送**GET**请求，就是在请求的url中添加一个回调函数，并通过这个回调函数把数据发送给前端\n\n实现：\n\n```html\n<script src = \"http://localhost:3000?test\"></srcipt>\n\n<script>\n    test(res){\n\t\tconsole.log(res)\n    }\n</script>\n```\n\n\n\n2. CORS\n\n​\t整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通\t信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自\t动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。\n\n​\t因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信\n\n​\t==Access-Control-Allow-Origin: *==\n\n>**跨源资源共享** ([CORS](https://developer.mozilla.org/zh-CN/docs/Glossary/CORS)) （或通俗地译为跨域资源共享）是一种基于[HTTP](https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP) 头的机制，该机制通过允许服务器标示除了它自己以外的其它[origin](https://developer.mozilla.org/zh-CN/docs/Glossary/Origin)（域，协议和端口），这样浏览器可以访问加载这些资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的\"预检\"请求。在预检中，浏览器发送的头中标示有HTTP方法和真实请求中会用到的头。\n\n3. 代理转发\n\n​\t因为跨域这个是浏览器才有的，所以在用服务器向另一个服务器请求数据的时候，就不会产生跨域这个问题了\n\n​\tnginx反向代理\n\n​\tvue-cli 配置代理\n\n​\t浏览器插件解决跨域\n\n#### 3.1 vue-cli\n\n只能用于开发环境，等项目上线的时候还是需要服务端配置\n\n```js\nmodule.exports = {\n    entry: {},\n    module: {},\n    ...\n    devServer: {\n        historyApiFallback: true,\n        proxy: [{\n            context: '/login',\n            target: 'http://www.domain2.com:8080',  // 代理跨域目标接口\n            changeOrigin: true,\n            secure: false,  // 当代理某些https服务报错时用\n            cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改\n        }],\n        noInfo: true\n    }\n}\n```\n\n#### 3.2 浏览器插件\n\n只能用于开发环境，等项目上线的时候还是需要服务端配置\n\n可以在谷歌商店搜索 ==Allow CORS: Access-Control-Allow-Origin===\n\n#### 3.3 node 中间件\n\n这里使用 koa2 框架，只需要下载一个==koa2-cors==即可\n\n```javascript\nconst koa = require('koa')\nconst cors = require('koa2-cors')\nconst app = new koa()\n\napp.use(cors())\n\napp.listen(3001)\n```\n\n或者自己写一下\n\n```javascript\napp.use(async (ctx, next)=> {\n  ctx.set('Access-Control-Allow-Origin', '*');\n  ctx.set('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild');\n  ctx.set('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS');\n  if (ctx.method == 'OPTIONS') {\n    ctx.body = 200; \n  } else {\n    await next();\n  }\n});\n```\n\n\n\n#### 3.4 nginx 反向代理配置\n\n```javascript\n#proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    }\n}\n```\n\n","source":"_posts/前端解决跨域的几种方法.md","raw":"---\ntitle: 前端解决跨域的几种方法\ndate: 2021-12-07 20:33:16\ntags: tips\ncategories: 前端\nindex_img: /img/font-index.jpg\nbanner_img: /img/CORS_banner.jpeg\n---\n\n> 跨域这个问题还是比较常见的，下面我们来讨论一下几种解决跨域的办法\n\n### HTTP中的请求方法\n\n**HTTP/1.1协议定义了八种方法**\n\n| 方法    | 描述                                                   | 是否包含主体 |\n| ------- | ------------------------------------------------------ | ------------ |\n| GET     | 请求指定的页面，并返回实体主体                         | 否           |\n| POST    | 向服务器发送带要处理的数据                             | 是           |\n| DELETE  | 从服务器上删除一份文档                                 | 否           |\n| PUT     | 将请求的主体部分存储在服务器上                         | 是           |\n| HEAD    | 只从服务器获取文档的首部                               | 否           |\n| OPTIONS | 决定可以在服务器上执行哪些方法                         | 否           |\n| TRACE   | 对可能经过代理服务器传送到服务器上去的报文进行追踪     | 否           |\n| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器 | 否           |\n\n\n\n### 1. 什么是跨域\n\n在我们向一个接口发送请求的时候，也就是你的==请求的url==的**协议**、**域名**\n\n、**端口**三者之间任意一个与当前页面的url不同就是  **跨域**\n\n| 当前页面                    | 被请求页面            | 是否跨域 | 原因                                      |\n| --------------------------- | --------------------- | -------- | ----------------------------------------- |\n| http://localhost            | https://localhost     | 是       | 协议不同，一个是http协议，一个是https协议 |\n| http://localhsot            | http://www.baidu.com  | 是       | 域名不同                                  |\n| http://localhost:3000       | http://localhost:8080 | 是       | 端口号不同                                |\n| http://localhsot/index.html | http://localhost      | 否       | 同源                                      |\n\n### 2.为什么会产生跨域\n\n跨域是出于浏览器的同源策略限制，**同源策略**是一个重要的安全策略，它能够帮助阻隔恶意文档，减少可能被攻击的媒介\n\n>服务端响应数据返回给浏览器的时候，浏览器根据响应头的Access-Control-Allow-Origin字段的值来判断是否有权限获取数据\n>\n\n### 3.跨域请求的分类\n\n下面是在阮一峰博客摘抄的，详情可见[跨域资源共享 CORS 详解 - 阮一峰的网络日志 (ruanyifeng.com)](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n\n>什么是域呢？\n>\n>Origin 表示本域，也就是浏览器当前页面的域，当JavaScript向外域（如sina.com）\n>发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，\n>如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。\n>\n>假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，或者是*，本次请求就可以成功。\n>\n>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。\n\n**两种请求**(简单请求和复杂请求)\n\n#### 3.1 简单请求\n\n只要同时满足以下两个条件的就是简单请求\n\n```http\n1.请求方法是以下三种方法之一：\n   -HEAD\n   -GET\n   -POST\n2.HTPTP的头信息不超过以下几种字段\n   -Accept\n   -Accept-Language\n   -Content-Language\n   -Last-Event-ID\n   -Content-Type: 只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n```\n\n对于简单请求，浏览器会直接发送CORS请求，也就是在头信息中增加一个==Origin==字段\n\n```http\nGET /cors HTTP/1.1\nOrigin: http://api.bob.com\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n```\n\n上面的头信息中，`Origin`字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。\n\n如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段（详见下文），就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。\n\n如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。\n\n> ```http\n> Access-Control-Allow-Origin: http://api.bob.com\n> Access-Control-Allow-Credentials: true\n> Access-Control-Expose-Headers: FooBar\n> Content-Type: text/html; charset=utf-8\n> ```\n\n上面的头信息之中，有三个与CORS请求相关的字段，都以`Access-Control-`开头。\n\n**（1）Access-Control-Allow-Origin**\n\n该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。\n\n**（2）Access-Control-Allow-Credentials**\n\n该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为`true`，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为`true`，如果服务器不要浏览器发送Cookie，删除该字段即可。\n\n**（3）Access-Control-Expose-Headers**\n\n该字段可选。CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。上面的例子指定，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值。\n\n#### 3.2 withCredentials 属性\n\n上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定`Access-Control-Allow-Credentials`字段。\n\n> ```http\n> Access-Control-Allow-Credentials: true\n> ```\n\n另一方面，开发者必须在AJAX请求中打开`withCredentials`属性。\n\n> ```javascript\n> var xhr = new XMLHttpRequest();\n> xhr.withCredentials = true;\n> ```\n\n否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。\n\n但是，如果省略`withCredentials`设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭`withCredentials`。\n\n> ```javascript\n> xhr.withCredentials = false;\n> ```\n\n需要注意的是，如果要发送Cookie，`Access-Control-Allow-Origin`就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的`document.cookie`也无法读取服务器域名下的Cookie。\n\n#### 3.3复杂请求\n\n简单请求是直接发送的，而复杂请求会在实际请求之前发送一个==预检请求(preflight)==预检请求通过访问控制检查后才会发送需要的请求。\n\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。 \n\n浏览器发现，这是一个非简单请求，就自动发出一个\"预检\"请求，要求服务器确认可以这样请求。下面是这个\"预检\"请求的HTTP头信息。\n\n> ```http\n> OPTIONS /cors HTTP/1.1\n> Origin: http://api.bob.com\n> Access-Control-Request-Method: PUT\n> Access-Control-Request-Headers: X-Custom-Header\n> Host: api.alice.com\n> Accept-Language: en-US\n> Connection: keep-alive\n> User-Agent: Mozilla/5.0...\n> ```\n\n预检请求的方法是==OPTIONS==\n\n### 4.解决跨域问题\n\n1. JSONP\n\n​\t利用的是 ==script== 标签可以任意跨域，这样子的标签还有 ==img== ==link==,\t\n\n​\t优点是兼容性特别好，但是只能发送**GET**请求，就是在请求的url中添加一个回调函数，并通过这个回调函数把数据发送给前端\n\n实现：\n\n```html\n<script src = \"http://localhost:3000?test\"></srcipt>\n\n<script>\n    test(res){\n\t\tconsole.log(res)\n    }\n</script>\n```\n\n\n\n2. CORS\n\n​\t整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通\t信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自\t动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。\n\n​\t因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信\n\n​\t==Access-Control-Allow-Origin: *==\n\n>**跨源资源共享** ([CORS](https://developer.mozilla.org/zh-CN/docs/Glossary/CORS)) （或通俗地译为跨域资源共享）是一种基于[HTTP](https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP) 头的机制，该机制通过允许服务器标示除了它自己以外的其它[origin](https://developer.mozilla.org/zh-CN/docs/Glossary/Origin)（域，协议和端口），这样浏览器可以访问加载这些资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的\"预检\"请求。在预检中，浏览器发送的头中标示有HTTP方法和真实请求中会用到的头。\n\n3. 代理转发\n\n​\t因为跨域这个是浏览器才有的，所以在用服务器向另一个服务器请求数据的时候，就不会产生跨域这个问题了\n\n​\tnginx反向代理\n\n​\tvue-cli 配置代理\n\n​\t浏览器插件解决跨域\n\n#### 3.1 vue-cli\n\n只能用于开发环境，等项目上线的时候还是需要服务端配置\n\n```js\nmodule.exports = {\n    entry: {},\n    module: {},\n    ...\n    devServer: {\n        historyApiFallback: true,\n        proxy: [{\n            context: '/login',\n            target: 'http://www.domain2.com:8080',  // 代理跨域目标接口\n            changeOrigin: true,\n            secure: false,  // 当代理某些https服务报错时用\n            cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改\n        }],\n        noInfo: true\n    }\n}\n```\n\n#### 3.2 浏览器插件\n\n只能用于开发环境，等项目上线的时候还是需要服务端配置\n\n可以在谷歌商店搜索 ==Allow CORS: Access-Control-Allow-Origin===\n\n#### 3.3 node 中间件\n\n这里使用 koa2 框架，只需要下载一个==koa2-cors==即可\n\n```javascript\nconst koa = require('koa')\nconst cors = require('koa2-cors')\nconst app = new koa()\n\napp.use(cors())\n\napp.listen(3001)\n```\n\n或者自己写一下\n\n```javascript\napp.use(async (ctx, next)=> {\n  ctx.set('Access-Control-Allow-Origin', '*');\n  ctx.set('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild');\n  ctx.set('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS');\n  if (ctx.method == 'OPTIONS') {\n    ctx.body = 200; \n  } else {\n    await next();\n  }\n});\n```\n\n\n\n#### 3.4 nginx 反向代理配置\n\n```javascript\n#proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    }\n}\n```\n\n","slug":"前端解决跨域的几种方法","published":1,"updated":"2024-11-17T13:58:10.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpn002173t3dyd9aper","content":"<blockquote>\n<p>跨域这个问题还是比较常见的，下面我们来讨论一下几种解决跨域的办法</p>\n</blockquote>\n<h3 id=\"HTTP中的请求方法\"><a href=\"#HTTP中的请求方法\" class=\"headerlink\" title=\"HTTP中的请求方法\"></a>HTTP中的请求方法</h3><p><strong>HTTP/1.1协议定义了八种方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>是否包含主体</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GET</td>\n<td>请求指定的页面，并返回实体主体</td>\n<td>否</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>向服务器发送带要处理的数据</td>\n<td>是</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>从服务器上删除一份文档</td>\n<td>否</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>将请求的主体部分存储在服务器上</td>\n<td>是</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>只从服务器获取文档的首部</td>\n<td>否</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>决定可以在服务器上执行哪些方法</td>\n<td>否</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>对可能经过代理服务器传送到服务器上去的报文进行追踪</td>\n<td>否</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td>\n<td>否</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-什么是跨域\"><a href=\"#1-什么是跨域\" class=\"headerlink\" title=\"1. 什么是跨域\"></a>1. 什么是跨域</h3><p>在我们向一个接口发送请求的时候，也就是你的==请求的url==的<strong>协议</strong>、<strong>域名</strong></p>\n<p>、<strong>端口</strong>三者之间任意一个与当前页面的url不同就是  <strong>跨域</strong></p>\n<table>\n<thead>\n<tr>\n<th>当前页面</th>\n<th>被请求页面</th>\n<th>是否跨域</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"http://localhost/\">http://localhost</a></td>\n<td><a href=\"https://localhost/\">https://localhost</a></td>\n<td>是</td>\n<td>协议不同，一个是http协议，一个是https协议</td>\n</tr>\n<tr>\n<td><a href=\"http://localhsot/\">http://localhsot</a></td>\n<td><a href=\"http://www.baidu.com/\">http://www.baidu.com</a></td>\n<td>是</td>\n<td>域名不同</td>\n</tr>\n<tr>\n<td><a href=\"http://localhost:3000/\">http://localhost:3000</a></td>\n<td><a href=\"http://localhost:8080/\">http://localhost:8080</a></td>\n<td>是</td>\n<td>端口号不同</td>\n</tr>\n<tr>\n<td><a href=\"http://localhsot/index.html\">http://localhsot/index.html</a></td>\n<td><a href=\"http://localhost/\">http://localhost</a></td>\n<td>否</td>\n<td>同源</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-为什么会产生跨域\"><a href=\"#2-为什么会产生跨域\" class=\"headerlink\" title=\"2.为什么会产生跨域\"></a>2.为什么会产生跨域</h3><p>跨域是出于浏览器的同源策略限制，<strong>同源策略</strong>是一个重要的安全策略，它能够帮助阻隔恶意文档，减少可能被攻击的媒介</p>\n<blockquote>\n<p>服务端响应数据返回给浏览器的时候，浏览器根据响应头的Access-Control-Allow-Origin字段的值来判断是否有权限获取数据</p>\n</blockquote>\n<h3 id=\"3-跨域请求的分类\"><a href=\"#3-跨域请求的分类\" class=\"headerlink\" title=\"3.跨域请求的分类\"></a>3.跨域请求的分类</h3><p>下面是在阮一峰博客摘抄的，详情可见<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">跨域资源共享 CORS 详解 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>\n<blockquote>\n<p>什么是域呢？</p>\n<p>Origin 表示本域，也就是浏览器当前页面的域，当JavaScript向外域（如sina.com）<br>发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，<br>如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p>\n<p>假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为<a href=\"http://my.com,或者是*,本次请求就可以成功./\">http://my.com，或者是*，本次请求就可以成功。</a></p>\n<p>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。</p>\n</blockquote>\n<p><strong>两种请求</strong>(简单请求和复杂请求)</p>\n<h4 id=\"3-1-简单请求\"><a href=\"#3-1-简单请求\" class=\"headerlink\" title=\"3.1 简单请求\"></a>3.1 简单请求</h4><p>只要同时满足以下两个条件的就是简单请求</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\">1.请求方法是以下三种方法之一：<br>   -HEAD<br>   -GET<br>   -POST<br>2.HTPTP的头信息不超过以下几种字段<br>   -Accept<br>   -Accept-Language<br>   -Content-Language<br>   -Last-Event-ID<br>   -Content-Type: 只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain<br></code></pre></td></tr></table></figure>\n\n<p>对于简单请求，浏览器会直接发送CORS请求，也就是在头信息中增加一个==Origin==字段</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-keyword\">GET</span> <span class=\"hljs-string\">/cors</span> <span class=\"hljs-meta\">HTTP/1.1</span><br><span class=\"hljs-attribute\">Origin</span><span class=\"hljs-punctuation\">: </span>http://api.bob.com<br><span class=\"hljs-attribute\">Host</span><span class=\"hljs-punctuation\">: </span>api.alice.com<br><span class=\"hljs-attribute\">Accept-Language</span><span class=\"hljs-punctuation\">: </span>en-US<br><span class=\"hljs-attribute\">Connection</span><span class=\"hljs-punctuation\">: </span>keep-alive<br><span class=\"hljs-attribute\">User-Agent</span><span class=\"hljs-punctuation\">: </span>Mozilla/5.0...<br></code></pre></td></tr></table></figure>\n\n<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>\n<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>\n<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>\n<blockquote>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-attribute\">Access-Control-Allow-Origin</span><span class=\"hljs-punctuation\">: </span>http://api.bob.com<br><span class=\"hljs-attribute\">Access-Control-Allow-Credentials</span><span class=\"hljs-punctuation\">: </span>true<br><span class=\"hljs-attribute\">Access-Control-Expose-Headers</span><span class=\"hljs-punctuation\">: </span>FooBar<br><span class=\"hljs-attribute\">Content-Type</span><span class=\"hljs-punctuation\">: </span>text/html; charset=utf-8<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p>\n<p><strong>（1）Access-Control-Allow-Origin</strong></p>\n<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>\n<p><strong>（2）Access-Control-Allow-Credentials</strong></p>\n<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>\n<p><strong>（3）Access-Control-Expose-Headers</strong></p>\n<p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>\n<h4 id=\"3-2-withCredentials-属性\"><a href=\"#3-2-withCredentials-属性\" class=\"headerlink\" title=\"3.2 withCredentials 属性\"></a>3.2 withCredentials 属性</h4><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>\n<blockquote>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-attribute\">Access-Control-Allow-Credentials</span><span class=\"hljs-punctuation\">: </span>true<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p>\n<blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">XMLHttpRequest</span>();<br>xhr.<span class=\"hljs-property\">withCredentials</span> = <span class=\"hljs-literal\">true</span>;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>\n<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>\n<blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">xhr.<span class=\"hljs-property\">withCredentials</span> = <span class=\"hljs-literal\">false</span>;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>\n<h4 id=\"3-3复杂请求\"><a href=\"#3-3复杂请求\" class=\"headerlink\" title=\"3.3复杂请求\"></a>3.3复杂请求</h4><p>简单请求是直接发送的，而复杂请求会在实际请求之前发送一个==预检请求(preflight)==预检请求通过访问控制检查后才会发送需要的请求。</p>\n<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。 </p>\n<p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p>\n<blockquote>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-keyword\">OPTIONS</span> <span class=\"hljs-string\">/cors</span> <span class=\"hljs-meta\">HTTP/1.1</span><br><span class=\"hljs-attribute\">Origin</span><span class=\"hljs-punctuation\">: </span>http://api.bob.com<br><span class=\"hljs-attribute\">Access-Control-Request-Method</span><span class=\"hljs-punctuation\">: </span>PUT<br><span class=\"hljs-attribute\">Access-Control-Request-Headers</span><span class=\"hljs-punctuation\">: </span>X-Custom-Header<br><span class=\"hljs-attribute\">Host</span><span class=\"hljs-punctuation\">: </span>api.alice.com<br><span class=\"hljs-attribute\">Accept-Language</span><span class=\"hljs-punctuation\">: </span>en-US<br><span class=\"hljs-attribute\">Connection</span><span class=\"hljs-punctuation\">: </span>keep-alive<br><span class=\"hljs-attribute\">User-Agent</span><span class=\"hljs-punctuation\">: </span>Mozilla/5.0...<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>预检请求的方法是==OPTIONS==</p>\n<h3 id=\"4-解决跨域问题\"><a href=\"#4-解决跨域问题\" class=\"headerlink\" title=\"4.解决跨域问题\"></a>4.解决跨域问题</h3><ol>\n<li>JSONP</li>\n</ol>\n<p>​    利用的是 ==script== 标签可以任意跨域，这样子的标签还有 ==img== ==link==,    </p>\n<p>​    优点是兼容性特别好，但是只能发送<strong>GET</strong>请求，就是在请求的url中添加一个回调函数，并通过这个回调函数把数据发送给前端</p>\n<p>实现：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span> = <span class=\"hljs-string\">&quot;http://localhost:3000?test&quot;</span>&gt;</span><span class=\"language-handlebars\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">srcipt</span>&gt;</span></span></span><br><span class=\"language-xml\"><span class=\"language-handlebars\"></span></span><br><span class=\"language-xml\"><span class=\"language-handlebars\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"language-handlebars\">    <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\">res</span>)&#123;</span></span></span><br><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"language-handlebars\">\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res)</span></span></span><br><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"language-handlebars\">    &#125;</span></span></span><br><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"language-handlebars\"></span></span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n\n\n<ol start=\"2\">\n<li>CORS</li>\n</ol>\n<p>​    整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通    信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自    动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>\n<p>​    因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信</p>\n<p>​    ==Access-Control-Allow-Origin: *==</p>\n<blockquote>\n<p><strong>跨源资源共享</strong> (<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/CORS\">CORS</a>) （或通俗地译为跨域资源共享）是一种基于<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP\">HTTP</a> 头的机制，该机制通过允许服务器标示除了它自己以外的其它<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Origin\">origin</a>（域，协议和端口），这样浏览器可以访问加载这些资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的”预检”请求。在预检中，浏览器发送的头中标示有HTTP方法和真实请求中会用到的头。</p>\n</blockquote>\n<ol start=\"3\">\n<li>代理转发</li>\n</ol>\n<p>​    因为跨域这个是浏览器才有的，所以在用服务器向另一个服务器请求数据的时候，就不会产生跨域这个问题了</p>\n<p>​    nginx反向代理</p>\n<p>​    vue-cli 配置代理</p>\n<p>​    浏览器插件解决跨域</p>\n<h4 id=\"3-1-vue-cli\"><a href=\"#3-1-vue-cli\" class=\"headerlink\" title=\"3.1 vue-cli\"></a>3.1 vue-cli</h4><p>只能用于开发环境，等项目上线的时候还是需要服务端配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>    <span class=\"hljs-attr\">entry</span>: &#123;&#125;,<br>    <span class=\"hljs-attr\">module</span>: &#123;&#125;,<br>    ...<br>    <span class=\"hljs-attr\">devServer</span>: &#123;<br>        <span class=\"hljs-attr\">historyApiFallback</span>: <span class=\"hljs-literal\">true</span>,<br>        <span class=\"hljs-attr\">proxy</span>: [&#123;<br>            <span class=\"hljs-attr\">context</span>: <span class=\"hljs-string\">&#x27;/login&#x27;</span>,<br>            <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&#x27;http://www.domain2.com:8080&#x27;</span>,  <span class=\"hljs-comment\">// 代理跨域目标接口</span><br>            <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,<br>            <span class=\"hljs-attr\">secure</span>: <span class=\"hljs-literal\">false</span>,  <span class=\"hljs-comment\">// 当代理某些https服务报错时用</span><br>            <span class=\"hljs-attr\">cookieDomainRewrite</span>: <span class=\"hljs-string\">&#x27;www.domain1.com&#x27;</span>  <span class=\"hljs-comment\">// 可以为false，表示不修改</span><br>        &#125;],<br>        <span class=\"hljs-attr\">noInfo</span>: <span class=\"hljs-literal\">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-浏览器插件\"><a href=\"#3-2-浏览器插件\" class=\"headerlink\" title=\"3.2 浏览器插件\"></a>3.2 浏览器插件</h4><p>只能用于开发环境，等项目上线的时候还是需要服务端配置</p>\n<p>可以在谷歌商店搜索 ==Allow CORS: Access-Control-Allow-Origin===</p>\n<h4 id=\"3-3-node-中间件\"><a href=\"#3-3-node-中间件\" class=\"headerlink\" title=\"3.3 node 中间件\"></a>3.3 node 中间件</h4><p>这里使用 koa2 框架，只需要下载一个==koa2-cors==即可</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> koa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> cors = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa2-cors&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">koa</span>()<br><br>app.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-title function_\">cors</span>())<br><br>app.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3001</span>)<br></code></pre></td></tr></table></figure>\n\n<p>或者自己写一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">app.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-title function_\">async</span> (ctx, next)=&gt; &#123;<br>  ctx.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class=\"hljs-string\">&#x27;*&#x27;</span>);<br>  ctx.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class=\"hljs-string\">&#x27;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#x27;</span>);<br>  ctx.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class=\"hljs-string\">&#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;</span>);<br>  <span class=\"hljs-keyword\">if</span> (ctx.<span class=\"hljs-property\">method</span> == <span class=\"hljs-string\">&#x27;OPTIONS&#x27;</span>) &#123;<br>    ctx.<span class=\"hljs-property\">body</span> = <span class=\"hljs-number\">200</span>; <br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">next</span>();<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-4-nginx-反向代理配置\"><a href=\"#3-4-nginx-反向代理配置\" class=\"headerlink\" title=\"3.4 nginx 反向代理配置\"></a>3.4 nginx 反向代理配置</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">#proxy服务器<br>server &#123;<br>    listen       <span class=\"hljs-number\">81</span>;<br>    server_name  www.<span class=\"hljs-property\">domain1</span>.<span class=\"hljs-property\">com</span>;<br><br>    location / &#123;<br>        proxy_pass   <span class=\"hljs-attr\">http</span>:<span class=\"hljs-comment\">//www.domain2.com:8080;  #反向代理</span><br>        proxy_cookie_domain www.<span class=\"hljs-property\">domain2</span>.<span class=\"hljs-property\">com</span> www.<span class=\"hljs-property\">domain1</span>.<span class=\"hljs-property\">com</span>; #修改cookie里域名<br>        index  index.<span class=\"hljs-property\">html</span> index.<span class=\"hljs-property\">htm</span>;<br><br>        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用<br>        add_header <span class=\"hljs-title class_\">Access</span>-<span class=\"hljs-title class_\">Control</span>-<span class=\"hljs-title class_\">Allow</span>-<span class=\"hljs-title class_\">Origin</span> <span class=\"hljs-attr\">http</span>:<span class=\"hljs-comment\">//www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br>        add_header <span class=\"hljs-title class_\">Access</span>-<span class=\"hljs-title class_\">Control</span>-<span class=\"hljs-title class_\">Allow</span>-<span class=\"hljs-title class_\">Credentials</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"wordcount":5795,"excerpt":"","more":"<blockquote>\n<p>跨域这个问题还是比较常见的，下面我们来讨论一下几种解决跨域的办法</p>\n</blockquote>\n<h3 id=\"HTTP中的请求方法\"><a href=\"#HTTP中的请求方法\" class=\"headerlink\" title=\"HTTP中的请求方法\"></a>HTTP中的请求方法</h3><p><strong>HTTP/1.1协议定义了八种方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>是否包含主体</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GET</td>\n<td>请求指定的页面，并返回实体主体</td>\n<td>否</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>向服务器发送带要处理的数据</td>\n<td>是</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>从服务器上删除一份文档</td>\n<td>否</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>将请求的主体部分存储在服务器上</td>\n<td>是</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>只从服务器获取文档的首部</td>\n<td>否</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>决定可以在服务器上执行哪些方法</td>\n<td>否</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>对可能经过代理服务器传送到服务器上去的报文进行追踪</td>\n<td>否</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td>\n<td>否</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-什么是跨域\"><a href=\"#1-什么是跨域\" class=\"headerlink\" title=\"1. 什么是跨域\"></a>1. 什么是跨域</h3><p>在我们向一个接口发送请求的时候，也就是你的==请求的url==的<strong>协议</strong>、<strong>域名</strong></p>\n<p>、<strong>端口</strong>三者之间任意一个与当前页面的url不同就是  <strong>跨域</strong></p>\n<table>\n<thead>\n<tr>\n<th>当前页面</th>\n<th>被请求页面</th>\n<th>是否跨域</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"http://localhost/\">http://localhost</a></td>\n<td><a href=\"https://localhost/\">https://localhost</a></td>\n<td>是</td>\n<td>协议不同，一个是http协议，一个是https协议</td>\n</tr>\n<tr>\n<td><a href=\"http://localhsot/\">http://localhsot</a></td>\n<td><a href=\"http://www.baidu.com/\">http://www.baidu.com</a></td>\n<td>是</td>\n<td>域名不同</td>\n</tr>\n<tr>\n<td><a href=\"http://localhost:3000/\">http://localhost:3000</a></td>\n<td><a href=\"http://localhost:8080/\">http://localhost:8080</a></td>\n<td>是</td>\n<td>端口号不同</td>\n</tr>\n<tr>\n<td><a href=\"http://localhsot/index.html\">http://localhsot/index.html</a></td>\n<td><a href=\"http://localhost/\">http://localhost</a></td>\n<td>否</td>\n<td>同源</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-为什么会产生跨域\"><a href=\"#2-为什么会产生跨域\" class=\"headerlink\" title=\"2.为什么会产生跨域\"></a>2.为什么会产生跨域</h3><p>跨域是出于浏览器的同源策略限制，<strong>同源策略</strong>是一个重要的安全策略，它能够帮助阻隔恶意文档，减少可能被攻击的媒介</p>\n<blockquote>\n<p>服务端响应数据返回给浏览器的时候，浏览器根据响应头的Access-Control-Allow-Origin字段的值来判断是否有权限获取数据</p>\n</blockquote>\n<h3 id=\"3-跨域请求的分类\"><a href=\"#3-跨域请求的分类\" class=\"headerlink\" title=\"3.跨域请求的分类\"></a>3.跨域请求的分类</h3><p>下面是在阮一峰博客摘抄的，详情可见<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">跨域资源共享 CORS 详解 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>\n<blockquote>\n<p>什么是域呢？</p>\n<p>Origin 表示本域，也就是浏览器当前页面的域，当JavaScript向外域（如sina.com）<br>发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，<br>如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p>\n<p>假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为<a href=\"http://my.com,或者是*,本次请求就可以成功./\">http://my.com，或者是*，本次请求就可以成功。</a></p>\n<p>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。</p>\n</blockquote>\n<p><strong>两种请求</strong>(简单请求和复杂请求)</p>\n<h4 id=\"3-1-简单请求\"><a href=\"#3-1-简单请求\" class=\"headerlink\" title=\"3.1 简单请求\"></a>3.1 简单请求</h4><p>只要同时满足以下两个条件的就是简单请求</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\">1.请求方法是以下三种方法之一：<br>   -HEAD<br>   -GET<br>   -POST<br>2.HTPTP的头信息不超过以下几种字段<br>   -Accept<br>   -Accept-Language<br>   -Content-Language<br>   -Last-Event-ID<br>   -Content-Type: 只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain<br></code></pre></td></tr></table></figure>\n\n<p>对于简单请求，浏览器会直接发送CORS请求，也就是在头信息中增加一个==Origin==字段</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-keyword\">GET</span> <span class=\"hljs-string\">/cors</span> <span class=\"hljs-meta\">HTTP/1.1</span><br><span class=\"hljs-attribute\">Origin</span><span class=\"hljs-punctuation\">: </span>http://api.bob.com<br><span class=\"hljs-attribute\">Host</span><span class=\"hljs-punctuation\">: </span>api.alice.com<br><span class=\"hljs-attribute\">Accept-Language</span><span class=\"hljs-punctuation\">: </span>en-US<br><span class=\"hljs-attribute\">Connection</span><span class=\"hljs-punctuation\">: </span>keep-alive<br><span class=\"hljs-attribute\">User-Agent</span><span class=\"hljs-punctuation\">: </span>Mozilla/5.0...<br></code></pre></td></tr></table></figure>\n\n<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>\n<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>\n<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>\n<blockquote>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-attribute\">Access-Control-Allow-Origin</span><span class=\"hljs-punctuation\">: </span>http://api.bob.com<br><span class=\"hljs-attribute\">Access-Control-Allow-Credentials</span><span class=\"hljs-punctuation\">: </span>true<br><span class=\"hljs-attribute\">Access-Control-Expose-Headers</span><span class=\"hljs-punctuation\">: </span>FooBar<br><span class=\"hljs-attribute\">Content-Type</span><span class=\"hljs-punctuation\">: </span>text/html; charset=utf-8<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p>\n<p><strong>（1）Access-Control-Allow-Origin</strong></p>\n<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>\n<p><strong>（2）Access-Control-Allow-Credentials</strong></p>\n<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>\n<p><strong>（3）Access-Control-Expose-Headers</strong></p>\n<p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>\n<h4 id=\"3-2-withCredentials-属性\"><a href=\"#3-2-withCredentials-属性\" class=\"headerlink\" title=\"3.2 withCredentials 属性\"></a>3.2 withCredentials 属性</h4><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>\n<blockquote>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-attribute\">Access-Control-Allow-Credentials</span><span class=\"hljs-punctuation\">: </span>true<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p>\n<blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">XMLHttpRequest</span>();<br>xhr.<span class=\"hljs-property\">withCredentials</span> = <span class=\"hljs-literal\">true</span>;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>\n<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>\n<blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">xhr.<span class=\"hljs-property\">withCredentials</span> = <span class=\"hljs-literal\">false</span>;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>\n<h4 id=\"3-3复杂请求\"><a href=\"#3-3复杂请求\" class=\"headerlink\" title=\"3.3复杂请求\"></a>3.3复杂请求</h4><p>简单请求是直接发送的，而复杂请求会在实际请求之前发送一个==预检请求(preflight)==预检请求通过访问控制检查后才会发送需要的请求。</p>\n<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。 </p>\n<p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p>\n<blockquote>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-keyword\">OPTIONS</span> <span class=\"hljs-string\">/cors</span> <span class=\"hljs-meta\">HTTP/1.1</span><br><span class=\"hljs-attribute\">Origin</span><span class=\"hljs-punctuation\">: </span>http://api.bob.com<br><span class=\"hljs-attribute\">Access-Control-Request-Method</span><span class=\"hljs-punctuation\">: </span>PUT<br><span class=\"hljs-attribute\">Access-Control-Request-Headers</span><span class=\"hljs-punctuation\">: </span>X-Custom-Header<br><span class=\"hljs-attribute\">Host</span><span class=\"hljs-punctuation\">: </span>api.alice.com<br><span class=\"hljs-attribute\">Accept-Language</span><span class=\"hljs-punctuation\">: </span>en-US<br><span class=\"hljs-attribute\">Connection</span><span class=\"hljs-punctuation\">: </span>keep-alive<br><span class=\"hljs-attribute\">User-Agent</span><span class=\"hljs-punctuation\">: </span>Mozilla/5.0...<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>预检请求的方法是==OPTIONS==</p>\n<h3 id=\"4-解决跨域问题\"><a href=\"#4-解决跨域问题\" class=\"headerlink\" title=\"4.解决跨域问题\"></a>4.解决跨域问题</h3><ol>\n<li>JSONP</li>\n</ol>\n<p>​    利用的是 ==script== 标签可以任意跨域，这样子的标签还有 ==img== ==link==,    </p>\n<p>​    优点是兼容性特别好，但是只能发送<strong>GET</strong>请求，就是在请求的url中添加一个回调函数，并通过这个回调函数把数据发送给前端</p>\n<p>实现：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span> = <span class=\"hljs-string\">&quot;http://localhost:3000?test&quot;</span>&gt;</span><span class=\"language-handlebars\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">srcipt</span>&gt;</span></span></span><br><span class=\"language-xml\"><span class=\"language-handlebars\"></span></span><br><span class=\"language-xml\"><span class=\"language-handlebars\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"language-handlebars\">    <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\">res</span>)&#123;</span></span></span><br><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"language-handlebars\">\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res)</span></span></span><br><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"language-handlebars\">    &#125;</span></span></span><br><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"language-handlebars\"></span></span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n\n\n<ol start=\"2\">\n<li>CORS</li>\n</ol>\n<p>​    整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通    信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自    动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>\n<p>​    因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信</p>\n<p>​    ==Access-Control-Allow-Origin: *==</p>\n<blockquote>\n<p><strong>跨源资源共享</strong> (<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/CORS\">CORS</a>) （或通俗地译为跨域资源共享）是一种基于<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP\">HTTP</a> 头的机制，该机制通过允许服务器标示除了它自己以外的其它<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Origin\">origin</a>（域，协议和端口），这样浏览器可以访问加载这些资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的”预检”请求。在预检中，浏览器发送的头中标示有HTTP方法和真实请求中会用到的头。</p>\n</blockquote>\n<ol start=\"3\">\n<li>代理转发</li>\n</ol>\n<p>​    因为跨域这个是浏览器才有的，所以在用服务器向另一个服务器请求数据的时候，就不会产生跨域这个问题了</p>\n<p>​    nginx反向代理</p>\n<p>​    vue-cli 配置代理</p>\n<p>​    浏览器插件解决跨域</p>\n<h4 id=\"3-1-vue-cli\"><a href=\"#3-1-vue-cli\" class=\"headerlink\" title=\"3.1 vue-cli\"></a>3.1 vue-cli</h4><p>只能用于开发环境，等项目上线的时候还是需要服务端配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>    <span class=\"hljs-attr\">entry</span>: &#123;&#125;,<br>    <span class=\"hljs-attr\">module</span>: &#123;&#125;,<br>    ...<br>    <span class=\"hljs-attr\">devServer</span>: &#123;<br>        <span class=\"hljs-attr\">historyApiFallback</span>: <span class=\"hljs-literal\">true</span>,<br>        <span class=\"hljs-attr\">proxy</span>: [&#123;<br>            <span class=\"hljs-attr\">context</span>: <span class=\"hljs-string\">&#x27;/login&#x27;</span>,<br>            <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&#x27;http://www.domain2.com:8080&#x27;</span>,  <span class=\"hljs-comment\">// 代理跨域目标接口</span><br>            <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,<br>            <span class=\"hljs-attr\">secure</span>: <span class=\"hljs-literal\">false</span>,  <span class=\"hljs-comment\">// 当代理某些https服务报错时用</span><br>            <span class=\"hljs-attr\">cookieDomainRewrite</span>: <span class=\"hljs-string\">&#x27;www.domain1.com&#x27;</span>  <span class=\"hljs-comment\">// 可以为false，表示不修改</span><br>        &#125;],<br>        <span class=\"hljs-attr\">noInfo</span>: <span class=\"hljs-literal\">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-浏览器插件\"><a href=\"#3-2-浏览器插件\" class=\"headerlink\" title=\"3.2 浏览器插件\"></a>3.2 浏览器插件</h4><p>只能用于开发环境，等项目上线的时候还是需要服务端配置</p>\n<p>可以在谷歌商店搜索 ==Allow CORS: Access-Control-Allow-Origin===</p>\n<h4 id=\"3-3-node-中间件\"><a href=\"#3-3-node-中间件\" class=\"headerlink\" title=\"3.3 node 中间件\"></a>3.3 node 中间件</h4><p>这里使用 koa2 框架，只需要下载一个==koa2-cors==即可</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> koa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> cors = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa2-cors&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">koa</span>()<br><br>app.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-title function_\">cors</span>())<br><br>app.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3001</span>)<br></code></pre></td></tr></table></figure>\n\n<p>或者自己写一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">app.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-title function_\">async</span> (ctx, next)=&gt; &#123;<br>  ctx.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class=\"hljs-string\">&#x27;*&#x27;</span>);<br>  ctx.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class=\"hljs-string\">&#x27;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#x27;</span>);<br>  ctx.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class=\"hljs-string\">&#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;</span>);<br>  <span class=\"hljs-keyword\">if</span> (ctx.<span class=\"hljs-property\">method</span> == <span class=\"hljs-string\">&#x27;OPTIONS&#x27;</span>) &#123;<br>    ctx.<span class=\"hljs-property\">body</span> = <span class=\"hljs-number\">200</span>; <br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">next</span>();<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-4-nginx-反向代理配置\"><a href=\"#3-4-nginx-反向代理配置\" class=\"headerlink\" title=\"3.4 nginx 反向代理配置\"></a>3.4 nginx 反向代理配置</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">#proxy服务器<br>server &#123;<br>    listen       <span class=\"hljs-number\">81</span>;<br>    server_name  www.<span class=\"hljs-property\">domain1</span>.<span class=\"hljs-property\">com</span>;<br><br>    location / &#123;<br>        proxy_pass   <span class=\"hljs-attr\">http</span>:<span class=\"hljs-comment\">//www.domain2.com:8080;  #反向代理</span><br>        proxy_cookie_domain www.<span class=\"hljs-property\">domain2</span>.<span class=\"hljs-property\">com</span> www.<span class=\"hljs-property\">domain1</span>.<span class=\"hljs-property\">com</span>; #修改cookie里域名<br>        index  index.<span class=\"hljs-property\">html</span> index.<span class=\"hljs-property\">htm</span>;<br><br>        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用<br>        add_header <span class=\"hljs-title class_\">Access</span>-<span class=\"hljs-title class_\">Control</span>-<span class=\"hljs-title class_\">Allow</span>-<span class=\"hljs-title class_\">Origin</span> <span class=\"hljs-attr\">http</span>:<span class=\"hljs-comment\">//www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br>        add_header <span class=\"hljs-title class_\">Access</span>-<span class=\"hljs-title class_\">Control</span>-<span class=\"hljs-title class_\">Allow</span>-<span class=\"hljs-title class_\">Credentials</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"面试题","date":"2023-02-22T14:29:35.000Z","index_img":"/img/spider.jpg","banner_img":null,"_content":"\n### 1.HTML\n\n##### 1.src 和 href 的区别\n\nsrc 和 href 都是**用来引用外部的资源**，它们的区别如下：\n\n- **src：** 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src 会将其指向的资源下载并应⽤到⽂档内，如请求 js 脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般 js 脚本会放在页面底部。\n\n- **href：** 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在 a、link 等标签上。\n\n##### 2.对 HTML 语义化的理解\n\n**语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）**。通俗来讲就是用正确的标签做正确的事情。\n\n语义化的优点如下：\n\n（1） 用正确的标签做正确的事情。\n（2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;\n（3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;\n（4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;\n（5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n\n常用的语义化标签：\n\n```html\n<header></header>\n头部\n<section></section>\n区块(有语义化的div)\n<main></main>\n主要区域\n<nav></nav>\n导航栏\n<aside></aside>\n侧边栏\n<footer></footer>\n底部\n```\n\n##### 3.DOCTYPE(文档类型)的作用\n\nDOCTYPE 是 HTML5 中一种标准通用标记语言的文档类型声明，它的目的是**告诉浏览器（解析器）应该以什么样（html 或 xhtml）的文档类型定义来解析文档**，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在 HTML ⽂档的第⼀⾏。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。\n\n##### 4.script 标签中的 defer 和 async 的区别\n\n如果没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。\n\n下图可以直观的看出三者之间的区别: ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0a8a139519f46dfa2d1992c58eb5397~tplv-k3u1fbpfcp-watermark.awebp) 其中蓝色代表 js 脚本网络加载时间，红色代表 js 脚本执行时间，绿色代表 html 解析。\n\n**defer 和 async 属性都是去异步加载外部的 JS 脚本文件，它们都不会阻塞页面的解析**，其区别如下：\n\n- **执行顺序：** 多个带 async 属性的标签，不能保证加载的顺序；多个带 defer 属性的标签，按照加载顺序执行；\n- **脚本是否并行执行：\\*\\*async 属性，表示\\*\\*后续文档的加载和执行与 js 脚本的加载和执行是并行进行的**，即异步执行；defer 属性，加载后续文档的过程和 js 脚本的加载(此时仅加载不执行)是并行进行的(异步)，js 脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded 事件触发执行之前。\n\n##### 5.常用的 meta 标签\n\n`meta` 标签由 `name` 和 `content` 属性定义，**用来描述网页文档的属性**，比如网页的作者，网页描述，关键词等，除了 HTTP 标准固定了一些`name`作为大家使用的共识，开发者还可以自定义 name。\n\n常用的 meta 标签：\n\n（1）`charset`，用来描述 HTML 文档的编码类型：\n\n```html\n<meta charset=\"UTF-8\" />\n```\n\n（2） `keywords`，页面关键词：\n\n```html\n<meta name=\"keywords\" content=\"关键词\" />\n```\n\n（3）`description`，页面描述：\n\n```html\n<meta name=\"description\" content=\"页面描述内容\" />\n```\n\n（4）`refresh`，页面重定向和刷新：\n\n```html\n<meta http-equiv=\"refresh\" content=\"0;url=\" />\n```\n\n（5）`viewport`，适配移动端，可以控制视口的大小和比例：\n\n```html\n<meta\n  name=\"viewport\"\n  content=\"width=device-width, initial-scale=1, maximum-scale=1\"\n/>\n```\n\n其中，`content` 参数有以下几种：\n\n- `width viewport` ：宽度(数值/device-width)\n- `height viewport` ：高度(数值/device-height)\n- `initial-scale` ：初始缩放比例\n- `maximum-scale` ：最大缩放比例\n- `minimum-scale` ：最小缩放比例\n- `user-scalable` ：是否允许用户缩放(yes/no）\n\n（6）搜索引擎索引方式：\n\n```html\n<meta name=\"robots\" content=\"index,follow\" />\n```\n\n其中，`content` 参数有以下几种：\n\n- `all`：文件将被检索，且页面上的链接可以被查询；\n- `none`：文件将不被检索，且页面上的链接不可以被查询；\n- `index`：文件将被检索；\n- `follow`：页面上的链接可以被查询；\n- `noindex`：文件将不被检索；\n- `nofollow`：页面上的链接不可以被查询。\n\n##### 6.HTML5 有哪些更新\n\n1. 语义化标签\n2. 媒体标签\n3. 表单\n4. 进度条、度量器\n\n- progress 标签： 用来表示任务的进度，有 max 和 value 属性\n\n```html\n<progress max=\"100\" value=\"20\"></progress>\n```\n\n5. DOM 查询操作\n\n- document.queryselector()\n- document.queryselectorAll()\n\n6. web 存储\n\n- localStorage 永久存储在浏览器中\n- sessionStorage 随着浏览器的关闭而清空\n\n7. 其他\n\n- 拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置\n\n```html\n<img draggable=\"true\" />\n```\n\n- 画布 canvas\n- SVG\n\n##### 7.img 的 srcset 属性的作用\n\n响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的 srcset 属性。srcset 属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：\n\n```html\n<img src=\"image-128.png\" srcset=\"image-256.png 2x\" />\n```\n\n使用上面的代码，就能实现在屏幕密度为 1x 的情况下加载 image-128.png, 屏幕密度为 2x 时加载 image-256.png。\n\n按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有 1x,2x,3x,4x 四种，如果每一个图片都设置 4 张图片，加载就会很慢。所以就有了新的 srcset 标准。代码如下：\n\n```html\n<img\n  src=\"image-128.png\"\n  srcset=\"image-128.png 128w, image-256.png 256w, image-512.png 512w\"\n  sizes=\"(max-width: 360px) 340px, 128px\"\n/>\n```\n\n其中 srcset 指定图片的地址和对应的图片质量。sizes 用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。\n\nsizes 语法如下：\n\n```html\nsizes=\"[media query] [length], [media query] [length] \"\n```\n\nsizes 就是指默认显示 128px, 如果视区宽度小于 360px, 则显示 340px。\n\n##### 8.行内元素有哪些？块级元素有哪些？空（void）元素有哪些？\n\n- 行内元素：**span a img input a b strong select**\n- 块级元素：**div h1 ul ol li dl dt dd p **\n- 空元素： \\<br> \\ <hr> \\ <input> \\<img> \\ <meta> \\\n\n空元素就是那些没有内容的标签,也没有闭合标签\n\n##### 9.说一说 web worker\n\n在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。\n\n##### 10.HTML5 的离线储存怎么使用，它的工作原理是什么？\n\n离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n\n**原理：**HTML5 的离线存储是基于一个新建的 `.appcache` 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n\n**使用方法：** （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：\n\n```html\n<html lang=\"en\" manifest=\"index.manifest\">\n  复制代码\n</html>\n```\n\n（2）在 `cache.manifest` 文件中编写需要离线存储的资源：\n\n```html\nCACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png\nFALLBACK: / /offline.html 复制代码\n```\n\n- **CACHE**: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。\n- **NETWORK**: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。\n- **FALLBACK**: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。\n\n（3）在离线状态时，操作 `window.applicationCache` 进行离线缓存的操作。\n\n**如何更新缓存：**\n\n（1）更新 manifest 文件\n\n（2）通过 javascript 操作\n\n（3）清除浏览器缓存\n\n**注意事项：**\n\n（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。\n\n（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。\n\n（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。\n\n（4）FALLBACK 中的资源必须和 manifest 文件同源。\n\n（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。\n\n（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。\n\n（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。\n\n##### 11.title 与 h1 的区别、b 与 strong 的区别，i 与 em 的区别\n\n- strong 标签有语义，是起到加重语气的效果，而 b 标签是没有的，b 标签只是一个简单加粗标签。b 标签之间的字符都设为粗体，strong 标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重 strong 标签。\n\n- title 属性没有明确意义只表示是个标题，H1 则表示层次明确的标题，对页面信息的抓取有很大的影响\n\n- **i 内容展示为斜体，em 表示强调的文本**\n\n##### 12.浏览器乱码的原因是什么？如何解决？\n\n**产生乱码的原因**：\n\n- 网页源代码是==gbk==的编码，而内容中的中文字是==utf-8==编码的，这样子浏览器打开即会出现==html==乱码，反之也会出现乱码\n- ==html==网页编码是==gbk==，而程序从数据库中调出呈现是==utf-8==编码的内容也会造成编码乱码\n- 浏览器不能自动检测网页编码，造成网页乱码\n\n##### 13.页面导入样式时，使用 link 和@import 有什么区别\n\n1. 兼容问题 ： link 是 HTML 提供的标签，不仅可以加 载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等，不存在兼容问题，而@import 是 CSS 提供的语法规则，在 IE5+才可以识别\n2. 加载顺序区别：link 会和页面并行加载，而@import 会等页面加载完成再进行加载\n3. DOM 可控性区别：可以通过 JS 操作 DOM，插入 link 标签来改变样式，由于 DOM 是基于文档的，无法使用@import 的方式插入样式\n\n##### 14.标准模式与兼容模式有什么区别\n\n标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作\n\n##### 15.渲染页面时常见哪些不良现象\n\n- FOUC：主要指的是样式闪烁问题，由于浏览器渲染机制（比如 firefox），在 css 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要就是 css 加载时间过长，或者 css 被放在了文档底部\n- 白屏： 有些浏览器渲染机制(比如 chrome)要先构建 DOM 树和 CSSOM 树，构建完成之后再进行渲染，如果 css 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏，也可能是把 js 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题\n\n##### 16.什么是重绘和重排（回流）\n\n重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们称这样的操作为 重绘\n\n重排： 当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为 回流\n\n常见引起回流属性和方法：\n\n任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。\n\n（1）添加或者删除可见的 DOM 元素；\n（2）元素尺寸改变——边距、填充、边框、宽度和高度\n（3）内容变化，比如用户在 input 框中输入文字\n（4）浏览器窗口尺寸改变——resize 事件发生时\n（5）计算 offsetWidth 和 offsetHeight 属性\n（6）设置 style 属性的值\n（7）当你修改网页的默认字体时。\n\n回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列\n回流。\n\n##### 17.为什么操作 ODM 慢\n\n一些 DOM 的操作或属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗\n\n##### 18.前端需要注意哪些 SEO\n\n（1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超\n过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不\n同页面 description 有所不同；keywords 列举出重要关键词即可。\n\n（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。\n\n（3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被\n抓取。\n\n（4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容\n\n（5）少用 iframe：搜索引擎不会抓取 iframe 中的内容\n\n（6）非装饰性图片必须加 alt\n\n（7）提高网站速度：网站速度是搜索引擎排序的一个重要指标\n\n##### 19.页面可见性(Page Visibility API) 可以有哪些用途\n\n这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户\n不看网页，下面这些网页行为都是可以暂停的。\n\n（1）对服务器的轮询\n（2）网页动画\n（3）正在播放的音频或视频\n\n详细资料可以参考： [《Page Visibility API 教程》](http://www.ruanyifeng.com/blog/2018/10/page_visibility_api.html)\n\n##### 20. <img> 的 title 和 alt 有什么区别\n\ntitle 通常是当鼠标滑到元素上的时候显示\n\nalt 是 <img> 的特有的属性，是图片内容的等价描述，用于图片无法加载时显示，读屏器阅读图片。可提高图片可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析\n\n##### 21.常用的 meat 标签\n\n```html\n<meta />\n元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。\n<meta /> 标签位于文档的头部，不包含任何内容。<meta />\n标签的属性定义了与文档相关联的名称/值对。\n\n<!DOCTYPE html> H5标准声明，使用 HTML5 doctype，不区分大小写\n<head lang=\"en\">\n  标准的 lang 属性写法\n  <meta charset=\"utf-8\" />\n  声明文档使用的字符编码\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  优先使用 IE 最新版本和 Chrome\n  <meta name=\"description\" content=\"不超过150个字符\" />\n  页面描述\n  <meta name=\"keywords\" content=\"\" />\n  页面关键词者\n  <meta name=\"author\" content=\"name, email@gmail.com\" />\n  网页作\n  <meta name=\"robots\" content=\"index,follow\" />\n  搜索引擎抓取\n  <meta\n    name=\"viewport\"\n    content=\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"\n  />\n  为移动设备添加 viewport\n  <meta name=\"apple-mobile-web-app-title\" content=\"标题\" />\n  iOS 设备 begin\n  <meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n  添加到主屏后的标题（iOS 6 新增） 是否启用 WebApp\n  全屏模式，删除苹果默认的工具栏和菜单栏\n  <meta\n    name=\"apple-itunes-app\"\n    content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\"\n  />\n  添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）\n  <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n  <meta name=\"format-detection\" content=\"telphone=no, email=no\" />\n  设置苹果工具栏颜色\n  <meta name=\"renderer\" content=\"webkit\" />\n  启用360浏览器的极速模式(webkit)\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n  避免IE使用兼容模式\n  <meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" />\n  不让百度转码\n  <meta name=\"HandheldFriendly\" content=\"true\" />\n  针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓\n  <meta name=\"MobileOptimized\" content=\"320\" />\n  微软的老式浏览器\n  <meta name=\"screen-orientation\" content=\"portrait\" />\n  uc强制竖屏\n  <meta name=\"x5-orientation\" content=\"portrait\" />\n  QQ强制竖屏\n  <meta name=\"full-screen\" content=\"yes\" />\n  UC强制全屏\n  <meta name=\"x5-fullscreen\" content=\"true\" />\n  QQ强制全屏\n  <meta name=\"browsermode\" content=\"application\" />\n  UC应用模式\n  <meta name=\"x5-page-mode\" content=\"app\" />\n  QQ应用模式\n  <meta name=\"msapplication-tap-highlight\" content=\"no\" />\n  windows phone 点击无高光 设置页面不缓存\n  <meta http-equiv=\"pragma\" content=\"no-cache\" />\n  <meta http-equiv=\"cache-control\" content=\"no-cache\" />\n  <meta http-equiv=\"expires\" content=\"0\" />\n</head>\n```\n\n详细资料可以参考： [《Meta 标签用法大全》](http://www.cnblogs.com/qiumohanyu/p/5431859.html)\n\n##### 22.主流浏览器内核私有属性 css 前缀\n\nmozilla 内核 （firefox,flock 等） -moz\nwebkit 内核 （safari,chrome 等） -webkit\nopera 内核 （opera 浏览器） -o\ntrident 内核 （ie 浏览器） -ms\n\n##### 23.HTML 规范中为什么要求引用资源不加协议头 http 或者 https\n\n如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现\n警告信息，不同浏览器警告信息展现形式不同。\n\n为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为\nprotocol-relative URL，暂且可译作协议相对 URL。\n\n如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似\n的警告信息，同时还可以节省 5 字节的数据量。\n\n##### sub 和 sup 标签\n\n<sub></sub>用来表示下标 H<sub>2</sub>o 像这个样子\n\n<sup></sup>用来表示上标 3<sup>2</sup>\n\n---\n\n### 2.CSS\n\n##### 1.介绍一下标准的 CSS 的盒子模型？低版本的浏览器盒子模型有什么不同\n\n盒模型都是由四个部分组成的，分别是 margin、border、padding 和 content。\n\n标准盒模型和 IE 盒模型的区别在于设置 width 和 height 时，所对应的范围不同。标准盒模型的 width 和 height 属性的\n范围只包含了 content，而 IE 盒模型的 width 和 height 属性的范围包含了 border、padding 和 content。\n\n一般来说，我们可以通过修改元素的 box-sizing 属性来改变元素的盒模型。\n\n##### 2.css 选择器有哪些\n\n| **选择器**     | **格式**      |\n| -------------- | ------------- |\n| id 选择器      | #id           |\n| 类选择器       | .classname    |\n| 属性选择器     | a[ref=“eee”]  |\n| 伪类选择器     | li:last-child |\n| 标签选择器     | div           |\n| 伪元素选择器   | li::after     |\n| 兄弟选择器     | li~a          |\n| 相邻兄弟选择器 | h1+p          |\n| 子选择器       | ul>li         |\n| 后代选择器     | li a          |\n| 通配符选择器   | \\*            |\n\n##### 3.::before 和 :after 中双冒号和单冒号的区别\n\n在 css3 中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号\n来表示伪元素。\n\n伪类一般匹配的是元素的一些特殊状态，如 hover、link 等，而伪元素一般匹配的特殊的位置，比如 after、before 等。\n\n##### 4.伪类与伪元素的区别\n\ncss 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句\n话中的第一个字母，或者是列表中的第一个元素。\n\n伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的\n元素时，我们可以通过:hover 来描述这个元素的状态。\n\n伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::be\nfore 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。\n\n有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是 CSS3 的一部分，并尝试区分伪类和伪元素。大多数浏览\n器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的 W3C 规范并未对此进行\n特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。\n\ncss 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。\n\n> 如何对伪元素进行操作？\n\n**伪类** 用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover 来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 dom 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。\n\n**伪元素** 譬如::before 和::after 伪元素，用于在 CSS 渲染中向元素的头部或尾部插入内容，它们不受文档约束，也不影响文档本身，只影响最终样式。这些添加的内容不会出现在 DOM 中，仅仅是在 CSS 渲染层中加入。它不存在于文档中，所以 JS 无法直接操作它。而 jQuery 的选择器都是基于 DOM 元素的，因此也并不能直接操作伪元素。那该怎样操作伪元素的样式呢？为此总结整理一篇，以备查用。\n\n## 有哪些伪元素\n\n:first-letter：向文本的第一个字母添加特殊样式。\n\n:first-line:　向文本的首行添加特殊样式。\n\n:before：在元素之前添加内容。\n\n:after：在元素之后添加内容。\n\n::placeholder：匹配占位符的文本，只有元素设置了 placeholder 属性时，该伪元素才能生效。\n\n::selection：CSS 伪元素应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）\n\n::backdrop(处于试验阶段)：用于改变全屏模式下的背景颜色，全屏模式的默认颜色为黑色。该伪元素只支持双冒号的形式\n\n## 获取伪元素的属性值\n\n获取伪元素的属性值可以使用 window.getComputedStyle()方法，获取伪元素的 CSS 样式声明对象。然后利用 getPropertyValue 方法或直接使用键值访问都可以获取对应的属性值。\n\n**语法：** window.getComputedStyle(element[, pseudoElement])\n\n**参数：**element（Object）：伪元素的所在的 DOM 元素；pseudoElement（String）：伪元素类型。可选值有：”:after”、”:before”、”:first-line”、”:first-letter”、”:selection”、”:backdrop”；\n","source":"_posts/前端.md","raw":"---\ntitle: 面试题\ndate: 2023-2-22 22:29:35\ntags: 前端\nindex_img: /img/spider.jpg\nbanner_img:\n---\n\n### 1.HTML\n\n##### 1.src 和 href 的区别\n\nsrc 和 href 都是**用来引用外部的资源**，它们的区别如下：\n\n- **src：** 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src 会将其指向的资源下载并应⽤到⽂档内，如请求 js 脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般 js 脚本会放在页面底部。\n\n- **href：** 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在 a、link 等标签上。\n\n##### 2.对 HTML 语义化的理解\n\n**语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）**。通俗来讲就是用正确的标签做正确的事情。\n\n语义化的优点如下：\n\n（1） 用正确的标签做正确的事情。\n（2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;\n（3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;\n（4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;\n（5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n\n常用的语义化标签：\n\n```html\n<header></header>\n头部\n<section></section>\n区块(有语义化的div)\n<main></main>\n主要区域\n<nav></nav>\n导航栏\n<aside></aside>\n侧边栏\n<footer></footer>\n底部\n```\n\n##### 3.DOCTYPE(文档类型)的作用\n\nDOCTYPE 是 HTML5 中一种标准通用标记语言的文档类型声明，它的目的是**告诉浏览器（解析器）应该以什么样（html 或 xhtml）的文档类型定义来解析文档**，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在 HTML ⽂档的第⼀⾏。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。\n\n##### 4.script 标签中的 defer 和 async 的区别\n\n如果没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。\n\n下图可以直观的看出三者之间的区别: ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0a8a139519f46dfa2d1992c58eb5397~tplv-k3u1fbpfcp-watermark.awebp) 其中蓝色代表 js 脚本网络加载时间，红色代表 js 脚本执行时间，绿色代表 html 解析。\n\n**defer 和 async 属性都是去异步加载外部的 JS 脚本文件，它们都不会阻塞页面的解析**，其区别如下：\n\n- **执行顺序：** 多个带 async 属性的标签，不能保证加载的顺序；多个带 defer 属性的标签，按照加载顺序执行；\n- **脚本是否并行执行：\\*\\*async 属性，表示\\*\\*后续文档的加载和执行与 js 脚本的加载和执行是并行进行的**，即异步执行；defer 属性，加载后续文档的过程和 js 脚本的加载(此时仅加载不执行)是并行进行的(异步)，js 脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded 事件触发执行之前。\n\n##### 5.常用的 meta 标签\n\n`meta` 标签由 `name` 和 `content` 属性定义，**用来描述网页文档的属性**，比如网页的作者，网页描述，关键词等，除了 HTTP 标准固定了一些`name`作为大家使用的共识，开发者还可以自定义 name。\n\n常用的 meta 标签：\n\n（1）`charset`，用来描述 HTML 文档的编码类型：\n\n```html\n<meta charset=\"UTF-8\" />\n```\n\n（2） `keywords`，页面关键词：\n\n```html\n<meta name=\"keywords\" content=\"关键词\" />\n```\n\n（3）`description`，页面描述：\n\n```html\n<meta name=\"description\" content=\"页面描述内容\" />\n```\n\n（4）`refresh`，页面重定向和刷新：\n\n```html\n<meta http-equiv=\"refresh\" content=\"0;url=\" />\n```\n\n（5）`viewport`，适配移动端，可以控制视口的大小和比例：\n\n```html\n<meta\n  name=\"viewport\"\n  content=\"width=device-width, initial-scale=1, maximum-scale=1\"\n/>\n```\n\n其中，`content` 参数有以下几种：\n\n- `width viewport` ：宽度(数值/device-width)\n- `height viewport` ：高度(数值/device-height)\n- `initial-scale` ：初始缩放比例\n- `maximum-scale` ：最大缩放比例\n- `minimum-scale` ：最小缩放比例\n- `user-scalable` ：是否允许用户缩放(yes/no）\n\n（6）搜索引擎索引方式：\n\n```html\n<meta name=\"robots\" content=\"index,follow\" />\n```\n\n其中，`content` 参数有以下几种：\n\n- `all`：文件将被检索，且页面上的链接可以被查询；\n- `none`：文件将不被检索，且页面上的链接不可以被查询；\n- `index`：文件将被检索；\n- `follow`：页面上的链接可以被查询；\n- `noindex`：文件将不被检索；\n- `nofollow`：页面上的链接不可以被查询。\n\n##### 6.HTML5 有哪些更新\n\n1. 语义化标签\n2. 媒体标签\n3. 表单\n4. 进度条、度量器\n\n- progress 标签： 用来表示任务的进度，有 max 和 value 属性\n\n```html\n<progress max=\"100\" value=\"20\"></progress>\n```\n\n5. DOM 查询操作\n\n- document.queryselector()\n- document.queryselectorAll()\n\n6. web 存储\n\n- localStorage 永久存储在浏览器中\n- sessionStorage 随着浏览器的关闭而清空\n\n7. 其他\n\n- 拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置\n\n```html\n<img draggable=\"true\" />\n```\n\n- 画布 canvas\n- SVG\n\n##### 7.img 的 srcset 属性的作用\n\n响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的 srcset 属性。srcset 属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：\n\n```html\n<img src=\"image-128.png\" srcset=\"image-256.png 2x\" />\n```\n\n使用上面的代码，就能实现在屏幕密度为 1x 的情况下加载 image-128.png, 屏幕密度为 2x 时加载 image-256.png。\n\n按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有 1x,2x,3x,4x 四种，如果每一个图片都设置 4 张图片，加载就会很慢。所以就有了新的 srcset 标准。代码如下：\n\n```html\n<img\n  src=\"image-128.png\"\n  srcset=\"image-128.png 128w, image-256.png 256w, image-512.png 512w\"\n  sizes=\"(max-width: 360px) 340px, 128px\"\n/>\n```\n\n其中 srcset 指定图片的地址和对应的图片质量。sizes 用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。\n\nsizes 语法如下：\n\n```html\nsizes=\"[media query] [length], [media query] [length] \"\n```\n\nsizes 就是指默认显示 128px, 如果视区宽度小于 360px, 则显示 340px。\n\n##### 8.行内元素有哪些？块级元素有哪些？空（void）元素有哪些？\n\n- 行内元素：**span a img input a b strong select**\n- 块级元素：**div h1 ul ol li dl dt dd p **\n- 空元素： \\<br> \\ <hr> \\ <input> \\<img> \\ <meta> \\\n\n空元素就是那些没有内容的标签,也没有闭合标签\n\n##### 9.说一说 web worker\n\n在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。\n\n##### 10.HTML5 的离线储存怎么使用，它的工作原理是什么？\n\n离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n\n**原理：**HTML5 的离线存储是基于一个新建的 `.appcache` 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n\n**使用方法：** （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：\n\n```html\n<html lang=\"en\" manifest=\"index.manifest\">\n  复制代码\n</html>\n```\n\n（2）在 `cache.manifest` 文件中编写需要离线存储的资源：\n\n```html\nCACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png\nFALLBACK: / /offline.html 复制代码\n```\n\n- **CACHE**: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。\n- **NETWORK**: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。\n- **FALLBACK**: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。\n\n（3）在离线状态时，操作 `window.applicationCache` 进行离线缓存的操作。\n\n**如何更新缓存：**\n\n（1）更新 manifest 文件\n\n（2）通过 javascript 操作\n\n（3）清除浏览器缓存\n\n**注意事项：**\n\n（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。\n\n（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。\n\n（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。\n\n（4）FALLBACK 中的资源必须和 manifest 文件同源。\n\n（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。\n\n（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。\n\n（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。\n\n##### 11.title 与 h1 的区别、b 与 strong 的区别，i 与 em 的区别\n\n- strong 标签有语义，是起到加重语气的效果，而 b 标签是没有的，b 标签只是一个简单加粗标签。b 标签之间的字符都设为粗体，strong 标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重 strong 标签。\n\n- title 属性没有明确意义只表示是个标题，H1 则表示层次明确的标题，对页面信息的抓取有很大的影响\n\n- **i 内容展示为斜体，em 表示强调的文本**\n\n##### 12.浏览器乱码的原因是什么？如何解决？\n\n**产生乱码的原因**：\n\n- 网页源代码是==gbk==的编码，而内容中的中文字是==utf-8==编码的，这样子浏览器打开即会出现==html==乱码，反之也会出现乱码\n- ==html==网页编码是==gbk==，而程序从数据库中调出呈现是==utf-8==编码的内容也会造成编码乱码\n- 浏览器不能自动检测网页编码，造成网页乱码\n\n##### 13.页面导入样式时，使用 link 和@import 有什么区别\n\n1. 兼容问题 ： link 是 HTML 提供的标签，不仅可以加 载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等，不存在兼容问题，而@import 是 CSS 提供的语法规则，在 IE5+才可以识别\n2. 加载顺序区别：link 会和页面并行加载，而@import 会等页面加载完成再进行加载\n3. DOM 可控性区别：可以通过 JS 操作 DOM，插入 link 标签来改变样式，由于 DOM 是基于文档的，无法使用@import 的方式插入样式\n\n##### 14.标准模式与兼容模式有什么区别\n\n标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作\n\n##### 15.渲染页面时常见哪些不良现象\n\n- FOUC：主要指的是样式闪烁问题，由于浏览器渲染机制（比如 firefox），在 css 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要就是 css 加载时间过长，或者 css 被放在了文档底部\n- 白屏： 有些浏览器渲染机制(比如 chrome)要先构建 DOM 树和 CSSOM 树，构建完成之后再进行渲染，如果 css 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏，也可能是把 js 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题\n\n##### 16.什么是重绘和重排（回流）\n\n重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们称这样的操作为 重绘\n\n重排： 当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为 回流\n\n常见引起回流属性和方法：\n\n任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。\n\n（1）添加或者删除可见的 DOM 元素；\n（2）元素尺寸改变——边距、填充、边框、宽度和高度\n（3）内容变化，比如用户在 input 框中输入文字\n（4）浏览器窗口尺寸改变——resize 事件发生时\n（5）计算 offsetWidth 和 offsetHeight 属性\n（6）设置 style 属性的值\n（7）当你修改网页的默认字体时。\n\n回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列\n回流。\n\n##### 17.为什么操作 ODM 慢\n\n一些 DOM 的操作或属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗\n\n##### 18.前端需要注意哪些 SEO\n\n（1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超\n过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不\n同页面 description 有所不同；keywords 列举出重要关键词即可。\n\n（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。\n\n（3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被\n抓取。\n\n（4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容\n\n（5）少用 iframe：搜索引擎不会抓取 iframe 中的内容\n\n（6）非装饰性图片必须加 alt\n\n（7）提高网站速度：网站速度是搜索引擎排序的一个重要指标\n\n##### 19.页面可见性(Page Visibility API) 可以有哪些用途\n\n这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户\n不看网页，下面这些网页行为都是可以暂停的。\n\n（1）对服务器的轮询\n（2）网页动画\n（3）正在播放的音频或视频\n\n详细资料可以参考： [《Page Visibility API 教程》](http://www.ruanyifeng.com/blog/2018/10/page_visibility_api.html)\n\n##### 20. <img> 的 title 和 alt 有什么区别\n\ntitle 通常是当鼠标滑到元素上的时候显示\n\nalt 是 <img> 的特有的属性，是图片内容的等价描述，用于图片无法加载时显示，读屏器阅读图片。可提高图片可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析\n\n##### 21.常用的 meat 标签\n\n```html\n<meta />\n元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。\n<meta /> 标签位于文档的头部，不包含任何内容。<meta />\n标签的属性定义了与文档相关联的名称/值对。\n\n<!DOCTYPE html> H5标准声明，使用 HTML5 doctype，不区分大小写\n<head lang=\"en\">\n  标准的 lang 属性写法\n  <meta charset=\"utf-8\" />\n  声明文档使用的字符编码\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  优先使用 IE 最新版本和 Chrome\n  <meta name=\"description\" content=\"不超过150个字符\" />\n  页面描述\n  <meta name=\"keywords\" content=\"\" />\n  页面关键词者\n  <meta name=\"author\" content=\"name, email@gmail.com\" />\n  网页作\n  <meta name=\"robots\" content=\"index,follow\" />\n  搜索引擎抓取\n  <meta\n    name=\"viewport\"\n    content=\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"\n  />\n  为移动设备添加 viewport\n  <meta name=\"apple-mobile-web-app-title\" content=\"标题\" />\n  iOS 设备 begin\n  <meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n  添加到主屏后的标题（iOS 6 新增） 是否启用 WebApp\n  全屏模式，删除苹果默认的工具栏和菜单栏\n  <meta\n    name=\"apple-itunes-app\"\n    content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\"\n  />\n  添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）\n  <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n  <meta name=\"format-detection\" content=\"telphone=no, email=no\" />\n  设置苹果工具栏颜色\n  <meta name=\"renderer\" content=\"webkit\" />\n  启用360浏览器的极速模式(webkit)\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n  避免IE使用兼容模式\n  <meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" />\n  不让百度转码\n  <meta name=\"HandheldFriendly\" content=\"true\" />\n  针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓\n  <meta name=\"MobileOptimized\" content=\"320\" />\n  微软的老式浏览器\n  <meta name=\"screen-orientation\" content=\"portrait\" />\n  uc强制竖屏\n  <meta name=\"x5-orientation\" content=\"portrait\" />\n  QQ强制竖屏\n  <meta name=\"full-screen\" content=\"yes\" />\n  UC强制全屏\n  <meta name=\"x5-fullscreen\" content=\"true\" />\n  QQ强制全屏\n  <meta name=\"browsermode\" content=\"application\" />\n  UC应用模式\n  <meta name=\"x5-page-mode\" content=\"app\" />\n  QQ应用模式\n  <meta name=\"msapplication-tap-highlight\" content=\"no\" />\n  windows phone 点击无高光 设置页面不缓存\n  <meta http-equiv=\"pragma\" content=\"no-cache\" />\n  <meta http-equiv=\"cache-control\" content=\"no-cache\" />\n  <meta http-equiv=\"expires\" content=\"0\" />\n</head>\n```\n\n详细资料可以参考： [《Meta 标签用法大全》](http://www.cnblogs.com/qiumohanyu/p/5431859.html)\n\n##### 22.主流浏览器内核私有属性 css 前缀\n\nmozilla 内核 （firefox,flock 等） -moz\nwebkit 内核 （safari,chrome 等） -webkit\nopera 内核 （opera 浏览器） -o\ntrident 内核 （ie 浏览器） -ms\n\n##### 23.HTML 规范中为什么要求引用资源不加协议头 http 或者 https\n\n如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现\n警告信息，不同浏览器警告信息展现形式不同。\n\n为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为\nprotocol-relative URL，暂且可译作协议相对 URL。\n\n如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似\n的警告信息，同时还可以节省 5 字节的数据量。\n\n##### sub 和 sup 标签\n\n<sub></sub>用来表示下标 H<sub>2</sub>o 像这个样子\n\n<sup></sup>用来表示上标 3<sup>2</sup>\n\n---\n\n### 2.CSS\n\n##### 1.介绍一下标准的 CSS 的盒子模型？低版本的浏览器盒子模型有什么不同\n\n盒模型都是由四个部分组成的，分别是 margin、border、padding 和 content。\n\n标准盒模型和 IE 盒模型的区别在于设置 width 和 height 时，所对应的范围不同。标准盒模型的 width 和 height 属性的\n范围只包含了 content，而 IE 盒模型的 width 和 height 属性的范围包含了 border、padding 和 content。\n\n一般来说，我们可以通过修改元素的 box-sizing 属性来改变元素的盒模型。\n\n##### 2.css 选择器有哪些\n\n| **选择器**     | **格式**      |\n| -------------- | ------------- |\n| id 选择器      | #id           |\n| 类选择器       | .classname    |\n| 属性选择器     | a[ref=“eee”]  |\n| 伪类选择器     | li:last-child |\n| 标签选择器     | div           |\n| 伪元素选择器   | li::after     |\n| 兄弟选择器     | li~a          |\n| 相邻兄弟选择器 | h1+p          |\n| 子选择器       | ul>li         |\n| 后代选择器     | li a          |\n| 通配符选择器   | \\*            |\n\n##### 3.::before 和 :after 中双冒号和单冒号的区别\n\n在 css3 中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号\n来表示伪元素。\n\n伪类一般匹配的是元素的一些特殊状态，如 hover、link 等，而伪元素一般匹配的特殊的位置，比如 after、before 等。\n\n##### 4.伪类与伪元素的区别\n\ncss 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句\n话中的第一个字母，或者是列表中的第一个元素。\n\n伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的\n元素时，我们可以通过:hover 来描述这个元素的状态。\n\n伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::be\nfore 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。\n\n有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是 CSS3 的一部分，并尝试区分伪类和伪元素。大多数浏览\n器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的 W3C 规范并未对此进行\n特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。\n\ncss 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。\n\n> 如何对伪元素进行操作？\n\n**伪类** 用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover 来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 dom 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。\n\n**伪元素** 譬如::before 和::after 伪元素，用于在 CSS 渲染中向元素的头部或尾部插入内容，它们不受文档约束，也不影响文档本身，只影响最终样式。这些添加的内容不会出现在 DOM 中，仅仅是在 CSS 渲染层中加入。它不存在于文档中，所以 JS 无法直接操作它。而 jQuery 的选择器都是基于 DOM 元素的，因此也并不能直接操作伪元素。那该怎样操作伪元素的样式呢？为此总结整理一篇，以备查用。\n\n## 有哪些伪元素\n\n:first-letter：向文本的第一个字母添加特殊样式。\n\n:first-line:　向文本的首行添加特殊样式。\n\n:before：在元素之前添加内容。\n\n:after：在元素之后添加内容。\n\n::placeholder：匹配占位符的文本，只有元素设置了 placeholder 属性时，该伪元素才能生效。\n\n::selection：CSS 伪元素应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）\n\n::backdrop(处于试验阶段)：用于改变全屏模式下的背景颜色，全屏模式的默认颜色为黑色。该伪元素只支持双冒号的形式\n\n## 获取伪元素的属性值\n\n获取伪元素的属性值可以使用 window.getComputedStyle()方法，获取伪元素的 CSS 样式声明对象。然后利用 getPropertyValue 方法或直接使用键值访问都可以获取对应的属性值。\n\n**语法：** window.getComputedStyle(element[, pseudoElement])\n\n**参数：**element（Object）：伪元素的所在的 DOM 元素；pseudoElement（String）：伪元素类型。可选值有：”:after”、”:before”、”:first-line”、”:first-letter”、”:selection”、”:backdrop”；\n","slug":"前端","published":1,"updated":"2024-11-17T13:58:10.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpn002473t308ri4s2x","content":"<h3 id=\"1-HTML\"><a href=\"#1-HTML\" class=\"headerlink\" title=\"1.HTML\"></a>1.HTML</h3><h5 id=\"1-src-和-href-的区别\"><a href=\"#1-src-和-href-的区别\" class=\"headerlink\" title=\"1.src 和 href 的区别\"></a>1.src 和 href 的区别</h5><p>src 和 href 都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p>\n<ul>\n<li><p><strong>src：</strong> 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src 会将其指向的资源下载并应⽤到⽂档内，如请求 js 脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般 js 脚本会放在页面底部。</p>\n</li>\n<li><p><strong>href：</strong> 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在 a、link 等标签上。</p>\n</li>\n</ul>\n<h5 id=\"2-对-HTML-语义化的理解\"><a href=\"#2-对-HTML-语义化的理解\" class=\"headerlink\" title=\"2.对 HTML 语义化的理解\"></a>2.对 HTML 语义化的理解</h5><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗来讲就是用正确的标签做正确的事情。</p>\n<p>语义化的优点如下：</p>\n<p>（1） 用正确的标签做正确的事情。<br>（2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;<br>（3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;<br>（4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;<br>（5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>\n<p>常用的语义化标签：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span><br>头部<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">section</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">section</span>&gt;</span><br>区块(有语义化的div)<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">main</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">main</span>&gt;</span><br>主要区域<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span><br>导航栏<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aside</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aside</span>&gt;</span><br>侧边栏<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span><br>底部<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"3-DOCTYPE-文档类型-的作用\"><a href=\"#3-DOCTYPE-文档类型-的作用\" class=\"headerlink\" title=\"3.DOCTYPE(文档类型)的作用\"></a>3.DOCTYPE(文档类型)的作用</h5><p>DOCTYPE 是 HTML5 中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html 或 xhtml）的文档类型定义来解析文档</strong>，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在 HTML ⽂档的第⼀⾏。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。</p>\n<h5 id=\"4-script-标签中的-defer-和-async-的区别\"><a href=\"#4-script-标签中的-defer-和-async-的区别\" class=\"headerlink\" title=\"4.script 标签中的 defer 和 async 的区别\"></a>4.script 标签中的 defer 和 async 的区别</h5><p>如果没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p>\n<p>下图可以直观的看出三者之间的区别: <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0a8a139519f46dfa2d1992c58eb5397~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"image.png\"> 其中蓝色代表 js 脚本网络加载时间，红色代表 js 脚本执行时间，绿色代表 html 解析。</p>\n<p><strong>defer 和 async 属性都是去异步加载外部的 JS 脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p>\n<ul>\n<li><strong>执行顺序：</strong> 多个带 async 属性的标签，不能保证加载的顺序；多个带 defer 属性的标签，按照加载顺序执行；</li>\n<li><strong>脚本是否并行执行：**async 属性，表示**后续文档的加载和执行与 js 脚本的加载和执行是并行进行的</strong>，即异步执行；defer 属性，加载后续文档的过程和 js 脚本的加载(此时仅加载不执行)是并行进行的(异步)，js 脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded 事件触发执行之前。</li>\n</ul>\n<h5 id=\"5-常用的-meta-标签\"><a href=\"#5-常用的-meta-标签\" class=\"headerlink\" title=\"5.常用的 meta 标签\"></a>5.常用的 meta 标签</h5><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了 HTTP 标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义 name。</p>\n<p>常用的 meta 标签：</p>\n<p>（1）<code>charset</code>，用来描述 HTML 文档的编码类型：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>（2） <code>keywords</code>，页面关键词：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;keywords&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;关键词&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>（3）<code>description</code>，页面描述：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;description&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;页面描述内容&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>（4）<code>refresh</code>，页面重定向和刷新：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;refresh&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;0;url=&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span></span><br><span class=\"hljs-tag\">/&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>其中，<code>content</code> 参数有以下几种：</p>\n<ul>\n<li><code>width viewport</code> ：宽度(数值/device-width)</li>\n<li><code>height viewport</code> ：高度(数值/device-height)</li>\n<li><code>initial-scale</code> ：初始缩放比例</li>\n<li><code>maximum-scale</code> ：最大缩放比例</li>\n<li><code>minimum-scale</code> ：最小缩放比例</li>\n<li><code>user-scalable</code> ：是否允许用户缩放(yes/no）</li>\n</ul>\n<p>（6）搜索引擎索引方式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;robots&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;index,follow&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>其中，<code>content</code> 参数有以下几种：</p>\n<ul>\n<li><code>all</code>：文件将被检索，且页面上的链接可以被查询；</li>\n<li><code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li>\n<li><code>index</code>：文件将被检索；</li>\n<li><code>follow</code>：页面上的链接可以被查询；</li>\n<li><code>noindex</code>：文件将不被检索；</li>\n<li><code>nofollow</code>：页面上的链接不可以被查询。</li>\n</ul>\n<h5 id=\"6-HTML5-有哪些更新\"><a href=\"#6-HTML5-有哪些更新\" class=\"headerlink\" title=\"6.HTML5 有哪些更新\"></a>6.HTML5 有哪些更新</h5><ol>\n<li>语义化标签</li>\n<li>媒体标签</li>\n<li>表单</li>\n<li>进度条、度量器</li>\n</ol>\n<ul>\n<li>progress 标签： 用来表示任务的进度，有 max 和 value 属性</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">progress</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">&quot;100&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;20&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">progress</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>DOM 查询操作</li>\n</ol>\n<ul>\n<li>document.queryselector()</li>\n<li>document.queryselectorAll()</li>\n</ul>\n<ol start=\"6\">\n<li>web 存储</li>\n</ol>\n<ul>\n<li>localStorage 永久存储在浏览器中</li>\n<li>sessionStorage 随着浏览器的关闭而清空</li>\n</ul>\n<ol start=\"7\">\n<li>其他</li>\n</ol>\n<ul>\n<li>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">draggable</span>=<span class=\"hljs-string\">&quot;true&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>画布 canvas</li>\n<li>SVG</li>\n</ul>\n<h5 id=\"7-img-的-srcset-属性的作用\"><a href=\"#7-img-的-srcset-属性的作用\" class=\"headerlink\" title=\"7.img 的 srcset 属性的作用\"></a>7.img 的 srcset 属性的作用</h5><p>响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的 srcset 属性。srcset 属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;image-128.png&quot;</span> <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">&quot;image-256.png 2x&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>使用上面的代码，就能实现在屏幕密度为 1x 的情况下加载 image-128.png, 屏幕密度为 2x 时加载 image-256.png。</p>\n<p>按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有 1x,2x,3x,4x 四种，如果每一个图片都设置 4 张图片，加载就会很慢。所以就有了新的 srcset 标准。代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;image-128.png&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">&quot;image-128.png 128w, image-256.png 256w, image-512.png 512w&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">sizes</span>=<span class=\"hljs-string\">&quot;(max-width: 360px) 340px, 128px&quot;</span></span><br><span class=\"hljs-tag\">/&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>其中 srcset 指定图片的地址和对应的图片质量。sizes 用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。</p>\n<p>sizes 语法如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">sizes=&quot;[media query] [length], [media query] [length] &quot;<br></code></pre></td></tr></table></figure>\n\n<p>sizes 就是指默认显示 128px, 如果视区宽度小于 360px, 则显示 340px。</p>\n<h5 id=\"8-行内元素有哪些？块级元素有哪些？空（void）元素有哪些？\"><a href=\"#8-行内元素有哪些？块级元素有哪些？空（void）元素有哪些？\" class=\"headerlink\" title=\"8.行内元素有哪些？块级元素有哪些？空（void）元素有哪些？\"></a>8.行内元素有哪些？块级元素有哪些？空（void）元素有哪些？</h5><ul>\n<li>行内元素：<strong>span a img input a b strong select</strong></li>\n<li>块级元素：**div h1 ul ol li dl dt dd p **</li>\n<li>空元素： &lt;br&gt; \\ <hr> \\ <input> &lt;img&gt; \\ <meta> \\</li>\n</ul>\n<p>空元素就是那些没有内容的标签,也没有闭合标签</p>\n<h5 id=\"9-说一说-web-worker\"><a href=\"#9-说一说-web-worker\" class=\"headerlink\" title=\"9.说一说 web worker\"></a>9.说一说 web worker</h5><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>\n<h5 id=\"10-HTML5-的离线储存怎么使用，它的工作原理是什么？\"><a href=\"#10-HTML5-的离线储存怎么使用，它的工作原理是什么？\" class=\"headerlink\" title=\"10.HTML5 的离线储存怎么使用，它的工作原理是什么？\"></a>10.HTML5 的离线储存怎么使用，它的工作原理是什么？</h5><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>\n<p><strong>原理：</strong>HTML5 的离线存储是基于一个新建的 <code>.appcache</code> 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>\n<p><strong>使用方法：</strong> （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span> <span class=\"hljs-attr\">manifest</span>=<span class=\"hljs-string\">&quot;index.manifest&quot;</span>&gt;</span><br>  复制代码<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>（2）在 <code>cache.manifest</code> 文件中编写需要离线存储的资源：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png<br>FALLBACK: / /offline.html 复制代码<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>CACHE</strong>: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li>\n<li><strong>NETWORK</strong>: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li>\n<li><strong>FALLBACK</strong>: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li>\n</ul>\n<p>（3）在离线状态时，操作 <code>window.applicationCache</code> 进行离线缓存的操作。</p>\n<p><strong>如何更新缓存：</strong></p>\n<p>（1）更新 manifest 文件</p>\n<p>（2）通过 javascript 操作</p>\n<p>（3）清除浏览器缓存</p>\n<p><strong>注意事项：</strong></p>\n<p>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p>\n<p>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</p>\n<p>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</p>\n<p>（4）FALLBACK 中的资源必须和 manifest 文件同源。</p>\n<p>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</p>\n<p>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</p>\n<p>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p>\n<h5 id=\"11-title-与-h1-的区别、b-与-strong-的区别，i-与-em-的区别\"><a href=\"#11-title-与-h1-的区别、b-与-strong-的区别，i-与-em-的区别\" class=\"headerlink\" title=\"11.title 与 h1 的区别、b 与 strong 的区别，i 与 em 的区别\"></a>11.title 与 h1 的区别、b 与 strong 的区别，i 与 em 的区别</h5><ul>\n<li><p>strong 标签有语义，是起到加重语气的效果，而 b 标签是没有的，b 标签只是一个简单加粗标签。b 标签之间的字符都设为粗体，strong 标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重 strong 标签。</p>\n</li>\n<li><p>title 属性没有明确意义只表示是个标题，H1 则表示层次明确的标题，对页面信息的抓取有很大的影响</p>\n</li>\n<li><p><strong>i 内容展示为斜体，em 表示强调的文本</strong></p>\n</li>\n</ul>\n<h5 id=\"12-浏览器乱码的原因是什么？如何解决？\"><a href=\"#12-浏览器乱码的原因是什么？如何解决？\" class=\"headerlink\" title=\"12.浏览器乱码的原因是什么？如何解决？\"></a>12.浏览器乱码的原因是什么？如何解决？</h5><p><strong>产生乱码的原因</strong>：</p>\n<ul>\n<li>网页源代码是==gbk==的编码，而内容中的中文字是==utf-8==编码的，这样子浏览器打开即会出现==html==乱码，反之也会出现乱码</li>\n<li>==html==网页编码是==gbk==，而程序从数据库中调出呈现是==utf-8==编码的内容也会造成编码乱码</li>\n<li>浏览器不能自动检测网页编码，造成网页乱码</li>\n</ul>\n<h5 id=\"13-页面导入样式时，使用-link-和-import-有什么区别\"><a href=\"#13-页面导入样式时，使用-link-和-import-有什么区别\" class=\"headerlink\" title=\"13.页面导入样式时，使用 link 和@import 有什么区别\"></a>13.页面导入样式时，使用 link 和@import 有什么区别</h5><ol>\n<li>兼容问题 ： link 是 HTML 提供的标签，不仅可以加 载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等，不存在兼容问题，而@import 是 CSS 提供的语法规则，在 IE5+才可以识别</li>\n<li>加载顺序区别：link 会和页面并行加载，而@import 会等页面加载完成再进行加载</li>\n<li>DOM 可控性区别：可以通过 JS 操作 DOM，插入 link 标签来改变样式，由于 DOM 是基于文档的，无法使用@import 的方式插入样式</li>\n</ol>\n<h5 id=\"14-标准模式与兼容模式有什么区别\"><a href=\"#14-标准模式与兼容模式有什么区别\" class=\"headerlink\" title=\"14.标准模式与兼容模式有什么区别\"></a>14.标准模式与兼容模式有什么区别</h5><p>标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作</p>\n<h5 id=\"15-渲染页面时常见哪些不良现象\"><a href=\"#15-渲染页面时常见哪些不良现象\" class=\"headerlink\" title=\"15.渲染页面时常见哪些不良现象\"></a>15.渲染页面时常见哪些不良现象</h5><ul>\n<li>FOUC：主要指的是样式闪烁问题，由于浏览器渲染机制（比如 firefox），在 css 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要就是 css 加载时间过长，或者 css 被放在了文档底部</li>\n<li>白屏： 有些浏览器渲染机制(比如 chrome)要先构建 DOM 树和 CSSOM 树，构建完成之后再进行渲染，如果 css 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏，也可能是把 js 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题</li>\n</ul>\n<h5 id=\"16-什么是重绘和重排（回流）\"><a href=\"#16-什么是重绘和重排（回流）\" class=\"headerlink\" title=\"16.什么是重绘和重排（回流）\"></a>16.什么是重绘和重排（回流）</h5><p>重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们称这样的操作为 重绘</p>\n<p>重排： 当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为 回流</p>\n<p>常见引起回流属性和方法：</p>\n<p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p>\n<p>（1）添加或者删除可见的 DOM 元素；<br>（2）元素尺寸改变——边距、填充、边框、宽度和高度<br>（3）内容变化，比如用户在 input 框中输入文字<br>（4）浏览器窗口尺寸改变——resize 事件发生时<br>（5）计算 offsetWidth 和 offsetHeight 属性<br>（6）设置 style 属性的值<br>（7）当你修改网页的默认字体时。</p>\n<p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列<br>回流。</p>\n<h5 id=\"17-为什么操作-ODM-慢\"><a href=\"#17-为什么操作-ODM-慢\" class=\"headerlink\" title=\"17.为什么操作 ODM 慢\"></a>17.为什么操作 ODM 慢</h5><p>一些 DOM 的操作或属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗</p>\n<h5 id=\"18-前端需要注意哪些-SEO\"><a href=\"#18-前端需要注意哪些-SEO\" class=\"headerlink\" title=\"18.前端需要注意哪些 SEO\"></a>18.前端需要注意哪些 SEO</h5><p>（1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超<br>过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不<br>同页面 description 有所不同；keywords 列举出重要关键词即可。</p>\n<p>（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。</p>\n<p>（3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被<br>抓取。</p>\n<p>（4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容</p>\n<p>（5）少用 iframe：搜索引擎不会抓取 iframe 中的内容</p>\n<p>（6）非装饰性图片必须加 alt</p>\n<p>（7）提高网站速度：网站速度是搜索引擎排序的一个重要指标</p>\n<h5 id=\"19-页面可见性-Page-Visibility-API-可以有哪些用途\"><a href=\"#19-页面可见性-Page-Visibility-API-可以有哪些用途\" class=\"headerlink\" title=\"19.页面可见性(Page Visibility API) 可以有哪些用途\"></a>19.页面可见性(Page Visibility API) 可以有哪些用途</h5><p>这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户<br>不看网页，下面这些网页行为都是可以暂停的。</p>\n<p>（1）对服务器的轮询<br>（2）网页动画<br>（3）正在播放的音频或视频</p>\n<p>详细资料可以参考： <a href=\"http://www.ruanyifeng.com/blog/2018/10/page_visibility_api.html\">《Page Visibility API 教程》</a></p>\n<h5 id=\"20-的-title-和-alt-有什么区别\"><a href=\"#20-的-title-和-alt-有什么区别\" class=\"headerlink\" title=\"20.  的 title 和 alt 有什么区别\"></a>20. <img> 的 title 和 alt 有什么区别</h5><p>title 通常是当鼠标滑到元素上的时候显示</p>\n<p>alt 是 <img> 的特有的属性，是图片内容的等价描述，用于图片无法加载时显示，读屏器阅读图片。可提高图片可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析</p>\n<h5 id=\"21-常用的-meat-标签\"><a href=\"#21-常用的-meat-标签\" class=\"headerlink\" title=\"21.常用的 meat 标签\"></a>21.常用的 meat 标签</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> /&gt;</span><br>元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> /&gt;</span> 标签位于文档的头部，不包含任何内容。<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> /&gt;</span><br>标签的属性定义了与文档相关联的名称/值对。<br><br><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span> H5标准声明，使用 HTML5 doctype，不区分大小写<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br>  标准的 lang 属性写法<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span> /&gt;</span><br>  声明文档使用的字符编码<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span><br>  优先使用 IE 最新版本和 Chrome<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;description&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;不超过150个字符&quot;</span> /&gt;</span><br>  页面描述<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;keywords&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;&quot;</span> /&gt;</span><br>  页面关键词者<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;author&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;name, email@gmail.com&quot;</span> /&gt;</span><br>  网页作<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;robots&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;index,follow&quot;</span> /&gt;</span><br>  搜索引擎抓取<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span></span><br><span class=\"hljs-tag\">    <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span></span><br><span class=\"hljs-tag\">    <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;</span></span><br><span class=\"hljs-tag\">  /&gt;</span><br>  为移动设备添加 viewport<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;apple-mobile-web-app-title&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;标题&quot;</span> /&gt;</span><br>  iOS 设备 begin<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;apple-mobile-web-app-capable&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;yes&quot;</span> /&gt;</span><br>  添加到主屏后的标题（iOS 6 新增） 是否启用 WebApp<br>  全屏模式，删除苹果默认的工具栏和菜单栏<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span></span><br><span class=\"hljs-tag\">    <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;apple-itunes-app&quot;</span></span><br><span class=\"hljs-tag\">    <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;</span></span><br><span class=\"hljs-tag\">  /&gt;</span><br>  添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;apple-mobile-web-app-status-bar-style&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;black&quot;</span> /&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;format-detection&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;telphone=no, email=no&quot;</span> /&gt;</span><br>  设置苹果工具栏颜色<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;renderer&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;webkit&quot;</span> /&gt;</span><br>  启用360浏览器的极速模式(webkit)<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span> /&gt;</span><br>  避免IE使用兼容模式<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;Cache-Control&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;no-siteapp&quot;</span> /&gt;</span><br>  不让百度转码<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;HandheldFriendly&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;true&quot;</span> /&gt;</span><br>  针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;MobileOptimized&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;320&quot;</span> /&gt;</span><br>  微软的老式浏览器<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;screen-orientation&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;portrait&quot;</span> /&gt;</span><br>  uc强制竖屏<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;x5-orientation&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;portrait&quot;</span> /&gt;</span><br>  QQ强制竖屏<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;full-screen&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;yes&quot;</span> /&gt;</span><br>  UC强制全屏<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;x5-fullscreen&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;true&quot;</span> /&gt;</span><br>  QQ强制全屏<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;browsermode&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;application&quot;</span> /&gt;</span><br>  UC应用模式<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;x5-page-mode&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;app&quot;</span> /&gt;</span><br>  QQ应用模式<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;msapplication-tap-highlight&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;no&quot;</span> /&gt;</span><br>  windows phone 点击无高光 设置页面不缓存<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;pragma&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;no-cache&quot;</span> /&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;cache-control&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;no-cache&quot;</span> /&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;expires&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;0&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>详细资料可以参考： <a href=\"http://www.cnblogs.com/qiumohanyu/p/5431859.html\">《Meta 标签用法大全》</a></p>\n<h5 id=\"22-主流浏览器内核私有属性-css-前缀\"><a href=\"#22-主流浏览器内核私有属性-css-前缀\" class=\"headerlink\" title=\"22.主流浏览器内核私有属性 css 前缀\"></a>22.主流浏览器内核私有属性 css 前缀</h5><p>mozilla 内核 （firefox,flock 等） -moz<br>webkit 内核 （safari,chrome 等） -webkit<br>opera 内核 （opera 浏览器） -o<br>trident 内核 （ie 浏览器） -ms</p>\n<h5 id=\"23-HTML-规范中为什么要求引用资源不加协议头-http-或者-https\"><a href=\"#23-HTML-规范中为什么要求引用资源不加协议头-http-或者-https\" class=\"headerlink\" title=\"23.HTML 规范中为什么要求引用资源不加协议头 http 或者 https\"></a>23.HTML 规范中为什么要求引用资源不加协议头 http 或者 https</h5><p>如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现<br>警告信息，不同浏览器警告信息展现形式不同。</p>\n<p>为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为<br>protocol-relative URL，暂且可译作协议相对 URL。</p>\n<p>如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似<br>的警告信息，同时还可以节省 5 字节的数据量。</p>\n<h5 id=\"sub-和-sup-标签\"><a href=\"#sub-和-sup-标签\" class=\"headerlink\" title=\"sub 和 sup 标签\"></a>sub 和 sup 标签</h5><p><sub></sub>用来表示下标 H<sub>2</sub>o 像这个样子</p>\n<p><sup></sup>用来表示上标 3<sup>2</sup></p>\n<hr>\n<h3 id=\"2-CSS\"><a href=\"#2-CSS\" class=\"headerlink\" title=\"2.CSS\"></a>2.CSS</h3><h5 id=\"1-介绍一下标准的-CSS-的盒子模型？低版本的浏览器盒子模型有什么不同\"><a href=\"#1-介绍一下标准的-CSS-的盒子模型？低版本的浏览器盒子模型有什么不同\" class=\"headerlink\" title=\"1.介绍一下标准的 CSS 的盒子模型？低版本的浏览器盒子模型有什么不同\"></a>1.介绍一下标准的 CSS 的盒子模型？低版本的浏览器盒子模型有什么不同</h5><p>盒模型都是由四个部分组成的，分别是 margin、border、padding 和 content。</p>\n<p>标准盒模型和 IE 盒模型的区别在于设置 width 和 height 时，所对应的范围不同。标准盒模型的 width 和 height 属性的<br>范围只包含了 content，而 IE 盒模型的 width 和 height 属性的范围包含了 border、padding 和 content。</p>\n<p>一般来说，我们可以通过修改元素的 box-sizing 属性来改变元素的盒模型。</p>\n<h5 id=\"2-css-选择器有哪些\"><a href=\"#2-css-选择器有哪些\" class=\"headerlink\" title=\"2.css 选择器有哪些\"></a>2.css 选择器有哪些</h5><table>\n<thead>\n<tr>\n<th><strong>选择器</strong></th>\n<th><strong>格式</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id 选择器</td>\n<td>#id</td>\n</tr>\n<tr>\n<td>类选择器</td>\n<td>.classname</td>\n</tr>\n<tr>\n<td>属性选择器</td>\n<td>a[ref=“eee”]</td>\n</tr>\n<tr>\n<td>伪类选择器</td>\n<td>li:last-child</td>\n</tr>\n<tr>\n<td>标签选择器</td>\n<td>div</td>\n</tr>\n<tr>\n<td>伪元素选择器</td>\n<td>li::after</td>\n</tr>\n<tr>\n<td>兄弟选择器</td>\n<td>li~a</td>\n</tr>\n<tr>\n<td>相邻兄弟选择器</td>\n<td>h1+p</td>\n</tr>\n<tr>\n<td>子选择器</td>\n<td>ul&gt;li</td>\n</tr>\n<tr>\n<td>后代选择器</td>\n<td>li a</td>\n</tr>\n<tr>\n<td>通配符选择器</td>\n<td>*</td>\n</tr>\n</tbody></table>\n<h5 id=\"3-before-和-after-中双冒号和单冒号的区别\"><a href=\"#3-before-和-after-中双冒号和单冒号的区别\" class=\"headerlink\" title=\"3.::before 和 :after 中双冒号和单冒号的区别\"></a>3.::before 和 :after 中双冒号和单冒号的区别</h5><p>在 css3 中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号<br>来表示伪元素。</p>\n<p>伪类一般匹配的是元素的一些特殊状态，如 hover、link 等，而伪元素一般匹配的特殊的位置，比如 after、before 等。</p>\n<h5 id=\"4-伪类与伪元素的区别\"><a href=\"#4-伪类与伪元素的区别\" class=\"headerlink\" title=\"4.伪类与伪元素的区别\"></a>4.伪类与伪元素的区别</h5><p>css 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句<br>话中的第一个字母，或者是列表中的第一个元素。</p>\n<p>伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的<br>元素时，我们可以通过:hover 来描述这个元素的状态。</p>\n<p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::be<br>fore 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p>\n<p>有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是 CSS3 的一部分，并尝试区分伪类和伪元素。大多数浏览<br>器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的 W3C 规范并未对此进行<br>特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。</p>\n<p>css 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。</p>\n<blockquote>\n<p>如何对伪元素进行操作？</p>\n</blockquote>\n<p><strong>伪类</strong> 用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover 来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 dom 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</p>\n<p><strong>伪元素</strong> 譬如::before 和::after 伪元素，用于在 CSS 渲染中向元素的头部或尾部插入内容，它们不受文档约束，也不影响文档本身，只影响最终样式。这些添加的内容不会出现在 DOM 中，仅仅是在 CSS 渲染层中加入。它不存在于文档中，所以 JS 无法直接操作它。而 jQuery 的选择器都是基于 DOM 元素的，因此也并不能直接操作伪元素。那该怎样操作伪元素的样式呢？为此总结整理一篇，以备查用。</p>\n<h2 id=\"有哪些伪元素\"><a href=\"#有哪些伪元素\" class=\"headerlink\" title=\"有哪些伪元素\"></a>有哪些伪元素</h2><p>:first-letter：向文本的第一个字母添加特殊样式。</p>\n<p>:first-line:　向文本的首行添加特殊样式。</p>\n<p>:before：在元素之前添加内容。</p>\n<p>:after：在元素之后添加内容。</p>\n<p>::placeholder：匹配占位符的文本，只有元素设置了 placeholder 属性时，该伪元素才能生效。</p>\n<p>::selection：CSS 伪元素应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）</p>\n<p>::backdrop(处于试验阶段)：用于改变全屏模式下的背景颜色，全屏模式的默认颜色为黑色。该伪元素只支持双冒号的形式</p>\n<h2 id=\"获取伪元素的属性值\"><a href=\"#获取伪元素的属性值\" class=\"headerlink\" title=\"获取伪元素的属性值\"></a>获取伪元素的属性值</h2><p>获取伪元素的属性值可以使用 window.getComputedStyle()方法，获取伪元素的 CSS 样式声明对象。然后利用 getPropertyValue 方法或直接使用键值访问都可以获取对应的属性值。</p>\n<p><strong>语法：</strong> window.getComputedStyle(element[, pseudoElement])</p>\n<p><strong>参数：</strong>element（Object）：伪元素的所在的 DOM 元素；pseudoElement（String）：伪元素类型。可选值有：”:after”、”:before”、”:first-line”、”:first-letter”、”:selection”、”:backdrop”；</p>\n","site":{"data":{}},"wordcount":12090,"excerpt":"","more":"<h3 id=\"1-HTML\"><a href=\"#1-HTML\" class=\"headerlink\" title=\"1.HTML\"></a>1.HTML</h3><h5 id=\"1-src-和-href-的区别\"><a href=\"#1-src-和-href-的区别\" class=\"headerlink\" title=\"1.src 和 href 的区别\"></a>1.src 和 href 的区别</h5><p>src 和 href 都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p>\n<ul>\n<li><p><strong>src：</strong> 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src 会将其指向的资源下载并应⽤到⽂档内，如请求 js 脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般 js 脚本会放在页面底部。</p>\n</li>\n<li><p><strong>href：</strong> 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在 a、link 等标签上。</p>\n</li>\n</ul>\n<h5 id=\"2-对-HTML-语义化的理解\"><a href=\"#2-对-HTML-语义化的理解\" class=\"headerlink\" title=\"2.对 HTML 语义化的理解\"></a>2.对 HTML 语义化的理解</h5><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗来讲就是用正确的标签做正确的事情。</p>\n<p>语义化的优点如下：</p>\n<p>（1） 用正确的标签做正确的事情。<br>（2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;<br>（3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;<br>（4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;<br>（5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>\n<p>常用的语义化标签：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span><br>头部<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">section</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">section</span>&gt;</span><br>区块(有语义化的div)<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">main</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">main</span>&gt;</span><br>主要区域<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span><br>导航栏<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aside</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aside</span>&gt;</span><br>侧边栏<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span><br>底部<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"3-DOCTYPE-文档类型-的作用\"><a href=\"#3-DOCTYPE-文档类型-的作用\" class=\"headerlink\" title=\"3.DOCTYPE(文档类型)的作用\"></a>3.DOCTYPE(文档类型)的作用</h5><p>DOCTYPE 是 HTML5 中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html 或 xhtml）的文档类型定义来解析文档</strong>，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在 HTML ⽂档的第⼀⾏。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。</p>\n<h5 id=\"4-script-标签中的-defer-和-async-的区别\"><a href=\"#4-script-标签中的-defer-和-async-的区别\" class=\"headerlink\" title=\"4.script 标签中的 defer 和 async 的区别\"></a>4.script 标签中的 defer 和 async 的区别</h5><p>如果没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p>\n<p>下图可以直观的看出三者之间的区别: <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0a8a139519f46dfa2d1992c58eb5397~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"image.png\"> 其中蓝色代表 js 脚本网络加载时间，红色代表 js 脚本执行时间，绿色代表 html 解析。</p>\n<p><strong>defer 和 async 属性都是去异步加载外部的 JS 脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p>\n<ul>\n<li><strong>执行顺序：</strong> 多个带 async 属性的标签，不能保证加载的顺序；多个带 defer 属性的标签，按照加载顺序执行；</li>\n<li><strong>脚本是否并行执行：**async 属性，表示**后续文档的加载和执行与 js 脚本的加载和执行是并行进行的</strong>，即异步执行；defer 属性，加载后续文档的过程和 js 脚本的加载(此时仅加载不执行)是并行进行的(异步)，js 脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded 事件触发执行之前。</li>\n</ul>\n<h5 id=\"5-常用的-meta-标签\"><a href=\"#5-常用的-meta-标签\" class=\"headerlink\" title=\"5.常用的 meta 标签\"></a>5.常用的 meta 标签</h5><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了 HTTP 标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义 name。</p>\n<p>常用的 meta 标签：</p>\n<p>（1）<code>charset</code>，用来描述 HTML 文档的编码类型：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>（2） <code>keywords</code>，页面关键词：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;keywords&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;关键词&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>（3）<code>description</code>，页面描述：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;description&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;页面描述内容&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>（4）<code>refresh</code>，页面重定向和刷新：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;refresh&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;0;url=&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span></span><br><span class=\"hljs-tag\">/&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>其中，<code>content</code> 参数有以下几种：</p>\n<ul>\n<li><code>width viewport</code> ：宽度(数值/device-width)</li>\n<li><code>height viewport</code> ：高度(数值/device-height)</li>\n<li><code>initial-scale</code> ：初始缩放比例</li>\n<li><code>maximum-scale</code> ：最大缩放比例</li>\n<li><code>minimum-scale</code> ：最小缩放比例</li>\n<li><code>user-scalable</code> ：是否允许用户缩放(yes/no）</li>\n</ul>\n<p>（6）搜索引擎索引方式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;robots&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;index,follow&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>其中，<code>content</code> 参数有以下几种：</p>\n<ul>\n<li><code>all</code>：文件将被检索，且页面上的链接可以被查询；</li>\n<li><code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li>\n<li><code>index</code>：文件将被检索；</li>\n<li><code>follow</code>：页面上的链接可以被查询；</li>\n<li><code>noindex</code>：文件将不被检索；</li>\n<li><code>nofollow</code>：页面上的链接不可以被查询。</li>\n</ul>\n<h5 id=\"6-HTML5-有哪些更新\"><a href=\"#6-HTML5-有哪些更新\" class=\"headerlink\" title=\"6.HTML5 有哪些更新\"></a>6.HTML5 有哪些更新</h5><ol>\n<li>语义化标签</li>\n<li>媒体标签</li>\n<li>表单</li>\n<li>进度条、度量器</li>\n</ol>\n<ul>\n<li>progress 标签： 用来表示任务的进度，有 max 和 value 属性</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">progress</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">&quot;100&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;20&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">progress</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>DOM 查询操作</li>\n</ol>\n<ul>\n<li>document.queryselector()</li>\n<li>document.queryselectorAll()</li>\n</ul>\n<ol start=\"6\">\n<li>web 存储</li>\n</ol>\n<ul>\n<li>localStorage 永久存储在浏览器中</li>\n<li>sessionStorage 随着浏览器的关闭而清空</li>\n</ul>\n<ol start=\"7\">\n<li>其他</li>\n</ol>\n<ul>\n<li>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">draggable</span>=<span class=\"hljs-string\">&quot;true&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>画布 canvas</li>\n<li>SVG</li>\n</ul>\n<h5 id=\"7-img-的-srcset-属性的作用\"><a href=\"#7-img-的-srcset-属性的作用\" class=\"headerlink\" title=\"7.img 的 srcset 属性的作用\"></a>7.img 的 srcset 属性的作用</h5><p>响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的 srcset 属性。srcset 属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;image-128.png&quot;</span> <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">&quot;image-256.png 2x&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>使用上面的代码，就能实现在屏幕密度为 1x 的情况下加载 image-128.png, 屏幕密度为 2x 时加载 image-256.png。</p>\n<p>按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有 1x,2x,3x,4x 四种，如果每一个图片都设置 4 张图片，加载就会很慢。所以就有了新的 srcset 标准。代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;image-128.png&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">&quot;image-128.png 128w, image-256.png 256w, image-512.png 512w&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">sizes</span>=<span class=\"hljs-string\">&quot;(max-width: 360px) 340px, 128px&quot;</span></span><br><span class=\"hljs-tag\">/&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>其中 srcset 指定图片的地址和对应的图片质量。sizes 用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。</p>\n<p>sizes 语法如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">sizes=&quot;[media query] [length], [media query] [length] &quot;<br></code></pre></td></tr></table></figure>\n\n<p>sizes 就是指默认显示 128px, 如果视区宽度小于 360px, 则显示 340px。</p>\n<h5 id=\"8-行内元素有哪些？块级元素有哪些？空（void）元素有哪些？\"><a href=\"#8-行内元素有哪些？块级元素有哪些？空（void）元素有哪些？\" class=\"headerlink\" title=\"8.行内元素有哪些？块级元素有哪些？空（void）元素有哪些？\"></a>8.行内元素有哪些？块级元素有哪些？空（void）元素有哪些？</h5><ul>\n<li>行内元素：<strong>span a img input a b strong select</strong></li>\n<li>块级元素：**div h1 ul ol li dl dt dd p **</li>\n<li>空元素： &lt;br&gt; \\ <hr> \\ <input> &lt;img&gt; \\ <meta> \\</li>\n</ul>\n<p>空元素就是那些没有内容的标签,也没有闭合标签</p>\n<h5 id=\"9-说一说-web-worker\"><a href=\"#9-说一说-web-worker\" class=\"headerlink\" title=\"9.说一说 web worker\"></a>9.说一说 web worker</h5><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>\n<h5 id=\"10-HTML5-的离线储存怎么使用，它的工作原理是什么？\"><a href=\"#10-HTML5-的离线储存怎么使用，它的工作原理是什么？\" class=\"headerlink\" title=\"10.HTML5 的离线储存怎么使用，它的工作原理是什么？\"></a>10.HTML5 的离线储存怎么使用，它的工作原理是什么？</h5><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>\n<p><strong>原理：</strong>HTML5 的离线存储是基于一个新建的 <code>.appcache</code> 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>\n<p><strong>使用方法：</strong> （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span> <span class=\"hljs-attr\">manifest</span>=<span class=\"hljs-string\">&quot;index.manifest&quot;</span>&gt;</span><br>  复制代码<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>（2）在 <code>cache.manifest</code> 文件中编写需要离线存储的资源：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png<br>FALLBACK: / /offline.html 复制代码<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>CACHE</strong>: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li>\n<li><strong>NETWORK</strong>: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li>\n<li><strong>FALLBACK</strong>: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li>\n</ul>\n<p>（3）在离线状态时，操作 <code>window.applicationCache</code> 进行离线缓存的操作。</p>\n<p><strong>如何更新缓存：</strong></p>\n<p>（1）更新 manifest 文件</p>\n<p>（2）通过 javascript 操作</p>\n<p>（3）清除浏览器缓存</p>\n<p><strong>注意事项：</strong></p>\n<p>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p>\n<p>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</p>\n<p>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</p>\n<p>（4）FALLBACK 中的资源必须和 manifest 文件同源。</p>\n<p>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</p>\n<p>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</p>\n<p>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p>\n<h5 id=\"11-title-与-h1-的区别、b-与-strong-的区别，i-与-em-的区别\"><a href=\"#11-title-与-h1-的区别、b-与-strong-的区别，i-与-em-的区别\" class=\"headerlink\" title=\"11.title 与 h1 的区别、b 与 strong 的区别，i 与 em 的区别\"></a>11.title 与 h1 的区别、b 与 strong 的区别，i 与 em 的区别</h5><ul>\n<li><p>strong 标签有语义，是起到加重语气的效果，而 b 标签是没有的，b 标签只是一个简单加粗标签。b 标签之间的字符都设为粗体，strong 标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重 strong 标签。</p>\n</li>\n<li><p>title 属性没有明确意义只表示是个标题，H1 则表示层次明确的标题，对页面信息的抓取有很大的影响</p>\n</li>\n<li><p><strong>i 内容展示为斜体，em 表示强调的文本</strong></p>\n</li>\n</ul>\n<h5 id=\"12-浏览器乱码的原因是什么？如何解决？\"><a href=\"#12-浏览器乱码的原因是什么？如何解决？\" class=\"headerlink\" title=\"12.浏览器乱码的原因是什么？如何解决？\"></a>12.浏览器乱码的原因是什么？如何解决？</h5><p><strong>产生乱码的原因</strong>：</p>\n<ul>\n<li>网页源代码是==gbk==的编码，而内容中的中文字是==utf-8==编码的，这样子浏览器打开即会出现==html==乱码，反之也会出现乱码</li>\n<li>==html==网页编码是==gbk==，而程序从数据库中调出呈现是==utf-8==编码的内容也会造成编码乱码</li>\n<li>浏览器不能自动检测网页编码，造成网页乱码</li>\n</ul>\n<h5 id=\"13-页面导入样式时，使用-link-和-import-有什么区别\"><a href=\"#13-页面导入样式时，使用-link-和-import-有什么区别\" class=\"headerlink\" title=\"13.页面导入样式时，使用 link 和@import 有什么区别\"></a>13.页面导入样式时，使用 link 和@import 有什么区别</h5><ol>\n<li>兼容问题 ： link 是 HTML 提供的标签，不仅可以加 载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等，不存在兼容问题，而@import 是 CSS 提供的语法规则，在 IE5+才可以识别</li>\n<li>加载顺序区别：link 会和页面并行加载，而@import 会等页面加载完成再进行加载</li>\n<li>DOM 可控性区别：可以通过 JS 操作 DOM，插入 link 标签来改变样式，由于 DOM 是基于文档的，无法使用@import 的方式插入样式</li>\n</ol>\n<h5 id=\"14-标准模式与兼容模式有什么区别\"><a href=\"#14-标准模式与兼容模式有什么区别\" class=\"headerlink\" title=\"14.标准模式与兼容模式有什么区别\"></a>14.标准模式与兼容模式有什么区别</h5><p>标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作</p>\n<h5 id=\"15-渲染页面时常见哪些不良现象\"><a href=\"#15-渲染页面时常见哪些不良现象\" class=\"headerlink\" title=\"15.渲染页面时常见哪些不良现象\"></a>15.渲染页面时常见哪些不良现象</h5><ul>\n<li>FOUC：主要指的是样式闪烁问题，由于浏览器渲染机制（比如 firefox），在 css 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要就是 css 加载时间过长，或者 css 被放在了文档底部</li>\n<li>白屏： 有些浏览器渲染机制(比如 chrome)要先构建 DOM 树和 CSSOM 树，构建完成之后再进行渲染，如果 css 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏，也可能是把 js 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题</li>\n</ul>\n<h5 id=\"16-什么是重绘和重排（回流）\"><a href=\"#16-什么是重绘和重排（回流）\" class=\"headerlink\" title=\"16.什么是重绘和重排（回流）\"></a>16.什么是重绘和重排（回流）</h5><p>重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们称这样的操作为 重绘</p>\n<p>重排： 当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为 回流</p>\n<p>常见引起回流属性和方法：</p>\n<p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p>\n<p>（1）添加或者删除可见的 DOM 元素；<br>（2）元素尺寸改变——边距、填充、边框、宽度和高度<br>（3）内容变化，比如用户在 input 框中输入文字<br>（4）浏览器窗口尺寸改变——resize 事件发生时<br>（5）计算 offsetWidth 和 offsetHeight 属性<br>（6）设置 style 属性的值<br>（7）当你修改网页的默认字体时。</p>\n<p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列<br>回流。</p>\n<h5 id=\"17-为什么操作-ODM-慢\"><a href=\"#17-为什么操作-ODM-慢\" class=\"headerlink\" title=\"17.为什么操作 ODM 慢\"></a>17.为什么操作 ODM 慢</h5><p>一些 DOM 的操作或属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗</p>\n<h5 id=\"18-前端需要注意哪些-SEO\"><a href=\"#18-前端需要注意哪些-SEO\" class=\"headerlink\" title=\"18.前端需要注意哪些 SEO\"></a>18.前端需要注意哪些 SEO</h5><p>（1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超<br>过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不<br>同页面 description 有所不同；keywords 列举出重要关键词即可。</p>\n<p>（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。</p>\n<p>（3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被<br>抓取。</p>\n<p>（4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容</p>\n<p>（5）少用 iframe：搜索引擎不会抓取 iframe 中的内容</p>\n<p>（6）非装饰性图片必须加 alt</p>\n<p>（7）提高网站速度：网站速度是搜索引擎排序的一个重要指标</p>\n<h5 id=\"19-页面可见性-Page-Visibility-API-可以有哪些用途\"><a href=\"#19-页面可见性-Page-Visibility-API-可以有哪些用途\" class=\"headerlink\" title=\"19.页面可见性(Page Visibility API) 可以有哪些用途\"></a>19.页面可见性(Page Visibility API) 可以有哪些用途</h5><p>这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户<br>不看网页，下面这些网页行为都是可以暂停的。</p>\n<p>（1）对服务器的轮询<br>（2）网页动画<br>（3）正在播放的音频或视频</p>\n<p>详细资料可以参考： <a href=\"http://www.ruanyifeng.com/blog/2018/10/page_visibility_api.html\">《Page Visibility API 教程》</a></p>\n<h5 id=\"20-的-title-和-alt-有什么区别\"><a href=\"#20-的-title-和-alt-有什么区别\" class=\"headerlink\" title=\"20.  的 title 和 alt 有什么区别\"></a>20. <img> 的 title 和 alt 有什么区别</h5><p>title 通常是当鼠标滑到元素上的时候显示</p>\n<p>alt 是 <img> 的特有的属性，是图片内容的等价描述，用于图片无法加载时显示，读屏器阅读图片。可提高图片可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析</p>\n<h5 id=\"21-常用的-meat-标签\"><a href=\"#21-常用的-meat-标签\" class=\"headerlink\" title=\"21.常用的 meat 标签\"></a>21.常用的 meat 标签</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> /&gt;</span><br>元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> /&gt;</span> 标签位于文档的头部，不包含任何内容。<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> /&gt;</span><br>标签的属性定义了与文档相关联的名称/值对。<br><br><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span> H5标准声明，使用 HTML5 doctype，不区分大小写<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br>  标准的 lang 属性写法<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span> /&gt;</span><br>  声明文档使用的字符编码<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span><br>  优先使用 IE 最新版本和 Chrome<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;description&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;不超过150个字符&quot;</span> /&gt;</span><br>  页面描述<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;keywords&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;&quot;</span> /&gt;</span><br>  页面关键词者<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;author&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;name, email@gmail.com&quot;</span> /&gt;</span><br>  网页作<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;robots&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;index,follow&quot;</span> /&gt;</span><br>  搜索引擎抓取<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span></span><br><span class=\"hljs-tag\">    <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span></span><br><span class=\"hljs-tag\">    <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;</span></span><br><span class=\"hljs-tag\">  /&gt;</span><br>  为移动设备添加 viewport<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;apple-mobile-web-app-title&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;标题&quot;</span> /&gt;</span><br>  iOS 设备 begin<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;apple-mobile-web-app-capable&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;yes&quot;</span> /&gt;</span><br>  添加到主屏后的标题（iOS 6 新增） 是否启用 WebApp<br>  全屏模式，删除苹果默认的工具栏和菜单栏<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span></span><br><span class=\"hljs-tag\">    <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;apple-itunes-app&quot;</span></span><br><span class=\"hljs-tag\">    <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;</span></span><br><span class=\"hljs-tag\">  /&gt;</span><br>  添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;apple-mobile-web-app-status-bar-style&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;black&quot;</span> /&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;format-detection&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;telphone=no, email=no&quot;</span> /&gt;</span><br>  设置苹果工具栏颜色<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;renderer&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;webkit&quot;</span> /&gt;</span><br>  启用360浏览器的极速模式(webkit)<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span> /&gt;</span><br>  避免IE使用兼容模式<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;Cache-Control&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;no-siteapp&quot;</span> /&gt;</span><br>  不让百度转码<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;HandheldFriendly&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;true&quot;</span> /&gt;</span><br>  针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;MobileOptimized&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;320&quot;</span> /&gt;</span><br>  微软的老式浏览器<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;screen-orientation&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;portrait&quot;</span> /&gt;</span><br>  uc强制竖屏<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;x5-orientation&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;portrait&quot;</span> /&gt;</span><br>  QQ强制竖屏<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;full-screen&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;yes&quot;</span> /&gt;</span><br>  UC强制全屏<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;x5-fullscreen&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;true&quot;</span> /&gt;</span><br>  QQ强制全屏<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;browsermode&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;application&quot;</span> /&gt;</span><br>  UC应用模式<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;x5-page-mode&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;app&quot;</span> /&gt;</span><br>  QQ应用模式<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;msapplication-tap-highlight&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;no&quot;</span> /&gt;</span><br>  windows phone 点击无高光 设置页面不缓存<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;pragma&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;no-cache&quot;</span> /&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;cache-control&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;no-cache&quot;</span> /&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;expires&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;0&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>详细资料可以参考： <a href=\"http://www.cnblogs.com/qiumohanyu/p/5431859.html\">《Meta 标签用法大全》</a></p>\n<h5 id=\"22-主流浏览器内核私有属性-css-前缀\"><a href=\"#22-主流浏览器内核私有属性-css-前缀\" class=\"headerlink\" title=\"22.主流浏览器内核私有属性 css 前缀\"></a>22.主流浏览器内核私有属性 css 前缀</h5><p>mozilla 内核 （firefox,flock 等） -moz<br>webkit 内核 （safari,chrome 等） -webkit<br>opera 内核 （opera 浏览器） -o<br>trident 内核 （ie 浏览器） -ms</p>\n<h5 id=\"23-HTML-规范中为什么要求引用资源不加协议头-http-或者-https\"><a href=\"#23-HTML-规范中为什么要求引用资源不加协议头-http-或者-https\" class=\"headerlink\" title=\"23.HTML 规范中为什么要求引用资源不加协议头 http 或者 https\"></a>23.HTML 规范中为什么要求引用资源不加协议头 http 或者 https</h5><p>如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现<br>警告信息，不同浏览器警告信息展现形式不同。</p>\n<p>为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为<br>protocol-relative URL，暂且可译作协议相对 URL。</p>\n<p>如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似<br>的警告信息，同时还可以节省 5 字节的数据量。</p>\n<h5 id=\"sub-和-sup-标签\"><a href=\"#sub-和-sup-标签\" class=\"headerlink\" title=\"sub 和 sup 标签\"></a>sub 和 sup 标签</h5><p><sub></sub>用来表示下标 H<sub>2</sub>o 像这个样子</p>\n<p><sup></sup>用来表示上标 3<sup>2</sup></p>\n<hr>\n<h3 id=\"2-CSS\"><a href=\"#2-CSS\" class=\"headerlink\" title=\"2.CSS\"></a>2.CSS</h3><h5 id=\"1-介绍一下标准的-CSS-的盒子模型？低版本的浏览器盒子模型有什么不同\"><a href=\"#1-介绍一下标准的-CSS-的盒子模型？低版本的浏览器盒子模型有什么不同\" class=\"headerlink\" title=\"1.介绍一下标准的 CSS 的盒子模型？低版本的浏览器盒子模型有什么不同\"></a>1.介绍一下标准的 CSS 的盒子模型？低版本的浏览器盒子模型有什么不同</h5><p>盒模型都是由四个部分组成的，分别是 margin、border、padding 和 content。</p>\n<p>标准盒模型和 IE 盒模型的区别在于设置 width 和 height 时，所对应的范围不同。标准盒模型的 width 和 height 属性的<br>范围只包含了 content，而 IE 盒模型的 width 和 height 属性的范围包含了 border、padding 和 content。</p>\n<p>一般来说，我们可以通过修改元素的 box-sizing 属性来改变元素的盒模型。</p>\n<h5 id=\"2-css-选择器有哪些\"><a href=\"#2-css-选择器有哪些\" class=\"headerlink\" title=\"2.css 选择器有哪些\"></a>2.css 选择器有哪些</h5><table>\n<thead>\n<tr>\n<th><strong>选择器</strong></th>\n<th><strong>格式</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id 选择器</td>\n<td>#id</td>\n</tr>\n<tr>\n<td>类选择器</td>\n<td>.classname</td>\n</tr>\n<tr>\n<td>属性选择器</td>\n<td>a[ref=“eee”]</td>\n</tr>\n<tr>\n<td>伪类选择器</td>\n<td>li:last-child</td>\n</tr>\n<tr>\n<td>标签选择器</td>\n<td>div</td>\n</tr>\n<tr>\n<td>伪元素选择器</td>\n<td>li::after</td>\n</tr>\n<tr>\n<td>兄弟选择器</td>\n<td>li~a</td>\n</tr>\n<tr>\n<td>相邻兄弟选择器</td>\n<td>h1+p</td>\n</tr>\n<tr>\n<td>子选择器</td>\n<td>ul&gt;li</td>\n</tr>\n<tr>\n<td>后代选择器</td>\n<td>li a</td>\n</tr>\n<tr>\n<td>通配符选择器</td>\n<td>*</td>\n</tr>\n</tbody></table>\n<h5 id=\"3-before-和-after-中双冒号和单冒号的区别\"><a href=\"#3-before-和-after-中双冒号和单冒号的区别\" class=\"headerlink\" title=\"3.::before 和 :after 中双冒号和单冒号的区别\"></a>3.::before 和 :after 中双冒号和单冒号的区别</h5><p>在 css3 中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号<br>来表示伪元素。</p>\n<p>伪类一般匹配的是元素的一些特殊状态，如 hover、link 等，而伪元素一般匹配的特殊的位置，比如 after、before 等。</p>\n<h5 id=\"4-伪类与伪元素的区别\"><a href=\"#4-伪类与伪元素的区别\" class=\"headerlink\" title=\"4.伪类与伪元素的区别\"></a>4.伪类与伪元素的区别</h5><p>css 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句<br>话中的第一个字母，或者是列表中的第一个元素。</p>\n<p>伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的<br>元素时，我们可以通过:hover 来描述这个元素的状态。</p>\n<p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::be<br>fore 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p>\n<p>有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是 CSS3 的一部分，并尝试区分伪类和伪元素。大多数浏览<br>器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的 W3C 规范并未对此进行<br>特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。</p>\n<p>css 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。</p>\n<blockquote>\n<p>如何对伪元素进行操作？</p>\n</blockquote>\n<p><strong>伪类</strong> 用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover 来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 dom 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</p>\n<p><strong>伪元素</strong> 譬如::before 和::after 伪元素，用于在 CSS 渲染中向元素的头部或尾部插入内容，它们不受文档约束，也不影响文档本身，只影响最终样式。这些添加的内容不会出现在 DOM 中，仅仅是在 CSS 渲染层中加入。它不存在于文档中，所以 JS 无法直接操作它。而 jQuery 的选择器都是基于 DOM 元素的，因此也并不能直接操作伪元素。那该怎样操作伪元素的样式呢？为此总结整理一篇，以备查用。</p>\n<h2 id=\"有哪些伪元素\"><a href=\"#有哪些伪元素\" class=\"headerlink\" title=\"有哪些伪元素\"></a>有哪些伪元素</h2><p>:first-letter：向文本的第一个字母添加特殊样式。</p>\n<p>:first-line:　向文本的首行添加特殊样式。</p>\n<p>:before：在元素之前添加内容。</p>\n<p>:after：在元素之后添加内容。</p>\n<p>::placeholder：匹配占位符的文本，只有元素设置了 placeholder 属性时，该伪元素才能生效。</p>\n<p>::selection：CSS 伪元素应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）</p>\n<p>::backdrop(处于试验阶段)：用于改变全屏模式下的背景颜色，全屏模式的默认颜色为黑色。该伪元素只支持双冒号的形式</p>\n<h2 id=\"获取伪元素的属性值\"><a href=\"#获取伪元素的属性值\" class=\"headerlink\" title=\"获取伪元素的属性值\"></a>获取伪元素的属性值</h2><p>获取伪元素的属性值可以使用 window.getComputedStyle()方法，获取伪元素的 CSS 样式声明对象。然后利用 getPropertyValue 方法或直接使用键值访问都可以获取对应的属性值。</p>\n<p><strong>语法：</strong> window.getComputedStyle(element[, pseudoElement])</p>\n<p><strong>参数：</strong>element（Object）：伪元素的所在的 DOM 元素；pseudoElement（String）：伪元素类型。可选值有：”:after”、”:before”、”:first-line”、”:first-letter”、”:selection”、”:backdrop”；</p>\n"},{"title":"原型链","date":"2023-02-28T14:29:35.000Z","index_img":"/img/原型链.jpeg","banner_img":null,"_content":"\n> 理解 new 关键字的作用机制\n>\n> 理解 [[GET]] \n>\n> 对象有隐式原型，而函数有显示原型\n>\n> 隐式原型是指向显示原型的，然后一直递归下去，直到为null 就会返回undefined\n\n##  new 关键字的作用机制\n\n1.执行前\n\n- 1.绑定this为空对象\n- 2.让空对象[[Prototype]] --> 函数的 prototype属性\n- 2.1 所有对象都有[[Prototype]] (`__proto__`)\n- 2.2 所有的函数对象 -->prototype\n- 3.正常执行函数\n- 4.如果函数返回的基本类型，返回this的值，否则返回原函数的返回值\n\n**[[GET]]**\n\n如果要访问对象的属性，就需要用到一个隐式方法[[GET]]，会一直沿着原型链找，直到找到NULL的话，如果找不到这个属性的话会返回一个 undefined，而不会报错\n\n1. 判断对象里面有没有\n2. 判断它的` __proto__ `指向的对象里面有没有\n\n```js\nfunction foo(){\n\tconsole.log(1);\n}\n\nvar a = new foo(); //返回值：this指向的对象的引用\n\nconsole.log(a.b);  //undefined\n```\n\n原型链，共享方法和属性，节省内存开销\n\n```js\n//阿里 四面\nObject.prototype.a = function(){\n    console.log(\"a\");\n}\n\nFunction.prototype.b = function(){\n    console.log(\"b\");\n}\n\nvar F = function(){};\n\nvar f = new F();\n\nf.a();  //a\nf.b();  // 报错，没有b这个方法\nF.a();  //a\nF.b();   //b\n```\n\n\n\n\n\n![原型链](原型链.png)\n\n**静态方法和实例方法**\n\n```js\nfunction foo(){\n    console.log(1);\n}\n\n//静态方法\nfoo.a = 1;  //这个是写在函数上面的，实例是拿不到的\nvar bar = new foo();\nbar.a;  //undefined\n//实例方法\nfoo.prototype.a = a;  //这个是写在构造函数的上的，实例是可以拿到的\nvar bar = new foo();\nbar.a; //1\n```\n\n\n\n\n\n## 一些很奇怪的问题\n\n```js\n//Object 和 Function\n\n//关于{} 和 function(){}\n//Object.prototype.__proto__   = null;  //不是所有对象都是 Object的实例\n//Function.prototype.__prototype = Object.prototype;\n//Object.__proto__  = Function.prototype  new Function\n//Function.__proto__ = Function.prototype  new Function\n\n\n//只要是对象就有 __proto__  ,只要是函数就有 prototype\n//对象的隐式原型对象 指向 函数的显示原型对象\n//函数的隐式原型对象  指向  函数的显示原型对象\n```\n\n\n\n## 原型链的引用\n\n1. 面向对象编程 ->提高代码的可复用率 -> 更加合理的数据关系\n2. 原型链的本质：对象的隐式原型和构造函数的显示原型的连接\n3. 连接方式：new 关键字， 使用方式: [[GET]] 和 [[PUT]]\n\n## instanceof 的作用机制\n\n```js\nvar Studen = {\n    age:12,\n    name:\"spider\"\n}\n\nvar s1 = new Student;\n\nconsole.log(s1 instanceOf Object;)\n\n```\n\n作用：判断 s1 是不是 Object的一个实例\n\n1. s1.`__proto__` === Object.prototype\n2. s1.proto.proto === Object.prototype\n3. s1.proto = Student.prototype\n4.  s1.proto.proto = Student.prototype.proto = Object.prototype //true\n\n**手写一个 instanceOf**\n\n```js\nObject.myInstanceOf = funcrion(obj,fun){\n    if(obj === null) return false; //找到了终点\n    \n    if(Object.getPrototypeOf(obj) === fun.prototype){\n\t\treturn true;\n    }else{\n        return Object.myInstanceOf(Object.getPrototypeOf(obj),fun);\n        //Object.getPrototypeOf(obj);  //返回obj的隐式原型\n    }\n}\n```\n\n\n\n## 数组和类数组\n\n```js\n//数组\nvar a = [1,2,3];\n\na = {\n    \"0\":1,\n    \"1\":2,\n    \"2\":3,\n    \"length\":3,\n    __proto:Array.prototype\n}\n\n\n//类数组\na = {\n    \"0\":1,\n    \"1\":2,\n    \"2\":3,\n    \"length\":3,\n    __proto: XXX;   //这里是主要的区别，所以类数组拿不到数组的一些方法\n    //不能通过 Array.prototype 拿到一些数组的方法\n}\n\n```\n\n\n\n## RHS(读) 和 LHS (写)\n\n所有的程序都是一个状态机\n\n状态机也就是数据的集合  -> RHS 读和 LHS 写\n\nLHS          RHS\n\n[[PUT]]    [[GET]]\n\n**修改一个对象的属性**\n\n[[PUT]]  --> LHS\n\n1.判断对象里面有没有属性\n\n如果找到了\n\n- 如果是基本类型： 覆盖\n- 如果是引用类型：\n\t- 是对引用类型的引用 ---> 覆盖\n\t- 对引用类型的访问  ---> 修改\n\n2.如果没有\n\n- 沿着原型链找\n- 如果没有找到，就一直找，直到原型链终点\n- 如果终点都没有的话，就会自己创建一个\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/原型链.md","raw":"---\ntitle: 原型链\ndate: 2023-2-28 22:29:35\ncategory: 前端\ntags: 基础知识点\nindex_img: /img/原型链.jpeg\nbanner_img:\n---\n\n> 理解 new 关键字的作用机制\n>\n> 理解 [[GET]] \n>\n> 对象有隐式原型，而函数有显示原型\n>\n> 隐式原型是指向显示原型的，然后一直递归下去，直到为null 就会返回undefined\n\n##  new 关键字的作用机制\n\n1.执行前\n\n- 1.绑定this为空对象\n- 2.让空对象[[Prototype]] --> 函数的 prototype属性\n- 2.1 所有对象都有[[Prototype]] (`__proto__`)\n- 2.2 所有的函数对象 -->prototype\n- 3.正常执行函数\n- 4.如果函数返回的基本类型，返回this的值，否则返回原函数的返回值\n\n**[[GET]]**\n\n如果要访问对象的属性，就需要用到一个隐式方法[[GET]]，会一直沿着原型链找，直到找到NULL的话，如果找不到这个属性的话会返回一个 undefined，而不会报错\n\n1. 判断对象里面有没有\n2. 判断它的` __proto__ `指向的对象里面有没有\n\n```js\nfunction foo(){\n\tconsole.log(1);\n}\n\nvar a = new foo(); //返回值：this指向的对象的引用\n\nconsole.log(a.b);  //undefined\n```\n\n原型链，共享方法和属性，节省内存开销\n\n```js\n//阿里 四面\nObject.prototype.a = function(){\n    console.log(\"a\");\n}\n\nFunction.prototype.b = function(){\n    console.log(\"b\");\n}\n\nvar F = function(){};\n\nvar f = new F();\n\nf.a();  //a\nf.b();  // 报错，没有b这个方法\nF.a();  //a\nF.b();   //b\n```\n\n\n\n\n\n![原型链](原型链.png)\n\n**静态方法和实例方法**\n\n```js\nfunction foo(){\n    console.log(1);\n}\n\n//静态方法\nfoo.a = 1;  //这个是写在函数上面的，实例是拿不到的\nvar bar = new foo();\nbar.a;  //undefined\n//实例方法\nfoo.prototype.a = a;  //这个是写在构造函数的上的，实例是可以拿到的\nvar bar = new foo();\nbar.a; //1\n```\n\n\n\n\n\n## 一些很奇怪的问题\n\n```js\n//Object 和 Function\n\n//关于{} 和 function(){}\n//Object.prototype.__proto__   = null;  //不是所有对象都是 Object的实例\n//Function.prototype.__prototype = Object.prototype;\n//Object.__proto__  = Function.prototype  new Function\n//Function.__proto__ = Function.prototype  new Function\n\n\n//只要是对象就有 __proto__  ,只要是函数就有 prototype\n//对象的隐式原型对象 指向 函数的显示原型对象\n//函数的隐式原型对象  指向  函数的显示原型对象\n```\n\n\n\n## 原型链的引用\n\n1. 面向对象编程 ->提高代码的可复用率 -> 更加合理的数据关系\n2. 原型链的本质：对象的隐式原型和构造函数的显示原型的连接\n3. 连接方式：new 关键字， 使用方式: [[GET]] 和 [[PUT]]\n\n## instanceof 的作用机制\n\n```js\nvar Studen = {\n    age:12,\n    name:\"spider\"\n}\n\nvar s1 = new Student;\n\nconsole.log(s1 instanceOf Object;)\n\n```\n\n作用：判断 s1 是不是 Object的一个实例\n\n1. s1.`__proto__` === Object.prototype\n2. s1.proto.proto === Object.prototype\n3. s1.proto = Student.prototype\n4.  s1.proto.proto = Student.prototype.proto = Object.prototype //true\n\n**手写一个 instanceOf**\n\n```js\nObject.myInstanceOf = funcrion(obj,fun){\n    if(obj === null) return false; //找到了终点\n    \n    if(Object.getPrototypeOf(obj) === fun.prototype){\n\t\treturn true;\n    }else{\n        return Object.myInstanceOf(Object.getPrototypeOf(obj),fun);\n        //Object.getPrototypeOf(obj);  //返回obj的隐式原型\n    }\n}\n```\n\n\n\n## 数组和类数组\n\n```js\n//数组\nvar a = [1,2,3];\n\na = {\n    \"0\":1,\n    \"1\":2,\n    \"2\":3,\n    \"length\":3,\n    __proto:Array.prototype\n}\n\n\n//类数组\na = {\n    \"0\":1,\n    \"1\":2,\n    \"2\":3,\n    \"length\":3,\n    __proto: XXX;   //这里是主要的区别，所以类数组拿不到数组的一些方法\n    //不能通过 Array.prototype 拿到一些数组的方法\n}\n\n```\n\n\n\n## RHS(读) 和 LHS (写)\n\n所有的程序都是一个状态机\n\n状态机也就是数据的集合  -> RHS 读和 LHS 写\n\nLHS          RHS\n\n[[PUT]]    [[GET]]\n\n**修改一个对象的属性**\n\n[[PUT]]  --> LHS\n\n1.判断对象里面有没有属性\n\n如果找到了\n\n- 如果是基本类型： 覆盖\n- 如果是引用类型：\n\t- 是对引用类型的引用 ---> 覆盖\n\t- 对引用类型的访问  ---> 修改\n\n2.如果没有\n\n- 沿着原型链找\n- 如果没有找到，就一直找，直到原型链终点\n- 如果终点都没有的话，就会自己创建一个\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"原型链","published":1,"updated":"2024-11-17T13:58:10.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpo002773t3e4g67kzk","content":"<blockquote>\n<p>理解 new 关键字的作用机制</p>\n<p>理解 [[GET]] </p>\n<p>对象有隐式原型，而函数有显示原型</p>\n<p>隐式原型是指向显示原型的，然后一直递归下去，直到为null 就会返回undefined</p>\n</blockquote>\n<h2 id=\"new-关键字的作用机制\"><a href=\"#new-关键字的作用机制\" class=\"headerlink\" title=\"new 关键字的作用机制\"></a>new 关键字的作用机制</h2><p>1.执行前</p>\n<ul>\n<li>1.绑定this为空对象</li>\n<li>2.让空对象[[Prototype]] –&gt; 函数的 prototype属性</li>\n<li>2.1 所有对象都有[[Prototype]] (<code>__proto__</code>)</li>\n<li>2.2 所有的函数对象 –&gt;prototype</li>\n<li>3.正常执行函数</li>\n<li>4.如果函数返回的基本类型，返回this的值，否则返回原函数的返回值</li>\n</ul>\n<p><strong>[[GET]]</strong></p>\n<p>如果要访问对象的属性，就需要用到一个隐式方法[[GET]]，会一直沿着原型链找，直到找到NULL的话，如果找不到这个属性的话会返回一个 undefined，而不会报错</p>\n<ol>\n<li>判断对象里面有没有</li>\n<li>判断它的<code>__proto__</code>指向的对象里面有没有</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">//返回值：this指向的对象的引用</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-property\">b</span>);  <span class=\"hljs-comment\">//undefined</span><br></code></pre></td></tr></table></figure>\n\n<p>原型链，共享方法和属性，节省内存开销</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//阿里 四面</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">a</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>&#125;<br><br><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;b&quot;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> F = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;&#125;;<br><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">F</span>();<br><br>f.<span class=\"hljs-title function_\">a</span>();  <span class=\"hljs-comment\">//a</span><br>f.<span class=\"hljs-title function_\">b</span>();  <span class=\"hljs-comment\">// 报错，没有b这个方法</span><br>F.<span class=\"hljs-title function_\">a</span>();  <span class=\"hljs-comment\">//a</span><br>F.<span class=\"hljs-title function_\">b</span>();   <span class=\"hljs-comment\">//b</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<p><img src=\"/2023/02/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE.png\" alt=\"原型链\"></p>\n<p><strong>静态方法和实例方法</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-comment\">//静态方法</span><br>foo.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">//这个是写在函数上面的，实例是拿不到的</span><br><span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">foo</span>();<br>bar.<span class=\"hljs-property\">a</span>;  <span class=\"hljs-comment\">//undefined</span><br><span class=\"hljs-comment\">//实例方法</span><br>foo.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">a</span> = a;  <span class=\"hljs-comment\">//这个是写在构造函数的上的，实例是可以拿到的</span><br><span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">foo</span>();<br>bar.<span class=\"hljs-property\">a</span>; <span class=\"hljs-comment\">//1</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"一些很奇怪的问题\"><a href=\"#一些很奇怪的问题\" class=\"headerlink\" title=\"一些很奇怪的问题\"></a>一些很奇怪的问题</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//Object 和 Function</span><br><br><span class=\"hljs-comment\">//关于&#123;&#125; 和 function()&#123;&#125;</span><br><span class=\"hljs-comment\">//Object.prototype.__proto__   = null;  //不是所有对象都是 Object的实例</span><br><span class=\"hljs-comment\">//Function.prototype.__prototype = Object.prototype;</span><br><span class=\"hljs-comment\">//Object.__proto__  = Function.prototype  new Function</span><br><span class=\"hljs-comment\">//Function.__proto__ = Function.prototype  new Function</span><br><br><br><span class=\"hljs-comment\">//只要是对象就有 __proto__  ,只要是函数就有 prototype</span><br><span class=\"hljs-comment\">//对象的隐式原型对象 指向 函数的显示原型对象</span><br><span class=\"hljs-comment\">//函数的隐式原型对象  指向  函数的显示原型对象</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"原型链的引用\"><a href=\"#原型链的引用\" class=\"headerlink\" title=\"原型链的引用\"></a>原型链的引用</h2><ol>\n<li>面向对象编程 -&gt;提高代码的可复用率 -&gt; 更加合理的数据关系</li>\n<li>原型链的本质：对象的隐式原型和构造函数的显示原型的连接</li>\n<li>连接方式：new 关键字， 使用方式: [[GET]] 和 [[PUT]]</li>\n</ol>\n<h2 id=\"instanceof-的作用机制\"><a href=\"#instanceof-的作用机制\" class=\"headerlink\" title=\"instanceof 的作用机制\"></a>instanceof 的作用机制</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">Studen</span> = &#123;<br>    <span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">12</span>,<br>    <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;spider&quot;</span><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(s1 instanceOf <span class=\"hljs-title class_\">Object</span>;)<br><br></code></pre></td></tr></table></figure>\n\n<p>作用：判断 s1 是不是 Object的一个实例</p>\n<ol>\n<li>s1.<code>__proto__</code> === Object.prototype</li>\n<li>s1.proto.proto === Object.prototype</li>\n<li>s1.proto = Student.prototype</li>\n<li> s1.proto.proto = Student.prototype.proto = Object.prototype //true</li>\n</ol>\n<p><strong>手写一个 instanceOf</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\">myInstanceOf</span> = <span class=\"hljs-title function_\">funcrion</span>(<span class=\"hljs-params\">obj,fun</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span>(obj === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">//找到了终点</span><br>    <br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj) === fun.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>)&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">myInstanceOf</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj),fun);<br>        <span class=\"hljs-comment\">//Object.getPrototypeOf(obj);  //返回obj的隐式原型</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"数组和类数组\"><a href=\"#数组和类数组\" class=\"headerlink\" title=\"数组和类数组\"></a>数组和类数组</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//数组</span><br><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><br>a = &#123;<br>    <span class=\"hljs-string\">&quot;0&quot;</span>:<span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-string\">&quot;1&quot;</span>:<span class=\"hljs-number\">2</span>,<br>    <span class=\"hljs-string\">&quot;2&quot;</span>:<span class=\"hljs-number\">3</span>,<br>    <span class=\"hljs-string\">&quot;length&quot;</span>:<span class=\"hljs-number\">3</span>,<br>    <span class=\"hljs-attr\">__proto</span>:<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span><br>&#125;<br><br><br><span class=\"hljs-comment\">//类数组</span><br>a = &#123;<br>    <span class=\"hljs-string\">&quot;0&quot;</span>:<span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-string\">&quot;1&quot;</span>:<span class=\"hljs-number\">2</span>,<br>    <span class=\"hljs-string\">&quot;2&quot;</span>:<span class=\"hljs-number\">3</span>,<br>    <span class=\"hljs-string\">&quot;length&quot;</span>:<span class=\"hljs-number\">3</span>,<br>    <span class=\"hljs-attr\">__proto</span>: <span class=\"hljs-variable constant_\">XXX</span>;   <span class=\"hljs-comment\">//这里是主要的区别，所以类数组拿不到数组的一些方法</span><br>    <span class=\"hljs-comment\">//不能通过 Array.prototype 拿到一些数组的方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"RHS-读-和-LHS-写\"><a href=\"#RHS-读-和-LHS-写\" class=\"headerlink\" title=\"RHS(读) 和 LHS (写)\"></a>RHS(读) 和 LHS (写)</h2><p>所有的程序都是一个状态机</p>\n<p>状态机也就是数据的集合  -&gt; RHS 读和 LHS 写</p>\n<p>LHS          RHS</p>\n<p>[[PUT]]    [[GET]]</p>\n<p><strong>修改一个对象的属性</strong></p>\n<p>[[PUT]]  –&gt; LHS</p>\n<p>1.判断对象里面有没有属性</p>\n<p>如果找到了</p>\n<ul>\n<li>如果是基本类型： 覆盖</li>\n<li>如果是引用类型：<ul>\n<li>是对引用类型的引用 —&gt; 覆盖</li>\n<li>对引用类型的访问  —&gt; 修改</li>\n</ul>\n</li>\n</ul>\n<p>2.如果没有</p>\n<ul>\n<li>沿着原型链找</li>\n<li>如果没有找到，就一直找，直到原型链终点</li>\n<li>如果终点都没有的话，就会自己创建一个</li>\n</ul>\n","site":{"data":{}},"wordcount":2524,"excerpt":"","more":"<blockquote>\n<p>理解 new 关键字的作用机制</p>\n<p>理解 [[GET]] </p>\n<p>对象有隐式原型，而函数有显示原型</p>\n<p>隐式原型是指向显示原型的，然后一直递归下去，直到为null 就会返回undefined</p>\n</blockquote>\n<h2 id=\"new-关键字的作用机制\"><a href=\"#new-关键字的作用机制\" class=\"headerlink\" title=\"new 关键字的作用机制\"></a>new 关键字的作用机制</h2><p>1.执行前</p>\n<ul>\n<li>1.绑定this为空对象</li>\n<li>2.让空对象[[Prototype]] –&gt; 函数的 prototype属性</li>\n<li>2.1 所有对象都有[[Prototype]] (<code>__proto__</code>)</li>\n<li>2.2 所有的函数对象 –&gt;prototype</li>\n<li>3.正常执行函数</li>\n<li>4.如果函数返回的基本类型，返回this的值，否则返回原函数的返回值</li>\n</ul>\n<p><strong>[[GET]]</strong></p>\n<p>如果要访问对象的属性，就需要用到一个隐式方法[[GET]]，会一直沿着原型链找，直到找到NULL的话，如果找不到这个属性的话会返回一个 undefined，而不会报错</p>\n<ol>\n<li>判断对象里面有没有</li>\n<li>判断它的<code>__proto__</code>指向的对象里面有没有</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">//返回值：this指向的对象的引用</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-property\">b</span>);  <span class=\"hljs-comment\">//undefined</span><br></code></pre></td></tr></table></figure>\n\n<p>原型链，共享方法和属性，节省内存开销</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//阿里 四面</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">a</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>&#125;<br><br><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;b&quot;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> F = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;&#125;;<br><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">F</span>();<br><br>f.<span class=\"hljs-title function_\">a</span>();  <span class=\"hljs-comment\">//a</span><br>f.<span class=\"hljs-title function_\">b</span>();  <span class=\"hljs-comment\">// 报错，没有b这个方法</span><br>F.<span class=\"hljs-title function_\">a</span>();  <span class=\"hljs-comment\">//a</span><br>F.<span class=\"hljs-title function_\">b</span>();   <span class=\"hljs-comment\">//b</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<p><img src=\"/2023/02/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE.png\" alt=\"原型链\"></p>\n<p><strong>静态方法和实例方法</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-comment\">//静态方法</span><br>foo.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">//这个是写在函数上面的，实例是拿不到的</span><br><span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">foo</span>();<br>bar.<span class=\"hljs-property\">a</span>;  <span class=\"hljs-comment\">//undefined</span><br><span class=\"hljs-comment\">//实例方法</span><br>foo.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">a</span> = a;  <span class=\"hljs-comment\">//这个是写在构造函数的上的，实例是可以拿到的</span><br><span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">foo</span>();<br>bar.<span class=\"hljs-property\">a</span>; <span class=\"hljs-comment\">//1</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"一些很奇怪的问题\"><a href=\"#一些很奇怪的问题\" class=\"headerlink\" title=\"一些很奇怪的问题\"></a>一些很奇怪的问题</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//Object 和 Function</span><br><br><span class=\"hljs-comment\">//关于&#123;&#125; 和 function()&#123;&#125;</span><br><span class=\"hljs-comment\">//Object.prototype.__proto__   = null;  //不是所有对象都是 Object的实例</span><br><span class=\"hljs-comment\">//Function.prototype.__prototype = Object.prototype;</span><br><span class=\"hljs-comment\">//Object.__proto__  = Function.prototype  new Function</span><br><span class=\"hljs-comment\">//Function.__proto__ = Function.prototype  new Function</span><br><br><br><span class=\"hljs-comment\">//只要是对象就有 __proto__  ,只要是函数就有 prototype</span><br><span class=\"hljs-comment\">//对象的隐式原型对象 指向 函数的显示原型对象</span><br><span class=\"hljs-comment\">//函数的隐式原型对象  指向  函数的显示原型对象</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"原型链的引用\"><a href=\"#原型链的引用\" class=\"headerlink\" title=\"原型链的引用\"></a>原型链的引用</h2><ol>\n<li>面向对象编程 -&gt;提高代码的可复用率 -&gt; 更加合理的数据关系</li>\n<li>原型链的本质：对象的隐式原型和构造函数的显示原型的连接</li>\n<li>连接方式：new 关键字， 使用方式: [[GET]] 和 [[PUT]]</li>\n</ol>\n<h2 id=\"instanceof-的作用机制\"><a href=\"#instanceof-的作用机制\" class=\"headerlink\" title=\"instanceof 的作用机制\"></a>instanceof 的作用机制</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">Studen</span> = &#123;<br>    <span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">12</span>,<br>    <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;spider&quot;</span><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(s1 instanceOf <span class=\"hljs-title class_\">Object</span>;)<br><br></code></pre></td></tr></table></figure>\n\n<p>作用：判断 s1 是不是 Object的一个实例</p>\n<ol>\n<li>s1.<code>__proto__</code> === Object.prototype</li>\n<li>s1.proto.proto === Object.prototype</li>\n<li>s1.proto = Student.prototype</li>\n<li> s1.proto.proto = Student.prototype.proto = Object.prototype //true</li>\n</ol>\n<p><strong>手写一个 instanceOf</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\">myInstanceOf</span> = <span class=\"hljs-title function_\">funcrion</span>(<span class=\"hljs-params\">obj,fun</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span>(obj === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">//找到了终点</span><br>    <br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj) === fun.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>)&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">myInstanceOf</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj),fun);<br>        <span class=\"hljs-comment\">//Object.getPrototypeOf(obj);  //返回obj的隐式原型</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"数组和类数组\"><a href=\"#数组和类数组\" class=\"headerlink\" title=\"数组和类数组\"></a>数组和类数组</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//数组</span><br><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><br>a = &#123;<br>    <span class=\"hljs-string\">&quot;0&quot;</span>:<span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-string\">&quot;1&quot;</span>:<span class=\"hljs-number\">2</span>,<br>    <span class=\"hljs-string\">&quot;2&quot;</span>:<span class=\"hljs-number\">3</span>,<br>    <span class=\"hljs-string\">&quot;length&quot;</span>:<span class=\"hljs-number\">3</span>,<br>    <span class=\"hljs-attr\">__proto</span>:<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span><br>&#125;<br><br><br><span class=\"hljs-comment\">//类数组</span><br>a = &#123;<br>    <span class=\"hljs-string\">&quot;0&quot;</span>:<span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-string\">&quot;1&quot;</span>:<span class=\"hljs-number\">2</span>,<br>    <span class=\"hljs-string\">&quot;2&quot;</span>:<span class=\"hljs-number\">3</span>,<br>    <span class=\"hljs-string\">&quot;length&quot;</span>:<span class=\"hljs-number\">3</span>,<br>    <span class=\"hljs-attr\">__proto</span>: <span class=\"hljs-variable constant_\">XXX</span>;   <span class=\"hljs-comment\">//这里是主要的区别，所以类数组拿不到数组的一些方法</span><br>    <span class=\"hljs-comment\">//不能通过 Array.prototype 拿到一些数组的方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"RHS-读-和-LHS-写\"><a href=\"#RHS-读-和-LHS-写\" class=\"headerlink\" title=\"RHS(读) 和 LHS (写)\"></a>RHS(读) 和 LHS (写)</h2><p>所有的程序都是一个状态机</p>\n<p>状态机也就是数据的集合  -&gt; RHS 读和 LHS 写</p>\n<p>LHS          RHS</p>\n<p>[[PUT]]    [[GET]]</p>\n<p><strong>修改一个对象的属性</strong></p>\n<p>[[PUT]]  –&gt; LHS</p>\n<p>1.判断对象里面有没有属性</p>\n<p>如果找到了</p>\n<ul>\n<li>如果是基本类型： 覆盖</li>\n<li>如果是引用类型：<ul>\n<li>是对引用类型的引用 —&gt; 覆盖</li>\n<li>对引用类型的访问  —&gt; 修改</li>\n</ul>\n</li>\n</ul>\n<p>2.如果没有</p>\n<ul>\n<li>沿着原型链找</li>\n<li>如果没有找到，就一直找，直到原型链终点</li>\n<li>如果终点都没有的话，就会自己创建一个</li>\n</ul>\n"},{"title":"变量提升","date":"2021-04-24T12:44:18.000Z","index_img":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd4ac36c685b4177907bb98a8c13c9bd~tplv-k3u1fbpfcp-watermark.image","banner_img":"https://w.wallhaven.cc/full/wy/wallhaven-wyk5rr.jpg","_content":"\n## 关于变量提升\n\nJavaScript 和其他的强类型的语言有所不同，它是`弱类型`的\n\n所以 JavaScript 定义变量是不需要考虑是什么类型的，在 ES6 之前我们一般使用 var 来声明一个变量，在 ES6 之后我们会使用 let 和 const 来定义变量(常量)\n\n**那么什么是变量提升呢？**\n\n> 打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被\"移动\"到了最上面---《你不知道的 Javscript 上卷》\n\n在直觉上我们会认为 JavaScript 代码在执行的时候是由上到下一行一行执行的，但是实际上这并不完全准确，有一种特殊情况会导致整个假设错误\n\n```javascript\na = 2;\nvar a;\nconsole.log(a);\n```\n\n你认为这个里面会输出什么呢？\n\n**undefined or 2**\n\n正确答案是 2 ，那么为什么是 2 呢，按道理 a 应该是重新赋值了呀(a=undefined)\n\n**其实这里面就是因为变量提升**，实际上他会变成这样子的：\n\n```javascript\nvar a;\na = 2;\nconsole(a); //2\n```\n\n下面我们再看一段代码\n\n```javascript\nconsole.log(a);\nvar a = 2;\n```\n\n这次会输出什么呢？是 2 ? undefined ? ReferenceError\n\n其实是 undefined,其实是这样子的：\n\n```javascript\nvar a;\nconsole.log(a); // a is undefined\na = 2;\n```\n\n#### 下面我们来解释一下这个是为什么呢\n\n引擎会在解释 JavaScript 代码之前`首先对其进行编译`。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将他们关联起来\n\n因此，正确的思考路线是，包括`变量和函数`在内的所有声明都会在任何代码被执行前`首先被处理`\n\n当你看到 `var a = 2` 时,可能会认为这是一个声明，但 JavaScript 实际上会将其看成两个声明: `var a ` 和 `a = 2`，第一个定义声明是在编译阶段进行的，第二个赋值声明会被留在原地等待执行阶段，其实就是先有`声明`后有`赋值`\n\n> 只有声明本身会被提升，而赋值或其他的运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏\n\n```javascript\nfoo()\n\nfunction(){\n\tconsole.log(a) \t//undefined\n    var a = 2\n}\n```\n\nfoo 函数的声明(这个例子还包括实际函数的蕴含值)被提升了，因此第一行中的调用可以正常执行\n\n另外值得注意的是，`每个作用域`都会进行提升操作。尽管前面大部分的代码片段已经简化了(因为他们只包含全局作用域)，而我们正在讨论的 foo(...)函数本身也会在内部对`var a `进行提升(显然并不是提升到了整个程序的最上方)。因此这段代码实际上会被理解为下面的形式：\n\n```javascript\nfunction foo() {\n  var a;\n  console.log(a); //undefined\n  a = 2;\n}\nfoo();\n```\n\n可以看到，函数声明会提升，但是函数表达式不会被提升\n\n**函数优先**\n\n函数声明和变量声明都会被提升，但是一个值得注意的细节(这个细节可以出现在有很多个\"重复\"声明的代码中)是函数会首先被提升，然后才是变量\n\n考虑以下代码：\n\n```javascript\nfoo(); //1\n\nvar foo;\n\nfunction foo() {\n  console.log(1);\n}\n\nfoo = function () {\n  console.log(2);\n};\n```\n\n会输出 1 而不是 2 ，这个代码片段会被引擎解释理解为如下形式：\n\n```javascript\nfunction foo() {\n  console.log(1);\n}\n\nfoo(); //1\n\nfoo = function () {\n  console.log(2);\n};\n```\n\n注意，`var foo` 尽管出现在 function foo()...的声明之前，但它是重复的声明(因此被忽略了)，因为函数声明会被提升到普通变量之前\n\n尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的\n\n```javascript\nfoo(); //3\n\nfunction foo() {\n  consloe.log(1);\n}\n\nvar foo = function () {\n  console.log(2);\n};\n\nfunction foo() {\n  console.log(3);\n}\n```\n\n虽然这些听起来都是些无用的学院理论，但是它说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题\n\n一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码暗示的那样可以被条件判断所控制：\n\n```javascript\nfoo(); //TypeError: foo is not a function\n\nvar a = true;\n\nif (a) {\n  function foo() {\n    console.log(\"a\");\n  }\n} else {\n  function foo() {\n    console.log(\"b\");\n  }\n}\n```\n","source":"_posts/变量提升.md","raw":"---\ntitle: 变量提升\ndate: 2021-04-24 20:44:18\ntags: 变量提升\ncategories: JavaScript\nindex_img: https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd4ac36c685b4177907bb98a8c13c9bd~tplv-k3u1fbpfcp-watermark.image\nbanner_img: https://w.wallhaven.cc/full/wy/wallhaven-wyk5rr.jpg\n---\n\n## 关于变量提升\n\nJavaScript 和其他的强类型的语言有所不同，它是`弱类型`的\n\n所以 JavaScript 定义变量是不需要考虑是什么类型的，在 ES6 之前我们一般使用 var 来声明一个变量，在 ES6 之后我们会使用 let 和 const 来定义变量(常量)\n\n**那么什么是变量提升呢？**\n\n> 打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被\"移动\"到了最上面---《你不知道的 Javscript 上卷》\n\n在直觉上我们会认为 JavaScript 代码在执行的时候是由上到下一行一行执行的，但是实际上这并不完全准确，有一种特殊情况会导致整个假设错误\n\n```javascript\na = 2;\nvar a;\nconsole.log(a);\n```\n\n你认为这个里面会输出什么呢？\n\n**undefined or 2**\n\n正确答案是 2 ，那么为什么是 2 呢，按道理 a 应该是重新赋值了呀(a=undefined)\n\n**其实这里面就是因为变量提升**，实际上他会变成这样子的：\n\n```javascript\nvar a;\na = 2;\nconsole(a); //2\n```\n\n下面我们再看一段代码\n\n```javascript\nconsole.log(a);\nvar a = 2;\n```\n\n这次会输出什么呢？是 2 ? undefined ? ReferenceError\n\n其实是 undefined,其实是这样子的：\n\n```javascript\nvar a;\nconsole.log(a); // a is undefined\na = 2;\n```\n\n#### 下面我们来解释一下这个是为什么呢\n\n引擎会在解释 JavaScript 代码之前`首先对其进行编译`。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将他们关联起来\n\n因此，正确的思考路线是，包括`变量和函数`在内的所有声明都会在任何代码被执行前`首先被处理`\n\n当你看到 `var a = 2` 时,可能会认为这是一个声明，但 JavaScript 实际上会将其看成两个声明: `var a ` 和 `a = 2`，第一个定义声明是在编译阶段进行的，第二个赋值声明会被留在原地等待执行阶段，其实就是先有`声明`后有`赋值`\n\n> 只有声明本身会被提升，而赋值或其他的运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏\n\n```javascript\nfoo()\n\nfunction(){\n\tconsole.log(a) \t//undefined\n    var a = 2\n}\n```\n\nfoo 函数的声明(这个例子还包括实际函数的蕴含值)被提升了，因此第一行中的调用可以正常执行\n\n另外值得注意的是，`每个作用域`都会进行提升操作。尽管前面大部分的代码片段已经简化了(因为他们只包含全局作用域)，而我们正在讨论的 foo(...)函数本身也会在内部对`var a `进行提升(显然并不是提升到了整个程序的最上方)。因此这段代码实际上会被理解为下面的形式：\n\n```javascript\nfunction foo() {\n  var a;\n  console.log(a); //undefined\n  a = 2;\n}\nfoo();\n```\n\n可以看到，函数声明会提升，但是函数表达式不会被提升\n\n**函数优先**\n\n函数声明和变量声明都会被提升，但是一个值得注意的细节(这个细节可以出现在有很多个\"重复\"声明的代码中)是函数会首先被提升，然后才是变量\n\n考虑以下代码：\n\n```javascript\nfoo(); //1\n\nvar foo;\n\nfunction foo() {\n  console.log(1);\n}\n\nfoo = function () {\n  console.log(2);\n};\n```\n\n会输出 1 而不是 2 ，这个代码片段会被引擎解释理解为如下形式：\n\n```javascript\nfunction foo() {\n  console.log(1);\n}\n\nfoo(); //1\n\nfoo = function () {\n  console.log(2);\n};\n```\n\n注意，`var foo` 尽管出现在 function foo()...的声明之前，但它是重复的声明(因此被忽略了)，因为函数声明会被提升到普通变量之前\n\n尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的\n\n```javascript\nfoo(); //3\n\nfunction foo() {\n  consloe.log(1);\n}\n\nvar foo = function () {\n  console.log(2);\n};\n\nfunction foo() {\n  console.log(3);\n}\n```\n\n虽然这些听起来都是些无用的学院理论，但是它说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题\n\n一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码暗示的那样可以被条件判断所控制：\n\n```javascript\nfoo(); //TypeError: foo is not a function\n\nvar a = true;\n\nif (a) {\n  function foo() {\n    console.log(\"a\");\n  }\n} else {\n  function foo() {\n    console.log(\"b\");\n  }\n}\n```\n","slug":"变量提升","published":1,"updated":"2024-11-17T13:58:10.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpo002a73t3e0sic4k1","content":"<h2 id=\"关于变量提升\"><a href=\"#关于变量提升\" class=\"headerlink\" title=\"关于变量提升\"></a>关于变量提升</h2><p>JavaScript 和其他的强类型的语言有所不同，它是<code>弱类型</code>的</p>\n<p>所以 JavaScript 定义变量是不需要考虑是什么类型的，在 ES6 之前我们一般使用 var 来声明一个变量，在 ES6 之后我们会使用 let 和 const 来定义变量(常量)</p>\n<p><strong>那么什么是变量提升呢？</strong></p>\n<blockquote>\n<p>打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被”移动”到了最上面—《你不知道的 Javscript 上卷》</p>\n</blockquote>\n<p>在直觉上我们会认为 JavaScript 代码在执行的时候是由上到下一行一行执行的，但是实际上这并不完全准确，有一种特殊情况会导致整个假设错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-keyword\">var</span> a;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a);<br></code></pre></td></tr></table></figure>\n\n<p>你认为这个里面会输出什么呢？</p>\n<p><strong>undefined or 2</strong></p>\n<p>正确答案是 2 ，那么为什么是 2 呢，按道理 a 应该是重新赋值了呀(a=undefined)</p>\n<p><strong>其实这里面就是因为变量提升</strong>，实际上他会变成这样子的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a;<br>a = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-title function_\">console</span>(a); <span class=\"hljs-comment\">//2</span><br></code></pre></td></tr></table></figure>\n\n<p>下面我们再看一段代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a);<br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这次会输出什么呢？是 2 ? undefined ? ReferenceError</p>\n<p>其实是 undefined,其实是这样子的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// a is undefined</span><br>a = <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"下面我们来解释一下这个是为什么呢\"><a href=\"#下面我们来解释一下这个是为什么呢\" class=\"headerlink\" title=\"下面我们来解释一下这个是为什么呢\"></a>下面我们来解释一下这个是为什么呢</h4><p>引擎会在解释 JavaScript 代码之前<code>首先对其进行编译</code>。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将他们关联起来</p>\n<p>因此，正确的思考路线是，包括<code>变量和函数</code>在内的所有声明都会在任何代码被执行前<code>首先被处理</code></p>\n<p>当你看到 <code>var a = 2</code> 时,可能会认为这是一个声明，但 JavaScript 实际上会将其看成两个声明: <code>var a </code> 和 <code>a = 2</code>，第一个定义声明是在编译阶段进行的，第二个赋值声明会被留在原地等待执行阶段，其实就是先有<code>声明</code>后有<code>赋值</code></p>\n<blockquote>\n<p>只有声明本身会被提升，而赋值或其他的运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">foo</span>()<br><br><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a) \t<span class=\"hljs-comment\">//undefined</span><br>    <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>foo 函数的声明(这个例子还包括实际函数的蕴含值)被提升了，因此第一行中的调用可以正常执行</p>\n<p>另外值得注意的是，<code>每个作用域</code>都会进行提升操作。尽管前面大部分的代码片段已经简化了(因为他们只包含全局作用域)，而我们正在讨论的 foo(…)函数本身也会在内部对<code>var a </code>进行提升(显然并不是提升到了整个程序的最上方)。因此这段代码实际上会被理解为下面的形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> a;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">//undefined</span><br>  a = <span class=\"hljs-number\">2</span>;<br>&#125;<br><span class=\"hljs-title function_\">foo</span>();<br></code></pre></td></tr></table></figure>\n\n<p>可以看到，函数声明会提升，但是函数表达式不会被提升</p>\n<p><strong>函数优先</strong></p>\n<p>函数声明和变量声明都会被提升，但是一个值得注意的细节(这个细节可以出现在有很多个”重复”声明的代码中)是函数会首先被提升，然后才是变量</p>\n<p>考虑以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">//1</span><br><br><span class=\"hljs-keyword\">var</span> foo;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>);<br>&#125;<br><br>foo = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">2</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>会输出 1 而不是 2 ，这个代码片段会被引擎解释理解为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">//1</span><br><br>foo = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">2</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>注意，<code>var foo</code> 尽管出现在 function foo()…的声明之前，但它是重复的声明(因此被忽略了)，因为函数声明会被提升到普通变量之前</p>\n<p>尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">//3</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  consloe.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">2</span>);<br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>虽然这些听起来都是些无用的学院理论，但是它说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题</p>\n<p>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码暗示的那样可以被条件判断所控制：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">//TypeError: foo is not a function</span><br><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-literal\">true</span>;<br><br><span class=\"hljs-keyword\">if</span> (a) &#123;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>  &#125;<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;b&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":2039,"excerpt":"","more":"<h2 id=\"关于变量提升\"><a href=\"#关于变量提升\" class=\"headerlink\" title=\"关于变量提升\"></a>关于变量提升</h2><p>JavaScript 和其他的强类型的语言有所不同，它是<code>弱类型</code>的</p>\n<p>所以 JavaScript 定义变量是不需要考虑是什么类型的，在 ES6 之前我们一般使用 var 来声明一个变量，在 ES6 之后我们会使用 let 和 const 来定义变量(常量)</p>\n<p><strong>那么什么是变量提升呢？</strong></p>\n<blockquote>\n<p>打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被”移动”到了最上面—《你不知道的 Javscript 上卷》</p>\n</blockquote>\n<p>在直觉上我们会认为 JavaScript 代码在执行的时候是由上到下一行一行执行的，但是实际上这并不完全准确，有一种特殊情况会导致整个假设错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-keyword\">var</span> a;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a);<br></code></pre></td></tr></table></figure>\n\n<p>你认为这个里面会输出什么呢？</p>\n<p><strong>undefined or 2</strong></p>\n<p>正确答案是 2 ，那么为什么是 2 呢，按道理 a 应该是重新赋值了呀(a=undefined)</p>\n<p><strong>其实这里面就是因为变量提升</strong>，实际上他会变成这样子的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a;<br>a = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-title function_\">console</span>(a); <span class=\"hljs-comment\">//2</span><br></code></pre></td></tr></table></figure>\n\n<p>下面我们再看一段代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a);<br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这次会输出什么呢？是 2 ? undefined ? ReferenceError</p>\n<p>其实是 undefined,其实是这样子的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// a is undefined</span><br>a = <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"下面我们来解释一下这个是为什么呢\"><a href=\"#下面我们来解释一下这个是为什么呢\" class=\"headerlink\" title=\"下面我们来解释一下这个是为什么呢\"></a>下面我们来解释一下这个是为什么呢</h4><p>引擎会在解释 JavaScript 代码之前<code>首先对其进行编译</code>。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将他们关联起来</p>\n<p>因此，正确的思考路线是，包括<code>变量和函数</code>在内的所有声明都会在任何代码被执行前<code>首先被处理</code></p>\n<p>当你看到 <code>var a = 2</code> 时,可能会认为这是一个声明，但 JavaScript 实际上会将其看成两个声明: <code>var a </code> 和 <code>a = 2</code>，第一个定义声明是在编译阶段进行的，第二个赋值声明会被留在原地等待执行阶段，其实就是先有<code>声明</code>后有<code>赋值</code></p>\n<blockquote>\n<p>只有声明本身会被提升，而赋值或其他的运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">foo</span>()<br><br><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a) \t<span class=\"hljs-comment\">//undefined</span><br>    <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>foo 函数的声明(这个例子还包括实际函数的蕴含值)被提升了，因此第一行中的调用可以正常执行</p>\n<p>另外值得注意的是，<code>每个作用域</code>都会进行提升操作。尽管前面大部分的代码片段已经简化了(因为他们只包含全局作用域)，而我们正在讨论的 foo(…)函数本身也会在内部对<code>var a </code>进行提升(显然并不是提升到了整个程序的最上方)。因此这段代码实际上会被理解为下面的形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> a;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">//undefined</span><br>  a = <span class=\"hljs-number\">2</span>;<br>&#125;<br><span class=\"hljs-title function_\">foo</span>();<br></code></pre></td></tr></table></figure>\n\n<p>可以看到，函数声明会提升，但是函数表达式不会被提升</p>\n<p><strong>函数优先</strong></p>\n<p>函数声明和变量声明都会被提升，但是一个值得注意的细节(这个细节可以出现在有很多个”重复”声明的代码中)是函数会首先被提升，然后才是变量</p>\n<p>考虑以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">//1</span><br><br><span class=\"hljs-keyword\">var</span> foo;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>);<br>&#125;<br><br>foo = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">2</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>会输出 1 而不是 2 ，这个代码片段会被引擎解释理解为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">//1</span><br><br>foo = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">2</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>注意，<code>var foo</code> 尽管出现在 function foo()…的声明之前，但它是重复的声明(因此被忽略了)，因为函数声明会被提升到普通变量之前</p>\n<p>尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">//3</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  consloe.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">2</span>);<br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>虽然这些听起来都是些无用的学院理论，但是它说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题</p>\n<p>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码暗示的那样可以被条件判断所控制：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">//TypeError: foo is not a function</span><br><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-literal\">true</span>;<br><br><span class=\"hljs-keyword\">if</span> (a) &#123;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>  &#125;<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;b&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"变量的本质和垃圾回收","date":"2023-02-27T04:00:45.000Z","index_img":"/img/变量的本质.jpg","_content":"\n```js\nvar b1 =1 , b2 = b1;\nb2 =2 ;  //RHS   right hand search  右查询读的是内存中的值\n//由于基本类型是不可修改的，所以这里是先申请了栈里的一块空间，然后赋值为2，然后b指向那个新的地址，旧地方的地址会被垃圾回收给清除掉\nconsole.log(b1,b1);    // 1  2\n\nvar r1 = {\n    a:1,\n},\n    r2 = r1; //栈里面的数据\n\nr2.a = 2 ;\n\nconsole.log(r1.a,r2.a);    //2   2\n```\n\n\n\n> 从本质上理解变量\n\n程序的本质是一个状态机(数据的集合)，程序本质是只能访问栈，不能直接访问堆，但是可以通过标识符间接的访问堆，因为栈的访问速度快(因为栈的大小是确定的，可以直接找到变量的地址)\n\n**1.Primitive Type(原始类型)**\n\n值不可以改变的类型，是一个二进制的字符串,基本数据类型一般存在栈(FILO)里，还有引用类型的标识符\n\n1. NULL\n2. Undefined\n3. Boolean\n4. Number\n5. BigInt\n6. String\n7. Symbol\n\n> Stack\n>\n> 1.结构性强，内存连续\n>\n> 2.寻址速度快\n>\n> 3.数据稳定，每一个类型的大小都是确定的\n>\n> 4.容量小\n\n![栈](栈.png)\n\n**2.Reference Type（引用类型）**\n\n> **Heap**\n>\n> 1. 树的结构，有大根堆和小根堆\n> 2. 存储的大小不一\n> 3. 容量大 \n> 4. 不同数据间内存不连续 \n\n![heap](heap.png)\n\n# Object\n\n**`Object`** 是 JavaScript 的一种 [数据类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures) 。它用于存储各种键值集合和更复杂的实体。Objects 可以通过 `Object()` 构造函数或者使用 [对象字面量](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Object_initializer) 的方式创建。\n\n对象是存在堆heap里的，因为对象的大小是不确定而且是可变的，所以不能放在栈里\n\n\n\n# 特殊的字符串\n\n字符串是无法修改的，是基本数据类型，但是其大小又是不确定的。修改值只会重新开辟一块内存空间\n\n浏览器的垃圾回收机制有：标记清除和引用计数\n\n当一个内存单元没有被使用的时候，会被标记为空，下次的数据就可以直接覆盖到上面\n\n\n\n# 深拷贝和浅拷贝\n\n```js\nvar person1 = {\n\tage:28,\n    hobby:\"学习\",\n    son:{\n\t\tage:3,\n        hobby:\"drink milk\",\n        firdens:['jack','luck']\n    }\n}\n\nvar clone = person1;   //读stack\nclone.age = 18;\nconsole.log(person1.gae);   // 18\n\n//浅拷贝\nfunction clone2(obj){\n\tvar clonePerson = {}\n        //为什么不用clonePerson.key?  其实persone.age 会被进一步编译为 persone[\"age\"]\n        //如果用clonePerson.key  -->  clonePerson[\"key\"] ，但是clonePerson里面是没有这个键，意思就是 person[age],这里面的age是个变量\n        for(var key in obj){ //for in 会读原型链可枚举的属性\n            clonePerson[key] = obj[key];\n\t\t}\n    return clonePerson;\n}\n//这里为什么是浅拷贝呢，因为这个里面的son其实拿到的还是地址，所以如果person1改了的话，clone还是会受到影响\n\n```\n\n\n\n![浅拷贝](浅拷贝.png)\n\n\n\n```js\n// 深拷贝\nfunction clone2(obj){\n\tif(typeof obj !== \"object\" || obj === null){\n\t\treturn obj;\n    }\n    \n    var clone = Array.isArray(obj)? [] : {};\n    for(var key in obj){\n        if(typeof obj[key] === 'object'){\n            clone[key] = clone2(obj[key]);\n    }else{\n        clone[key] = obj[key];\n    \t}\n    }\n    return clone;\n    \n}\n```\n\n\n\n# **垃圾回收机制**\n\n```js\nvar foo = {a:1,b:{x:2}};\nvar bar = foo.b;\nbar.c = foo;\n\nconsole.log(bar.c.a);\n```\n\n![垃圾回收](垃圾回收.png)\n\n\n\n# 原型链\n\n> 理解new关键字的作用机制\n>\n> 理解 [[GET]]\n\n\n\n# 浏览器\n\n早期的浏览器是一个单进程的，有很多的线程，最重要的就是Page Thread\n\n**现代浏览器架构** （多进程）\n\n主进程：\n\n1. 浏览器界面\n2. 用户交互\n3. 管理子进程\n4. 提供存储功能\n\n网络进程：负责网络资源的请求和接收\n\nGPU进程\n\n插件进程\n\n渲染进程（内核）\n\n渲染进程是运行在沙箱中的，保证用户的安全，主要是**渲染引擎**和**JS解析引擎**\n\n\n\n![浏览器的进程](浏览器的进程.png)\n\n**浏览器内核执行机制** \n\n浏览器内核也就是渲染进程分别由渲染引擎和JS解析引擎构成\n\n渲染引擎用来渲染页面，JS解析引擎用来解析JS代码，但是两个进程是不能直接通信的，就需要一个中间人来搭建桥梁，也就是**事件循环**\n\n#### 渲染引擎\n\n* 解析HTML，生成用于构建页面的信息\n* 如果遇到Script 标签，则停止解析，就会挂起解析HTML\n\n#### JS执行机制\n\n1. 单线程执行 \n\nJS单线程不可怕，可怕的是他与渲染引擎是互斥的，会造成页面卡顿，无响应等\n\n> 那么如何解决呢？ 异步编程就是一种办法\n\n同步： 在主线程中执行的代码\n\n异步： 不在主线程执行，而是通过任务队列通知主线程\n\n1. 定时器\n2. 网络请求\n3. 与用户的交互\n4. 。。。。。\n\n\n\n#### 任务队列\n\n* 延时队列： 用户存放计时器线程包装的回调任务    优先级： 中\n* 交互队列： 用于存放用户操作事件产生后的事件处理任务  优先级： 高\n* 微任务队列： 优先级： 最高\n\n**只有同步任务执行完了，才会执行异步任务，那么怎么判断同步任务执行完成了呢？**\n\n也就是看栈，如果执行栈空了，就说明同步任务执行完了，可以去执行任务队列中的任务了\n\n![同步和异步栈](同步和异步栈.png)\n\n  \n\n​\t\t\t\t\t         *任务队列*\n\n![任务队列](D任务队列.png)\n\n\n\n\n\n\n\n```js\nvar flag = true;\n\nwhile(flag){\n\tsetTimeOut(function(){\n        flag = false;\n    },10);\n}\n\n//请问这个循环会结束吗？\n\n//答案是不会的，因为JS是单线程的，为了j所以就有了异步和同步，只有执行完同步才会执行异步的任务，这里面会一直执行循环，也就是同步的任务栈中的任务是一直有新的任务压栈的，是不会为空的，所以异步任务的任务队列是执行不到的\n```\n\n\n\n","source":"_posts/变量的本质和垃圾回收.md","raw":"---\ntitle: 变量的本质和垃圾回收\ndate: 2023-02-27 12:00:45\ncategory: 前端\ntags: 基础知识点\nindex_img: /img/变量的本质.jpg\n---\n\n```js\nvar b1 =1 , b2 = b1;\nb2 =2 ;  //RHS   right hand search  右查询读的是内存中的值\n//由于基本类型是不可修改的，所以这里是先申请了栈里的一块空间，然后赋值为2，然后b指向那个新的地址，旧地方的地址会被垃圾回收给清除掉\nconsole.log(b1,b1);    // 1  2\n\nvar r1 = {\n    a:1,\n},\n    r2 = r1; //栈里面的数据\n\nr2.a = 2 ;\n\nconsole.log(r1.a,r2.a);    //2   2\n```\n\n\n\n> 从本质上理解变量\n\n程序的本质是一个状态机(数据的集合)，程序本质是只能访问栈，不能直接访问堆，但是可以通过标识符间接的访问堆，因为栈的访问速度快(因为栈的大小是确定的，可以直接找到变量的地址)\n\n**1.Primitive Type(原始类型)**\n\n值不可以改变的类型，是一个二进制的字符串,基本数据类型一般存在栈(FILO)里，还有引用类型的标识符\n\n1. NULL\n2. Undefined\n3. Boolean\n4. Number\n5. BigInt\n6. String\n7. Symbol\n\n> Stack\n>\n> 1.结构性强，内存连续\n>\n> 2.寻址速度快\n>\n> 3.数据稳定，每一个类型的大小都是确定的\n>\n> 4.容量小\n\n![栈](栈.png)\n\n**2.Reference Type（引用类型）**\n\n> **Heap**\n>\n> 1. 树的结构，有大根堆和小根堆\n> 2. 存储的大小不一\n> 3. 容量大 \n> 4. 不同数据间内存不连续 \n\n![heap](heap.png)\n\n# Object\n\n**`Object`** 是 JavaScript 的一种 [数据类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures) 。它用于存储各种键值集合和更复杂的实体。Objects 可以通过 `Object()` 构造函数或者使用 [对象字面量](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Object_initializer) 的方式创建。\n\n对象是存在堆heap里的，因为对象的大小是不确定而且是可变的，所以不能放在栈里\n\n\n\n# 特殊的字符串\n\n字符串是无法修改的，是基本数据类型，但是其大小又是不确定的。修改值只会重新开辟一块内存空间\n\n浏览器的垃圾回收机制有：标记清除和引用计数\n\n当一个内存单元没有被使用的时候，会被标记为空，下次的数据就可以直接覆盖到上面\n\n\n\n# 深拷贝和浅拷贝\n\n```js\nvar person1 = {\n\tage:28,\n    hobby:\"学习\",\n    son:{\n\t\tage:3,\n        hobby:\"drink milk\",\n        firdens:['jack','luck']\n    }\n}\n\nvar clone = person1;   //读stack\nclone.age = 18;\nconsole.log(person1.gae);   // 18\n\n//浅拷贝\nfunction clone2(obj){\n\tvar clonePerson = {}\n        //为什么不用clonePerson.key?  其实persone.age 会被进一步编译为 persone[\"age\"]\n        //如果用clonePerson.key  -->  clonePerson[\"key\"] ，但是clonePerson里面是没有这个键，意思就是 person[age],这里面的age是个变量\n        for(var key in obj){ //for in 会读原型链可枚举的属性\n            clonePerson[key] = obj[key];\n\t\t}\n    return clonePerson;\n}\n//这里为什么是浅拷贝呢，因为这个里面的son其实拿到的还是地址，所以如果person1改了的话，clone还是会受到影响\n\n```\n\n\n\n![浅拷贝](浅拷贝.png)\n\n\n\n```js\n// 深拷贝\nfunction clone2(obj){\n\tif(typeof obj !== \"object\" || obj === null){\n\t\treturn obj;\n    }\n    \n    var clone = Array.isArray(obj)? [] : {};\n    for(var key in obj){\n        if(typeof obj[key] === 'object'){\n            clone[key] = clone2(obj[key]);\n    }else{\n        clone[key] = obj[key];\n    \t}\n    }\n    return clone;\n    \n}\n```\n\n\n\n# **垃圾回收机制**\n\n```js\nvar foo = {a:1,b:{x:2}};\nvar bar = foo.b;\nbar.c = foo;\n\nconsole.log(bar.c.a);\n```\n\n![垃圾回收](垃圾回收.png)\n\n\n\n# 原型链\n\n> 理解new关键字的作用机制\n>\n> 理解 [[GET]]\n\n\n\n# 浏览器\n\n早期的浏览器是一个单进程的，有很多的线程，最重要的就是Page Thread\n\n**现代浏览器架构** （多进程）\n\n主进程：\n\n1. 浏览器界面\n2. 用户交互\n3. 管理子进程\n4. 提供存储功能\n\n网络进程：负责网络资源的请求和接收\n\nGPU进程\n\n插件进程\n\n渲染进程（内核）\n\n渲染进程是运行在沙箱中的，保证用户的安全，主要是**渲染引擎**和**JS解析引擎**\n\n\n\n![浏览器的进程](浏览器的进程.png)\n\n**浏览器内核执行机制** \n\n浏览器内核也就是渲染进程分别由渲染引擎和JS解析引擎构成\n\n渲染引擎用来渲染页面，JS解析引擎用来解析JS代码，但是两个进程是不能直接通信的，就需要一个中间人来搭建桥梁，也就是**事件循环**\n\n#### 渲染引擎\n\n* 解析HTML，生成用于构建页面的信息\n* 如果遇到Script 标签，则停止解析，就会挂起解析HTML\n\n#### JS执行机制\n\n1. 单线程执行 \n\nJS单线程不可怕，可怕的是他与渲染引擎是互斥的，会造成页面卡顿，无响应等\n\n> 那么如何解决呢？ 异步编程就是一种办法\n\n同步： 在主线程中执行的代码\n\n异步： 不在主线程执行，而是通过任务队列通知主线程\n\n1. 定时器\n2. 网络请求\n3. 与用户的交互\n4. 。。。。。\n\n\n\n#### 任务队列\n\n* 延时队列： 用户存放计时器线程包装的回调任务    优先级： 中\n* 交互队列： 用于存放用户操作事件产生后的事件处理任务  优先级： 高\n* 微任务队列： 优先级： 最高\n\n**只有同步任务执行完了，才会执行异步任务，那么怎么判断同步任务执行完成了呢？**\n\n也就是看栈，如果执行栈空了，就说明同步任务执行完了，可以去执行任务队列中的任务了\n\n![同步和异步栈](同步和异步栈.png)\n\n  \n\n​\t\t\t\t\t         *任务队列*\n\n![任务队列](D任务队列.png)\n\n\n\n\n\n\n\n```js\nvar flag = true;\n\nwhile(flag){\n\tsetTimeOut(function(){\n        flag = false;\n    },10);\n}\n\n//请问这个循环会结束吗？\n\n//答案是不会的，因为JS是单线程的，为了j所以就有了异步和同步，只有执行完同步才会执行异步的任务，这里面会一直执行循环，也就是同步的任务栈中的任务是一直有新的任务压栈的，是不会为空的，所以异步任务的任务队列是执行不到的\n```\n\n\n\n","slug":"变量的本质和垃圾回收","published":1,"updated":"2024-11-17T13:58:10.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpo002d73t38ys68845","content":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> b1 =<span class=\"hljs-number\">1</span> , b2 = b1;<br>b2 =<span class=\"hljs-number\">2</span> ;  <span class=\"hljs-comment\">//RHS   right hand search  右查询读的是内存中的值</span><br><span class=\"hljs-comment\">//由于基本类型是不可修改的，所以这里是先申请了栈里的一块空间，然后赋值为2，然后b指向那个新的地址，旧地方的地址会被垃圾回收给清除掉</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b1,b1);    <span class=\"hljs-comment\">// 1  2</span><br><br><span class=\"hljs-keyword\">var</span> r1 = &#123;<br>    <span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>,<br>&#125;,<br>    r2 = r1; <span class=\"hljs-comment\">//栈里面的数据</span><br><br>r2.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">2</span> ;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r1.<span class=\"hljs-property\">a</span>,r2.<span class=\"hljs-property\">a</span>);    <span class=\"hljs-comment\">//2   2</span><br></code></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>从本质上理解变量</p>\n</blockquote>\n<p>程序的本质是一个状态机(数据的集合)，程序本质是只能访问栈，不能直接访问堆，但是可以通过标识符间接的访问堆，因为栈的访问速度快(因为栈的大小是确定的，可以直接找到变量的地址)</p>\n<p><strong>1.Primitive Type(原始类型)</strong></p>\n<p>值不可以改变的类型，是一个二进制的字符串,基本数据类型一般存在栈(FILO)里，还有引用类型的标识符</p>\n<ol>\n<li>NULL</li>\n<li>Undefined</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>BigInt</li>\n<li>String</li>\n<li>Symbol</li>\n</ol>\n<blockquote>\n<p>Stack</p>\n<p>1.结构性强，内存连续</p>\n<p>2.寻址速度快</p>\n<p>3.数据稳定，每一个类型的大小都是确定的</p>\n<p>4.容量小</p>\n</blockquote>\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%88.png\" alt=\"栈\"></p>\n<p><strong>2.Reference Type（引用类型）</strong></p>\n<blockquote>\n<p><strong>Heap</strong></p>\n<ol>\n<li>树的结构，有大根堆和小根堆</li>\n<li>存储的大小不一</li>\n<li>容量大 </li>\n<li>不同数据间内存不连续 </li>\n</ol>\n</blockquote>\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/heap.png\" alt=\"heap\"></p>\n<h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><p><strong><code>Object</code></strong> 是 JavaScript 的一种 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures\">数据类型</a> 。它用于存储各种键值集合和更复杂的实体。Objects 可以通过 <code>Object()</code> 构造函数或者使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Object_initializer\">对象字面量</a> 的方式创建。</p>\n<p>对象是存在堆heap里的，因为对象的大小是不确定而且是可变的，所以不能放在栈里</p>\n<h1 id=\"特殊的字符串\"><a href=\"#特殊的字符串\" class=\"headerlink\" title=\"特殊的字符串\"></a>特殊的字符串</h1><p>字符串是无法修改的，是基本数据类型，但是其大小又是不确定的。修改值只会重新开辟一块内存空间</p>\n<p>浏览器的垃圾回收机制有：标记清除和引用计数</p>\n<p>当一个内存单元没有被使用的时候，会被标记为空，下次的数据就可以直接覆盖到上面</p>\n<h1 id=\"深拷贝和浅拷贝\"><a href=\"#深拷贝和浅拷贝\" class=\"headerlink\" title=\"深拷贝和浅拷贝\"></a>深拷贝和浅拷贝</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> person1 = &#123;<br>\t<span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">28</span>,<br>    <span class=\"hljs-attr\">hobby</span>:<span class=\"hljs-string\">&quot;学习&quot;</span>,<br>    <span class=\"hljs-attr\">son</span>:&#123;<br>\t\t<span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">3</span>,<br>        <span class=\"hljs-attr\">hobby</span>:<span class=\"hljs-string\">&quot;drink milk&quot;</span>,<br>        <span class=\"hljs-attr\">firdens</span>:[<span class=\"hljs-string\">&#x27;jack&#x27;</span>,<span class=\"hljs-string\">&#x27;luck&#x27;</span>]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> clone = person1;   <span class=\"hljs-comment\">//读stack</span><br>clone.<span class=\"hljs-property\">age</span> = <span class=\"hljs-number\">18</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1.<span class=\"hljs-property\">gae</span>);   <span class=\"hljs-comment\">// 18</span><br><br><span class=\"hljs-comment\">//浅拷贝</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clone2</span>(<span class=\"hljs-params\">obj</span>)&#123;<br>\t<span class=\"hljs-keyword\">var</span> clonePerson = &#123;&#125;<br>        <span class=\"hljs-comment\">//为什么不用clonePerson.key?  其实persone.age 会被进一步编译为 persone[&quot;age&quot;]</span><br>        <span class=\"hljs-comment\">//如果用clonePerson.key  --&gt;  clonePerson[&quot;key&quot;] ，但是clonePerson里面是没有这个键，意思就是 person[age],这里面的age是个变量</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> key <span class=\"hljs-keyword\">in</span> obj)&#123; <span class=\"hljs-comment\">//for in 会读原型链可枚举的属性</span><br>            clonePerson[key] = obj[key];<br>\t\t&#125;<br>    <span class=\"hljs-keyword\">return</span> clonePerson;<br>&#125;<br><span class=\"hljs-comment\">//这里为什么是浅拷贝呢，因为这个里面的son其实拿到的还是地址，所以如果person1改了的话，clone还是会受到影响</span><br><br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%B5%85%E6%8B%B7%E8%B4%9D.png\" alt=\"浅拷贝\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 深拷贝</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clone2</span>(<span class=\"hljs-params\">obj</span>)&#123;<br>\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> obj !== <span class=\"hljs-string\">&quot;object&quot;</span> || obj === <span class=\"hljs-literal\">null</span>)&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> obj;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">var</span> clone = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(obj)? [] : &#123;&#125;;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> key <span class=\"hljs-keyword\">in</span> obj)&#123;<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> obj[key] === <span class=\"hljs-string\">&#x27;object&#x27;</span>)&#123;<br>            clone[key] = <span class=\"hljs-title function_\">clone2</span>(obj[key]);<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        clone[key] = obj[key];<br>    \t&#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> clone;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a><strong>垃圾回收机制</strong></h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> foo = &#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-attr\">b</span>:&#123;<span class=\"hljs-attr\">x</span>:<span class=\"hljs-number\">2</span>&#125;&#125;;<br><span class=\"hljs-keyword\">var</span> bar = foo.<span class=\"hljs-property\">b</span>;<br>bar.<span class=\"hljs-property\">c</span> = foo;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(bar.<span class=\"hljs-property\">c</span>.<span class=\"hljs-property\">a</span>);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png\" alt=\"垃圾回收\"></p>\n<h1 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h1><blockquote>\n<p>理解new关键字的作用机制</p>\n<p>理解 [[GET]]</p>\n</blockquote>\n<h1 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h1><p>早期的浏览器是一个单进程的，有很多的线程，最重要的就是Page Thread</p>\n<p><strong>现代浏览器架构</strong> （多进程）</p>\n<p>主进程：</p>\n<ol>\n<li>浏览器界面</li>\n<li>用户交互</li>\n<li>管理子进程</li>\n<li>提供存储功能</li>\n</ol>\n<p>网络进程：负责网络资源的请求和接收</p>\n<p>GPU进程</p>\n<p>插件进程</p>\n<p>渲染进程（内核）</p>\n<p>渲染进程是运行在沙箱中的，保证用户的安全，主要是<strong>渲染引擎</strong>和<strong>JS解析引擎</strong></p>\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B.png\" alt=\"浏览器的进程\"></p>\n<p><strong>浏览器内核执行机制</strong> </p>\n<p>浏览器内核也就是渲染进程分别由渲染引擎和JS解析引擎构成</p>\n<p>渲染引擎用来渲染页面，JS解析引擎用来解析JS代码，但是两个进程是不能直接通信的，就需要一个中间人来搭建桥梁，也就是<strong>事件循环</strong></p>\n<h4 id=\"渲染引擎\"><a href=\"#渲染引擎\" class=\"headerlink\" title=\"渲染引擎\"></a>渲染引擎</h4><ul>\n<li>解析HTML，生成用于构建页面的信息</li>\n<li>如果遇到Script 标签，则停止解析，就会挂起解析HTML</li>\n</ul>\n<h4 id=\"JS执行机制\"><a href=\"#JS执行机制\" class=\"headerlink\" title=\"JS执行机制\"></a>JS执行机制</h4><ol>\n<li>单线程执行 </li>\n</ol>\n<p>JS单线程不可怕，可怕的是他与渲染引擎是互斥的，会造成页面卡顿，无响应等</p>\n<blockquote>\n<p>那么如何解决呢？ 异步编程就是一种办法</p>\n</blockquote>\n<p>同步： 在主线程中执行的代码</p>\n<p>异步： 不在主线程执行，而是通过任务队列通知主线程</p>\n<ol>\n<li>定时器</li>\n<li>网络请求</li>\n<li>与用户的交互</li>\n<li>。。。。。</li>\n</ol>\n<h4 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a>任务队列</h4><ul>\n<li>延时队列： 用户存放计时器线程包装的回调任务    优先级： 中</li>\n<li>交互队列： 用于存放用户操作事件产生后的事件处理任务  优先级： 高</li>\n<li>微任务队列： 优先级： 最高</li>\n</ul>\n<p><strong>只有同步任务执行完了，才会执行异步任务，那么怎么判断同步任务执行完成了呢？</strong></p>\n<p>也就是看栈，如果执行栈空了，就说明同步任务执行完了，可以去执行任务队列中的任务了</p>\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%A0%88.png\" alt=\"同步和异步栈\"></p>\n<p>​                             <em>任务队列</em></p>\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/D%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97.png\" alt=\"任务队列\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> flag = <span class=\"hljs-literal\">true</span>;<br><br><span class=\"hljs-keyword\">while</span>(flag)&#123;<br>\t<span class=\"hljs-title function_\">setTimeOut</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>        flag = <span class=\"hljs-literal\">false</span>;<br>    &#125;,<span class=\"hljs-number\">10</span>);<br>&#125;<br><br><span class=\"hljs-comment\">//请问这个循环会结束吗？</span><br><br><span class=\"hljs-comment\">//答案是不会的，因为JS是单线程的，为了j所以就有了异步和同步，只有执行完同步才会执行异步的任务，这里面会一直执行循环，也就是同步的任务栈中的任务是一直有新的任务压栈的，是不会为空的，所以异步任务的任务队列是执行不到的</span><br></code></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"wordcount":2667,"excerpt":"","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> b1 =<span class=\"hljs-number\">1</span> , b2 = b1;<br>b2 =<span class=\"hljs-number\">2</span> ;  <span class=\"hljs-comment\">//RHS   right hand search  右查询读的是内存中的值</span><br><span class=\"hljs-comment\">//由于基本类型是不可修改的，所以这里是先申请了栈里的一块空间，然后赋值为2，然后b指向那个新的地址，旧地方的地址会被垃圾回收给清除掉</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b1,b1);    <span class=\"hljs-comment\">// 1  2</span><br><br><span class=\"hljs-keyword\">var</span> r1 = &#123;<br>    <span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>,<br>&#125;,<br>    r2 = r1; <span class=\"hljs-comment\">//栈里面的数据</span><br><br>r2.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">2</span> ;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r1.<span class=\"hljs-property\">a</span>,r2.<span class=\"hljs-property\">a</span>);    <span class=\"hljs-comment\">//2   2</span><br></code></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>从本质上理解变量</p>\n</blockquote>\n<p>程序的本质是一个状态机(数据的集合)，程序本质是只能访问栈，不能直接访问堆，但是可以通过标识符间接的访问堆，因为栈的访问速度快(因为栈的大小是确定的，可以直接找到变量的地址)</p>\n<p><strong>1.Primitive Type(原始类型)</strong></p>\n<p>值不可以改变的类型，是一个二进制的字符串,基本数据类型一般存在栈(FILO)里，还有引用类型的标识符</p>\n<ol>\n<li>NULL</li>\n<li>Undefined</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>BigInt</li>\n<li>String</li>\n<li>Symbol</li>\n</ol>\n<blockquote>\n<p>Stack</p>\n<p>1.结构性强，内存连续</p>\n<p>2.寻址速度快</p>\n<p>3.数据稳定，每一个类型的大小都是确定的</p>\n<p>4.容量小</p>\n</blockquote>\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%88.png\" alt=\"栈\"></p>\n<p><strong>2.Reference Type（引用类型）</strong></p>\n<blockquote>\n<p><strong>Heap</strong></p>\n<ol>\n<li>树的结构，有大根堆和小根堆</li>\n<li>存储的大小不一</li>\n<li>容量大 </li>\n<li>不同数据间内存不连续 </li>\n</ol>\n</blockquote>\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/heap.png\" alt=\"heap\"></p>\n<h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><p><strong><code>Object</code></strong> 是 JavaScript 的一种 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures\">数据类型</a> 。它用于存储各种键值集合和更复杂的实体。Objects 可以通过 <code>Object()</code> 构造函数或者使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Object_initializer\">对象字面量</a> 的方式创建。</p>\n<p>对象是存在堆heap里的，因为对象的大小是不确定而且是可变的，所以不能放在栈里</p>\n<h1 id=\"特殊的字符串\"><a href=\"#特殊的字符串\" class=\"headerlink\" title=\"特殊的字符串\"></a>特殊的字符串</h1><p>字符串是无法修改的，是基本数据类型，但是其大小又是不确定的。修改值只会重新开辟一块内存空间</p>\n<p>浏览器的垃圾回收机制有：标记清除和引用计数</p>\n<p>当一个内存单元没有被使用的时候，会被标记为空，下次的数据就可以直接覆盖到上面</p>\n<h1 id=\"深拷贝和浅拷贝\"><a href=\"#深拷贝和浅拷贝\" class=\"headerlink\" title=\"深拷贝和浅拷贝\"></a>深拷贝和浅拷贝</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> person1 = &#123;<br>\t<span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">28</span>,<br>    <span class=\"hljs-attr\">hobby</span>:<span class=\"hljs-string\">&quot;学习&quot;</span>,<br>    <span class=\"hljs-attr\">son</span>:&#123;<br>\t\t<span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">3</span>,<br>        <span class=\"hljs-attr\">hobby</span>:<span class=\"hljs-string\">&quot;drink milk&quot;</span>,<br>        <span class=\"hljs-attr\">firdens</span>:[<span class=\"hljs-string\">&#x27;jack&#x27;</span>,<span class=\"hljs-string\">&#x27;luck&#x27;</span>]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> clone = person1;   <span class=\"hljs-comment\">//读stack</span><br>clone.<span class=\"hljs-property\">age</span> = <span class=\"hljs-number\">18</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1.<span class=\"hljs-property\">gae</span>);   <span class=\"hljs-comment\">// 18</span><br><br><span class=\"hljs-comment\">//浅拷贝</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clone2</span>(<span class=\"hljs-params\">obj</span>)&#123;<br>\t<span class=\"hljs-keyword\">var</span> clonePerson = &#123;&#125;<br>        <span class=\"hljs-comment\">//为什么不用clonePerson.key?  其实persone.age 会被进一步编译为 persone[&quot;age&quot;]</span><br>        <span class=\"hljs-comment\">//如果用clonePerson.key  --&gt;  clonePerson[&quot;key&quot;] ，但是clonePerson里面是没有这个键，意思就是 person[age],这里面的age是个变量</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> key <span class=\"hljs-keyword\">in</span> obj)&#123; <span class=\"hljs-comment\">//for in 会读原型链可枚举的属性</span><br>            clonePerson[key] = obj[key];<br>\t\t&#125;<br>    <span class=\"hljs-keyword\">return</span> clonePerson;<br>&#125;<br><span class=\"hljs-comment\">//这里为什么是浅拷贝呢，因为这个里面的son其实拿到的还是地址，所以如果person1改了的话，clone还是会受到影响</span><br><br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%B5%85%E6%8B%B7%E8%B4%9D.png\" alt=\"浅拷贝\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 深拷贝</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clone2</span>(<span class=\"hljs-params\">obj</span>)&#123;<br>\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> obj !== <span class=\"hljs-string\">&quot;object&quot;</span> || obj === <span class=\"hljs-literal\">null</span>)&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> obj;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">var</span> clone = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(obj)? [] : &#123;&#125;;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> key <span class=\"hljs-keyword\">in</span> obj)&#123;<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> obj[key] === <span class=\"hljs-string\">&#x27;object&#x27;</span>)&#123;<br>            clone[key] = <span class=\"hljs-title function_\">clone2</span>(obj[key]);<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        clone[key] = obj[key];<br>    \t&#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> clone;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a><strong>垃圾回收机制</strong></h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> foo = &#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-attr\">b</span>:&#123;<span class=\"hljs-attr\">x</span>:<span class=\"hljs-number\">2</span>&#125;&#125;;<br><span class=\"hljs-keyword\">var</span> bar = foo.<span class=\"hljs-property\">b</span>;<br>bar.<span class=\"hljs-property\">c</span> = foo;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(bar.<span class=\"hljs-property\">c</span>.<span class=\"hljs-property\">a</span>);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png\" alt=\"垃圾回收\"></p>\n<h1 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h1><blockquote>\n<p>理解new关键字的作用机制</p>\n<p>理解 [[GET]]</p>\n</blockquote>\n<h1 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h1><p>早期的浏览器是一个单进程的，有很多的线程，最重要的就是Page Thread</p>\n<p><strong>现代浏览器架构</strong> （多进程）</p>\n<p>主进程：</p>\n<ol>\n<li>浏览器界面</li>\n<li>用户交互</li>\n<li>管理子进程</li>\n<li>提供存储功能</li>\n</ol>\n<p>网络进程：负责网络资源的请求和接收</p>\n<p>GPU进程</p>\n<p>插件进程</p>\n<p>渲染进程（内核）</p>\n<p>渲染进程是运行在沙箱中的，保证用户的安全，主要是<strong>渲染引擎</strong>和<strong>JS解析引擎</strong></p>\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B.png\" alt=\"浏览器的进程\"></p>\n<p><strong>浏览器内核执行机制</strong> </p>\n<p>浏览器内核也就是渲染进程分别由渲染引擎和JS解析引擎构成</p>\n<p>渲染引擎用来渲染页面，JS解析引擎用来解析JS代码，但是两个进程是不能直接通信的，就需要一个中间人来搭建桥梁，也就是<strong>事件循环</strong></p>\n<h4 id=\"渲染引擎\"><a href=\"#渲染引擎\" class=\"headerlink\" title=\"渲染引擎\"></a>渲染引擎</h4><ul>\n<li>解析HTML，生成用于构建页面的信息</li>\n<li>如果遇到Script 标签，则停止解析，就会挂起解析HTML</li>\n</ul>\n<h4 id=\"JS执行机制\"><a href=\"#JS执行机制\" class=\"headerlink\" title=\"JS执行机制\"></a>JS执行机制</h4><ol>\n<li>单线程执行 </li>\n</ol>\n<p>JS单线程不可怕，可怕的是他与渲染引擎是互斥的，会造成页面卡顿，无响应等</p>\n<blockquote>\n<p>那么如何解决呢？ 异步编程就是一种办法</p>\n</blockquote>\n<p>同步： 在主线程中执行的代码</p>\n<p>异步： 不在主线程执行，而是通过任务队列通知主线程</p>\n<ol>\n<li>定时器</li>\n<li>网络请求</li>\n<li>与用户的交互</li>\n<li>。。。。。</li>\n</ol>\n<h4 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a>任务队列</h4><ul>\n<li>延时队列： 用户存放计时器线程包装的回调任务    优先级： 中</li>\n<li>交互队列： 用于存放用户操作事件产生后的事件处理任务  优先级： 高</li>\n<li>微任务队列： 优先级： 最高</li>\n</ul>\n<p><strong>只有同步任务执行完了，才会执行异步任务，那么怎么判断同步任务执行完成了呢？</strong></p>\n<p>也就是看栈，如果执行栈空了，就说明同步任务执行完了，可以去执行任务队列中的任务了</p>\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%A0%88.png\" alt=\"同步和异步栈\"></p>\n<p>​                             <em>任务队列</em></p>\n<p><img src=\"/2023/02/27/%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/D%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97.png\" alt=\"任务队列\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> flag = <span class=\"hljs-literal\">true</span>;<br><br><span class=\"hljs-keyword\">while</span>(flag)&#123;<br>\t<span class=\"hljs-title function_\">setTimeOut</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>        flag = <span class=\"hljs-literal\">false</span>;<br>    &#125;,<span class=\"hljs-number\">10</span>);<br>&#125;<br><br><span class=\"hljs-comment\">//请问这个循环会结束吗？</span><br><br><span class=\"hljs-comment\">//答案是不会的，因为JS是单线程的，为了j所以就有了异步和同步，只有执行完同步才会执行异步的任务，这里面会一直执行循环，也就是同步的任务栈中的任务是一直有新的任务压栈的，是不会为空的，所以异步任务的任务队列是执行不到的</span><br></code></pre></td></tr></table></figure>\n\n\n\n"},{"title":"回流与重绘","date":"2023-02-23T14:29:35.000Z","index_img":"/img/回流与重绘.jpeg","banner_img":null,"_content":"\n\n## 回流与重绘\n\n**回流必定引起重绘，重绘不一定引起回流**\n\n\n\n在HTML中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘。\n\n\n\n**回流**：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置。\n\n\n\n在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变。\n\n当渲染树的一部分因为元素的规模尺寸、布局、隐藏等改变需要重新构建的操作，会影响布局的操作。\n\n\n\n**重绘**：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制。\n\n\n\n当渲染树的一些元素只需更新属性，而这些属性只会影响元素的外观，而不影响布局的操作。浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了重绘。\n\n回流**触发时机**\n\n**任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。**\n\n1）添加或者删除可见的 DOM 元素；\n\n2）元素的位置发生变化，元素尺寸改变（边距、填充、边框、宽度和高度）；\n\n3）内容变化。比如文本变化（用户在 input 框中输入文字）、图片被另一个不同尺寸的图片所替代；\n\n4）浏览器窗口尺寸改变。如resize事件发生时。\n\n5）获取一些特定属性的值。offsetTop、offsetLeft、\n\noffsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeigh。这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流。\n\n6）当你修改网页的默认字体时。\n\n常见的回流：\n\n\n\n![img](回流.jpg)\n\n回流\n\n\n\n重绘**触发时机**\n\n**回流必定会发生重绘，重绘不一定会引发回流。**\n\n常见的重绘：\n\n\n\n![img](重绘.jpg)\n\n重绘\n\n\n\n#### 如何减少回流呢？\n\n1）使用 transform 替代 top\n\n2）不要把节点的属性值放在一个循环里当成循环里的变量。\n\n3）避免使用 table 布局，可能table 中每个元素的大小以及内容的改动会造成整个 table 的重新布局。\n\n4）对于那些复杂的动画，对其设置 position: fixed/absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响\n\n5）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM。我们还可以通过通过设置元素属性display: none，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作。\n\n6）如果想设定元素的样式，通过改变元素的 class 类名。不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。","source":"_posts/回流和重绘.md","raw":"---\ntitle: 回流与重绘\ndate: 2023-2-23 22:29:35\ncategory: 前端\ntags: 基础知识点\nindex_img: /img/回流与重绘.jpeg\nbanner_img:\n---\n\n\n## 回流与重绘\n\n**回流必定引起重绘，重绘不一定引起回流**\n\n\n\n在HTML中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘。\n\n\n\n**回流**：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置。\n\n\n\n在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变。\n\n当渲染树的一部分因为元素的规模尺寸、布局、隐藏等改变需要重新构建的操作，会影响布局的操作。\n\n\n\n**重绘**：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制。\n\n\n\n当渲染树的一些元素只需更新属性，而这些属性只会影响元素的外观，而不影响布局的操作。浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了重绘。\n\n回流**触发时机**\n\n**任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。**\n\n1）添加或者删除可见的 DOM 元素；\n\n2）元素的位置发生变化，元素尺寸改变（边距、填充、边框、宽度和高度）；\n\n3）内容变化。比如文本变化（用户在 input 框中输入文字）、图片被另一个不同尺寸的图片所替代；\n\n4）浏览器窗口尺寸改变。如resize事件发生时。\n\n5）获取一些特定属性的值。offsetTop、offsetLeft、\n\noffsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeigh。这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流。\n\n6）当你修改网页的默认字体时。\n\n常见的回流：\n\n\n\n![img](回流.jpg)\n\n回流\n\n\n\n重绘**触发时机**\n\n**回流必定会发生重绘，重绘不一定会引发回流。**\n\n常见的重绘：\n\n\n\n![img](重绘.jpg)\n\n重绘\n\n\n\n#### 如何减少回流呢？\n\n1）使用 transform 替代 top\n\n2）不要把节点的属性值放在一个循环里当成循环里的变量。\n\n3）避免使用 table 布局，可能table 中每个元素的大小以及内容的改动会造成整个 table 的重新布局。\n\n4）对于那些复杂的动画，对其设置 position: fixed/absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响\n\n5）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM。我们还可以通过通过设置元素属性display: none，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作。\n\n6）如果想设定元素的样式，通过改变元素的 class 类名。不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。","slug":"回流和重绘","published":1,"updated":"2024-11-17T13:58:10.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpp002i73t3a9zrcnu6","content":"<h2 id=\"回流与重绘\"><a href=\"#回流与重绘\" class=\"headerlink\" title=\"回流与重绘\"></a>回流与重绘</h2><p><strong>回流必定引起重绘，重绘不一定引起回流</strong></p>\n<p>在HTML中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘。</p>\n<p><strong>回流</strong>：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置。</p>\n<p>在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变。</p>\n<p>当渲染树的一部分因为元素的规模尺寸、布局、隐藏等改变需要重新构建的操作，会影响布局的操作。</p>\n<p><strong>重绘</strong>：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制。</p>\n<p>当渲染树的一些元素只需更新属性，而这些属性只会影响元素的外观，而不影响布局的操作。浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了重绘。</p>\n<p>回流<strong>触发时机</strong></p>\n<p><strong>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</strong></p>\n<p>1）添加或者删除可见的 DOM 元素；</p>\n<p>2）元素的位置发生变化，元素尺寸改变（边距、填充、边框、宽度和高度）；</p>\n<p>3）内容变化。比如文本变化（用户在 input 框中输入文字）、图片被另一个不同尺寸的图片所替代；</p>\n<p>4）浏览器窗口尺寸改变。如resize事件发生时。</p>\n<p>5）获取一些特定属性的值。offsetTop、offsetLeft、</p>\n<p>offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeigh。这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流。</p>\n<p>6）当你修改网页的默认字体时。</p>\n<p>常见的回流：</p>\n<p><img src=\"/2023/02/23/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/%E5%9B%9E%E6%B5%81.jpg\" alt=\"img\"></p>\n<p>回流</p>\n<p>重绘<strong>触发时机</strong></p>\n<p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong></p>\n<p>常见的重绘：</p>\n<p><img src=\"/2023/02/23/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/%E9%87%8D%E7%BB%98.jpg\" alt=\"img\"></p>\n<p>重绘</p>\n<h4 id=\"如何减少回流呢？\"><a href=\"#如何减少回流呢？\" class=\"headerlink\" title=\"如何减少回流呢？\"></a>如何减少回流呢？</h4><p>1）使用 transform 替代 top</p>\n<p>2）不要把节点的属性值放在一个循环里当成循环里的变量。</p>\n<p>3）避免使用 table 布局，可能table 中每个元素的大小以及内容的改动会造成整个 table 的重新布局。</p>\n<p>4）对于那些复杂的动画，对其设置 position: fixed/absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响</p>\n<p>5）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM。我们还可以通过通过设置元素属性display: none，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作。</p>\n<p>6）如果想设定元素的样式，通过改变元素的 class 类名。不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。</p>\n","site":{"data":{}},"wordcount":1107,"excerpt":"","more":"<h2 id=\"回流与重绘\"><a href=\"#回流与重绘\" class=\"headerlink\" title=\"回流与重绘\"></a>回流与重绘</h2><p><strong>回流必定引起重绘，重绘不一定引起回流</strong></p>\n<p>在HTML中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘。</p>\n<p><strong>回流</strong>：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置。</p>\n<p>在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变。</p>\n<p>当渲染树的一部分因为元素的规模尺寸、布局、隐藏等改变需要重新构建的操作，会影响布局的操作。</p>\n<p><strong>重绘</strong>：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制。</p>\n<p>当渲染树的一些元素只需更新属性，而这些属性只会影响元素的外观，而不影响布局的操作。浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了重绘。</p>\n<p>回流<strong>触发时机</strong></p>\n<p><strong>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</strong></p>\n<p>1）添加或者删除可见的 DOM 元素；</p>\n<p>2）元素的位置发生变化，元素尺寸改变（边距、填充、边框、宽度和高度）；</p>\n<p>3）内容变化。比如文本变化（用户在 input 框中输入文字）、图片被另一个不同尺寸的图片所替代；</p>\n<p>4）浏览器窗口尺寸改变。如resize事件发生时。</p>\n<p>5）获取一些特定属性的值。offsetTop、offsetLeft、</p>\n<p>offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeigh。这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流。</p>\n<p>6）当你修改网页的默认字体时。</p>\n<p>常见的回流：</p>\n<p><img src=\"/2023/02/23/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/%E5%9B%9E%E6%B5%81.jpg\" alt=\"img\"></p>\n<p>回流</p>\n<p>重绘<strong>触发时机</strong></p>\n<p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong></p>\n<p>常见的重绘：</p>\n<p><img src=\"/2023/02/23/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/%E9%87%8D%E7%BB%98.jpg\" alt=\"img\"></p>\n<p>重绘</p>\n<h4 id=\"如何减少回流呢？\"><a href=\"#如何减少回流呢？\" class=\"headerlink\" title=\"如何减少回流呢？\"></a>如何减少回流呢？</h4><p>1）使用 transform 替代 top</p>\n<p>2）不要把节点的属性值放在一个循环里当成循环里的变量。</p>\n<p>3）避免使用 table 布局，可能table 中每个元素的大小以及内容的改动会造成整个 table 的重新布局。</p>\n<p>4）对于那些复杂的动画，对其设置 position: fixed/absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响</p>\n<p>5）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM。我们还可以通过通过设置元素属性display: none，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作。</p>\n<p>6）如果想设定元素的样式，通过改变元素的 class 类名。不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。</p>\n"},{"title":"【每日算法】平方数之和","date":"2024-11-03T10:31:02.000Z","index_img":"/img/post/leetcode.jpg","banner_img":null,"_content":"\n[663.平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/?envType=daily-question&envId=2024-11-05)\n\ntag:`数学` `双指针` `二分查找`\n\n给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 `a2 + b2 = c` 。\n\n**示例 1：**\n\n```js\n输入： c = 5\n输出： true\n解释： 1 * 1 + 2 * 2 = 5\n```\n\n#### 题解：\n\n```js\n/**\n * @param {number} c\n * @return {boolean}\n */\nvar judgeSquareSum = function(c) {\n    let a = 0,b = Math.floor(Math.sqrt(c))\n\n    while(a<=b){\n        const s = a*a+b*b\n        if(s===c) return true\n\n        if(s<c){\n            a++\n        }else{\n            b--\n        }\n    }\n    return false\n};\n```\n\n#### 思路：\n\n这个题目其实和**两数之和**类似，使用相向双指针来解决，看成给定一个[0,.....,c]的数组，找出两个数满足： a+b=c\n\n一个指针p1指向头arr[0] ,一个指针p2指向尾arr[arr.length-1],因为数组是有序的，判断a+b是否大于，如果大于的话p2--，否则p1--\n\n#### 复杂度\n\n时间复杂度：O(c开根号)\n\n空间复杂度：O(1)\n","source":"_posts/平方数之和.md","raw":"---\ntitle: 【每日算法】平方数之和\ndate: 2024-11-03 18:31:02\ntags: 每日一题\ncategories: 算法\nindex_img: /img/post/leetcode.jpg\nbanner_img: \n---\n\n[663.平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/?envType=daily-question&envId=2024-11-05)\n\ntag:`数学` `双指针` `二分查找`\n\n给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 `a2 + b2 = c` 。\n\n**示例 1：**\n\n```js\n输入： c = 5\n输出： true\n解释： 1 * 1 + 2 * 2 = 5\n```\n\n#### 题解：\n\n```js\n/**\n * @param {number} c\n * @return {boolean}\n */\nvar judgeSquareSum = function(c) {\n    let a = 0,b = Math.floor(Math.sqrt(c))\n\n    while(a<=b){\n        const s = a*a+b*b\n        if(s===c) return true\n\n        if(s<c){\n            a++\n        }else{\n            b--\n        }\n    }\n    return false\n};\n```\n\n#### 思路：\n\n这个题目其实和**两数之和**类似，使用相向双指针来解决，看成给定一个[0,.....,c]的数组，找出两个数满足： a+b=c\n\n一个指针p1指向头arr[0] ,一个指针p2指向尾arr[arr.length-1],因为数组是有序的，判断a+b是否大于，如果大于的话p2--，否则p1--\n\n#### 复杂度\n\n时间复杂度：O(c开根号)\n\n空间复杂度：O(1)\n","slug":"平方数之和","published":1,"updated":"2024-11-17T13:58:10.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpp002l73t3ekieg99g","content":"<p><a href=\"https://leetcode.cn/problems/sum-of-square-numbers/?envType=daily-question&envId=2024-11-05\">663.平方数之和</a></p>\n<p>tag:<code>数学</code> <code>双指针</code> <code>二分查找</code></p>\n<p>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 <code>a2 + b2 = c</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">输入： c = <span class=\"hljs-number\">5</span><br>输出： <span class=\"hljs-literal\">true</span><br>解释： <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">2</span> = <span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number</span>&#125; <span class=\"hljs-variable\">c</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-type\">boolean</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">var</span> judgeSquareSum = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">c</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">0</span>,b = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sqrt</span>(c))<br><br>    <span class=\"hljs-keyword\">while</span>(a&lt;=b)&#123;<br>        <span class=\"hljs-keyword\">const</span> s = a*a+b*b<br>        <span class=\"hljs-keyword\">if</span>(s===c) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br><br>        <span class=\"hljs-keyword\">if</span>(s&lt;c)&#123;<br>            a++<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            b--<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>这个题目其实和<strong>两数之和</strong>类似，使用相向双指针来解决，看成给定一个[0,…..,c]的数组，找出两个数满足： a+b=c</p>\n<p>一个指针p1指向头arr[0] ,一个指针p2指向尾arr[arr.length-1],因为数组是有序的，判断a+b是否大于，如果大于的话p2–，否则p1–</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>时间复杂度：O(c开根号)</p>\n<p>空间复杂度：O(1)</p>\n","site":{"data":{}},"wordcount":532,"excerpt":"","more":"<p><a href=\"https://leetcode.cn/problems/sum-of-square-numbers/?envType=daily-question&envId=2024-11-05\">663.平方数之和</a></p>\n<p>tag:<code>数学</code> <code>双指针</code> <code>二分查找</code></p>\n<p>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 <code>a2 + b2 = c</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">输入： c = <span class=\"hljs-number\">5</span><br>输出： <span class=\"hljs-literal\">true</span><br>解释： <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">2</span> = <span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number</span>&#125; <span class=\"hljs-variable\">c</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-type\">boolean</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">var</span> judgeSquareSum = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">c</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">0</span>,b = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sqrt</span>(c))<br><br>    <span class=\"hljs-keyword\">while</span>(a&lt;=b)&#123;<br>        <span class=\"hljs-keyword\">const</span> s = a*a+b*b<br>        <span class=\"hljs-keyword\">if</span>(s===c) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br><br>        <span class=\"hljs-keyword\">if</span>(s&lt;c)&#123;<br>            a++<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            b--<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>这个题目其实和<strong>两数之和</strong>类似，使用相向双指针来解决，看成给定一个[0,…..,c]的数组，找出两个数满足： a+b=c</p>\n<p>一个指针p1指向头arr[0] ,一个指针p2指向尾arr[arr.length-1],因为数组是有序的，判断a+b是否大于，如果大于的话p2–，否则p1–</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>时间复杂度：O(c开根号)</p>\n<p>空间复杂度：O(1)</p>\n"},{"title":"有序数组中的单一元素","date":"2024-11-10T15:12:30.000Z","index_img":"/img/post/leetcode.jpg","banner_img":null,"_content":"\n[540. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/description/?envType=daily-question&envId=2024-11-10)\n\ntag:`数组` `二分查找`\n\n给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。\n\n请你找出并返回只出现一次的那个数。\n\n你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。\n\n**示例 1：**\n\n```js\n输入: nums = [1, 1, 2, 3, 3, 4, 4, 8, 8];\n输出: 2;\n```\n\n#### 题解：\n\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNonDuplicate = function (nums) {\n  let left = 0;\n  let right = nums.length - 1;\n\n  while (left < right) {\n    let mid = Math.floor((left + right) / 2);\n    if (mid % 2 === 1) {\n      mid -= 1;\n    }\n\n    // 判断mid和mid + 1是否是配对的\n    if (nums[mid] === nums[mid + 1]) {\n      // 配对在右半部分\n      left = mid + 2;\n    } else {\n      // 配对在左半部分\n      right = mid;\n    }\n  }\n\n  return nums[left];\n};\n```\n\n#### 思路：\n\n主要是要满足 **O(log n) 时间复杂度和 O(1) 空间复杂度**，所以不能使用哈希表。\n根据给的条件可知，只有一个数会出现一次，同时看到 O(log n)时间复杂度，就会想到二分查找。\n\n1. mid 指的下标是偶数的时候，说明左侧是奇数，如果都出现两次的话，那么 nums[mid] === nums[mid+1]，此时说明单一元素在右侧，所以 left = mid + 2\n2. mid 指的下标是奇数的时候，说明左侧是偶数，如果都出现两次的话，那么 nums[mid] === nums[mid-1]，此时说明单一元素在左侧，所以 right = mid\n3. 最后返回 nums[left] 即可\n\n#### 复杂度\n\n时间复杂度：O(log n)\n\n空间复杂度：O(1)\n","source":"_posts/有序数组中的单一元素.md","raw":"---\ntitle: 有序数组中的单一元素\ndate: 2024-11-10 23:12:30\ntags: 每日一题\ncategories: 算法\nindex_img: /img/post/leetcode.jpg\nbanner_img:\n---\n\n[540. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/description/?envType=daily-question&envId=2024-11-10)\n\ntag:`数组` `二分查找`\n\n给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。\n\n请你找出并返回只出现一次的那个数。\n\n你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。\n\n**示例 1：**\n\n```js\n输入: nums = [1, 1, 2, 3, 3, 4, 4, 8, 8];\n输出: 2;\n```\n\n#### 题解：\n\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNonDuplicate = function (nums) {\n  let left = 0;\n  let right = nums.length - 1;\n\n  while (left < right) {\n    let mid = Math.floor((left + right) / 2);\n    if (mid % 2 === 1) {\n      mid -= 1;\n    }\n\n    // 判断mid和mid + 1是否是配对的\n    if (nums[mid] === nums[mid + 1]) {\n      // 配对在右半部分\n      left = mid + 2;\n    } else {\n      // 配对在左半部分\n      right = mid;\n    }\n  }\n\n  return nums[left];\n};\n```\n\n#### 思路：\n\n主要是要满足 **O(log n) 时间复杂度和 O(1) 空间复杂度**，所以不能使用哈希表。\n根据给的条件可知，只有一个数会出现一次，同时看到 O(log n)时间复杂度，就会想到二分查找。\n\n1. mid 指的下标是偶数的时候，说明左侧是奇数，如果都出现两次的话，那么 nums[mid] === nums[mid+1]，此时说明单一元素在右侧，所以 left = mid + 2\n2. mid 指的下标是奇数的时候，说明左侧是偶数，如果都出现两次的话，那么 nums[mid] === nums[mid-1]，此时说明单一元素在左侧，所以 right = mid\n3. 最后返回 nums[left] 即可\n\n#### 复杂度\n\n时间复杂度：O(log n)\n\n空间复杂度：O(1)\n","slug":"有序数组中的单一元素","published":1,"updated":"2024-11-17T13:58:10.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpp002o73t33cwuey2n","content":"<p><a href=\"https://leetcode.cn/problems/single-element-in-a-sorted-array/description/?envType=daily-question&envId=2024-11-10\">540. 有序数组中的单一元素</a></p>\n<p>tag:<code>数组</code> <code>二分查找</code></p>\n<p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p>\n<p>请你找出并返回只出现一次的那个数。</p>\n<p>你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">输入: nums = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">8</span>];<br>输出: <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number[]</span>&#125; <span class=\"hljs-variable\">nums</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-type\">number</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">var</span> singleNonDuplicate = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> left = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">let</span> right = nums.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>;<br><br>  <span class=\"hljs-keyword\">while</span> (left &lt; right) &#123;<br>    <span class=\"hljs-keyword\">let</span> mid = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>((left + right) / <span class=\"hljs-number\">2</span>);<br>    <span class=\"hljs-keyword\">if</span> (mid % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">1</span>) &#123;<br>      mid -= <span class=\"hljs-number\">1</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 判断mid和mid + 1是否是配对的</span><br>    <span class=\"hljs-keyword\">if</span> (nums[mid] === nums[mid + <span class=\"hljs-number\">1</span>]) &#123;<br>      <span class=\"hljs-comment\">// 配对在右半部分</span><br>      left = mid + <span class=\"hljs-number\">2</span>;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-comment\">// 配对在左半部分</span><br>      right = mid;<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> nums[left];<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>主要是要满足 <strong>O(log n) 时间复杂度和 O(1) 空间复杂度</strong>，所以不能使用哈希表。<br>根据给的条件可知，只有一个数会出现一次，同时看到 O(log n)时间复杂度，就会想到二分查找。</p>\n<ol>\n<li>mid 指的下标是偶数的时候，说明左侧是奇数，如果都出现两次的话，那么 nums[mid] === nums[mid+1]，此时说明单一元素在右侧，所以 left = mid + 2</li>\n<li>mid 指的下标是奇数的时候，说明左侧是偶数，如果都出现两次的话，那么 nums[mid] === nums[mid-1]，此时说明单一元素在左侧，所以 right = mid</li>\n<li>最后返回 nums[left] 即可</li>\n</ol>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>时间复杂度：O(log n)</p>\n<p>空间复杂度：O(1)</p>\n","site":{"data":{}},"wordcount":867,"excerpt":"","more":"<p><a href=\"https://leetcode.cn/problems/single-element-in-a-sorted-array/description/?envType=daily-question&envId=2024-11-10\">540. 有序数组中的单一元素</a></p>\n<p>tag:<code>数组</code> <code>二分查找</code></p>\n<p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p>\n<p>请你找出并返回只出现一次的那个数。</p>\n<p>你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">输入: nums = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">8</span>];<br>输出: <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number[]</span>&#125; <span class=\"hljs-variable\">nums</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-type\">number</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">var</span> singleNonDuplicate = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> left = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">let</span> right = nums.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>;<br><br>  <span class=\"hljs-keyword\">while</span> (left &lt; right) &#123;<br>    <span class=\"hljs-keyword\">let</span> mid = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>((left + right) / <span class=\"hljs-number\">2</span>);<br>    <span class=\"hljs-keyword\">if</span> (mid % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">1</span>) &#123;<br>      mid -= <span class=\"hljs-number\">1</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 判断mid和mid + 1是否是配对的</span><br>    <span class=\"hljs-keyword\">if</span> (nums[mid] === nums[mid + <span class=\"hljs-number\">1</span>]) &#123;<br>      <span class=\"hljs-comment\">// 配对在右半部分</span><br>      left = mid + <span class=\"hljs-number\">2</span>;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-comment\">// 配对在左半部分</span><br>      right = mid;<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> nums[left];<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>主要是要满足 <strong>O(log n) 时间复杂度和 O(1) 空间复杂度</strong>，所以不能使用哈希表。<br>根据给的条件可知，只有一个数会出现一次，同时看到 O(log n)时间复杂度，就会想到二分查找。</p>\n<ol>\n<li>mid 指的下标是偶数的时候，说明左侧是奇数，如果都出现两次的话，那么 nums[mid] === nums[mid+1]，此时说明单一元素在右侧，所以 left = mid + 2</li>\n<li>mid 指的下标是奇数的时候，说明左侧是偶数，如果都出现两次的话，那么 nums[mid] === nums[mid-1]，此时说明单一元素在左侧，所以 right = mid</li>\n<li>最后返回 nums[left] 即可</li>\n</ol>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>时间复杂度：O(log n)</p>\n<p>空间复杂度：O(1)</p>\n"},{"title":"服务器端","date":"2021-04-11T05:44:55.000Z","index_img":"/img/server.jpg","banner_img":"/img/server-banner.jpg","_content":"\n## 1.服务器端基础概念\n\n#### 1.1URL\n\n统一资源定位符，又叫 URL(Uniform Resource Locator),是专门为标识 Internet 网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是 URL\n\n**URL 的组成**\n\n<p><span style=\"color:red\">传输协议：</span>服务器 ip 或域名:端口<span style=\"color:red\">资源所在位置标识</span></p>\n\n<p><span style=\"color:red\">http:</span>//www.badspider.top/<span style=\"color:red\">page/1024.html</span></p>\n\nhttp:超文本传输协议，提供了一种发布和接受 HTML 页面的方法\n\n> 关于端口，我们输入网址的时候是不需要写的，因为浏览器在请求的时候会默认加上 80 端口\n\n#### 1.2 开发过程中客户端和服务器端说明\n\n在开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑\n\n​ 开发人员电脑\n\n<div style=\"color:white; background-color:skyblue; width:200px; text-align:center;height:30px;line-height:30px\">客户端(浏览器)\n    </div>\n<div style=\"color:white; background-color:skyblue; width:200px; text-align:center;height:30px;line-height:30px\">\n    服务器端(Node)\n</div>\n\n本机域名：localhost\n\n本地 ip:127.0.0.1\n\n## 2.创建 web 服务器\n\n#### 2.1 创建 web 服务器\n\n```javascript\n//引用系统模块\nconst http = require(\"http\");\n//创建web服务器\nconst app = http.createSever();\n//当客户端发送请求的时候\napp.on(\"request\", (req, res) => {\n  //响应\n  res.end(\"<h1>hi,user</h1>\");\n});\n//监听3000端口\napp.listen(3000);\nconsole.log(\"服务器已经启动，监听3000端口，请访问localhost:3000\");\n```\n\n#### 2.2Http 协议的概念\n\n**报文**\n\n在 http 请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式\n\n![QQ截图20210408083639](../服务器端/server01.png)\n\n#### 2.3 请求报文\n\n1.请求方式（Request Method)\n\n- GET 请求数据\n- POST 发送数据 (更安全)\n\n  2.请求地址(Request URL)\n\n```javascript\napp.on(\"request\", (req, res) => {\n  req.headers; //获取请求报文\n  req.url; //获取请求地址\n  req.method; //获取请求方法\n});\n```\n\n#### 2.4 响应报文\n\n1. http 状态码\n\n   - 200 请求成功\n   - 404 请求的资源没有被找到\n   - 500 服务器端错误\n   - 400 客户端请求有语法错误\n\n2. 内容类型\n   - text/html\n   - text/css\n   - application/javascript\n   - image/jepg\n   - application/ json\n\n## 3.HTTP 请求与响应处理\n\n#### 3.1 请求参数\n\n客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作\n\n##### 3.1.1 GET 请求参数\n\n- 参数被放置在浏览器地址栏中，例如： http://127.0.0.1:3000?name=zhangsan&age=20\n\n> 问号后面的就是参数，如果传递多个用&分隔\n\n##### 3.1.2 POST 请求参数\n\nmethod： 指定当前表单提交的方式\n\naction： 指定当前表单提交的地址\n\n**post 参数是通过事件的方式接收的**\n\n1. data 当请求参数传递的时候触发 data 事件\n2. end 当参数传递完成的时候触发 end 事件\n\n```javascript\n//当客户端有请求来的时候\napp.on(\"request\", (req, res) => {\n  let postParams = \"\";\n  req.on(\"data\", (params) => {\n    postParams += params;\n  });\n  req.on(\"end\", () => {\n    console.log(postParams);\n  });\n  res.end(\"ok\");\n});\n```\n\n#### 3.2 路由\n\n路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么![QQ截图20210409091759](../服务器端/server02.png)\n\n```javascript\n//当客户端发来请求的时候\napp.on(\"request\", (req, res) => {\n  //获取客户端的请求路径\n  let { pathname } = url.parse(req.url);\n  if (pathname == \"/\" || pathname == \"/index\") {\n    res.end(\"welcome to index\");\n  } else if (pathname == \"/list\") {\n    res.end(\"welcome to list \");\n  } else {\n    res.end(\"sorry,404 not found\");\n  }\n});\n```\n\n#### 3.3 静态资源\n\n服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如 CSS,Javascript，image 文件\n\n```javascript\nconst http = require(\"http\");\nconst url = require(\"url\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\n\nvar app = http.createServer();\n\napp.on(\"request\", (req, res) => {\n  res.writeHead(200, {\n    \"content-type\": \"text/html;charset=utf8\",\n  });\n  //获取用户的请求路径\n  let pathname = url.parse(req.url).pathname;\n  //将用户的请求路径转换为实际的服务器硬盘路径\n  let readpath = path.join(__dirname, \"public\" + pathname);\n  //读取文件\n  fs.readFile(readpath, (error, result) => {\n    if (error != null) {\n      res.end(\"文件读取失败\");\n      return;\n    }\n    res.end(result);\n  });\n});\n\napp.listen(3000);\nconsole.log(\"It's working\");\n```\n\n#### 3.4 动态资源\n\n相同的请求地址不同的响应资源，这种资源就是动态资源\n\n## 4.Node.js 异步编程\n\n#### 4.1 同步 API,异步 API\n\n**同步 api：只有当前 api 执行完成后，才能继续执行下一个 api**\n\n```javascript\nconsole.log(\"before\");\nconsole.log(\"after\");\n```\n\n**异步 api：当前 api 的执行不会阻塞后续代码的执行**\n\n```javascript\nconsole.log('before')\nsetTimeout(\n\t()=>{console.log('last')}\n),2000)\nconsole.log('after')\n```\n\n#### 4.2 同步 api，异步 api 的区别（获取返回值）\n\n同步 api 可以从返回值中拿到 api 执行的结果，但是异步 api 是不可以的\n\n```javascript\n//同步\nfunction sum(s1, s2) {\n  return s1 + s2;\n}\nconst result = sum(10, 20);\n```\n\n```javascript\n//异步\nfunction getMsg() {\n  setTimeout(function () {\n    return (msg: \"hello node.js\");\n  }, 2000);\n}\n\nconst msg = getMsg();\nconsole.log(msg); //undefined\n```\n\n#### 4.3 回调函数\n\n自己定义函数让别人去调用\n\n```javascript\n//getData 函数定义\nfunction getData(callback) {}\n//getData 函数调用\ngetData(() => {});\n```\n\n#### 4.4 同步 api，异步 api 的区别（代码执行顺序）\n\n同步 api 从上到下依次执行，前面代码会阻塞后面代码的执行\n\n```javascript\nfor (var i = 1; i < 1000; i++) {\n  console.log(i);\n}\nconsole.log(\"it's ending\");\n```\n\n异步 api 不会等待 api 执行完成后再向下执行代码\n\n```javascript\nconsole.log(\"代码开始执行\");\nsetTimeout(() => {\n  console.log(\"ssss\");\n}, 2000);\nsetTimeout(() => {\n  console.log(\"aaa\");\n}, 0);\nconsole.log(\"it's ending\");\n```\n\n![屏幕截图 2021-04-09 194140](../服务器端/server03.png)\n\n> 会先执行完同步代码再去回调函数队列中拿回调函数执行\n\n#### 4.5Node.js 中的异步 api\n\n`fs.readFile('./demon.text',(err,result)=>{})`\n\n**回调地狱**\n\n```javascript\nconst fs = require(\"fs\");\n\nfs.readFile(\"./1.text\", \"utf8\", (err, result1) => {\n  console.log(result1);\n  fs.readFile(\"./2.text\", \"utf8\", (err, result2) => {\n    console.log(result2);\n    fs.readFile(\"./3.text\", \"utf8\", (err, result3) => {\n      console.log(result3);\n    });\n  });\n});\n```\n\n#### 4.6Promise\n\nPromise 出现的目的是解决 Node.js 异步编程中回调地狱的问题\n\n```javascript\nlet promise = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        if(true){\n\t\t\tresolve({name:'张三'})\n        }\n        else {\n            reject(\"失败了\")\n        }\n    }，2000)\n})\npromise.then(result=>console.log(result))\t\t//{name:'张三'}\n\t.catch(error=>console(error))\t\t\t\t//失败了\n```\n\n#### 4.7 异步函数\n\n异步函数是异步编程语法的终极解决方案，它可以让外面将异步代码写出同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了\n\n`const fn = async()=>{}`\n\n`async function fn(){}`\n\n> 1.在普通函数定义的前面加上 async 关键字，普通函数就变成了异步函数\n>\n> 2.异步函数默认的返回值是 promise 对象\n>\n> 3.在异步函数内部使用 return 关键字进行结果返回 结果会被包裹的 promise 对象中 return 关键字代替了 resolve 方法\n>\n> 4.在异步函数内部使用 throw 关键字抛出异常\n>\n> 5.调用异步函数再链式调用 then 方法获取异步函数执行结果\n>\n> 6.调用异步函数再链式调用 catch 方法获取异步函数执行的错误信息\n>\n> 7.await 关键字只能出现在异步函数中\n>\n> 8.await promise await 后面只能写 promise 对象 写其他类型的 api 是不可以的\n>\n> 9.await 关键字可以暂停异步函数向下执行 直到 promise 返回结果\n\n![QQ截图20210409202447](../服务器端/server04.png)\n\n```javascript\nconst fs = require(\"fs\");\n//改造现有异步函数api 让其返回promise对象\nconst promisify = require(\"util\").promisify;\nconst readFile = promisify(fs.readFile);\n\nasync function run() {\n  let r1 = await readFile(\"./1.txt\", \"utf8\");\n  let r2 = await readFile(\"./2.txt\", \"utf8\");\n  let r3 = await readFile(\"./3.txt\", \"utf8\");\n  console.log(r1);\n  console.log(r2);\n  console.log(r3);\n}\nrun();\n```\n","source":"_posts/服务器端.md","raw":"---\ntitle: 服务器端\ndate: 2021-04-11 13:44:55\ntags: 服务器端\ncategories: 后端\nindex_img: /img/server.jpg\nbanner_img: /img/server-banner.jpg\n---\n\n## 1.服务器端基础概念\n\n#### 1.1URL\n\n统一资源定位符，又叫 URL(Uniform Resource Locator),是专门为标识 Internet 网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是 URL\n\n**URL 的组成**\n\n<p><span style=\"color:red\">传输协议：</span>服务器 ip 或域名:端口<span style=\"color:red\">资源所在位置标识</span></p>\n\n<p><span style=\"color:red\">http:</span>//www.badspider.top/<span style=\"color:red\">page/1024.html</span></p>\n\nhttp:超文本传输协议，提供了一种发布和接受 HTML 页面的方法\n\n> 关于端口，我们输入网址的时候是不需要写的，因为浏览器在请求的时候会默认加上 80 端口\n\n#### 1.2 开发过程中客户端和服务器端说明\n\n在开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑\n\n​ 开发人员电脑\n\n<div style=\"color:white; background-color:skyblue; width:200px; text-align:center;height:30px;line-height:30px\">客户端(浏览器)\n    </div>\n<div style=\"color:white; background-color:skyblue; width:200px; text-align:center;height:30px;line-height:30px\">\n    服务器端(Node)\n</div>\n\n本机域名：localhost\n\n本地 ip:127.0.0.1\n\n## 2.创建 web 服务器\n\n#### 2.1 创建 web 服务器\n\n```javascript\n//引用系统模块\nconst http = require(\"http\");\n//创建web服务器\nconst app = http.createSever();\n//当客户端发送请求的时候\napp.on(\"request\", (req, res) => {\n  //响应\n  res.end(\"<h1>hi,user</h1>\");\n});\n//监听3000端口\napp.listen(3000);\nconsole.log(\"服务器已经启动，监听3000端口，请访问localhost:3000\");\n```\n\n#### 2.2Http 协议的概念\n\n**报文**\n\n在 http 请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式\n\n![QQ截图20210408083639](../服务器端/server01.png)\n\n#### 2.3 请求报文\n\n1.请求方式（Request Method)\n\n- GET 请求数据\n- POST 发送数据 (更安全)\n\n  2.请求地址(Request URL)\n\n```javascript\napp.on(\"request\", (req, res) => {\n  req.headers; //获取请求报文\n  req.url; //获取请求地址\n  req.method; //获取请求方法\n});\n```\n\n#### 2.4 响应报文\n\n1. http 状态码\n\n   - 200 请求成功\n   - 404 请求的资源没有被找到\n   - 500 服务器端错误\n   - 400 客户端请求有语法错误\n\n2. 内容类型\n   - text/html\n   - text/css\n   - application/javascript\n   - image/jepg\n   - application/ json\n\n## 3.HTTP 请求与响应处理\n\n#### 3.1 请求参数\n\n客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作\n\n##### 3.1.1 GET 请求参数\n\n- 参数被放置在浏览器地址栏中，例如： http://127.0.0.1:3000?name=zhangsan&age=20\n\n> 问号后面的就是参数，如果传递多个用&分隔\n\n##### 3.1.2 POST 请求参数\n\nmethod： 指定当前表单提交的方式\n\naction： 指定当前表单提交的地址\n\n**post 参数是通过事件的方式接收的**\n\n1. data 当请求参数传递的时候触发 data 事件\n2. end 当参数传递完成的时候触发 end 事件\n\n```javascript\n//当客户端有请求来的时候\napp.on(\"request\", (req, res) => {\n  let postParams = \"\";\n  req.on(\"data\", (params) => {\n    postParams += params;\n  });\n  req.on(\"end\", () => {\n    console.log(postParams);\n  });\n  res.end(\"ok\");\n});\n```\n\n#### 3.2 路由\n\n路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么![QQ截图20210409091759](../服务器端/server02.png)\n\n```javascript\n//当客户端发来请求的时候\napp.on(\"request\", (req, res) => {\n  //获取客户端的请求路径\n  let { pathname } = url.parse(req.url);\n  if (pathname == \"/\" || pathname == \"/index\") {\n    res.end(\"welcome to index\");\n  } else if (pathname == \"/list\") {\n    res.end(\"welcome to list \");\n  } else {\n    res.end(\"sorry,404 not found\");\n  }\n});\n```\n\n#### 3.3 静态资源\n\n服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如 CSS,Javascript，image 文件\n\n```javascript\nconst http = require(\"http\");\nconst url = require(\"url\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\n\nvar app = http.createServer();\n\napp.on(\"request\", (req, res) => {\n  res.writeHead(200, {\n    \"content-type\": \"text/html;charset=utf8\",\n  });\n  //获取用户的请求路径\n  let pathname = url.parse(req.url).pathname;\n  //将用户的请求路径转换为实际的服务器硬盘路径\n  let readpath = path.join(__dirname, \"public\" + pathname);\n  //读取文件\n  fs.readFile(readpath, (error, result) => {\n    if (error != null) {\n      res.end(\"文件读取失败\");\n      return;\n    }\n    res.end(result);\n  });\n});\n\napp.listen(3000);\nconsole.log(\"It's working\");\n```\n\n#### 3.4 动态资源\n\n相同的请求地址不同的响应资源，这种资源就是动态资源\n\n## 4.Node.js 异步编程\n\n#### 4.1 同步 API,异步 API\n\n**同步 api：只有当前 api 执行完成后，才能继续执行下一个 api**\n\n```javascript\nconsole.log(\"before\");\nconsole.log(\"after\");\n```\n\n**异步 api：当前 api 的执行不会阻塞后续代码的执行**\n\n```javascript\nconsole.log('before')\nsetTimeout(\n\t()=>{console.log('last')}\n),2000)\nconsole.log('after')\n```\n\n#### 4.2 同步 api，异步 api 的区别（获取返回值）\n\n同步 api 可以从返回值中拿到 api 执行的结果，但是异步 api 是不可以的\n\n```javascript\n//同步\nfunction sum(s1, s2) {\n  return s1 + s2;\n}\nconst result = sum(10, 20);\n```\n\n```javascript\n//异步\nfunction getMsg() {\n  setTimeout(function () {\n    return (msg: \"hello node.js\");\n  }, 2000);\n}\n\nconst msg = getMsg();\nconsole.log(msg); //undefined\n```\n\n#### 4.3 回调函数\n\n自己定义函数让别人去调用\n\n```javascript\n//getData 函数定义\nfunction getData(callback) {}\n//getData 函数调用\ngetData(() => {});\n```\n\n#### 4.4 同步 api，异步 api 的区别（代码执行顺序）\n\n同步 api 从上到下依次执行，前面代码会阻塞后面代码的执行\n\n```javascript\nfor (var i = 1; i < 1000; i++) {\n  console.log(i);\n}\nconsole.log(\"it's ending\");\n```\n\n异步 api 不会等待 api 执行完成后再向下执行代码\n\n```javascript\nconsole.log(\"代码开始执行\");\nsetTimeout(() => {\n  console.log(\"ssss\");\n}, 2000);\nsetTimeout(() => {\n  console.log(\"aaa\");\n}, 0);\nconsole.log(\"it's ending\");\n```\n\n![屏幕截图 2021-04-09 194140](../服务器端/server03.png)\n\n> 会先执行完同步代码再去回调函数队列中拿回调函数执行\n\n#### 4.5Node.js 中的异步 api\n\n`fs.readFile('./demon.text',(err,result)=>{})`\n\n**回调地狱**\n\n```javascript\nconst fs = require(\"fs\");\n\nfs.readFile(\"./1.text\", \"utf8\", (err, result1) => {\n  console.log(result1);\n  fs.readFile(\"./2.text\", \"utf8\", (err, result2) => {\n    console.log(result2);\n    fs.readFile(\"./3.text\", \"utf8\", (err, result3) => {\n      console.log(result3);\n    });\n  });\n});\n```\n\n#### 4.6Promise\n\nPromise 出现的目的是解决 Node.js 异步编程中回调地狱的问题\n\n```javascript\nlet promise = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        if(true){\n\t\t\tresolve({name:'张三'})\n        }\n        else {\n            reject(\"失败了\")\n        }\n    }，2000)\n})\npromise.then(result=>console.log(result))\t\t//{name:'张三'}\n\t.catch(error=>console(error))\t\t\t\t//失败了\n```\n\n#### 4.7 异步函数\n\n异步函数是异步编程语法的终极解决方案，它可以让外面将异步代码写出同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了\n\n`const fn = async()=>{}`\n\n`async function fn(){}`\n\n> 1.在普通函数定义的前面加上 async 关键字，普通函数就变成了异步函数\n>\n> 2.异步函数默认的返回值是 promise 对象\n>\n> 3.在异步函数内部使用 return 关键字进行结果返回 结果会被包裹的 promise 对象中 return 关键字代替了 resolve 方法\n>\n> 4.在异步函数内部使用 throw 关键字抛出异常\n>\n> 5.调用异步函数再链式调用 then 方法获取异步函数执行结果\n>\n> 6.调用异步函数再链式调用 catch 方法获取异步函数执行的错误信息\n>\n> 7.await 关键字只能出现在异步函数中\n>\n> 8.await promise await 后面只能写 promise 对象 写其他类型的 api 是不可以的\n>\n> 9.await 关键字可以暂停异步函数向下执行 直到 promise 返回结果\n\n![QQ截图20210409202447](../服务器端/server04.png)\n\n```javascript\nconst fs = require(\"fs\");\n//改造现有异步函数api 让其返回promise对象\nconst promisify = require(\"util\").promisify;\nconst readFile = promisify(fs.readFile);\n\nasync function run() {\n  let r1 = await readFile(\"./1.txt\", \"utf8\");\n  let r2 = await readFile(\"./2.txt\", \"utf8\");\n  let r3 = await readFile(\"./3.txt\", \"utf8\");\n  console.log(r1);\n  console.log(r2);\n  console.log(r3);\n}\nrun();\n```\n","slug":"服务器端","published":1,"updated":"2024-11-17T13:58:10.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpp002r73t39z9jgyv5","content":"<h2 id=\"1-服务器端基础概念\"><a href=\"#1-服务器端基础概念\" class=\"headerlink\" title=\"1.服务器端基础概念\"></a>1.服务器端基础概念</h2><h4 id=\"1-1URL\"><a href=\"#1-1URL\" class=\"headerlink\" title=\"1.1URL\"></a>1.1URL</h4><p>统一资源定位符，又叫 URL(Uniform Resource Locator),是专门为标识 Internet 网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是 URL</p>\n<p><strong>URL 的组成</strong></p>\n<p><span style=\"color:red\">传输协议：</span>服务器 ip 或域名:端口<span style=\"color:red\">资源所在位置标识</span></p>\n\n<p><span style=\"color:red\">http:</span>//www.badspider.top/<span style=\"color:red\">page/1024.html</span></p>\n\n<p>http:超文本传输协议，提供了一种发布和接受 HTML 页面的方法</p>\n<blockquote>\n<p>关于端口，我们输入网址的时候是不需要写的，因为浏览器在请求的时候会默认加上 80 端口</p>\n</blockquote>\n<h4 id=\"1-2-开发过程中客户端和服务器端说明\"><a href=\"#1-2-开发过程中客户端和服务器端说明\" class=\"headerlink\" title=\"1.2 开发过程中客户端和服务器端说明\"></a>1.2 开发过程中客户端和服务器端说明</h4><p>在开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑</p>\n<p>​ 开发人员电脑</p>\n<div style=\"color:white; background-color:skyblue; width:200px; text-align:center;height:30px;line-height:30px\">客户端(浏览器)\n    </div>\n<div style=\"color:white; background-color:skyblue; width:200px; text-align:center;height:30px;line-height:30px\">\n    服务器端(Node)\n</div>\n\n<p>本机域名：localhost</p>\n<p>本地 ip:127.0.0.1</p>\n<h2 id=\"2-创建-web-服务器\"><a href=\"#2-创建-web-服务器\" class=\"headerlink\" title=\"2.创建 web 服务器\"></a>2.创建 web 服务器</h2><h4 id=\"2-1-创建-web-服务器\"><a href=\"#2-1-创建-web-服务器\" class=\"headerlink\" title=\"2.1 创建 web 服务器\"></a>2.1 创建 web 服务器</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//引用系统模块</span><br><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;http&quot;</span>);<br><span class=\"hljs-comment\">//创建web服务器</span><br><span class=\"hljs-keyword\">const</span> app = http.<span class=\"hljs-title function_\">createSever</span>();<br><span class=\"hljs-comment\">//当客户端发送请求的时候</span><br>app.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">//响应</span><br>  res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&quot;&lt;h1&gt;hi,user&lt;/h1&gt;&quot;</span>);<br>&#125;);<br><span class=\"hljs-comment\">//监听3000端口</span><br>app.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;服务器已经启动，监听3000端口，请访问localhost:3000&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-2Http-协议的概念\"><a href=\"#2-2Http-协议的概念\" class=\"headerlink\" title=\"2.2Http 协议的概念\"></a>2.2Http 协议的概念</h4><p><strong>报文</strong></p>\n<p>在 http 请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式</p>\n<p><img src=\"/2021/04/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/server01.png\" alt=\"QQ截图20210408083639\"></p>\n<h4 id=\"2-3-请求报文\"><a href=\"#2-3-请求报文\" class=\"headerlink\" title=\"2.3 请求报文\"></a>2.3 请求报文</h4><p>1.请求方式（Request Method)</p>\n<ul>\n<li><p>GET 请求数据</p>\n</li>\n<li><p>POST 发送数据 (更安全)</p>\n<p>2.请求地址(Request URL)</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">app.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  req.<span class=\"hljs-property\">headers</span>; <span class=\"hljs-comment\">//获取请求报文</span><br>  req.<span class=\"hljs-property\">url</span>; <span class=\"hljs-comment\">//获取请求地址</span><br>  req.<span class=\"hljs-property\">method</span>; <span class=\"hljs-comment\">//获取请求方法</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-响应报文\"><a href=\"#2-4-响应报文\" class=\"headerlink\" title=\"2.4 响应报文\"></a>2.4 响应报文</h4><ol>\n<li><p>http 状态码</p>\n<ul>\n<li>200 请求成功</li>\n<li>404 请求的资源没有被找到</li>\n<li>500 服务器端错误</li>\n<li>400 客户端请求有语法错误</li>\n</ul>\n</li>\n<li><p>内容类型</p>\n<ul>\n<li>text/html</li>\n<li>text/css</li>\n<li>application/javascript</li>\n<li>image/jepg</li>\n<li>application/ json</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-HTTP-请求与响应处理\"><a href=\"#3-HTTP-请求与响应处理\" class=\"headerlink\" title=\"3.HTTP 请求与响应处理\"></a>3.HTTP 请求与响应处理</h2><h4 id=\"3-1-请求参数\"><a href=\"#3-1-请求参数\" class=\"headerlink\" title=\"3.1 请求参数\"></a>3.1 请求参数</h4><p>客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作</p>\n<h5 id=\"3-1-1-GET-请求参数\"><a href=\"#3-1-1-GET-请求参数\" class=\"headerlink\" title=\"3.1.1 GET 请求参数\"></a>3.1.1 GET 请求参数</h5><ul>\n<li>参数被放置在浏览器地址栏中，例如： <a href=\"http://127.0.0.1:3000/?name=zhangsan&amp;age=20\">http://127.0.0.1:3000?name=zhangsan&amp;age=20</a></li>\n</ul>\n<blockquote>\n<p>问号后面的就是参数，如果传递多个用&amp;分隔</p>\n</blockquote>\n<h5 id=\"3-1-2-POST-请求参数\"><a href=\"#3-1-2-POST-请求参数\" class=\"headerlink\" title=\"3.1.2 POST 请求参数\"></a>3.1.2 POST 请求参数</h5><p>method： 指定当前表单提交的方式</p>\n<p>action： 指定当前表单提交的地址</p>\n<p><strong>post 参数是通过事件的方式接收的</strong></p>\n<ol>\n<li>data 当请求参数传递的时候触发 data 事件</li>\n<li>end 当参数传递完成的时候触发 end 事件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//当客户端有请求来的时候</span><br>app.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">let</span> postParams = <span class=\"hljs-string\">&quot;&quot;</span>;<br>  req.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;data&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">params</span>) =&gt;</span> &#123;<br>    postParams += params;<br>  &#125;);<br>  req.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(postParams);<br>  &#125;);<br>  res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&quot;ok&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-路由\"><a href=\"#3-2-路由\" class=\"headerlink\" title=\"3.2 路由\"></a>3.2 路由</h4><p>路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么<img src=\"/2021/04/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/server02.png\" alt=\"QQ截图20210409091759\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//当客户端发来请求的时候</span><br>app.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">//获取客户端的请求路径</span><br>  <span class=\"hljs-keyword\">let</span> &#123; pathname &#125; = url.<span class=\"hljs-title function_\">parse</span>(req.<span class=\"hljs-property\">url</span>);<br>  <span class=\"hljs-keyword\">if</span> (pathname == <span class=\"hljs-string\">&quot;/&quot;</span> || pathname == <span class=\"hljs-string\">&quot;/index&quot;</span>) &#123;<br>    res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&quot;welcome to index&quot;</span>);<br>  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathname == <span class=\"hljs-string\">&quot;/list&quot;</span>) &#123;<br>    res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&quot;welcome to list &quot;</span>);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&quot;sorry,404 not found&quot;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-静态资源\"><a href=\"#3-3-静态资源\" class=\"headerlink\" title=\"3.3 静态资源\"></a>3.3 静态资源</h4><p>服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如 CSS,Javascript，image 文件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;http&quot;</span>);<br><span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;url&quot;</span>);<br><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>);<br><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;fs&quot;</span>);<br><br><span class=\"hljs-keyword\">var</span> app = http.<span class=\"hljs-title function_\">createServer</span>();<br><br>app.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123;<br>    <span class=\"hljs-string\">&quot;content-type&quot;</span>: <span class=\"hljs-string\">&quot;text/html;charset=utf8&quot;</span>,<br>  &#125;);<br>  <span class=\"hljs-comment\">//获取用户的请求路径</span><br>  <span class=\"hljs-keyword\">let</span> pathname = url.<span class=\"hljs-title function_\">parse</span>(req.<span class=\"hljs-property\">url</span>).<span class=\"hljs-property\">pathname</span>;<br>  <span class=\"hljs-comment\">//将用户的请求路径转换为实际的服务器硬盘路径</span><br>  <span class=\"hljs-keyword\">let</span> readpath = path.<span class=\"hljs-title function_\">join</span>(__dirname, <span class=\"hljs-string\">&quot;public&quot;</span> + pathname);<br>  <span class=\"hljs-comment\">//读取文件</span><br>  fs.<span class=\"hljs-title function_\">readFile</span>(readpath, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, result</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (error != <span class=\"hljs-literal\">null</span>) &#123;<br>      res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&quot;文件读取失败&quot;</span>);<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    res.<span class=\"hljs-title function_\">end</span>(result);<br>  &#125;);<br>&#125;);<br><br>app.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;It&#x27;s working&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-4-动态资源\"><a href=\"#3-4-动态资源\" class=\"headerlink\" title=\"3.4 动态资源\"></a>3.4 动态资源</h4><p>相同的请求地址不同的响应资源，这种资源就是动态资源</p>\n<h2 id=\"4-Node-js-异步编程\"><a href=\"#4-Node-js-异步编程\" class=\"headerlink\" title=\"4.Node.js 异步编程\"></a>4.Node.js 异步编程</h2><h4 id=\"4-1-同步-API-异步-API\"><a href=\"#4-1-同步-API-异步-API\" class=\"headerlink\" title=\"4.1 同步 API,异步 API\"></a>4.1 同步 API,异步 API</h4><p><strong>同步 api：只有当前 api 执行完成后，才能继续执行下一个 api</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;before&quot;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;after&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p><strong>异步 api：当前 api 的执行不会阻塞后续代码的执行</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;before&#x27;</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<br>\t<span class=\"hljs-function\">()=&gt;</span>&#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;last&#x27;</span>)&#125;<br>),<span class=\"hljs-number\">2000</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;after&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-同步-api，异步-api-的区别（获取返回值）\"><a href=\"#4-2-同步-api，异步-api-的区别（获取返回值）\" class=\"headerlink\" title=\"4.2 同步 api，异步 api 的区别（获取返回值）\"></a>4.2 同步 api，异步 api 的区别（获取返回值）</h4><p>同步 api 可以从返回值中拿到 api 执行的结果，但是异步 api 是不可以的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//同步</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">s1, s2</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> s1 + s2;<br>&#125;<br><span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>);<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//异步</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getMsg</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">&quot;hello node.js&quot;</span>);<br>  &#125;, <span class=\"hljs-number\">2000</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> msg = <span class=\"hljs-title function_\">getMsg</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(msg); <span class=\"hljs-comment\">//undefined</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-回调函数\"><a href=\"#4-3-回调函数\" class=\"headerlink\" title=\"4.3 回调函数\"></a>4.3 回调函数</h4><p>自己定义函数让别人去调用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//getData 函数定义</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getData</span>(<span class=\"hljs-params\">callback</span>) &#123;&#125;<br><span class=\"hljs-comment\">//getData 函数调用</span><br><span class=\"hljs-title function_\">getData</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;&#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-4-同步-api，异步-api-的区别（代码执行顺序）\"><a href=\"#4-4-同步-api，异步-api-的区别（代码执行顺序）\" class=\"headerlink\" title=\"4.4 同步 api，异步 api 的区别（代码执行顺序）\"></a>4.4 同步 api，异步 api 的区别（代码执行顺序）</h4><p>同步 api 从上到下依次执行，前面代码会阻塞后面代码的执行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;it&#x27;s ending&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>异步 api 不会等待 api 执行完成后再向下执行代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;代码开始执行&quot;</span>);<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;ssss&quot;</span>);<br>&#125;, <span class=\"hljs-number\">2000</span>);<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;aaa&quot;</span>);<br>&#125;, <span class=\"hljs-number\">0</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;it&#x27;s ending&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/2021/04/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/server03.png\" alt=\"屏幕截图 2021-04-09 194140\"></p>\n<blockquote>\n<p>会先执行完同步代码再去回调函数队列中拿回调函数执行</p>\n</blockquote>\n<h4 id=\"4-5Node-js-中的异步-api\"><a href=\"#4-5Node-js-中的异步-api\" class=\"headerlink\" title=\"4.5Node.js 中的异步 api\"></a>4.5Node.js 中的异步 api</h4><p><code>fs.readFile(&#39;./demon.text&#39;,(err,result)=&gt;&#123;&#125;)</code></p>\n<p><strong>回调地狱</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;fs&quot;</span>);<br><br>fs.<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./1.text&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, result1</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result1);<br>  fs.<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./2.text&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, result2</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result2);<br>    fs.<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./3.text&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, result3</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result3);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-6Promise\"><a href=\"#4-6Promise\" class=\"headerlink\" title=\"4.6Promise\"></a>4.6Promise</h4><p>Promise 出现的目的是解决 Node.js 异步编程中回调地狱的问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-literal\">true</span>)&#123;<br>\t\t\t<span class=\"hljs-title function_\">resolve</span>(&#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&#x27;张三&#x27;</span>&#125;)<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-string\">&quot;失败了&quot;</span>)<br>        &#125;<br>    &#125;，<span class=\"hljs-number\">2000</span>)<br>&#125;)<br>promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result))\t\t<span class=\"hljs-comment\">//&#123;name:&#x27;张三&#x27;&#125;</span><br>\t.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span>=&gt;</span><span class=\"hljs-title function_\">console</span>(error))\t\t\t\t<span class=\"hljs-comment\">//失败了</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-7-异步函数\"><a href=\"#4-7-异步函数\" class=\"headerlink\" title=\"4.7 异步函数\"></a>4.7 异步函数</h4><p>异步函数是异步编程语法的终极解决方案，它可以让外面将异步代码写出同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了</p>\n<p><code>const fn = async()=&gt;&#123;&#125;</code></p>\n<p><code>async function fn()&#123;&#125;</code></p>\n<blockquote>\n<p>1.在普通函数定义的前面加上 async 关键字，普通函数就变成了异步函数</p>\n<p>2.异步函数默认的返回值是 promise 对象</p>\n<p>3.在异步函数内部使用 return 关键字进行结果返回 结果会被包裹的 promise 对象中 return 关键字代替了 resolve 方法</p>\n<p>4.在异步函数内部使用 throw 关键字抛出异常</p>\n<p>5.调用异步函数再链式调用 then 方法获取异步函数执行结果</p>\n<p>6.调用异步函数再链式调用 catch 方法获取异步函数执行的错误信息</p>\n<p>7.await 关键字只能出现在异步函数中</p>\n<p>8.await promise await 后面只能写 promise 对象 写其他类型的 api 是不可以的</p>\n<p>9.await 关键字可以暂停异步函数向下执行 直到 promise 返回结果</p>\n</blockquote>\n<p><img src=\"/2021/04/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/server04.png\" alt=\"QQ截图20210409202447\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;fs&quot;</span>);<br><span class=\"hljs-comment\">//改造现有异步函数api 让其返回promise对象</span><br><span class=\"hljs-keyword\">const</span> promisify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;util&quot;</span>).<span class=\"hljs-property\">promisify</span>;<br><span class=\"hljs-keyword\">const</span> readFile = <span class=\"hljs-title function_\">promisify</span>(fs.<span class=\"hljs-property\">readFile</span>);<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">run</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> r1 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./1.txt&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>);<br>  <span class=\"hljs-keyword\">let</span> r2 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./2.txt&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>);<br>  <span class=\"hljs-keyword\">let</span> r3 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./3.txt&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r1);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r2);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r3);<br>&#125;<br><span class=\"hljs-title function_\">run</span>();<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":5569,"excerpt":"","more":"<h2 id=\"1-服务器端基础概念\"><a href=\"#1-服务器端基础概念\" class=\"headerlink\" title=\"1.服务器端基础概念\"></a>1.服务器端基础概念</h2><h4 id=\"1-1URL\"><a href=\"#1-1URL\" class=\"headerlink\" title=\"1.1URL\"></a>1.1URL</h4><p>统一资源定位符，又叫 URL(Uniform Resource Locator),是专门为标识 Internet 网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是 URL</p>\n<p><strong>URL 的组成</strong></p>\n<p><span style=\"color:red\">传输协议：</span>服务器 ip 或域名:端口<span style=\"color:red\">资源所在位置标识</span></p>\n\n<p><span style=\"color:red\">http:</span>//www.badspider.top/<span style=\"color:red\">page/1024.html</span></p>\n\n<p>http:超文本传输协议，提供了一种发布和接受 HTML 页面的方法</p>\n<blockquote>\n<p>关于端口，我们输入网址的时候是不需要写的，因为浏览器在请求的时候会默认加上 80 端口</p>\n</blockquote>\n<h4 id=\"1-2-开发过程中客户端和服务器端说明\"><a href=\"#1-2-开发过程中客户端和服务器端说明\" class=\"headerlink\" title=\"1.2 开发过程中客户端和服务器端说明\"></a>1.2 开发过程中客户端和服务器端说明</h4><p>在开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑</p>\n<p>​ 开发人员电脑</p>\n<div style=\"color:white; background-color:skyblue; width:200px; text-align:center;height:30px;line-height:30px\">客户端(浏览器)\n    </div>\n<div style=\"color:white; background-color:skyblue; width:200px; text-align:center;height:30px;line-height:30px\">\n    服务器端(Node)\n</div>\n\n<p>本机域名：localhost</p>\n<p>本地 ip:127.0.0.1</p>\n<h2 id=\"2-创建-web-服务器\"><a href=\"#2-创建-web-服务器\" class=\"headerlink\" title=\"2.创建 web 服务器\"></a>2.创建 web 服务器</h2><h4 id=\"2-1-创建-web-服务器\"><a href=\"#2-1-创建-web-服务器\" class=\"headerlink\" title=\"2.1 创建 web 服务器\"></a>2.1 创建 web 服务器</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//引用系统模块</span><br><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;http&quot;</span>);<br><span class=\"hljs-comment\">//创建web服务器</span><br><span class=\"hljs-keyword\">const</span> app = http.<span class=\"hljs-title function_\">createSever</span>();<br><span class=\"hljs-comment\">//当客户端发送请求的时候</span><br>app.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">//响应</span><br>  res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&quot;&lt;h1&gt;hi,user&lt;/h1&gt;&quot;</span>);<br>&#125;);<br><span class=\"hljs-comment\">//监听3000端口</span><br>app.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;服务器已经启动，监听3000端口，请访问localhost:3000&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-2Http-协议的概念\"><a href=\"#2-2Http-协议的概念\" class=\"headerlink\" title=\"2.2Http 协议的概念\"></a>2.2Http 协议的概念</h4><p><strong>报文</strong></p>\n<p>在 http 请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式</p>\n<p><img src=\"/2021/04/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/server01.png\" alt=\"QQ截图20210408083639\"></p>\n<h4 id=\"2-3-请求报文\"><a href=\"#2-3-请求报文\" class=\"headerlink\" title=\"2.3 请求报文\"></a>2.3 请求报文</h4><p>1.请求方式（Request Method)</p>\n<ul>\n<li><p>GET 请求数据</p>\n</li>\n<li><p>POST 发送数据 (更安全)</p>\n<p>2.请求地址(Request URL)</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">app.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  req.<span class=\"hljs-property\">headers</span>; <span class=\"hljs-comment\">//获取请求报文</span><br>  req.<span class=\"hljs-property\">url</span>; <span class=\"hljs-comment\">//获取请求地址</span><br>  req.<span class=\"hljs-property\">method</span>; <span class=\"hljs-comment\">//获取请求方法</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-响应报文\"><a href=\"#2-4-响应报文\" class=\"headerlink\" title=\"2.4 响应报文\"></a>2.4 响应报文</h4><ol>\n<li><p>http 状态码</p>\n<ul>\n<li>200 请求成功</li>\n<li>404 请求的资源没有被找到</li>\n<li>500 服务器端错误</li>\n<li>400 客户端请求有语法错误</li>\n</ul>\n</li>\n<li><p>内容类型</p>\n<ul>\n<li>text/html</li>\n<li>text/css</li>\n<li>application/javascript</li>\n<li>image/jepg</li>\n<li>application/ json</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-HTTP-请求与响应处理\"><a href=\"#3-HTTP-请求与响应处理\" class=\"headerlink\" title=\"3.HTTP 请求与响应处理\"></a>3.HTTP 请求与响应处理</h2><h4 id=\"3-1-请求参数\"><a href=\"#3-1-请求参数\" class=\"headerlink\" title=\"3.1 请求参数\"></a>3.1 请求参数</h4><p>客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作</p>\n<h5 id=\"3-1-1-GET-请求参数\"><a href=\"#3-1-1-GET-请求参数\" class=\"headerlink\" title=\"3.1.1 GET 请求参数\"></a>3.1.1 GET 请求参数</h5><ul>\n<li>参数被放置在浏览器地址栏中，例如： <a href=\"http://127.0.0.1:3000/?name=zhangsan&amp;age=20\">http://127.0.0.1:3000?name=zhangsan&amp;age=20</a></li>\n</ul>\n<blockquote>\n<p>问号后面的就是参数，如果传递多个用&amp;分隔</p>\n</blockquote>\n<h5 id=\"3-1-2-POST-请求参数\"><a href=\"#3-1-2-POST-请求参数\" class=\"headerlink\" title=\"3.1.2 POST 请求参数\"></a>3.1.2 POST 请求参数</h5><p>method： 指定当前表单提交的方式</p>\n<p>action： 指定当前表单提交的地址</p>\n<p><strong>post 参数是通过事件的方式接收的</strong></p>\n<ol>\n<li>data 当请求参数传递的时候触发 data 事件</li>\n<li>end 当参数传递完成的时候触发 end 事件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//当客户端有请求来的时候</span><br>app.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">let</span> postParams = <span class=\"hljs-string\">&quot;&quot;</span>;<br>  req.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;data&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">params</span>) =&gt;</span> &#123;<br>    postParams += params;<br>  &#125;);<br>  req.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;end&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(postParams);<br>  &#125;);<br>  res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&quot;ok&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-路由\"><a href=\"#3-2-路由\" class=\"headerlink\" title=\"3.2 路由\"></a>3.2 路由</h4><p>路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么<img src=\"/2021/04/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/server02.png\" alt=\"QQ截图20210409091759\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//当客户端发来请求的时候</span><br>app.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">//获取客户端的请求路径</span><br>  <span class=\"hljs-keyword\">let</span> &#123; pathname &#125; = url.<span class=\"hljs-title function_\">parse</span>(req.<span class=\"hljs-property\">url</span>);<br>  <span class=\"hljs-keyword\">if</span> (pathname == <span class=\"hljs-string\">&quot;/&quot;</span> || pathname == <span class=\"hljs-string\">&quot;/index&quot;</span>) &#123;<br>    res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&quot;welcome to index&quot;</span>);<br>  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pathname == <span class=\"hljs-string\">&quot;/list&quot;</span>) &#123;<br>    res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&quot;welcome to list &quot;</span>);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&quot;sorry,404 not found&quot;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-静态资源\"><a href=\"#3-3-静态资源\" class=\"headerlink\" title=\"3.3 静态资源\"></a>3.3 静态资源</h4><p>服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如 CSS,Javascript，image 文件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;http&quot;</span>);<br><span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;url&quot;</span>);<br><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>);<br><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;fs&quot;</span>);<br><br><span class=\"hljs-keyword\">var</span> app = http.<span class=\"hljs-title function_\">createServer</span>();<br><br>app.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123;<br>    <span class=\"hljs-string\">&quot;content-type&quot;</span>: <span class=\"hljs-string\">&quot;text/html;charset=utf8&quot;</span>,<br>  &#125;);<br>  <span class=\"hljs-comment\">//获取用户的请求路径</span><br>  <span class=\"hljs-keyword\">let</span> pathname = url.<span class=\"hljs-title function_\">parse</span>(req.<span class=\"hljs-property\">url</span>).<span class=\"hljs-property\">pathname</span>;<br>  <span class=\"hljs-comment\">//将用户的请求路径转换为实际的服务器硬盘路径</span><br>  <span class=\"hljs-keyword\">let</span> readpath = path.<span class=\"hljs-title function_\">join</span>(__dirname, <span class=\"hljs-string\">&quot;public&quot;</span> + pathname);<br>  <span class=\"hljs-comment\">//读取文件</span><br>  fs.<span class=\"hljs-title function_\">readFile</span>(readpath, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, result</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (error != <span class=\"hljs-literal\">null</span>) &#123;<br>      res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&quot;文件读取失败&quot;</span>);<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    res.<span class=\"hljs-title function_\">end</span>(result);<br>  &#125;);<br>&#125;);<br><br>app.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;It&#x27;s working&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-4-动态资源\"><a href=\"#3-4-动态资源\" class=\"headerlink\" title=\"3.4 动态资源\"></a>3.4 动态资源</h4><p>相同的请求地址不同的响应资源，这种资源就是动态资源</p>\n<h2 id=\"4-Node-js-异步编程\"><a href=\"#4-Node-js-异步编程\" class=\"headerlink\" title=\"4.Node.js 异步编程\"></a>4.Node.js 异步编程</h2><h4 id=\"4-1-同步-API-异步-API\"><a href=\"#4-1-同步-API-异步-API\" class=\"headerlink\" title=\"4.1 同步 API,异步 API\"></a>4.1 同步 API,异步 API</h4><p><strong>同步 api：只有当前 api 执行完成后，才能继续执行下一个 api</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;before&quot;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;after&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p><strong>异步 api：当前 api 的执行不会阻塞后续代码的执行</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;before&#x27;</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<br>\t<span class=\"hljs-function\">()=&gt;</span>&#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;last&#x27;</span>)&#125;<br>),<span class=\"hljs-number\">2000</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;after&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-同步-api，异步-api-的区别（获取返回值）\"><a href=\"#4-2-同步-api，异步-api-的区别（获取返回值）\" class=\"headerlink\" title=\"4.2 同步 api，异步 api 的区别（获取返回值）\"></a>4.2 同步 api，异步 api 的区别（获取返回值）</h4><p>同步 api 可以从返回值中拿到 api 执行的结果，但是异步 api 是不可以的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//同步</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">s1, s2</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> s1 + s2;<br>&#125;<br><span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>);<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//异步</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getMsg</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">&quot;hello node.js&quot;</span>);<br>  &#125;, <span class=\"hljs-number\">2000</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> msg = <span class=\"hljs-title function_\">getMsg</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(msg); <span class=\"hljs-comment\">//undefined</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-回调函数\"><a href=\"#4-3-回调函数\" class=\"headerlink\" title=\"4.3 回调函数\"></a>4.3 回调函数</h4><p>自己定义函数让别人去调用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//getData 函数定义</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getData</span>(<span class=\"hljs-params\">callback</span>) &#123;&#125;<br><span class=\"hljs-comment\">//getData 函数调用</span><br><span class=\"hljs-title function_\">getData</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;&#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-4-同步-api，异步-api-的区别（代码执行顺序）\"><a href=\"#4-4-同步-api，异步-api-的区别（代码执行顺序）\" class=\"headerlink\" title=\"4.4 同步 api，异步 api 的区别（代码执行顺序）\"></a>4.4 同步 api，异步 api 的区别（代码执行顺序）</h4><p>同步 api 从上到下依次执行，前面代码会阻塞后面代码的执行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;it&#x27;s ending&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>异步 api 不会等待 api 执行完成后再向下执行代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;代码开始执行&quot;</span>);<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;ssss&quot;</span>);<br>&#125;, <span class=\"hljs-number\">2000</span>);<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;aaa&quot;</span>);<br>&#125;, <span class=\"hljs-number\">0</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;it&#x27;s ending&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/2021/04/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/server03.png\" alt=\"屏幕截图 2021-04-09 194140\"></p>\n<blockquote>\n<p>会先执行完同步代码再去回调函数队列中拿回调函数执行</p>\n</blockquote>\n<h4 id=\"4-5Node-js-中的异步-api\"><a href=\"#4-5Node-js-中的异步-api\" class=\"headerlink\" title=\"4.5Node.js 中的异步 api\"></a>4.5Node.js 中的异步 api</h4><p><code>fs.readFile(&#39;./demon.text&#39;,(err,result)=&gt;&#123;&#125;)</code></p>\n<p><strong>回调地狱</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;fs&quot;</span>);<br><br>fs.<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./1.text&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, result1</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result1);<br>  fs.<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./2.text&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, result2</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result2);<br>    fs.<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./3.text&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, result3</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result3);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-6Promise\"><a href=\"#4-6Promise\" class=\"headerlink\" title=\"4.6Promise\"></a>4.6Promise</h4><p>Promise 出现的目的是解决 Node.js 异步编程中回调地狱的问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-literal\">true</span>)&#123;<br>\t\t\t<span class=\"hljs-title function_\">resolve</span>(&#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&#x27;张三&#x27;</span>&#125;)<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-string\">&quot;失败了&quot;</span>)<br>        &#125;<br>    &#125;，<span class=\"hljs-number\">2000</span>)<br>&#125;)<br>promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span>=&gt;</span><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result))\t\t<span class=\"hljs-comment\">//&#123;name:&#x27;张三&#x27;&#125;</span><br>\t.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span>=&gt;</span><span class=\"hljs-title function_\">console</span>(error))\t\t\t\t<span class=\"hljs-comment\">//失败了</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-7-异步函数\"><a href=\"#4-7-异步函数\" class=\"headerlink\" title=\"4.7 异步函数\"></a>4.7 异步函数</h4><p>异步函数是异步编程语法的终极解决方案，它可以让外面将异步代码写出同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了</p>\n<p><code>const fn = async()=&gt;&#123;&#125;</code></p>\n<p><code>async function fn()&#123;&#125;</code></p>\n<blockquote>\n<p>1.在普通函数定义的前面加上 async 关键字，普通函数就变成了异步函数</p>\n<p>2.异步函数默认的返回值是 promise 对象</p>\n<p>3.在异步函数内部使用 return 关键字进行结果返回 结果会被包裹的 promise 对象中 return 关键字代替了 resolve 方法</p>\n<p>4.在异步函数内部使用 throw 关键字抛出异常</p>\n<p>5.调用异步函数再链式调用 then 方法获取异步函数执行结果</p>\n<p>6.调用异步函数再链式调用 catch 方法获取异步函数执行的错误信息</p>\n<p>7.await 关键字只能出现在异步函数中</p>\n<p>8.await promise await 后面只能写 promise 对象 写其他类型的 api 是不可以的</p>\n<p>9.await 关键字可以暂停异步函数向下执行 直到 promise 返回结果</p>\n</blockquote>\n<p><img src=\"/2021/04/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/server04.png\" alt=\"QQ截图20210409202447\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;fs&quot;</span>);<br><span class=\"hljs-comment\">//改造现有异步函数api 让其返回promise对象</span><br><span class=\"hljs-keyword\">const</span> promisify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;util&quot;</span>).<span class=\"hljs-property\">promisify</span>;<br><span class=\"hljs-keyword\">const</span> readFile = <span class=\"hljs-title function_\">promisify</span>(fs.<span class=\"hljs-property\">readFile</span>);<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">run</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> r1 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./1.txt&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>);<br>  <span class=\"hljs-keyword\">let</span> r2 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./2.txt&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>);<br>  <span class=\"hljs-keyword\">let</span> r3 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./3.txt&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r1);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r2);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r3);<br>&#125;<br><span class=\"hljs-title function_\">run</span>();<br></code></pre></td></tr></table></figure>\n"},{"title":"检测相邻递增子数组 II","date":"2024-11-10T15:28:54.000Z","index_img":"/img/post/leetcode.jpg","banner_img":null,"_content":"\n[3350. 检测相邻递增子数组 II](https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-ii/description/)\n\ntag:`动态规划` `二分查找`\n\n给你一个由 n 个整数组成的数组 nums ，请你找出 k 的 最大值，使得存在 两个 相邻 且长度为 k 的 严格递增 子数组。具体来说，需要检查是否存在从下标 a 和 b (a < b) 开始的 两个 子数组，并满足下述全部条件：\n\n这两个子数组 nums[a..a + k - 1] 和 nums[b..b + k - 1] 都是 严格递增 的。\n这两个子数组必须是 相邻的，即 b = a + k。\n返回 k 的 最大可能 值。\n\n子数组 是数组中的一个连续 非空 的元素序列。\n\n**示例 1：**\n\n```js\n输入：nums = [2,5,7,8,9,2,3,4,3,1]\n\n输出：3\n\n解释：\n\n从下标 2 开始的子数组是 [7, 8, 9]，它是严格递增的。\n从下标 5 开始的子数组是 [2, 3, 4]，它也是严格递增的。\n这两个子数组是相邻的，因此 3 是满足题目条件的 最大 k 值。\n\n\n```\n\n#### 题解：\n\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxIncreasingSubarrays = function (nums) {\n  let pre = 0,\n    cnt = 0,\n    ans = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    cnt++;\n\n    if (i === nums.length - 1 || nums[i] >= nums[i + 1]) {\n      ans = Math.max(ans, Math.floor(cnt / 2), Math.min(pre, cnt));\n      pre = cnt;\n      cnt = 0;\n    }\n  }\n\n  return ans;\n};\n```\n\n#### 思路：\n\n- 遍历数组，统计递增子数组的长度，当遇到非递增的元素时，更新最大值，并重置递增子数组的长度。\n- 遍历过程中，记录当前递增子数组的长度，以及上一个递增子数组的长度。\n- 更新最大值时，需要考虑两种情况：\n  - 当前递增子数组的长度的一半，即可以拆分成两个递增子数组。\n  - 上一个递增子数组的长度和当前递增子数组的长度，即可以合并成一个递增子数组。\n\n#### 复杂度：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","source":"_posts/检测相邻递增子数组-II.md","raw":"---\ntitle: 检测相邻递增子数组 II\ndate: 2024-11-10 23:28:54\ntags: 算法\ncategories: 算法\nindex_img: /img/post/leetcode.jpg\nbanner_img:\n---\n\n[3350. 检测相邻递增子数组 II](https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-ii/description/)\n\ntag:`动态规划` `二分查找`\n\n给你一个由 n 个整数组成的数组 nums ，请你找出 k 的 最大值，使得存在 两个 相邻 且长度为 k 的 严格递增 子数组。具体来说，需要检查是否存在从下标 a 和 b (a < b) 开始的 两个 子数组，并满足下述全部条件：\n\n这两个子数组 nums[a..a + k - 1] 和 nums[b..b + k - 1] 都是 严格递增 的。\n这两个子数组必须是 相邻的，即 b = a + k。\n返回 k 的 最大可能 值。\n\n子数组 是数组中的一个连续 非空 的元素序列。\n\n**示例 1：**\n\n```js\n输入：nums = [2,5,7,8,9,2,3,4,3,1]\n\n输出：3\n\n解释：\n\n从下标 2 开始的子数组是 [7, 8, 9]，它是严格递增的。\n从下标 5 开始的子数组是 [2, 3, 4]，它也是严格递增的。\n这两个子数组是相邻的，因此 3 是满足题目条件的 最大 k 值。\n\n\n```\n\n#### 题解：\n\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxIncreasingSubarrays = function (nums) {\n  let pre = 0,\n    cnt = 0,\n    ans = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    cnt++;\n\n    if (i === nums.length - 1 || nums[i] >= nums[i + 1]) {\n      ans = Math.max(ans, Math.floor(cnt / 2), Math.min(pre, cnt));\n      pre = cnt;\n      cnt = 0;\n    }\n  }\n\n  return ans;\n};\n```\n\n#### 思路：\n\n- 遍历数组，统计递增子数组的长度，当遇到非递增的元素时，更新最大值，并重置递增子数组的长度。\n- 遍历过程中，记录当前递增子数组的长度，以及上一个递增子数组的长度。\n- 更新最大值时，需要考虑两种情况：\n  - 当前递增子数组的长度的一半，即可以拆分成两个递增子数组。\n  - 上一个递增子数组的长度和当前递增子数组的长度，即可以合并成一个递增子数组。\n\n#### 复杂度：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","slug":"检测相邻递增子数组-II","published":1,"updated":"2024-11-17T13:58:10.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpp002u73t38gkuffzc","content":"<p><a href=\"https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-ii/description/\">3350. 检测相邻递增子数组 II</a></p>\n<p>tag:<code>动态规划</code> <code>二分查找</code></p>\n<p>给你一个由 n 个整数组成的数组 nums ，请你找出 k 的 最大值，使得存在 两个 相邻 且长度为 k 的 严格递增 子数组。具体来说，需要检查是否存在从下标 a 和 b (a &lt; b) 开始的 两个 子数组，并满足下述全部条件：</p>\n<p>这两个子数组 nums[a..a + k - 1] 和 nums[b..b + k - 1] 都是 严格递增 的。<br>这两个子数组必须是 相邻的，即 b = a + k。<br>返回 k 的 最大可能 值。</p>\n<p>子数组 是数组中的一个连续 非空 的元素序列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">输入：nums = [<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">1</span>]<br><br>输出：<span class=\"hljs-number\">3</span><br><br>解释：<br><br>从下标 <span class=\"hljs-number\">2</span> 开始的子数组是 [<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>]，它是严格递增的。<br>从下标 <span class=\"hljs-number\">5</span> 开始的子数组是 [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]，它也是严格递增的。<br>这两个子数组是相邻的，因此 <span class=\"hljs-number\">3</span> 是满足题目条件的 最大 k 值。<br><br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number[]</span>&#125; <span class=\"hljs-variable\">nums</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-type\">number</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">var</span> maxIncreasingSubarrays = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> pre = <span class=\"hljs-number\">0</span>,<br>    cnt = <span class=\"hljs-number\">0</span>,<br>    ans = <span class=\"hljs-number\">0</span>;<br><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.<span class=\"hljs-property\">length</span>; i++) &#123;<br>    cnt++;<br><br>    <span class=\"hljs-keyword\">if</span> (i === nums.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span> || nums[i] &gt;= nums[i + <span class=\"hljs-number\">1</span>]) &#123;<br>      ans = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(ans, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(cnt / <span class=\"hljs-number\">2</span>), <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(pre, cnt));<br>      pre = cnt;<br>      cnt = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><ul>\n<li>遍历数组，统计递增子数组的长度，当遇到非递增的元素时，更新最大值，并重置递增子数组的长度。</li>\n<li>遍历过程中，记录当前递增子数组的长度，以及上一个递增子数组的长度。</li>\n<li>更新最大值时，需要考虑两种情况：<ul>\n<li>当前递增子数组的长度的一半，即可以拆分成两个递增子数组。</li>\n<li>上一个递增子数组的长度和当前递增子数组的长度，即可以合并成一个递增子数组。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"复杂度：\"><a href=\"#复杂度：\" class=\"headerlink\" title=\"复杂度：\"></a>复杂度：</h4><ul>\n<li>时间复杂度：O(n)</li>\n<li>空间复杂度：O(1)</li>\n</ul>\n","site":{"data":{}},"wordcount":895,"excerpt":"","more":"<p><a href=\"https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-ii/description/\">3350. 检测相邻递增子数组 II</a></p>\n<p>tag:<code>动态规划</code> <code>二分查找</code></p>\n<p>给你一个由 n 个整数组成的数组 nums ，请你找出 k 的 最大值，使得存在 两个 相邻 且长度为 k 的 严格递增 子数组。具体来说，需要检查是否存在从下标 a 和 b (a &lt; b) 开始的 两个 子数组，并满足下述全部条件：</p>\n<p>这两个子数组 nums[a..a + k - 1] 和 nums[b..b + k - 1] 都是 严格递增 的。<br>这两个子数组必须是 相邻的，即 b = a + k。<br>返回 k 的 最大可能 值。</p>\n<p>子数组 是数组中的一个连续 非空 的元素序列。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">输入：nums = [<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">1</span>]<br><br>输出：<span class=\"hljs-number\">3</span><br><br>解释：<br><br>从下标 <span class=\"hljs-number\">2</span> 开始的子数组是 [<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>]，它是严格递增的。<br>从下标 <span class=\"hljs-number\">5</span> 开始的子数组是 [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]，它也是严格递增的。<br>这两个子数组是相邻的，因此 <span class=\"hljs-number\">3</span> 是满足题目条件的 最大 k 值。<br><br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number[]</span>&#125; <span class=\"hljs-variable\">nums</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-type\">number</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">var</span> maxIncreasingSubarrays = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> pre = <span class=\"hljs-number\">0</span>,<br>    cnt = <span class=\"hljs-number\">0</span>,<br>    ans = <span class=\"hljs-number\">0</span>;<br><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.<span class=\"hljs-property\">length</span>; i++) &#123;<br>    cnt++;<br><br>    <span class=\"hljs-keyword\">if</span> (i === nums.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span> || nums[i] &gt;= nums[i + <span class=\"hljs-number\">1</span>]) &#123;<br>      ans = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(ans, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(cnt / <span class=\"hljs-number\">2</span>), <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(pre, cnt));<br>      pre = cnt;<br>      cnt = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><ul>\n<li>遍历数组，统计递增子数组的长度，当遇到非递增的元素时，更新最大值，并重置递增子数组的长度。</li>\n<li>遍历过程中，记录当前递增子数组的长度，以及上一个递增子数组的长度。</li>\n<li>更新最大值时，需要考虑两种情况：<ul>\n<li>当前递增子数组的长度的一半，即可以拆分成两个递增子数组。</li>\n<li>上一个递增子数组的长度和当前递增子数组的长度，即可以合并成一个递增子数组。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"复杂度：\"><a href=\"#复杂度：\" class=\"headerlink\" title=\"复杂度：\"></a>复杂度：</h4><ul>\n<li>时间复杂度：O(n)</li>\n<li>空间复杂度：O(1)</li>\n</ul>\n"},{"title":"正则表达式","date":"2021-04-11T11:09:19.000Z","index_img":"/img/regex.jfif","banner_img":"/img/git-banner.jpg","_content":"\n#### 正则表达式的概述\n\n**正则表达式**是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象\n\n> 正则表通常被用来检索，替换那些符合某个模式（规则）的文本，例如验证表单：用户名表只能输入英文字母，数字或者下划线，昵称输入框可以输入中文（匹配）。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词汇（替换），或从字符串中获取我们想要的特定部分（提取）等\n\n##### 正则表达式的特点\n\n1. 灵活性，逻辑性和功能性非常的强\n2. 可以迅速地用简单的方式达到字符串的复制控制\n3. 对于刚接触的人来说，比较难懂，比如：^\\w+([-+.]\\w+)\\*@\\w+([-.]\\w+)\\*\\\\.\\w\\*$\n\n4. 实际开发，一般都是直接复制写好的正则表达式，但是要求会使用正则表达式并且根据实际情况修改正则表达式\n\n#### 创建正则表达式\n\n在 JavaScript 中可以通过两种方法来创建正则表达式\n\n1. 通过调用 RegExp 对象的构造函数创建\n\n> var x = new RegExp(/表达式/);\n\n2. 通过字面量创建\n\n> var x = /表达式/;\n\n#### 测试正则表达式 test\n\ntest()正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false ,其参数是测试字符串\n\n> regexObj.test(str);\n\n1. regexObj 是写的正则表达式\n2. str 我们要测试的文本\n3. 就是检测 str 文本是否符合我们写的正则表达式规范\n\n#### 正则表达式中的特殊字符\n\n一个正则表达式==可以由简单的字符构成==，比如/abc/，==也可以是简答和特殊字符的组合==，比如/ab\\*c/。其中特殊字符也被称为==元字符==，在正则表达式中是具有特殊意义的专用符号。如 ^ \\$ + - 等\n\n#### 边界符\n\n正则表达式中的边界符（位置符）用来==提示字符所处的位置==,主要有两个字符\n\n| 边界符 | 说明                           |\n| ------ | ------------------------------ |\n| ^      | 表示匹配行首的文本（以谁开始） |\n| \\$     | 表示匹配行尾的文本（以谁结尾） |\n\n```javascript\n//边界符\nvar rg = /abc/; //正则表达式里面不需要加引号 不管是数字还是字符串\n// /abc/ 只要包含有 abc这个字符串返回的都是true\nconsole.log(rg.test(\"abc\"));\nconsole.log(rg.test(\"abcd\"));\nconsole.log(rg.test(\"aabc\"));\nconsole.log(\"----------------------------\");\nvar reg = /^abc/;\nconsole.log(rg.test(\"abc\")); //true\nconsole.log(rg.test(\"abcd\")); //true\nconsole.log(rg.test(\"aabc\")); //false\nconsole.log(\"-------------\");\n结尾同理;\nvar reg = /^abc$/; //精确匹配 要求必须是 abc字符串才符合规范\nconsole.log(rg.test(\"abc\")); //true\nconsole.log(rg.test(\"abcd\")); //false\nconsole.log(rg.test(\"aabc\")); //false\nconsole.log(rg.test(\"abcabc\")); //false\n```\n\n> 如果 ^ 和 \\$ 在一起就表示必须是精确匹配\n\n#### 字符类\n\n[]表示有一系列字符可供选择，只要匹配其中一个就可以了\n\n> [-] 表示范围\n\n```javascript\nvar rg = /[abc]/; //只要包含有a 或者 有b 或者有c 都返回为true\nconsloe.log(rg.test('andy'));  //true\nvar rg1 = /^[abc]$/; //三选一  只有是a 或者是b 或者是c 这三个字母才返回true\nconsole.log(rg1.test('a')); //true\nconsole.log(rg1.test('b')); //true\nconsole.log(rg1.test('c')); //true\nconsole.log(rg1.test('aa')); //false\nconsole.log(rg1.test('abc')); //false\nconsole.log(rg1.test('bb')); //false\n\nconsloe.log('--------------');\nvar rg2 = /^[a-z]$/; //26个英文字母任何一个字母返回 true\nconsole.log(rg2.test('a')); //true\nconsole.log(rg2.test('z')); //true\nconsole.log(rg2.test('A')); //false\n//字符组合\nvar reg = /^[a-zA-Z0-9]$/  英文字母和数字\n\n```\n\n> 如果中括号里面有^ 表示取反的意思 千万别和边界符 混淆了\n\n`var reg1 = /^[^ a-z]$/;`也就是不能取这些\n\n#### 量词符\n\n量词符是用来设定某个模式出现的次数\n\n| 量词  | 说明              |\n| ----- | ----------------- |\n| \\*    | 重复零次或更多次  |\n| +     | 重复一次或更多次  |\n| ？    | 重复零次或一次    |\n| {n}   | 重复 n 次         |\n| {n,}  | 重复 n 次或更多次 |\n| {n,m} | 重复 n 到 m 次    |\n\n```javascript\n// * 相当于 >=0 可以出现0次或者很多次\nvar reg = /^a*$/;\nconsole.log(\"a\"); //true\nconsole.log(\"\"); //true\nconsole.log(\"aaa\"); //true\n\n//+ 相当于 >=1 可以出现1次或者很多次\n//{3} 就是三次   {3，} 是大于等于3次   {3，16} 就是3到16次\n```\n\n#### 预定义类\n\n预定义类指的是某些常见模式的简写模式\n\n| 预定义类 | 说明                                                       |\n| :------- | ---------------------------------------------------------- |\n| \\d       | 匹配 0-9 之间的任一数字，相当于[0-9]                       |\n| \\D       | 匹配所有 0-9 以外的字符，相当于[\\^0-9]                     |\n| \\w       | 匹配任意的字母，数字，下划线，相当于[A-Za-z0-9_]           |\n| \\W       | 除所有字母，数字，下划线以外的字符                         |\n| \\s       | 匹配空格（包括换行符，制表符，空格符），相等于[\\t\\r\\n\\v\\f] |\n| \\S       | 匹配非空格的字符                                           |\n\n#### 正则表达式中的替换\n\nreplace()方法可以实现替换字符串操作，用来替换掉参数可以是一个字符串或是一个正则表达式\n\n> stringObject.replace(refexp/substr,replacement)\n\n1. 第一个参数：被替换的字符串或者正则表达式\n2. 第二个参数：替换为的字符串\n3. 返回值是一个替换完毕的新字符串\n\n#### 正则表达式参数\n\n> /表达式/[switch] /andy/g\n\nswitch(也称为修饰符)按照什么样的模式来匹配，有三种值\n\n- g：全局匹配\n- i:忽略大小写\n- gi：全局匹配 + 忽略大小写\n","source":"_posts/正则表达式.md","raw":"---\ntitle: 正则表达式\ndate: 2021-04-11 19:09:19\ntags: 正则表达式\ncategories: 后端\nindex_img: /img/regex.jfif\nbanner_img: /img/git-banner.jpg\n---\n\n#### 正则表达式的概述\n\n**正则表达式**是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象\n\n> 正则表通常被用来检索，替换那些符合某个模式（规则）的文本，例如验证表单：用户名表只能输入英文字母，数字或者下划线，昵称输入框可以输入中文（匹配）。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词汇（替换），或从字符串中获取我们想要的特定部分（提取）等\n\n##### 正则表达式的特点\n\n1. 灵活性，逻辑性和功能性非常的强\n2. 可以迅速地用简单的方式达到字符串的复制控制\n3. 对于刚接触的人来说，比较难懂，比如：^\\w+([-+.]\\w+)\\*@\\w+([-.]\\w+)\\*\\\\.\\w\\*$\n\n4. 实际开发，一般都是直接复制写好的正则表达式，但是要求会使用正则表达式并且根据实际情况修改正则表达式\n\n#### 创建正则表达式\n\n在 JavaScript 中可以通过两种方法来创建正则表达式\n\n1. 通过调用 RegExp 对象的构造函数创建\n\n> var x = new RegExp(/表达式/);\n\n2. 通过字面量创建\n\n> var x = /表达式/;\n\n#### 测试正则表达式 test\n\ntest()正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false ,其参数是测试字符串\n\n> regexObj.test(str);\n\n1. regexObj 是写的正则表达式\n2. str 我们要测试的文本\n3. 就是检测 str 文本是否符合我们写的正则表达式规范\n\n#### 正则表达式中的特殊字符\n\n一个正则表达式==可以由简单的字符构成==，比如/abc/，==也可以是简答和特殊字符的组合==，比如/ab\\*c/。其中特殊字符也被称为==元字符==，在正则表达式中是具有特殊意义的专用符号。如 ^ \\$ + - 等\n\n#### 边界符\n\n正则表达式中的边界符（位置符）用来==提示字符所处的位置==,主要有两个字符\n\n| 边界符 | 说明                           |\n| ------ | ------------------------------ |\n| ^      | 表示匹配行首的文本（以谁开始） |\n| \\$     | 表示匹配行尾的文本（以谁结尾） |\n\n```javascript\n//边界符\nvar rg = /abc/; //正则表达式里面不需要加引号 不管是数字还是字符串\n// /abc/ 只要包含有 abc这个字符串返回的都是true\nconsole.log(rg.test(\"abc\"));\nconsole.log(rg.test(\"abcd\"));\nconsole.log(rg.test(\"aabc\"));\nconsole.log(\"----------------------------\");\nvar reg = /^abc/;\nconsole.log(rg.test(\"abc\")); //true\nconsole.log(rg.test(\"abcd\")); //true\nconsole.log(rg.test(\"aabc\")); //false\nconsole.log(\"-------------\");\n结尾同理;\nvar reg = /^abc$/; //精确匹配 要求必须是 abc字符串才符合规范\nconsole.log(rg.test(\"abc\")); //true\nconsole.log(rg.test(\"abcd\")); //false\nconsole.log(rg.test(\"aabc\")); //false\nconsole.log(rg.test(\"abcabc\")); //false\n```\n\n> 如果 ^ 和 \\$ 在一起就表示必须是精确匹配\n\n#### 字符类\n\n[]表示有一系列字符可供选择，只要匹配其中一个就可以了\n\n> [-] 表示范围\n\n```javascript\nvar rg = /[abc]/; //只要包含有a 或者 有b 或者有c 都返回为true\nconsloe.log(rg.test('andy'));  //true\nvar rg1 = /^[abc]$/; //三选一  只有是a 或者是b 或者是c 这三个字母才返回true\nconsole.log(rg1.test('a')); //true\nconsole.log(rg1.test('b')); //true\nconsole.log(rg1.test('c')); //true\nconsole.log(rg1.test('aa')); //false\nconsole.log(rg1.test('abc')); //false\nconsole.log(rg1.test('bb')); //false\n\nconsloe.log('--------------');\nvar rg2 = /^[a-z]$/; //26个英文字母任何一个字母返回 true\nconsole.log(rg2.test('a')); //true\nconsole.log(rg2.test('z')); //true\nconsole.log(rg2.test('A')); //false\n//字符组合\nvar reg = /^[a-zA-Z0-9]$/  英文字母和数字\n\n```\n\n> 如果中括号里面有^ 表示取反的意思 千万别和边界符 混淆了\n\n`var reg1 = /^[^ a-z]$/;`也就是不能取这些\n\n#### 量词符\n\n量词符是用来设定某个模式出现的次数\n\n| 量词  | 说明              |\n| ----- | ----------------- |\n| \\*    | 重复零次或更多次  |\n| +     | 重复一次或更多次  |\n| ？    | 重复零次或一次    |\n| {n}   | 重复 n 次         |\n| {n,}  | 重复 n 次或更多次 |\n| {n,m} | 重复 n 到 m 次    |\n\n```javascript\n// * 相当于 >=0 可以出现0次或者很多次\nvar reg = /^a*$/;\nconsole.log(\"a\"); //true\nconsole.log(\"\"); //true\nconsole.log(\"aaa\"); //true\n\n//+ 相当于 >=1 可以出现1次或者很多次\n//{3} 就是三次   {3，} 是大于等于3次   {3，16} 就是3到16次\n```\n\n#### 预定义类\n\n预定义类指的是某些常见模式的简写模式\n\n| 预定义类 | 说明                                                       |\n| :------- | ---------------------------------------------------------- |\n| \\d       | 匹配 0-9 之间的任一数字，相当于[0-9]                       |\n| \\D       | 匹配所有 0-9 以外的字符，相当于[\\^0-9]                     |\n| \\w       | 匹配任意的字母，数字，下划线，相当于[A-Za-z0-9_]           |\n| \\W       | 除所有字母，数字，下划线以外的字符                         |\n| \\s       | 匹配空格（包括换行符，制表符，空格符），相等于[\\t\\r\\n\\v\\f] |\n| \\S       | 匹配非空格的字符                                           |\n\n#### 正则表达式中的替换\n\nreplace()方法可以实现替换字符串操作，用来替换掉参数可以是一个字符串或是一个正则表达式\n\n> stringObject.replace(refexp/substr,replacement)\n\n1. 第一个参数：被替换的字符串或者正则表达式\n2. 第二个参数：替换为的字符串\n3. 返回值是一个替换完毕的新字符串\n\n#### 正则表达式参数\n\n> /表达式/[switch] /andy/g\n\nswitch(也称为修饰符)按照什么样的模式来匹配，有三种值\n\n- g：全局匹配\n- i:忽略大小写\n- gi：全局匹配 + 忽略大小写\n","slug":"正则表达式","published":1,"updated":"2024-11-17T13:58:10.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpq002x73t30nrh53ee","content":"<h4 id=\"正则表达式的概述\"><a href=\"#正则表达式的概述\" class=\"headerlink\" title=\"正则表达式的概述\"></a>正则表达式的概述</h4><p><strong>正则表达式</strong>是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象</p>\n<blockquote>\n<p>正则表通常被用来检索，替换那些符合某个模式（规则）的文本，例如验证表单：用户名表只能输入英文字母，数字或者下划线，昵称输入框可以输入中文（匹配）。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词汇（替换），或从字符串中获取我们想要的特定部分（提取）等</p>\n</blockquote>\n<h5 id=\"正则表达式的特点\"><a href=\"#正则表达式的特点\" class=\"headerlink\" title=\"正则表达式的特点\"></a>正则表达式的特点</h5><ol>\n<li><p>灵活性，逻辑性和功能性非常的强</p>\n</li>\n<li><p>可以迅速地用简单的方式达到字符串的复制控制</p>\n</li>\n<li><p>对于刚接触的人来说，比较难懂，比如：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w*$</p>\n</li>\n<li><p>实际开发，一般都是直接复制写好的正则表达式，但是要求会使用正则表达式并且根据实际情况修改正则表达式</p>\n</li>\n</ol>\n<h4 id=\"创建正则表达式\"><a href=\"#创建正则表达式\" class=\"headerlink\" title=\"创建正则表达式\"></a>创建正则表达式</h4><p>在 JavaScript 中可以通过两种方法来创建正则表达式</p>\n<ol>\n<li>通过调用 RegExp 对象的构造函数创建</li>\n</ol>\n<blockquote>\n<p>var x = new RegExp(/表达式/);</p>\n</blockquote>\n<ol start=\"2\">\n<li>通过字面量创建</li>\n</ol>\n<blockquote>\n<p>var x = /表达式/;</p>\n</blockquote>\n<h4 id=\"测试正则表达式-test\"><a href=\"#测试正则表达式-test\" class=\"headerlink\" title=\"测试正则表达式 test\"></a>测试正则表达式 test</h4><p>test()正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false ,其参数是测试字符串</p>\n<blockquote>\n<p>regexObj.test(str);</p>\n</blockquote>\n<ol>\n<li>regexObj 是写的正则表达式</li>\n<li>str 我们要测试的文本</li>\n<li>就是检测 str 文本是否符合我们写的正则表达式规范</li>\n</ol>\n<h4 id=\"正则表达式中的特殊字符\"><a href=\"#正则表达式中的特殊字符\" class=\"headerlink\" title=\"正则表达式中的特殊字符\"></a>正则表达式中的特殊字符</h4><p>一个正则表达式==可以由简单的字符构成==，比如/abc/，==也可以是简答和特殊字符的组合==，比如/ab*c/。其中特殊字符也被称为==元字符==，在正则表达式中是具有特殊意义的专用符号。如 ^ $ + - 等</p>\n<h4 id=\"边界符\"><a href=\"#边界符\" class=\"headerlink\" title=\"边界符\"></a>边界符</h4><p>正则表达式中的边界符（位置符）用来==提示字符所处的位置==,主要有两个字符</p>\n<table>\n<thead>\n<tr>\n<th>边界符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>^</td>\n<td>表示匹配行首的文本（以谁开始）</td>\n</tr>\n<tr>\n<td>$</td>\n<td>表示匹配行尾的文本（以谁结尾）</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//边界符</span><br><span class=\"hljs-keyword\">var</span> rg = <span class=\"hljs-regexp\">/abc/</span>; <span class=\"hljs-comment\">//正则表达式里面不需要加引号 不管是数字还是字符串</span><br><span class=\"hljs-comment\">// /abc/ 只要包含有 abc这个字符串返回的都是true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abcd&quot;</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;aabc&quot;</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;----------------------------&quot;</span>);<br><span class=\"hljs-keyword\">var</span> reg = <span class=\"hljs-regexp\">/^abc/</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abcd&quot;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;aabc&quot;</span>)); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;-------------&quot;</span>);<br>结尾同理;<br><span class=\"hljs-keyword\">var</span> reg = <span class=\"hljs-regexp\">/^abc$/</span>; <span class=\"hljs-comment\">//精确匹配 要求必须是 abc字符串才符合规范</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abcd&quot;</span>)); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;aabc&quot;</span>)); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abcabc&quot;</span>)); <span class=\"hljs-comment\">//false</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果 ^ 和 $ 在一起就表示必须是精确匹配</p>\n</blockquote>\n<h4 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h4><p>[]表示有一系列字符可供选择，只要匹配其中一个就可以了</p>\n<blockquote>\n<p>[-] 表示范围</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> rg = <span class=\"hljs-regexp\">/[abc]/</span>; <span class=\"hljs-comment\">//只要包含有a 或者 有b 或者有c 都返回为true</span><br>consloe.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;andy&#x27;</span>));  <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-keyword\">var</span> rg1 = <span class=\"hljs-regexp\">/^[abc]$/</span>; <span class=\"hljs-comment\">//三选一  只有是a 或者是b 或者是c 这三个字母才返回true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg1.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg1.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg1.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg1.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;aa&#x27;</span>)); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg1.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;abc&#x27;</span>)); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg1.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;bb&#x27;</span>)); <span class=\"hljs-comment\">//false</span><br><br>consloe.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;--------------&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> rg2 = <span class=\"hljs-regexp\">/^[a-z]$/</span>; <span class=\"hljs-comment\">//26个英文字母任何一个字母返回 true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg2.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg2.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;z&#x27;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg2.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;A&#x27;</span>)); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-comment\">//字符组合</span><br><span class=\"hljs-keyword\">var</span> reg = <span class=\"hljs-regexp\">/^[a-zA-Z0-9]$/</span>  英文字母和数字<br><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果中括号里面有^ 表示取反的意思 千万别和边界符 混淆了</p>\n</blockquote>\n<p><code>var reg1 = /^[^ a-z]$/;</code>也就是不能取这些</p>\n<h4 id=\"量词符\"><a href=\"#量词符\" class=\"headerlink\" title=\"量词符\"></a>量词符</h4><p>量词符是用来设定某个模式出现的次数</p>\n<table>\n<thead>\n<tr>\n<th>量词</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>重复零次或更多次</td>\n</tr>\n<tr>\n<td>+</td>\n<td>重复一次或更多次</td>\n</tr>\n<tr>\n<td>？</td>\n<td>重复零次或一次</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>重复 n 次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>重复 n 次或更多次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>重复 n 到 m 次</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// * 相当于 &gt;=0 可以出现0次或者很多次</span><br><span class=\"hljs-keyword\">var</span> reg = <span class=\"hljs-regexp\">/^a*$/</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;a&quot;</span>); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;&quot;</span>); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;aaa&quot;</span>); <span class=\"hljs-comment\">//true</span><br><br><span class=\"hljs-comment\">//+ 相当于 &gt;=1 可以出现1次或者很多次</span><br><span class=\"hljs-comment\">//&#123;3&#125; 就是三次   &#123;3，&#125; 是大于等于3次   &#123;3，16&#125; 就是3到16次</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"预定义类\"><a href=\"#预定义类\" class=\"headerlink\" title=\"预定义类\"></a>预定义类</h4><p>预定义类指的是某些常见模式的简写模式</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">预定义类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">\\d</td>\n<td>匹配 0-9 之间的任一数字，相当于[0-9]</td>\n</tr>\n<tr>\n<td align=\"left\">\\D</td>\n<td>匹配所有 0-9 以外的字符，相当于[^0-9]</td>\n</tr>\n<tr>\n<td align=\"left\">\\w</td>\n<td>匹配任意的字母，数字，下划线，相当于[A-Za-z0-9_]</td>\n</tr>\n<tr>\n<td align=\"left\">\\W</td>\n<td>除所有字母，数字，下划线以外的字符</td>\n</tr>\n<tr>\n<td align=\"left\">\\s</td>\n<td>匹配空格（包括换行符，制表符，空格符），相等于[\\t\\r\\n\\v\\f]</td>\n</tr>\n<tr>\n<td align=\"left\">\\S</td>\n<td>匹配非空格的字符</td>\n</tr>\n</tbody></table>\n<h4 id=\"正则表达式中的替换\"><a href=\"#正则表达式中的替换\" class=\"headerlink\" title=\"正则表达式中的替换\"></a>正则表达式中的替换</h4><p>replace()方法可以实现替换字符串操作，用来替换掉参数可以是一个字符串或是一个正则表达式</p>\n<blockquote>\n<p>stringObject.replace(refexp/substr,replacement)</p>\n</blockquote>\n<ol>\n<li>第一个参数：被替换的字符串或者正则表达式</li>\n<li>第二个参数：替换为的字符串</li>\n<li>返回值是一个替换完毕的新字符串</li>\n</ol>\n<h4 id=\"正则表达式参数\"><a href=\"#正则表达式参数\" class=\"headerlink\" title=\"正则表达式参数\"></a>正则表达式参数</h4><blockquote>\n<p>/表达式/[switch] /andy/g</p>\n</blockquote>\n<p>switch(也称为修饰符)按照什么样的模式来匹配，有三种值</p>\n<ul>\n<li>g：全局匹配</li>\n<li>i:忽略大小写</li>\n<li>gi：全局匹配 + 忽略大小写</li>\n</ul>\n","site":{"data":{}},"wordcount":2917,"excerpt":"","more":"<h4 id=\"正则表达式的概述\"><a href=\"#正则表达式的概述\" class=\"headerlink\" title=\"正则表达式的概述\"></a>正则表达式的概述</h4><p><strong>正则表达式</strong>是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象</p>\n<blockquote>\n<p>正则表通常被用来检索，替换那些符合某个模式（规则）的文本，例如验证表单：用户名表只能输入英文字母，数字或者下划线，昵称输入框可以输入中文（匹配）。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词汇（替换），或从字符串中获取我们想要的特定部分（提取）等</p>\n</blockquote>\n<h5 id=\"正则表达式的特点\"><a href=\"#正则表达式的特点\" class=\"headerlink\" title=\"正则表达式的特点\"></a>正则表达式的特点</h5><ol>\n<li><p>灵活性，逻辑性和功能性非常的强</p>\n</li>\n<li><p>可以迅速地用简单的方式达到字符串的复制控制</p>\n</li>\n<li><p>对于刚接触的人来说，比较难懂，比如：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w*$</p>\n</li>\n<li><p>实际开发，一般都是直接复制写好的正则表达式，但是要求会使用正则表达式并且根据实际情况修改正则表达式</p>\n</li>\n</ol>\n<h4 id=\"创建正则表达式\"><a href=\"#创建正则表达式\" class=\"headerlink\" title=\"创建正则表达式\"></a>创建正则表达式</h4><p>在 JavaScript 中可以通过两种方法来创建正则表达式</p>\n<ol>\n<li>通过调用 RegExp 对象的构造函数创建</li>\n</ol>\n<blockquote>\n<p>var x = new RegExp(/表达式/);</p>\n</blockquote>\n<ol start=\"2\">\n<li>通过字面量创建</li>\n</ol>\n<blockquote>\n<p>var x = /表达式/;</p>\n</blockquote>\n<h4 id=\"测试正则表达式-test\"><a href=\"#测试正则表达式-test\" class=\"headerlink\" title=\"测试正则表达式 test\"></a>测试正则表达式 test</h4><p>test()正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false ,其参数是测试字符串</p>\n<blockquote>\n<p>regexObj.test(str);</p>\n</blockquote>\n<ol>\n<li>regexObj 是写的正则表达式</li>\n<li>str 我们要测试的文本</li>\n<li>就是检测 str 文本是否符合我们写的正则表达式规范</li>\n</ol>\n<h4 id=\"正则表达式中的特殊字符\"><a href=\"#正则表达式中的特殊字符\" class=\"headerlink\" title=\"正则表达式中的特殊字符\"></a>正则表达式中的特殊字符</h4><p>一个正则表达式==可以由简单的字符构成==，比如/abc/，==也可以是简答和特殊字符的组合==，比如/ab*c/。其中特殊字符也被称为==元字符==，在正则表达式中是具有特殊意义的专用符号。如 ^ $ + - 等</p>\n<h4 id=\"边界符\"><a href=\"#边界符\" class=\"headerlink\" title=\"边界符\"></a>边界符</h4><p>正则表达式中的边界符（位置符）用来==提示字符所处的位置==,主要有两个字符</p>\n<table>\n<thead>\n<tr>\n<th>边界符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>^</td>\n<td>表示匹配行首的文本（以谁开始）</td>\n</tr>\n<tr>\n<td>$</td>\n<td>表示匹配行尾的文本（以谁结尾）</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//边界符</span><br><span class=\"hljs-keyword\">var</span> rg = <span class=\"hljs-regexp\">/abc/</span>; <span class=\"hljs-comment\">//正则表达式里面不需要加引号 不管是数字还是字符串</span><br><span class=\"hljs-comment\">// /abc/ 只要包含有 abc这个字符串返回的都是true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abcd&quot;</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;aabc&quot;</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;----------------------------&quot;</span>);<br><span class=\"hljs-keyword\">var</span> reg = <span class=\"hljs-regexp\">/^abc/</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abcd&quot;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;aabc&quot;</span>)); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;-------------&quot;</span>);<br>结尾同理;<br><span class=\"hljs-keyword\">var</span> reg = <span class=\"hljs-regexp\">/^abc$/</span>; <span class=\"hljs-comment\">//精确匹配 要求必须是 abc字符串才符合规范</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abcd&quot;</span>)); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;aabc&quot;</span>)); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;abcabc&quot;</span>)); <span class=\"hljs-comment\">//false</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果 ^ 和 $ 在一起就表示必须是精确匹配</p>\n</blockquote>\n<h4 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h4><p>[]表示有一系列字符可供选择，只要匹配其中一个就可以了</p>\n<blockquote>\n<p>[-] 表示范围</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> rg = <span class=\"hljs-regexp\">/[abc]/</span>; <span class=\"hljs-comment\">//只要包含有a 或者 有b 或者有c 都返回为true</span><br>consloe.<span class=\"hljs-title function_\">log</span>(rg.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;andy&#x27;</span>));  <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-keyword\">var</span> rg1 = <span class=\"hljs-regexp\">/^[abc]$/</span>; <span class=\"hljs-comment\">//三选一  只有是a 或者是b 或者是c 这三个字母才返回true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg1.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg1.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg1.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg1.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;aa&#x27;</span>)); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg1.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;abc&#x27;</span>)); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg1.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;bb&#x27;</span>)); <span class=\"hljs-comment\">//false</span><br><br>consloe.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;--------------&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> rg2 = <span class=\"hljs-regexp\">/^[a-z]$/</span>; <span class=\"hljs-comment\">//26个英文字母任何一个字母返回 true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg2.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg2.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;z&#x27;</span>)); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rg2.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;A&#x27;</span>)); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-comment\">//字符组合</span><br><span class=\"hljs-keyword\">var</span> reg = <span class=\"hljs-regexp\">/^[a-zA-Z0-9]$/</span>  英文字母和数字<br><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果中括号里面有^ 表示取反的意思 千万别和边界符 混淆了</p>\n</blockquote>\n<p><code>var reg1 = /^[^ a-z]$/;</code>也就是不能取这些</p>\n<h4 id=\"量词符\"><a href=\"#量词符\" class=\"headerlink\" title=\"量词符\"></a>量词符</h4><p>量词符是用来设定某个模式出现的次数</p>\n<table>\n<thead>\n<tr>\n<th>量词</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>重复零次或更多次</td>\n</tr>\n<tr>\n<td>+</td>\n<td>重复一次或更多次</td>\n</tr>\n<tr>\n<td>？</td>\n<td>重复零次或一次</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>重复 n 次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>重复 n 次或更多次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>重复 n 到 m 次</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// * 相当于 &gt;=0 可以出现0次或者很多次</span><br><span class=\"hljs-keyword\">var</span> reg = <span class=\"hljs-regexp\">/^a*$/</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;a&quot;</span>); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;&quot;</span>); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;aaa&quot;</span>); <span class=\"hljs-comment\">//true</span><br><br><span class=\"hljs-comment\">//+ 相当于 &gt;=1 可以出现1次或者很多次</span><br><span class=\"hljs-comment\">//&#123;3&#125; 就是三次   &#123;3，&#125; 是大于等于3次   &#123;3，16&#125; 就是3到16次</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"预定义类\"><a href=\"#预定义类\" class=\"headerlink\" title=\"预定义类\"></a>预定义类</h4><p>预定义类指的是某些常见模式的简写模式</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">预定义类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">\\d</td>\n<td>匹配 0-9 之间的任一数字，相当于[0-9]</td>\n</tr>\n<tr>\n<td align=\"left\">\\D</td>\n<td>匹配所有 0-9 以外的字符，相当于[^0-9]</td>\n</tr>\n<tr>\n<td align=\"left\">\\w</td>\n<td>匹配任意的字母，数字，下划线，相当于[A-Za-z0-9_]</td>\n</tr>\n<tr>\n<td align=\"left\">\\W</td>\n<td>除所有字母，数字，下划线以外的字符</td>\n</tr>\n<tr>\n<td align=\"left\">\\s</td>\n<td>匹配空格（包括换行符，制表符，空格符），相等于[\\t\\r\\n\\v\\f]</td>\n</tr>\n<tr>\n<td align=\"left\">\\S</td>\n<td>匹配非空格的字符</td>\n</tr>\n</tbody></table>\n<h4 id=\"正则表达式中的替换\"><a href=\"#正则表达式中的替换\" class=\"headerlink\" title=\"正则表达式中的替换\"></a>正则表达式中的替换</h4><p>replace()方法可以实现替换字符串操作，用来替换掉参数可以是一个字符串或是一个正则表达式</p>\n<blockquote>\n<p>stringObject.replace(refexp/substr,replacement)</p>\n</blockquote>\n<ol>\n<li>第一个参数：被替换的字符串或者正则表达式</li>\n<li>第二个参数：替换为的字符串</li>\n<li>返回值是一个替换完毕的新字符串</li>\n</ol>\n<h4 id=\"正则表达式参数\"><a href=\"#正则表达式参数\" class=\"headerlink\" title=\"正则表达式参数\"></a>正则表达式参数</h4><blockquote>\n<p>/表达式/[switch] /andy/g</p>\n</blockquote>\n<p>switch(也称为修饰符)按照什么样的模式来匹配，有三种值</p>\n<ul>\n<li>g：全局匹配</li>\n<li>i:忽略大小写</li>\n<li>gi：全局匹配 + 忽略大小写</li>\n</ul>\n"},{"title":"求出胜利玩家的数目","date":"2024-11-23T04:33:15.000Z","index_img":"/img/post/leetcode.jpg","banner_img":null,"_content":"\n[3238. 求出胜利玩家的数目](https://leetcode.cn/problems/find-the-number-of-winning-players/description/?envType=daily-question&envId=2024-11-23)\n\nlevel: `easy`\n\ntag:`数组` `哈希表` `计数`\n\n给你一个整数 n ，表示在一个游戏中的玩家数目。同时给你一个二维整数数组 pick ，其中 pick[i] = [xi, yi] 表示玩家 xi 获得了一个颜色为 yi 的球。\n\n如果玩家 i 获得的球中任何一种颜色球的数目 严格大于 i 个，那么我们说玩家 i 是胜利玩家。换句话说：\n\n如果玩家 0 获得了任何的球，那么玩家 0 是胜利玩家。\n如果玩家 1 获得了至少 2 个相同颜色的球，那么玩家 1 是胜利玩家。\n...\n如果玩家 i 获得了至少 i + 1 个相同颜色的球，那么玩家 i 是胜利玩家。\n请你返回游戏中 胜利玩家 的数目。\n\n注意，可能有多个玩家是胜利玩家。\n\n**示例 1：**\n\n```js\n给你一个整数 n ，表示在一个游戏中的玩家数目。同时给你一个二维整数数组 pick ，其中 pick[i] = [xi, yi] 表示玩家 xi 获得了一个颜色为 yi 的球。\n\n如果玩家 i 获得的球中任何一种颜色球的数目 严格大于 i 个，那么我们说玩家 i 是胜利玩家。换句话说：\n\n如果玩家 0 获得了任何的球，那么玩家 0 是胜利玩家。\n如果玩家 1 获得了至少 2 个相同颜色的球，那么玩家 1 是胜利玩家。\n...\n如果玩家 i 获得了至少 i + 1 个相同颜色的球，那么玩家 i 是胜利玩家。\n请你返回游戏中 胜利玩家 的数目。\n\n注意，可能有多个玩家是胜利玩家。\n```\n\n#### 题解：\n\n```ts\nfunction winningPlayerCount(n: number, pick: number[][]): number {\n  const map = new Map();\n  const res = new Map();\n\n  pick.forEach((item) => {\n    if (map.has(item[0])) {\n      const obj = map.get(item[0]);\n      if (obj.hasOwnProperty(item[1])) {\n        ++obj[item[1]];\n      } else {\n        obj[item[1]] = 1;\n      }\n\n      if (obj[item[1]] > item[0] && !res.has(item[0])) {\n        res.set(item[0], 1);\n      }\n      map.set(item[0], obj);\n    } else {\n      const key = item[1];\n      if (item[0] === 0) {\n        res.set(item[0], 1);\n      }\n      map.set(item[0], { [key]: 1 });\n    }\n  });\n  return res.size;\n}\n```\n\n#### 思路：\n\n1. 遍历数组，将每个玩家的球的颜色和数量存入 map 中,其中 key 为玩家 id，value 为对象，对象的 key 为球的颜色，value 为该颜色球的数量\n2. 判断每个玩家是否满足胜利条件，如果满足则存入 res 中，res 使用了 map 数据结构，避免重复统计\n3. 返回 res 的长度\n\n#### 复杂度\n\n> m 为 pick 数组的长度， n 为 结果的长度\n\n时间复杂度：O(m)\n\n空间复杂度：O(n+m)\n","source":"_posts/求出胜利玩家的数目.md","raw":"---\ntitle: 求出胜利玩家的数目\ndate: 2024-11-23 12:33:15\ntags: 每日一题\ncategories: 算法\nindex_img: /img/post/leetcode.jpg\nbanner_img:\n---\n\n[3238. 求出胜利玩家的数目](https://leetcode.cn/problems/find-the-number-of-winning-players/description/?envType=daily-question&envId=2024-11-23)\n\nlevel: `easy`\n\ntag:`数组` `哈希表` `计数`\n\n给你一个整数 n ，表示在一个游戏中的玩家数目。同时给你一个二维整数数组 pick ，其中 pick[i] = [xi, yi] 表示玩家 xi 获得了一个颜色为 yi 的球。\n\n如果玩家 i 获得的球中任何一种颜色球的数目 严格大于 i 个，那么我们说玩家 i 是胜利玩家。换句话说：\n\n如果玩家 0 获得了任何的球，那么玩家 0 是胜利玩家。\n如果玩家 1 获得了至少 2 个相同颜色的球，那么玩家 1 是胜利玩家。\n...\n如果玩家 i 获得了至少 i + 1 个相同颜色的球，那么玩家 i 是胜利玩家。\n请你返回游戏中 胜利玩家 的数目。\n\n注意，可能有多个玩家是胜利玩家。\n\n**示例 1：**\n\n```js\n给你一个整数 n ，表示在一个游戏中的玩家数目。同时给你一个二维整数数组 pick ，其中 pick[i] = [xi, yi] 表示玩家 xi 获得了一个颜色为 yi 的球。\n\n如果玩家 i 获得的球中任何一种颜色球的数目 严格大于 i 个，那么我们说玩家 i 是胜利玩家。换句话说：\n\n如果玩家 0 获得了任何的球，那么玩家 0 是胜利玩家。\n如果玩家 1 获得了至少 2 个相同颜色的球，那么玩家 1 是胜利玩家。\n...\n如果玩家 i 获得了至少 i + 1 个相同颜色的球，那么玩家 i 是胜利玩家。\n请你返回游戏中 胜利玩家 的数目。\n\n注意，可能有多个玩家是胜利玩家。\n```\n\n#### 题解：\n\n```ts\nfunction winningPlayerCount(n: number, pick: number[][]): number {\n  const map = new Map();\n  const res = new Map();\n\n  pick.forEach((item) => {\n    if (map.has(item[0])) {\n      const obj = map.get(item[0]);\n      if (obj.hasOwnProperty(item[1])) {\n        ++obj[item[1]];\n      } else {\n        obj[item[1]] = 1;\n      }\n\n      if (obj[item[1]] > item[0] && !res.has(item[0])) {\n        res.set(item[0], 1);\n      }\n      map.set(item[0], obj);\n    } else {\n      const key = item[1];\n      if (item[0] === 0) {\n        res.set(item[0], 1);\n      }\n      map.set(item[0], { [key]: 1 });\n    }\n  });\n  return res.size;\n}\n```\n\n#### 思路：\n\n1. 遍历数组，将每个玩家的球的颜色和数量存入 map 中,其中 key 为玩家 id，value 为对象，对象的 key 为球的颜色，value 为该颜色球的数量\n2. 判断每个玩家是否满足胜利条件，如果满足则存入 res 中，res 使用了 map 数据结构，避免重复统计\n3. 返回 res 的长度\n\n#### 复杂度\n\n> m 为 pick 数组的长度， n 为 结果的长度\n\n时间复杂度：O(m)\n\n空间复杂度：O(n+m)\n","slug":"求出胜利玩家的数目","published":1,"updated":"2024-11-23T04:36:38.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpq003073t398ny9wpz","content":"<p><a href=\"https://leetcode.cn/problems/find-the-number-of-winning-players/description/?envType=daily-question&envId=2024-11-23\">3238. 求出胜利玩家的数目</a></p>\n<p>level: <code>easy</code></p>\n<p>tag:<code>数组</code> <code>哈希表</code> <code>计数</code></p>\n<p>给你一个整数 n ，表示在一个游戏中的玩家数目。同时给你一个二维整数数组 pick ，其中 pick[i] = [xi, yi] 表示玩家 xi 获得了一个颜色为 yi 的球。</p>\n<p>如果玩家 i 获得的球中任何一种颜色球的数目 严格大于 i 个，那么我们说玩家 i 是胜利玩家。换句话说：</p>\n<p>如果玩家 0 获得了任何的球，那么玩家 0 是胜利玩家。<br>如果玩家 1 获得了至少 2 个相同颜色的球，那么玩家 1 是胜利玩家。<br>…<br>如果玩家 i 获得了至少 i + 1 个相同颜色的球，那么玩家 i 是胜利玩家。<br>请你返回游戏中 胜利玩家 的数目。</p>\n<p>注意，可能有多个玩家是胜利玩家。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">给你一个整数 n ，表示在一个游戏中的玩家数目。同时给你一个二维整数数组 pick ，其中 pick[i] = [xi, yi] 表示玩家 xi 获得了一个颜色为 yi 的球。<br><br>如果玩家 i 获得的球中任何一种颜色球的数目 严格大于 i 个，那么我们说玩家 i 是胜利玩家。换句话说：<br><br>如果玩家 <span class=\"hljs-number\">0</span> 获得了任何的球，那么玩家 <span class=\"hljs-number\">0</span> 是胜利玩家。<br>如果玩家 <span class=\"hljs-number\">1</span> 获得了至少 <span class=\"hljs-number\">2</span> 个相同颜色的球，那么玩家 <span class=\"hljs-number\">1</span> 是胜利玩家。<br>...<br>如果玩家 i 获得了至少 i + <span class=\"hljs-number\">1</span> 个相同颜色的球，那么玩家 i 是胜利玩家。<br>请你返回游戏中 胜利玩家 的数目。<br><br>注意，可能有多个玩家是胜利玩家。<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">winningPlayerCount</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">n</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">pick</span>: <span class=\"hljs-built_in\">number</span>[][]</span>): <span class=\"hljs-built_in\">number</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><br>  pick.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (map.<span class=\"hljs-title function_\">has</span>(item[<span class=\"hljs-number\">0</span>])) &#123;<br>      <span class=\"hljs-keyword\">const</span> obj = map.<span class=\"hljs-title function_\">get</span>(item[<span class=\"hljs-number\">0</span>]);<br>      <span class=\"hljs-keyword\">if</span> (obj.<span class=\"hljs-title function_\">hasOwnProperty</span>(item[<span class=\"hljs-number\">1</span>])) &#123;<br>        ++obj[item[<span class=\"hljs-number\">1</span>]];<br>      &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        obj[item[<span class=\"hljs-number\">1</span>]] = <span class=\"hljs-number\">1</span>;<br>      &#125;<br><br>      <span class=\"hljs-keyword\">if</span> (obj[item[<span class=\"hljs-number\">1</span>]] &gt; item[<span class=\"hljs-number\">0</span>] &amp;&amp; !res.<span class=\"hljs-title function_\">has</span>(item[<span class=\"hljs-number\">0</span>])) &#123;<br>        res.<span class=\"hljs-title function_\">set</span>(item[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">1</span>);<br>      &#125;<br>      map.<span class=\"hljs-title function_\">set</span>(item[<span class=\"hljs-number\">0</span>], obj);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-keyword\">const</span> key = item[<span class=\"hljs-number\">1</span>];<br>      <span class=\"hljs-keyword\">if</span> (item[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-number\">0</span>) &#123;<br>        res.<span class=\"hljs-title function_\">set</span>(item[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">1</span>);<br>      &#125;<br>      map.<span class=\"hljs-title function_\">set</span>(item[<span class=\"hljs-number\">0</span>], &#123; [key]: <span class=\"hljs-number\">1</span> &#125;);<br>    &#125;<br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-property\">size</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><ol>\n<li>遍历数组，将每个玩家的球的颜色和数量存入 map 中,其中 key 为玩家 id，value 为对象，对象的 key 为球的颜色，value 为该颜色球的数量</li>\n<li>判断每个玩家是否满足胜利条件，如果满足则存入 res 中，res 使用了 map 数据结构，避免重复统计</li>\n<li>返回 res 的长度</li>\n</ol>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><blockquote>\n<p>m 为 pick 数组的长度， n 为 结果的长度</p>\n</blockquote>\n<p>时间复杂度：O(m)</p>\n<p>空间复杂度：O(n+m)</p>\n","site":{"data":{}},"wordcount":1281,"excerpt":"","more":"<p><a href=\"https://leetcode.cn/problems/find-the-number-of-winning-players/description/?envType=daily-question&envId=2024-11-23\">3238. 求出胜利玩家的数目</a></p>\n<p>level: <code>easy</code></p>\n<p>tag:<code>数组</code> <code>哈希表</code> <code>计数</code></p>\n<p>给你一个整数 n ，表示在一个游戏中的玩家数目。同时给你一个二维整数数组 pick ，其中 pick[i] = [xi, yi] 表示玩家 xi 获得了一个颜色为 yi 的球。</p>\n<p>如果玩家 i 获得的球中任何一种颜色球的数目 严格大于 i 个，那么我们说玩家 i 是胜利玩家。换句话说：</p>\n<p>如果玩家 0 获得了任何的球，那么玩家 0 是胜利玩家。<br>如果玩家 1 获得了至少 2 个相同颜色的球，那么玩家 1 是胜利玩家。<br>…<br>如果玩家 i 获得了至少 i + 1 个相同颜色的球，那么玩家 i 是胜利玩家。<br>请你返回游戏中 胜利玩家 的数目。</p>\n<p>注意，可能有多个玩家是胜利玩家。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">给你一个整数 n ，表示在一个游戏中的玩家数目。同时给你一个二维整数数组 pick ，其中 pick[i] = [xi, yi] 表示玩家 xi 获得了一个颜色为 yi 的球。<br><br>如果玩家 i 获得的球中任何一种颜色球的数目 严格大于 i 个，那么我们说玩家 i 是胜利玩家。换句话说：<br><br>如果玩家 <span class=\"hljs-number\">0</span> 获得了任何的球，那么玩家 <span class=\"hljs-number\">0</span> 是胜利玩家。<br>如果玩家 <span class=\"hljs-number\">1</span> 获得了至少 <span class=\"hljs-number\">2</span> 个相同颜色的球，那么玩家 <span class=\"hljs-number\">1</span> 是胜利玩家。<br>...<br>如果玩家 i 获得了至少 i + <span class=\"hljs-number\">1</span> 个相同颜色的球，那么玩家 i 是胜利玩家。<br>请你返回游戏中 胜利玩家 的数目。<br><br>注意，可能有多个玩家是胜利玩家。<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">winningPlayerCount</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">n</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">pick</span>: <span class=\"hljs-built_in\">number</span>[][]</span>): <span class=\"hljs-built_in\">number</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><br>  pick.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (map.<span class=\"hljs-title function_\">has</span>(item[<span class=\"hljs-number\">0</span>])) &#123;<br>      <span class=\"hljs-keyword\">const</span> obj = map.<span class=\"hljs-title function_\">get</span>(item[<span class=\"hljs-number\">0</span>]);<br>      <span class=\"hljs-keyword\">if</span> (obj.<span class=\"hljs-title function_\">hasOwnProperty</span>(item[<span class=\"hljs-number\">1</span>])) &#123;<br>        ++obj[item[<span class=\"hljs-number\">1</span>]];<br>      &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        obj[item[<span class=\"hljs-number\">1</span>]] = <span class=\"hljs-number\">1</span>;<br>      &#125;<br><br>      <span class=\"hljs-keyword\">if</span> (obj[item[<span class=\"hljs-number\">1</span>]] &gt; item[<span class=\"hljs-number\">0</span>] &amp;&amp; !res.<span class=\"hljs-title function_\">has</span>(item[<span class=\"hljs-number\">0</span>])) &#123;<br>        res.<span class=\"hljs-title function_\">set</span>(item[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">1</span>);<br>      &#125;<br>      map.<span class=\"hljs-title function_\">set</span>(item[<span class=\"hljs-number\">0</span>], obj);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-keyword\">const</span> key = item[<span class=\"hljs-number\">1</span>];<br>      <span class=\"hljs-keyword\">if</span> (item[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-number\">0</span>) &#123;<br>        res.<span class=\"hljs-title function_\">set</span>(item[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">1</span>);<br>      &#125;<br>      map.<span class=\"hljs-title function_\">set</span>(item[<span class=\"hljs-number\">0</span>], &#123; [key]: <span class=\"hljs-number\">1</span> &#125;);<br>    &#125;<br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-property\">size</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><ol>\n<li>遍历数组，将每个玩家的球的颜色和数量存入 map 中,其中 key 为玩家 id，value 为对象，对象的 key 为球的颜色，value 为该颜色球的数量</li>\n<li>判断每个玩家是否满足胜利条件，如果满足则存入 res 中，res 使用了 map 数据结构，避免重复统计</li>\n<li>返回 res 的长度</li>\n</ol>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><blockquote>\n<p>m 为 pick 数组的长度， n 为 结果的长度</p>\n</blockquote>\n<p>时间复杂度：O(m)</p>\n<p>空间复杂度：O(n+m)</p>\n"},{"title":"深拷贝和浅拷贝","date":"2023-02-22T14:29:35.000Z","index_img":"/img/深浅拷贝.jpeg","banner_img":null,"_content":"\n因为对象是引用类型，是存放在堆中的，栈中存着它的标识符，也就是对象在堆中的地址。\n\n浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址(也就是说第一层是拷贝的值，第二层之后拷贝的都是地址) ，所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**。\n\n深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且**修改新对象不会影响原对象**\n\n## 赋值和深/浅拷贝的区别\n\n这三者的区别如下，不过比较的前提都是**针对引用类型**：\n\n- 当我们把一个对象赋值给一个新的变量时，**赋的其实是该对象的在栈中的地址，而不是堆中的数据**。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。\n- 浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。\n- 深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。\n\n```js\n//给对象赋值\nlet person = {\n\tname:\"badspider\",\n    age:22,\n    school:{\n\t\tname:\"BJUS\",\n        age:200\n    }\n}\n\nlet person1 =  person;  //这个就是直接赋值，相当于把栈中指向对象的那个地址直接赋值给person1，所以person1里面的是指向同一个对象的地址，如果person发生改变，那么person1也就会改变\n\nconsole.log(person1 === person);  // true\n```\n\n![对象赋值](对象赋值.png)\n\n## 浅拷贝\n\n```js\n//浅拷贝\nlet person = {\n\tname:\"spider\",\n    hobbies:['drink','game','code']\n}\n\n\nfunction  shallowClone(obj){\n    let temp = {};\n\tfor(var i in obj){\n\t\tif(obj.hasOwnProperty(i)){//判断对象是否有这个属性，有则返回true，无则返回false\n            temp[i] = obj[i];\n        }\n    }\n    return temp;\n}\n\nlet person1 = shallowClone(person);\n\n\nconsole.log(person1 === person);  //false\nconsole.log(person1.hobbies === person.hobbies);  //true\n\n\n---------------------------------------------------------------------------------------\n  \n//另外一种办法 Object.assign(target,source)\n    \nlet p = Object.assign({},person);\nconsole.log(p);   //{  name:\"spider\",hobbies:['drink','game','code']  }\n\n---------------------------------------------------------------------------------------\n// 另外一种办法,展开运算符\nlet p = {...person};\nconsole.log(p);   //{  name:\"spider\",hobbies:['drink','game','code']  }\n```\n\n\n\n![浅拷贝](浅拷贝.png)\n\n## 深拷贝\n\n```js\n//深拷贝\n\nlet person = {\n\tname:\"spider\",\n    hobbies:['drink','game','code']\n}\n\nlet person1 = deepClone(person);\n\nfunction deepClone(obj) {\n    if (obj === null || typeof obj !== \"object\") {\n        return obj;\n    }\n    let clone = Array.isArray(obj) ? [] : {};\n    for (var i in obj) {\n        if (typeof obj[i] == \"object\") {\n            clone[i] = deepClone(obj[i]);\n        } else {\n            clone[i] = obj[i];\n        }\n    }\n\n    return clone;\n}\n\nconsole.log(person1);  //{ name: 'spider', hobbies: [ 'drink', 'game', 'code' ] }\nconsole.log(person1 === person);  //false\nperson.hobbies[0] = \"swimming\"\nconsole.log(person.hobbies[0]);  //swimming\nconsole.log(person1.hobbies[0]);  //drink\n\n---------------------------------------------------------------------\n//另外一种写法，但是会有问题\n JSON.parse(JSON.Stringify(obj))\n```\n\n\n\n这也是利用JSON.stringify将对象转成JSON字符串，再用JSON.parse把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。\n\n\n\n**这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则**，因为这两者基于JSON.stringify和JSON.parse处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为null）了。\n\n![深拷贝](深拷贝.png)\n","source":"_posts/深浅拷贝.md","raw":"---\ntitle: 深拷贝和浅拷贝\ndate: 2023-2-22 22:29:35\ntags: 前端\nindex_img: /img/深浅拷贝.jpeg\nbanner_img:\n---\n\n因为对象是引用类型，是存放在堆中的，栈中存着它的标识符，也就是对象在堆中的地址。\n\n浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址(也就是说第一层是拷贝的值，第二层之后拷贝的都是地址) ，所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**。\n\n深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且**修改新对象不会影响原对象**\n\n## 赋值和深/浅拷贝的区别\n\n这三者的区别如下，不过比较的前提都是**针对引用类型**：\n\n- 当我们把一个对象赋值给一个新的变量时，**赋的其实是该对象的在栈中的地址，而不是堆中的数据**。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。\n- 浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。\n- 深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。\n\n```js\n//给对象赋值\nlet person = {\n\tname:\"badspider\",\n    age:22,\n    school:{\n\t\tname:\"BJUS\",\n        age:200\n    }\n}\n\nlet person1 =  person;  //这个就是直接赋值，相当于把栈中指向对象的那个地址直接赋值给person1，所以person1里面的是指向同一个对象的地址，如果person发生改变，那么person1也就会改变\n\nconsole.log(person1 === person);  // true\n```\n\n![对象赋值](对象赋值.png)\n\n## 浅拷贝\n\n```js\n//浅拷贝\nlet person = {\n\tname:\"spider\",\n    hobbies:['drink','game','code']\n}\n\n\nfunction  shallowClone(obj){\n    let temp = {};\n\tfor(var i in obj){\n\t\tif(obj.hasOwnProperty(i)){//判断对象是否有这个属性，有则返回true，无则返回false\n            temp[i] = obj[i];\n        }\n    }\n    return temp;\n}\n\nlet person1 = shallowClone(person);\n\n\nconsole.log(person1 === person);  //false\nconsole.log(person1.hobbies === person.hobbies);  //true\n\n\n---------------------------------------------------------------------------------------\n  \n//另外一种办法 Object.assign(target,source)\n    \nlet p = Object.assign({},person);\nconsole.log(p);   //{  name:\"spider\",hobbies:['drink','game','code']  }\n\n---------------------------------------------------------------------------------------\n// 另外一种办法,展开运算符\nlet p = {...person};\nconsole.log(p);   //{  name:\"spider\",hobbies:['drink','game','code']  }\n```\n\n\n\n![浅拷贝](浅拷贝.png)\n\n## 深拷贝\n\n```js\n//深拷贝\n\nlet person = {\n\tname:\"spider\",\n    hobbies:['drink','game','code']\n}\n\nlet person1 = deepClone(person);\n\nfunction deepClone(obj) {\n    if (obj === null || typeof obj !== \"object\") {\n        return obj;\n    }\n    let clone = Array.isArray(obj) ? [] : {};\n    for (var i in obj) {\n        if (typeof obj[i] == \"object\") {\n            clone[i] = deepClone(obj[i]);\n        } else {\n            clone[i] = obj[i];\n        }\n    }\n\n    return clone;\n}\n\nconsole.log(person1);  //{ name: 'spider', hobbies: [ 'drink', 'game', 'code' ] }\nconsole.log(person1 === person);  //false\nperson.hobbies[0] = \"swimming\"\nconsole.log(person.hobbies[0]);  //swimming\nconsole.log(person1.hobbies[0]);  //drink\n\n---------------------------------------------------------------------\n//另外一种写法，但是会有问题\n JSON.parse(JSON.Stringify(obj))\n```\n\n\n\n这也是利用JSON.stringify将对象转成JSON字符串，再用JSON.parse把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。\n\n\n\n**这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则**，因为这两者基于JSON.stringify和JSON.parse处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为null）了。\n\n![深拷贝](深拷贝.png)\n","slug":"深浅拷贝","published":1,"updated":"2024-11-17T13:58:10.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpq003373t3b65e2oi8","content":"<p>因为对象是引用类型，是存放在堆中的，栈中存着它的标识符，也就是对象在堆中的地址。</p>\n<p>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址(也就是说第一层是拷贝的值，第二层之后拷贝的都是地址) ，所以<strong>如果其中一个对象改变了这个地址，就会影响到另一个对象</strong>。</p>\n<p>深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且<strong>修改新对象不会影响原对象</strong></p>\n<h2 id=\"赋值和深-浅拷贝的区别\"><a href=\"#赋值和深-浅拷贝的区别\" class=\"headerlink\" title=\"赋值和深/浅拷贝的区别\"></a>赋值和深/浅拷贝的区别</h2><p>这三者的区别如下，不过比较的前提都是<strong>针对引用类型</strong>：</p>\n<ul>\n<li>当我们把一个对象赋值给一个新的变量时，<strong>赋的其实是该对象的在栈中的地址，而不是堆中的数据</strong>。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li>\n<li>浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。</li>\n<li>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//给对象赋值</span><br><span class=\"hljs-keyword\">let</span> person = &#123;<br>\t<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;badspider&quot;</span>,<br>    <span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">22</span>,<br>    <span class=\"hljs-attr\">school</span>:&#123;<br>\t\t<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;BJUS&quot;</span>,<br>        <span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">200</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> person1 =  person;  <span class=\"hljs-comment\">//这个就是直接赋值，相当于把栈中指向对象的那个地址直接赋值给person1，所以person1里面的是指向同一个对象的地址，如果person发生改变，那么person1也就会改变</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1 === person);  <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/2023/02/22/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC.png\" alt=\"对象赋值\"></p>\n<h2 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//浅拷贝</span><br><span class=\"hljs-keyword\">let</span> person = &#123;<br>\t<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;spider&quot;</span>,<br>    <span class=\"hljs-attr\">hobbies</span>:[<span class=\"hljs-string\">&#x27;drink&#x27;</span>,<span class=\"hljs-string\">&#x27;game&#x27;</span>,<span class=\"hljs-string\">&#x27;code&#x27;</span>]<br>&#125;<br><br><br><span class=\"hljs-keyword\">function</span>  <span class=\"hljs-title function_\">shallowClone</span>(<span class=\"hljs-params\">obj</span>)&#123;<br>    <span class=\"hljs-keyword\">let</span> temp = &#123;&#125;;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">in</span> obj)&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(obj.<span class=\"hljs-title function_\">hasOwnProperty</span>(i))&#123;<span class=\"hljs-comment\">//判断对象是否有这个属性，有则返回true，无则返回false</span><br>            temp[i] = obj[i];<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> temp;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> person1 = <span class=\"hljs-title function_\">shallowClone</span>(person);<br><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1 === person);  <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1.<span class=\"hljs-property\">hobbies</span> === person.<span class=\"hljs-property\">hobbies</span>);  <span class=\"hljs-comment\">//true</span><br><br><br>---------------------------------------------------------------------------------------<br>  <br><span class=\"hljs-comment\">//另外一种办法 Object.assign(target,source)</span><br>    <br><span class=\"hljs-keyword\">let</span> p = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;,person);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p);   <span class=\"hljs-comment\">//&#123;  name:&quot;spider&quot;,hobbies:[&#x27;drink&#x27;,&#x27;game&#x27;,&#x27;code&#x27;]  &#125;</span><br><br>---------------------------------------------------------------------------------------<br><span class=\"hljs-comment\">// 另外一种办法,展开运算符</span><br><span class=\"hljs-keyword\">let</span> p = &#123;...person&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p);   <span class=\"hljs-comment\">//&#123;  name:&quot;spider&quot;,hobbies:[&#x27;drink&#x27;,&#x27;game&#x27;,&#x27;code&#x27;]  &#125;</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"/2023/02/22/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D.png\" alt=\"浅拷贝\"></p>\n<h2 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//深拷贝</span><br><br><span class=\"hljs-keyword\">let</span> person = &#123;<br>\t<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;spider&quot;</span>,<br>    <span class=\"hljs-attr\">hobbies</span>:[<span class=\"hljs-string\">&#x27;drink&#x27;</span>,<span class=\"hljs-string\">&#x27;game&#x27;</span>,<span class=\"hljs-string\">&#x27;code&#x27;</span>]<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> person1 = <span class=\"hljs-title function_\">deepClone</span>(person);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">deepClone</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (obj === <span class=\"hljs-literal\">null</span> || <span class=\"hljs-keyword\">typeof</span> obj !== <span class=\"hljs-string\">&quot;object&quot;</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> obj;<br>    &#125;<br>    <span class=\"hljs-keyword\">let</span> clone = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(obj) ? [] : &#123;&#125;;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">in</span> obj) &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> obj[i] == <span class=\"hljs-string\">&quot;object&quot;</span>) &#123;<br>            clone[i] = <span class=\"hljs-title function_\">deepClone</span>(obj[i]);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            clone[i] = obj[i];<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> clone;<br>&#125;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1);  <span class=\"hljs-comment\">//&#123; name: &#x27;spider&#x27;, hobbies: [ &#x27;drink&#x27;, &#x27;game&#x27;, &#x27;code&#x27; ] &#125;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1 === person);  <span class=\"hljs-comment\">//false</span><br>person.<span class=\"hljs-property\">hobbies</span>[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&quot;swimming&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person.<span class=\"hljs-property\">hobbies</span>[<span class=\"hljs-number\">0</span>]);  <span class=\"hljs-comment\">//swimming</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1.<span class=\"hljs-property\">hobbies</span>[<span class=\"hljs-number\">0</span>]);  <span class=\"hljs-comment\">//drink</span><br><br>---------------------------------------------------------------------<br><span class=\"hljs-comment\">//另外一种写法，但是会有问题</span><br> <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title class_\">Stringify</span>(obj))<br></code></pre></td></tr></table></figure>\n\n\n\n<p>这也是利用JSON.stringify将对象转成JSON字符串，再用JSON.parse把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p>\n<p><strong>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则</strong>，因为这两者基于JSON.stringify和JSON.parse处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为null）了。</p>\n<p><img src=\"/2023/02/22/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%8B%B7%E8%B4%9D.png\" alt=\"深拷贝\"></p>\n","site":{"data":{}},"wordcount":2815,"excerpt":"","more":"<p>因为对象是引用类型，是存放在堆中的，栈中存着它的标识符，也就是对象在堆中的地址。</p>\n<p>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址(也就是说第一层是拷贝的值，第二层之后拷贝的都是地址) ，所以<strong>如果其中一个对象改变了这个地址，就会影响到另一个对象</strong>。</p>\n<p>深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且<strong>修改新对象不会影响原对象</strong></p>\n<h2 id=\"赋值和深-浅拷贝的区别\"><a href=\"#赋值和深-浅拷贝的区别\" class=\"headerlink\" title=\"赋值和深/浅拷贝的区别\"></a>赋值和深/浅拷贝的区别</h2><p>这三者的区别如下，不过比较的前提都是<strong>针对引用类型</strong>：</p>\n<ul>\n<li>当我们把一个对象赋值给一个新的变量时，<strong>赋的其实是该对象的在栈中的地址，而不是堆中的数据</strong>。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li>\n<li>浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。</li>\n<li>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//给对象赋值</span><br><span class=\"hljs-keyword\">let</span> person = &#123;<br>\t<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;badspider&quot;</span>,<br>    <span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">22</span>,<br>    <span class=\"hljs-attr\">school</span>:&#123;<br>\t\t<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;BJUS&quot;</span>,<br>        <span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">200</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> person1 =  person;  <span class=\"hljs-comment\">//这个就是直接赋值，相当于把栈中指向对象的那个地址直接赋值给person1，所以person1里面的是指向同一个对象的地址，如果person发生改变，那么person1也就会改变</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1 === person);  <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/2023/02/22/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC.png\" alt=\"对象赋值\"></p>\n<h2 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//浅拷贝</span><br><span class=\"hljs-keyword\">let</span> person = &#123;<br>\t<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;spider&quot;</span>,<br>    <span class=\"hljs-attr\">hobbies</span>:[<span class=\"hljs-string\">&#x27;drink&#x27;</span>,<span class=\"hljs-string\">&#x27;game&#x27;</span>,<span class=\"hljs-string\">&#x27;code&#x27;</span>]<br>&#125;<br><br><br><span class=\"hljs-keyword\">function</span>  <span class=\"hljs-title function_\">shallowClone</span>(<span class=\"hljs-params\">obj</span>)&#123;<br>    <span class=\"hljs-keyword\">let</span> temp = &#123;&#125;;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">in</span> obj)&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(obj.<span class=\"hljs-title function_\">hasOwnProperty</span>(i))&#123;<span class=\"hljs-comment\">//判断对象是否有这个属性，有则返回true，无则返回false</span><br>            temp[i] = obj[i];<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> temp;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> person1 = <span class=\"hljs-title function_\">shallowClone</span>(person);<br><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1 === person);  <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1.<span class=\"hljs-property\">hobbies</span> === person.<span class=\"hljs-property\">hobbies</span>);  <span class=\"hljs-comment\">//true</span><br><br><br>---------------------------------------------------------------------------------------<br>  <br><span class=\"hljs-comment\">//另外一种办法 Object.assign(target,source)</span><br>    <br><span class=\"hljs-keyword\">let</span> p = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;,person);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p);   <span class=\"hljs-comment\">//&#123;  name:&quot;spider&quot;,hobbies:[&#x27;drink&#x27;,&#x27;game&#x27;,&#x27;code&#x27;]  &#125;</span><br><br>---------------------------------------------------------------------------------------<br><span class=\"hljs-comment\">// 另外一种办法,展开运算符</span><br><span class=\"hljs-keyword\">let</span> p = &#123;...person&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p);   <span class=\"hljs-comment\">//&#123;  name:&quot;spider&quot;,hobbies:[&#x27;drink&#x27;,&#x27;game&#x27;,&#x27;code&#x27;]  &#125;</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"/2023/02/22/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D.png\" alt=\"浅拷贝\"></p>\n<h2 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//深拷贝</span><br><br><span class=\"hljs-keyword\">let</span> person = &#123;<br>\t<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;spider&quot;</span>,<br>    <span class=\"hljs-attr\">hobbies</span>:[<span class=\"hljs-string\">&#x27;drink&#x27;</span>,<span class=\"hljs-string\">&#x27;game&#x27;</span>,<span class=\"hljs-string\">&#x27;code&#x27;</span>]<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> person1 = <span class=\"hljs-title function_\">deepClone</span>(person);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">deepClone</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (obj === <span class=\"hljs-literal\">null</span> || <span class=\"hljs-keyword\">typeof</span> obj !== <span class=\"hljs-string\">&quot;object&quot;</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> obj;<br>    &#125;<br>    <span class=\"hljs-keyword\">let</span> clone = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(obj) ? [] : &#123;&#125;;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">in</span> obj) &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> obj[i] == <span class=\"hljs-string\">&quot;object&quot;</span>) &#123;<br>            clone[i] = <span class=\"hljs-title function_\">deepClone</span>(obj[i]);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            clone[i] = obj[i];<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> clone;<br>&#125;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1);  <span class=\"hljs-comment\">//&#123; name: &#x27;spider&#x27;, hobbies: [ &#x27;drink&#x27;, &#x27;game&#x27;, &#x27;code&#x27; ] &#125;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1 === person);  <span class=\"hljs-comment\">//false</span><br>person.<span class=\"hljs-property\">hobbies</span>[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&quot;swimming&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person.<span class=\"hljs-property\">hobbies</span>[<span class=\"hljs-number\">0</span>]);  <span class=\"hljs-comment\">//swimming</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person1.<span class=\"hljs-property\">hobbies</span>[<span class=\"hljs-number\">0</span>]);  <span class=\"hljs-comment\">//drink</span><br><br>---------------------------------------------------------------------<br><span class=\"hljs-comment\">//另外一种写法，但是会有问题</span><br> <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title class_\">Stringify</span>(obj))<br></code></pre></td></tr></table></figure>\n\n\n\n<p>这也是利用JSON.stringify将对象转成JSON字符串，再用JSON.parse把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p>\n<p><strong>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则</strong>，因为这两者基于JSON.stringify和JSON.parse处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为null）了。</p>\n<p><img src=\"/2023/02/22/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%8B%B7%E8%B4%9D.png\" alt=\"深拷贝\"></p>\n"},{"title":"渲染引擎的执行原理","date":"2023-03-01T03:44:25.000Z","index_img":"/img/browser.jpg","_content":"\n\n\n\n\n# 渲染引擎的执行原理\n\n> 我们输入URL按下回车，发生了什么？\n\n1. 主进程中的UI线程会判断输入框中的是Query还是URL，如果是URL，则通知网络进程处理，网络进程是负责发送请求和接收响应的；\n2. UI线程得到网络进程返回的数据后，包装成渲染任务放入任务队列中，渲染进程的主线程开始渲染任务；\n\n**什么是浏览器的渲染？**\n\n首先拿到的数据是一个    HTML字符串  -->  渲染 --> 像素信息(绘制指令) --> GPU \n\n1.*PARESE HTML*\n\n对HTML文本进行解析： 元素标签，CSS，JS\n\n* 元素标签\n\n生成 DOM 树 （c++对象）\n\n控制台里面的元素不是HTML，而是一个DOM树\n\n![DOM树](DOM树.png)\n\n\n\n2. CSS Parser\n\nblink内核的默认CSS样式：https://github.com/chromium/chromium/blob/main/third_party/blink/renderer/core/html/resources/html.css\n\n![Tree解析](Tree.png)\n\n所以CSS 是不会堵塞DOM的解析的，但是会堵塞DOM的渲染\n\n2.1 CSSOM\n\n![CSSOM](CSSOM.png)\n\n\n\n2.2 样式计算\n\n通过CSSOM 和 DOM 生成\n\n含有所有 CSS 的 DOM 节点\n\n3. 布局(layout)\n\n![布局](布局.png)\n\n> display:none 和 opcity:0 的区别\n>\n> display:none  在生成布局树的时候就不会加进去了，没有几何信息\n\n**内容必须在行盒中**\n\n**行盒不能和快盒相邻**\n\n\n\n4. 分层\n\n减少变化产生的工作量(现代浏览器)  \n\n在文档发生改变的时候，就只改变特定的部分，不会全部改变\n\n5. 绘制\n\n根据布局树生成绘制指令\n\n在哪个坐标画什么颜色\n\n每一层一组指令\n\n6. 分块\n\n![分块](分块.png)\n\n\n\n7. 光栅化\n\n利用GPU进行加速\n\n![光栅化](光栅化.png)\n\n8. DRAW QUAD\n\n![DRAW QUAD](DRAW QUAD.png)\n\n## 回顾\n\n![浏览器解析原理](浏览器解析原理.png)\n\n\n\n\n\n![重绘](重绘.png)\n\n\n\ncss3的translate 不会导致页面的重绘，而是在draw这一块重新画出来\n\n而定位等行为会导致页面的重绘，会占用主线程\n\n\n\n\n\n\n\n","source":"_posts/渲染引擎的执行原理.md","raw":"---\ntitle: 渲染引擎的执行原理\ndate: 2023-03-01 11:44:25\ncategory: 前端\ntags: 基础知识点\nindex_img: /img/browser.jpg\n\n---\n\n\n\n\n\n# 渲染引擎的执行原理\n\n> 我们输入URL按下回车，发生了什么？\n\n1. 主进程中的UI线程会判断输入框中的是Query还是URL，如果是URL，则通知网络进程处理，网络进程是负责发送请求和接收响应的；\n2. UI线程得到网络进程返回的数据后，包装成渲染任务放入任务队列中，渲染进程的主线程开始渲染任务；\n\n**什么是浏览器的渲染？**\n\n首先拿到的数据是一个    HTML字符串  -->  渲染 --> 像素信息(绘制指令) --> GPU \n\n1.*PARESE HTML*\n\n对HTML文本进行解析： 元素标签，CSS，JS\n\n* 元素标签\n\n生成 DOM 树 （c++对象）\n\n控制台里面的元素不是HTML，而是一个DOM树\n\n![DOM树](DOM树.png)\n\n\n\n2. CSS Parser\n\nblink内核的默认CSS样式：https://github.com/chromium/chromium/blob/main/third_party/blink/renderer/core/html/resources/html.css\n\n![Tree解析](Tree.png)\n\n所以CSS 是不会堵塞DOM的解析的，但是会堵塞DOM的渲染\n\n2.1 CSSOM\n\n![CSSOM](CSSOM.png)\n\n\n\n2.2 样式计算\n\n通过CSSOM 和 DOM 生成\n\n含有所有 CSS 的 DOM 节点\n\n3. 布局(layout)\n\n![布局](布局.png)\n\n> display:none 和 opcity:0 的区别\n>\n> display:none  在生成布局树的时候就不会加进去了，没有几何信息\n\n**内容必须在行盒中**\n\n**行盒不能和快盒相邻**\n\n\n\n4. 分层\n\n减少变化产生的工作量(现代浏览器)  \n\n在文档发生改变的时候，就只改变特定的部分，不会全部改变\n\n5. 绘制\n\n根据布局树生成绘制指令\n\n在哪个坐标画什么颜色\n\n每一层一组指令\n\n6. 分块\n\n![分块](分块.png)\n\n\n\n7. 光栅化\n\n利用GPU进行加速\n\n![光栅化](光栅化.png)\n\n8. DRAW QUAD\n\n![DRAW QUAD](DRAW QUAD.png)\n\n## 回顾\n\n![浏览器解析原理](浏览器解析原理.png)\n\n\n\n\n\n![重绘](重绘.png)\n\n\n\ncss3的translate 不会导致页面的重绘，而是在draw这一块重新画出来\n\n而定位等行为会导致页面的重绘，会占用主线程\n\n\n\n\n\n\n\n","slug":"渲染引擎的执行原理","published":1,"updated":"2024-11-17T13:58:10.683Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpq003573t3arizf01d","content":"<h1 id=\"渲染引擎的执行原理\"><a href=\"#渲染引擎的执行原理\" class=\"headerlink\" title=\"渲染引擎的执行原理\"></a>渲染引擎的执行原理</h1><blockquote>\n<p>我们输入URL按下回车，发生了什么？</p>\n</blockquote>\n<ol>\n<li>主进程中的UI线程会判断输入框中的是Query还是URL，如果是URL，则通知网络进程处理，网络进程是负责发送请求和接收响应的；</li>\n<li>UI线程得到网络进程返回的数据后，包装成渲染任务放入任务队列中，渲染进程的主线程开始渲染任务；</li>\n</ol>\n<p><strong>什么是浏览器的渲染？</strong></p>\n<p>首先拿到的数据是一个    HTML字符串  –&gt;  渲染 –&gt; 像素信息(绘制指令) –&gt; GPU </p>\n<p>1.<em>PARESE HTML</em></p>\n<p>对HTML文本进行解析： 元素标签，CSS，JS</p>\n<ul>\n<li>元素标签</li>\n</ul>\n<p>生成 DOM 树 （c++对象）</p>\n<p>控制台里面的元素不是HTML，而是一个DOM树</p>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/DOM%E6%A0%91.png\" alt=\"DOM树\"></p>\n<ol start=\"2\">\n<li>CSS Parser</li>\n</ol>\n<p>blink内核的默认CSS样式：<a href=\"https://github.com/chromium/chromium/blob/main/third_party/blink/renderer/core/html/resources/html.css\">https://github.com/chromium/chromium/blob/main/third_party/blink/renderer/core/html/resources/html.css</a></p>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/Tree.png\" alt=\"Tree解析\"></p>\n<p>所以CSS 是不会堵塞DOM的解析的，但是会堵塞DOM的渲染</p>\n<p>2.1 CSSOM</p>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/CSSOM.png\" alt=\"CSSOM\"></p>\n<p>2.2 样式计算</p>\n<p>通过CSSOM 和 DOM 生成</p>\n<p>含有所有 CSS 的 DOM 节点</p>\n<ol start=\"3\">\n<li>布局(layout)</li>\n</ol>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/%E5%B8%83%E5%B1%80.png\" alt=\"布局\"></p>\n<blockquote>\n<p>display:none 和 opcity:0 的区别</p>\n<p>display:none  在生成布局树的时候就不会加进去了，没有几何信息</p>\n</blockquote>\n<p><strong>内容必须在行盒中</strong></p>\n<p><strong>行盒不能和快盒相邻</strong></p>\n<ol start=\"4\">\n<li>分层</li>\n</ol>\n<p>减少变化产生的工作量(现代浏览器)  </p>\n<p>在文档发生改变的时候，就只改变特定的部分，不会全部改变</p>\n<ol start=\"5\">\n<li>绘制</li>\n</ol>\n<p>根据布局树生成绘制指令</p>\n<p>在哪个坐标画什么颜色</p>\n<p>每一层一组指令</p>\n<ol start=\"6\">\n<li>分块</li>\n</ol>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/%E5%88%86%E5%9D%97.png\" alt=\"分块\"></p>\n<ol start=\"7\">\n<li>光栅化</li>\n</ol>\n<p>利用GPU进行加速</p>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/%E5%85%89%E6%A0%85%E5%8C%96.png\" alt=\"光栅化\"></p>\n<ol start=\"8\">\n<li>DRAW QUAD</li>\n</ol>\n<p>![DRAW QUAD](DRAW QUAD.png)</p>\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86.png\" alt=\"浏览器解析原理\"></p>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/%E9%87%8D%E7%BB%98.png\" alt=\"重绘\"></p>\n<p>css3的translate 不会导致页面的重绘，而是在draw这一块重新画出来</p>\n<p>而定位等行为会导致页面的重绘，会占用主线程</p>\n","site":{"data":{}},"wordcount":738,"excerpt":"","more":"<h1 id=\"渲染引擎的执行原理\"><a href=\"#渲染引擎的执行原理\" class=\"headerlink\" title=\"渲染引擎的执行原理\"></a>渲染引擎的执行原理</h1><blockquote>\n<p>我们输入URL按下回车，发生了什么？</p>\n</blockquote>\n<ol>\n<li>主进程中的UI线程会判断输入框中的是Query还是URL，如果是URL，则通知网络进程处理，网络进程是负责发送请求和接收响应的；</li>\n<li>UI线程得到网络进程返回的数据后，包装成渲染任务放入任务队列中，渲染进程的主线程开始渲染任务；</li>\n</ol>\n<p><strong>什么是浏览器的渲染？</strong></p>\n<p>首先拿到的数据是一个    HTML字符串  –&gt;  渲染 –&gt; 像素信息(绘制指令) –&gt; GPU </p>\n<p>1.<em>PARESE HTML</em></p>\n<p>对HTML文本进行解析： 元素标签，CSS，JS</p>\n<ul>\n<li>元素标签</li>\n</ul>\n<p>生成 DOM 树 （c++对象）</p>\n<p>控制台里面的元素不是HTML，而是一个DOM树</p>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/DOM%E6%A0%91.png\" alt=\"DOM树\"></p>\n<ol start=\"2\">\n<li>CSS Parser</li>\n</ol>\n<p>blink内核的默认CSS样式：<a href=\"https://github.com/chromium/chromium/blob/main/third_party/blink/renderer/core/html/resources/html.css\">https://github.com/chromium/chromium/blob/main/third_party/blink/renderer/core/html/resources/html.css</a></p>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/Tree.png\" alt=\"Tree解析\"></p>\n<p>所以CSS 是不会堵塞DOM的解析的，但是会堵塞DOM的渲染</p>\n<p>2.1 CSSOM</p>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/CSSOM.png\" alt=\"CSSOM\"></p>\n<p>2.2 样式计算</p>\n<p>通过CSSOM 和 DOM 生成</p>\n<p>含有所有 CSS 的 DOM 节点</p>\n<ol start=\"3\">\n<li>布局(layout)</li>\n</ol>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/%E5%B8%83%E5%B1%80.png\" alt=\"布局\"></p>\n<blockquote>\n<p>display:none 和 opcity:0 的区别</p>\n<p>display:none  在生成布局树的时候就不会加进去了，没有几何信息</p>\n</blockquote>\n<p><strong>内容必须在行盒中</strong></p>\n<p><strong>行盒不能和快盒相邻</strong></p>\n<ol start=\"4\">\n<li>分层</li>\n</ol>\n<p>减少变化产生的工作量(现代浏览器)  </p>\n<p>在文档发生改变的时候，就只改变特定的部分，不会全部改变</p>\n<ol start=\"5\">\n<li>绘制</li>\n</ol>\n<p>根据布局树生成绘制指令</p>\n<p>在哪个坐标画什么颜色</p>\n<p>每一层一组指令</p>\n<ol start=\"6\">\n<li>分块</li>\n</ol>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/%E5%88%86%E5%9D%97.png\" alt=\"分块\"></p>\n<ol start=\"7\">\n<li>光栅化</li>\n</ol>\n<p>利用GPU进行加速</p>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/%E5%85%89%E6%A0%85%E5%8C%96.png\" alt=\"光栅化\"></p>\n<ol start=\"8\">\n<li>DRAW QUAD</li>\n</ol>\n<p>![DRAW QUAD](DRAW QUAD.png)</p>\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86.png\" alt=\"浏览器解析原理\"></p>\n<p><img src=\"/2023/03/01/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/%E9%87%8D%E7%BB%98.png\" alt=\"重绘\"></p>\n<p>css3的translate 不会导致页面的重绘，而是在draw这一块重新画出来</p>\n<p>而定位等行为会导致页面的重绘，会占用主线程</p>\n"},{"title":"矩阵中的蛇","date":"2024-11-21T09:22:02.000Z","index_img":"/img/post/leetcode.jpg","banner_img":null,"_content":"\n[3248. 矩阵中的蛇](https://leetcode.cn/problems/snake-in-matrix/description/?envType=daily-question&envId=2024-11-21)\n\nlevel: `easy`\n\ntag:`数组` `字符串` `模拟`\n\n大小为 n x n 的矩阵 grid 中有一条蛇。蛇可以朝 四个可能的方向 移动。矩阵中的每个单元格都使用位置进行标识： grid[i][j] = (i \\* n) + j。\n\n蛇从单元格 0 开始，并遵循一系列命令移动。\n\n给你一个整数 n 表示 grid 的大小，另给你一个字符串数组 commands，其中包括 \"UP\"、\"RIGHT\"、\"DOWN\" 和 \"LEFT\"。题目测评数据保证蛇在整个移动过程中将始终位于 grid 边界内。\n\n返回执行 commands 后蛇所停留的最终单元格的位置。\n\n**示例 1：**\n\n```js\n输入：n = 2, commands = [\"RIGHT\",\"DOWN\"]\n\n输出：3\n```\n\n#### 题解：\n\n```ts\nfunction finalPositionOfSnake(n: number, commands: string[]): number {\n  let i = 0,\n    j = 0;\n  commands.map((cmd) => {\n    switch (cmd) {\n      case \"DOWN\":\n        ++i;\n        break;\n      case \"UP\":\n        --i;\n        break;\n      case \"LEFT\":\n        --j;\n        break;\n      case \"RIGHT\":\n        ++j;\n    }\n  });\n\n  return i * n + j;\n}\n```\n\n#### 思路：\n\n初始化 i=j=0，按题意要求上下左右移动即可，注意题目保证不会出界。\n\n最后返回 i⋅n+j。\n\n#### 复杂度\n\n时间复杂度：O(m)\n\n空间复杂度：O(1)\n","source":"_posts/矩阵中的蛇.md","raw":"---\ntitle: 矩阵中的蛇\ndate: 2024-11-21 17:22:02\ntags: 每日一题\ncategories: 算法\nindex_img: /img/post/leetcode.jpg\nbanner_img:\n---\n\n[3248. 矩阵中的蛇](https://leetcode.cn/problems/snake-in-matrix/description/?envType=daily-question&envId=2024-11-21)\n\nlevel: `easy`\n\ntag:`数组` `字符串` `模拟`\n\n大小为 n x n 的矩阵 grid 中有一条蛇。蛇可以朝 四个可能的方向 移动。矩阵中的每个单元格都使用位置进行标识： grid[i][j] = (i \\* n) + j。\n\n蛇从单元格 0 开始，并遵循一系列命令移动。\n\n给你一个整数 n 表示 grid 的大小，另给你一个字符串数组 commands，其中包括 \"UP\"、\"RIGHT\"、\"DOWN\" 和 \"LEFT\"。题目测评数据保证蛇在整个移动过程中将始终位于 grid 边界内。\n\n返回执行 commands 后蛇所停留的最终单元格的位置。\n\n**示例 1：**\n\n```js\n输入：n = 2, commands = [\"RIGHT\",\"DOWN\"]\n\n输出：3\n```\n\n#### 题解：\n\n```ts\nfunction finalPositionOfSnake(n: number, commands: string[]): number {\n  let i = 0,\n    j = 0;\n  commands.map((cmd) => {\n    switch (cmd) {\n      case \"DOWN\":\n        ++i;\n        break;\n      case \"UP\":\n        --i;\n        break;\n      case \"LEFT\":\n        --j;\n        break;\n      case \"RIGHT\":\n        ++j;\n    }\n  });\n\n  return i * n + j;\n}\n```\n\n#### 思路：\n\n初始化 i=j=0，按题意要求上下左右移动即可，注意题目保证不会出界。\n\n最后返回 i⋅n+j。\n\n#### 复杂度\n\n时间复杂度：O(m)\n\n空间复杂度：O(1)\n","slug":"矩阵中的蛇","published":1,"updated":"2024-11-21T09:25:54.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpq003973t3fe0bewng","content":"<p><a href=\"https://leetcode.cn/problems/snake-in-matrix/description/?envType=daily-question&envId=2024-11-21\">3248. 矩阵中的蛇</a></p>\n<p>level: <code>easy</code></p>\n<p>tag:<code>数组</code> <code>字符串</code> <code>模拟</code></p>\n<p>大小为 n x n 的矩阵 grid 中有一条蛇。蛇可以朝 四个可能的方向 移动。矩阵中的每个单元格都使用位置进行标识： grid[i][j] = (i * n) + j。</p>\n<p>蛇从单元格 0 开始，并遵循一系列命令移动。</p>\n<p>给你一个整数 n 表示 grid 的大小，另给你一个字符串数组 commands，其中包括 “UP”、”RIGHT”、”DOWN” 和 “LEFT”。题目测评数据保证蛇在整个移动过程中将始终位于 grid 边界内。</p>\n<p>返回执行 commands 后蛇所停留的最终单元格的位置。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">输入：n = <span class=\"hljs-number\">2</span>, commands = [<span class=\"hljs-string\">&quot;RIGHT&quot;</span>,<span class=\"hljs-string\">&quot;DOWN&quot;</span>]<br><br>输出：<span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">finalPositionOfSnake</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">n</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">commands</span>: <span class=\"hljs-built_in\">string</span>[]</span>): <span class=\"hljs-built_in\">number</span> &#123;<br>  <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>,<br>    j = <span class=\"hljs-number\">0</span>;<br>  commands.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">cmd</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">switch</span> (cmd) &#123;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;DOWN&quot;</span>:<br>        ++i;<br>        <span class=\"hljs-keyword\">break</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;UP&quot;</span>:<br>        --i;<br>        <span class=\"hljs-keyword\">break</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;LEFT&quot;</span>:<br>        --j;<br>        <span class=\"hljs-keyword\">break</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;RIGHT&quot;</span>:<br>        ++j;<br>    &#125;<br>  &#125;);<br><br>  <span class=\"hljs-keyword\">return</span> i * n + j;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>初始化 i=j=0，按题意要求上下左右移动即可，注意题目保证不会出界。</p>\n<p>最后返回 i⋅n+j。</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>时间复杂度：O(m)</p>\n<p>空间复杂度：O(1)</p>\n","site":{"data":{}},"wordcount":690,"excerpt":"","more":"<p><a href=\"https://leetcode.cn/problems/snake-in-matrix/description/?envType=daily-question&envId=2024-11-21\">3248. 矩阵中的蛇</a></p>\n<p>level: <code>easy</code></p>\n<p>tag:<code>数组</code> <code>字符串</code> <code>模拟</code></p>\n<p>大小为 n x n 的矩阵 grid 中有一条蛇。蛇可以朝 四个可能的方向 移动。矩阵中的每个单元格都使用位置进行标识： grid[i][j] = (i * n) + j。</p>\n<p>蛇从单元格 0 开始，并遵循一系列命令移动。</p>\n<p>给你一个整数 n 表示 grid 的大小，另给你一个字符串数组 commands，其中包括 “UP”、”RIGHT”、”DOWN” 和 “LEFT”。题目测评数据保证蛇在整个移动过程中将始终位于 grid 边界内。</p>\n<p>返回执行 commands 后蛇所停留的最终单元格的位置。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">输入：n = <span class=\"hljs-number\">2</span>, commands = [<span class=\"hljs-string\">&quot;RIGHT&quot;</span>,<span class=\"hljs-string\">&quot;DOWN&quot;</span>]<br><br>输出：<span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">finalPositionOfSnake</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">n</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">commands</span>: <span class=\"hljs-built_in\">string</span>[]</span>): <span class=\"hljs-built_in\">number</span> &#123;<br>  <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>,<br>    j = <span class=\"hljs-number\">0</span>;<br>  commands.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">cmd</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">switch</span> (cmd) &#123;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;DOWN&quot;</span>:<br>        ++i;<br>        <span class=\"hljs-keyword\">break</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;UP&quot;</span>:<br>        --i;<br>        <span class=\"hljs-keyword\">break</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;LEFT&quot;</span>:<br>        --j;<br>        <span class=\"hljs-keyword\">break</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;RIGHT&quot;</span>:<br>        ++j;<br>    &#125;<br>  &#125;);<br><br>  <span class=\"hljs-keyword\">return</span> i * n + j;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>初始化 i=j=0，按题意要求上下左右移动即可，注意题目保证不会出界。</p>\n<p>最后返回 i⋅n+j。</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>时间复杂度：O(m)</p>\n<p>空间复杂度：O(1)</p>\n"},{"title":"统计满足 K 约束的子字符串数量 I","date":"2024-11-11T03:49:55.000Z","index_img":"/img/post/leetcode.jpg","banner_img":null,"_content":"\n[3258. 统计满足 K 约束的子字符串数量 I](https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/?envType=daily-question&envId=2024-11-13)\n\nlevel: `easy`\n\ntag:`滑动窗口` `字符串`\n\n给你一个 二进制 字符串 s 和一个整数 k。\n\n如果一个 二进制字符串 满足以下任一条件，则认为该字符串满足 k 约束：\n\n字符串中 0 的数量最多为 k。\n字符串中 1 的数量最多为 k。\n\n返回一个整数，表示 s 的所有满足 k 约束 的子字符串 的数量。\n\n**示例 1：**\n\n```js\n输入：s = \"10101\", k = 1\n\n输出：12\n\n解释：\n\ns 的所有子字符串中，除了 \"1010\"、\"10101\" 和 \"0101\" 外，其余子字符串都满足 k 约束。\n```\n\n#### 题解：\n\n```js\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar countKConstraintSubstrings = function (s, k) {\n  let count = 0;\n  let zeroCount = 0,\n    oneCount = 0;\n  let left = 0;\n\n  for (let right = 0; right < s.length; right++) {\n    // 扩展窗口\n    if (s[right] === \"0\") zeroCount++;\n    else oneCount++;\n\n    // 当窗口不满足 k 约束时，收缩窗口\n    while (zeroCount > k && oneCount > k) {\n      if (s[left] === \"0\") zeroCount--;\n      else oneCount--;\n      left++;\n    }\n\n    // 符合条件的子字符串数量增加\n    count += right - left + 1;\n  }\n\n  return count;\n};\n```\n\n#### 思路：\n\n这是一道**不定长滑动窗口**的题目，通过不断遍历右端点，缩小左端点，来统计满足条件的子字符串数量。\n**首先** 看题目要求\n字符串中 0 的数量最多为 k\n字符串中 1 的数量最多为 k\n也就是 子串中不能 同时存在超过 k 个 0 和 1\n**其次** 可以找到一个规律，当一个最长子串满足条件时，那么它的所有子串都满足条件，也就是 right -left +1 个子串满足\n**最后** 通过不断遍历右端点，缩小左端点，来统计满足条件的子字符串数量。\n\n#### 复杂度：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","source":"_posts/统计满足-K-约束的子字符串数量-I.md","raw":"---\ntitle: 统计满足 K 约束的子字符串数量 I\ndate: 2024-11-11 11:49:55\ntags: 每日一题\ncategories: 算法\nindex_img: /img/post/leetcode.jpg\nbanner_img:\n---\n\n[3258. 统计满足 K 约束的子字符串数量 I](https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/?envType=daily-question&envId=2024-11-13)\n\nlevel: `easy`\n\ntag:`滑动窗口` `字符串`\n\n给你一个 二进制 字符串 s 和一个整数 k。\n\n如果一个 二进制字符串 满足以下任一条件，则认为该字符串满足 k 约束：\n\n字符串中 0 的数量最多为 k。\n字符串中 1 的数量最多为 k。\n\n返回一个整数，表示 s 的所有满足 k 约束 的子字符串 的数量。\n\n**示例 1：**\n\n```js\n输入：s = \"10101\", k = 1\n\n输出：12\n\n解释：\n\ns 的所有子字符串中，除了 \"1010\"、\"10101\" 和 \"0101\" 外，其余子字符串都满足 k 约束。\n```\n\n#### 题解：\n\n```js\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar countKConstraintSubstrings = function (s, k) {\n  let count = 0;\n  let zeroCount = 0,\n    oneCount = 0;\n  let left = 0;\n\n  for (let right = 0; right < s.length; right++) {\n    // 扩展窗口\n    if (s[right] === \"0\") zeroCount++;\n    else oneCount++;\n\n    // 当窗口不满足 k 约束时，收缩窗口\n    while (zeroCount > k && oneCount > k) {\n      if (s[left] === \"0\") zeroCount--;\n      else oneCount--;\n      left++;\n    }\n\n    // 符合条件的子字符串数量增加\n    count += right - left + 1;\n  }\n\n  return count;\n};\n```\n\n#### 思路：\n\n这是一道**不定长滑动窗口**的题目，通过不断遍历右端点，缩小左端点，来统计满足条件的子字符串数量。\n**首先** 看题目要求\n字符串中 0 的数量最多为 k\n字符串中 1 的数量最多为 k\n也就是 子串中不能 同时存在超过 k 个 0 和 1\n**其次** 可以找到一个规律，当一个最长子串满足条件时，那么它的所有子串都满足条件，也就是 right -left +1 个子串满足\n**最后** 通过不断遍历右端点，缩小左端点，来统计满足条件的子字符串数量。\n\n#### 复杂度：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","slug":"统计满足-K-约束的子字符串数量-I","published":1,"updated":"2024-11-17T13:58:10.689Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpr003c73t3hwcjehvi","content":"<p><a href=\"https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/?envType=daily-question&envId=2024-11-13\">3258. 统计满足 K 约束的子字符串数量 I</a></p>\n<p>level: <code>easy</code></p>\n<p>tag:<code>滑动窗口</code> <code>字符串</code></p>\n<p>给你一个 二进制 字符串 s 和一个整数 k。</p>\n<p>如果一个 二进制字符串 满足以下任一条件，则认为该字符串满足 k 约束：</p>\n<p>字符串中 0 的数量最多为 k。<br>字符串中 1 的数量最多为 k。</p>\n<p>返回一个整数，表示 s 的所有满足 k 约束 的子字符串 的数量。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">输入：s = <span class=\"hljs-string\">&quot;10101&quot;</span>, k = <span class=\"hljs-number\">1</span><br><br>输出：<span class=\"hljs-number\">12</span><br><br>解释：<br><br>s 的所有子字符串中，除了 <span class=\"hljs-string\">&quot;1010&quot;</span>、<span class=\"hljs-string\">&quot;10101&quot;</span> 和 <span class=\"hljs-string\">&quot;0101&quot;</span> 外，其余子字符串都满足 k 约束。<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">string</span>&#125; <span class=\"hljs-variable\">s</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number</span>&#125; <span class=\"hljs-variable\">k</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-type\">number</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">var</span> countKConstraintSubstrings = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">s, k</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">let</span> zeroCount = <span class=\"hljs-number\">0</span>,<br>    oneCount = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">let</span> left = <span class=\"hljs-number\">0</span>;<br><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> right = <span class=\"hljs-number\">0</span>; right &lt; s.<span class=\"hljs-property\">length</span>; right++) &#123;<br>    <span class=\"hljs-comment\">// 扩展窗口</span><br>    <span class=\"hljs-keyword\">if</span> (s[right] === <span class=\"hljs-string\">&quot;0&quot;</span>) zeroCount++;<br>    <span class=\"hljs-keyword\">else</span> oneCount++;<br><br>    <span class=\"hljs-comment\">// 当窗口不满足 k 约束时，收缩窗口</span><br>    <span class=\"hljs-keyword\">while</span> (zeroCount &gt; k &amp;&amp; oneCount &gt; k) &#123;<br>      <span class=\"hljs-keyword\">if</span> (s[left] === <span class=\"hljs-string\">&quot;0&quot;</span>) zeroCount--;<br>      <span class=\"hljs-keyword\">else</span> oneCount--;<br>      left++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 符合条件的子字符串数量增加</span><br>    count += right - left + <span class=\"hljs-number\">1</span>;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>这是一道<strong>不定长滑动窗口</strong>的题目，通过不断遍历右端点，缩小左端点，来统计满足条件的子字符串数量。<br><strong>首先</strong> 看题目要求<br>字符串中 0 的数量最多为 k<br>字符串中 1 的数量最多为 k<br>也就是 子串中不能 同时存在超过 k 个 0 和 1<br><strong>其次</strong> 可以找到一个规律，当一个最长子串满足条件时，那么它的所有子串都满足条件，也就是 right -left +1 个子串满足<br><strong>最后</strong> 通过不断遍历右端点，缩小左端点，来统计满足条件的子字符串数量。</p>\n<h4 id=\"复杂度：\"><a href=\"#复杂度：\" class=\"headerlink\" title=\"复杂度：\"></a>复杂度：</h4><ul>\n<li>时间复杂度：O(n)</li>\n<li>空间复杂度：O(1)</li>\n</ul>\n","site":{"data":{}},"wordcount":1014,"excerpt":"","more":"<p><a href=\"https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/?envType=daily-question&envId=2024-11-13\">3258. 统计满足 K 约束的子字符串数量 I</a></p>\n<p>level: <code>easy</code></p>\n<p>tag:<code>滑动窗口</code> <code>字符串</code></p>\n<p>给你一个 二进制 字符串 s 和一个整数 k。</p>\n<p>如果一个 二进制字符串 满足以下任一条件，则认为该字符串满足 k 约束：</p>\n<p>字符串中 0 的数量最多为 k。<br>字符串中 1 的数量最多为 k。</p>\n<p>返回一个整数，表示 s 的所有满足 k 约束 的子字符串 的数量。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">输入：s = <span class=\"hljs-string\">&quot;10101&quot;</span>, k = <span class=\"hljs-number\">1</span><br><br>输出：<span class=\"hljs-number\">12</span><br><br>解释：<br><br>s 的所有子字符串中，除了 <span class=\"hljs-string\">&quot;1010&quot;</span>、<span class=\"hljs-string\">&quot;10101&quot;</span> 和 <span class=\"hljs-string\">&quot;0101&quot;</span> 外，其余子字符串都满足 k 约束。<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">string</span>&#125; <span class=\"hljs-variable\">s</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number</span>&#125; <span class=\"hljs-variable\">k</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-type\">number</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">var</span> countKConstraintSubstrings = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">s, k</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">let</span> zeroCount = <span class=\"hljs-number\">0</span>,<br>    oneCount = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">let</span> left = <span class=\"hljs-number\">0</span>;<br><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> right = <span class=\"hljs-number\">0</span>; right &lt; s.<span class=\"hljs-property\">length</span>; right++) &#123;<br>    <span class=\"hljs-comment\">// 扩展窗口</span><br>    <span class=\"hljs-keyword\">if</span> (s[right] === <span class=\"hljs-string\">&quot;0&quot;</span>) zeroCount++;<br>    <span class=\"hljs-keyword\">else</span> oneCount++;<br><br>    <span class=\"hljs-comment\">// 当窗口不满足 k 约束时，收缩窗口</span><br>    <span class=\"hljs-keyword\">while</span> (zeroCount &gt; k &amp;&amp; oneCount &gt; k) &#123;<br>      <span class=\"hljs-keyword\">if</span> (s[left] === <span class=\"hljs-string\">&quot;0&quot;</span>) zeroCount--;<br>      <span class=\"hljs-keyword\">else</span> oneCount--;<br>      left++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 符合条件的子字符串数量增加</span><br>    count += right - left + <span class=\"hljs-number\">1</span>;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>这是一道<strong>不定长滑动窗口</strong>的题目，通过不断遍历右端点，缩小左端点，来统计满足条件的子字符串数量。<br><strong>首先</strong> 看题目要求<br>字符串中 0 的数量最多为 k<br>字符串中 1 的数量最多为 k<br>也就是 子串中不能 同时存在超过 k 个 0 和 1<br><strong>其次</strong> 可以找到一个规律，当一个最长子串满足条件时，那么它的所有子串都满足条件，也就是 right -left +1 个子串满足<br><strong>最后</strong> 通过不断遍历右端点，缩小左端点，来统计满足条件的子字符串数量。</p>\n<h4 id=\"复杂度：\"><a href=\"#复杂度：\" class=\"headerlink\" title=\"复杂度：\"></a>复杂度：</h4><ul>\n<li>时间复杂度：O(n)</li>\n<li>空间复杂度：O(1)</li>\n</ul>\n"},{"title":"节流与防抖","date":"2021-12-07T12:32:58.000Z","index_img":"/img/debounce_banner.jpg","banner_img":"/img/hexo.jpg","_content":"\n### 节流(throttle)与防抖(debounce)\n\n> 一个老生常谈的技巧，为了解决一些类似 搜索框提示，按钮点击等需要频繁触发的函数，这些函数会加重浏览器和服务器的负担，导致用户体验不好\n\n#### 防抖 debounce\n\n**防抖**就是给定一个时间和函数，在这个时间到了之后才会执行函数，但是如果在这个时间内又调用了这个函数，那么就会重新开始计时，直到没有再次调用这个函数，并且到达给定的时间\n\n实现一个简单的debounce：\n\n```js\n/**\n * @param fn 执行函数\n * @param delay 时间间隔\n * @param isImmediate 为true，debounce会在delay时间间隔的开始时立即调用这个函数\n * @returns {Function}\n */\n\nfunction debounce(fn,delay,isImmediate){\n    var timer = null;\n    return function(){\n\t\tlet ctx = this;\n        let args = arguments; //取得参数\n        clearTimeout(timer);\n        if(isImmediate && timer === null){\n            //时间间隔外立即执行\n\t\t\tfn.apply(ctx,args);\n            timer = 0;\n            return;\n        }\n        timer = setTimeout(function() {\n      \t\tfn.apply(context,args);\n      \t\ttimer = null;\n    \t}, delay);\n    }\n}\n\n```\n\n<img src=\"./节流与防抖/debounce.png\" alt=\"debounce 防抖\" style=\"zoom:150%;\" />\n\n#### 节流（throttle）\n\n**节流**就是像一个止水阀，在规定的时间内，不管你触发了多少次事件，只有最后一个事件才会执行\n\n简单实现：\n\n```js\n/**\n * 创建并返回一个像节流阀一样的函数，当重复调用函数的时候，最多每隔delay毫秒调用一次该函数\n * @param fn 执行函数\n * @param delay 时间间隔\n * @returns {Function}\n */\nfunction throttle(fn, delay) {\n  var timer = null;\n  var timeStamp = new Date();\n  return function() {\n    var context = this;  //获取函数所在作用域this\n    var args = arguments;  //取得传入参数\n    if(new Date()-timeStamp>delay){\n        timeStamp = new Date();\n        timer = setTimeout(function(){\n        fn.apply(context,args);\n      },delay);\n    }\n\n  }\n}\n```\n\n<img src=\"./节流与防抖/throttle.png\" alt=\"throttle\" style=\"zoom:150%;\" />\n","source":"_posts/节流与防抖.md","raw":"---\ntitle: 节流与防抖\ndate: 2021-12-07 20:32:58\ntags: tips\ncategories: 前端\nindex_img: /img/debounce_banner.jpg\nbanner_img: /img/hexo.jpg\n---\n\n### 节流(throttle)与防抖(debounce)\n\n> 一个老生常谈的技巧，为了解决一些类似 搜索框提示，按钮点击等需要频繁触发的函数，这些函数会加重浏览器和服务器的负担，导致用户体验不好\n\n#### 防抖 debounce\n\n**防抖**就是给定一个时间和函数，在这个时间到了之后才会执行函数，但是如果在这个时间内又调用了这个函数，那么就会重新开始计时，直到没有再次调用这个函数，并且到达给定的时间\n\n实现一个简单的debounce：\n\n```js\n/**\n * @param fn 执行函数\n * @param delay 时间间隔\n * @param isImmediate 为true，debounce会在delay时间间隔的开始时立即调用这个函数\n * @returns {Function}\n */\n\nfunction debounce(fn,delay,isImmediate){\n    var timer = null;\n    return function(){\n\t\tlet ctx = this;\n        let args = arguments; //取得参数\n        clearTimeout(timer);\n        if(isImmediate && timer === null){\n            //时间间隔外立即执行\n\t\t\tfn.apply(ctx,args);\n            timer = 0;\n            return;\n        }\n        timer = setTimeout(function() {\n      \t\tfn.apply(context,args);\n      \t\ttimer = null;\n    \t}, delay);\n    }\n}\n\n```\n\n<img src=\"./节流与防抖/debounce.png\" alt=\"debounce 防抖\" style=\"zoom:150%;\" />\n\n#### 节流（throttle）\n\n**节流**就是像一个止水阀，在规定的时间内，不管你触发了多少次事件，只有最后一个事件才会执行\n\n简单实现：\n\n```js\n/**\n * 创建并返回一个像节流阀一样的函数，当重复调用函数的时候，最多每隔delay毫秒调用一次该函数\n * @param fn 执行函数\n * @param delay 时间间隔\n * @returns {Function}\n */\nfunction throttle(fn, delay) {\n  var timer = null;\n  var timeStamp = new Date();\n  return function() {\n    var context = this;  //获取函数所在作用域this\n    var args = arguments;  //取得传入参数\n    if(new Date()-timeStamp>delay){\n        timeStamp = new Date();\n        timer = setTimeout(function(){\n        fn.apply(context,args);\n      },delay);\n    }\n\n  }\n}\n```\n\n<img src=\"./节流与防抖/throttle.png\" alt=\"throttle\" style=\"zoom:150%;\" />\n","slug":"节流与防抖","published":1,"updated":"2024-11-17T13:58:10.689Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpr003f73t3ciknbzsn","content":"<h3 id=\"节流-throttle-与防抖-debounce\"><a href=\"#节流-throttle-与防抖-debounce\" class=\"headerlink\" title=\"节流(throttle)与防抖(debounce)\"></a>节流(throttle)与防抖(debounce)</h3><blockquote>\n<p>一个老生常谈的技巧，为了解决一些类似 搜索框提示，按钮点击等需要频繁触发的函数，这些函数会加重浏览器和服务器的负担，导致用户体验不好</p>\n</blockquote>\n<h4 id=\"防抖-debounce\"><a href=\"#防抖-debounce\" class=\"headerlink\" title=\"防抖 debounce\"></a>防抖 debounce</h4><p><strong>防抖</strong>就是给定一个时间和函数，在这个时间到了之后才会执行函数，但是如果在这个时间内又调用了这个函数，那么就会重新开始计时，直到没有再次调用这个函数，并且到达给定的时间</p>\n<p>实现一个简单的debounce：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> fn 执行函数</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> delay 时间间隔</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> isImmediate 为true，debounce会在delay时间间隔的开始时立即调用这个函数</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@returns</span> &#123;<span class=\"hljs-type\">Function</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">debounce</span>(<span class=\"hljs-params\">fn,delay,isImmediate</span>)&#123;<br>    <span class=\"hljs-keyword\">var</span> timer = <span class=\"hljs-literal\">null</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t\t<span class=\"hljs-keyword\">let</span> ctx = <span class=\"hljs-variable language_\">this</span>;<br>        <span class=\"hljs-keyword\">let</span> args = <span class=\"hljs-variable language_\">arguments</span>; <span class=\"hljs-comment\">//取得参数</span><br>        <span class=\"hljs-built_in\">clearTimeout</span>(timer);<br>        <span class=\"hljs-keyword\">if</span>(isImmediate &amp;&amp; timer === <span class=\"hljs-literal\">null</span>)&#123;<br>            <span class=\"hljs-comment\">//时间间隔外立即执行</span><br>\t\t\tfn.<span class=\"hljs-title function_\">apply</span>(ctx,args);<br>            timer = <span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>      \t\tfn.<span class=\"hljs-title function_\">apply</span>(context,args);<br>      \t\ttimer = <span class=\"hljs-literal\">null</span>;<br>    \t&#125;, delay);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<img src=\"/2021/12/07/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/debounce.png\" alt=\"debounce 防抖\" style=\"zoom:150%;\">\n\n<h4 id=\"节流（throttle）\"><a href=\"#节流（throttle）\" class=\"headerlink\" title=\"节流（throttle）\"></a>节流（throttle）</h4><p><strong>节流</strong>就是像一个止水阀，在规定的时间内，不管你触发了多少次事件，只有最后一个事件才会执行</p>\n<p>简单实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 创建并返回一个像节流阀一样的函数，当重复调用函数的时候，最多每隔delay毫秒调用一次该函数</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> fn 执行函数</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> delay 时间间隔</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@returns</span> &#123;<span class=\"hljs-type\">Function</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">throttle</span>(<span class=\"hljs-params\">fn, delay</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> timer = <span class=\"hljs-literal\">null</span>;<br>  <span class=\"hljs-keyword\">var</span> timeStamp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>();<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> context = <span class=\"hljs-variable language_\">this</span>;  <span class=\"hljs-comment\">//获取函数所在作用域this</span><br>    <span class=\"hljs-keyword\">var</span> args = <span class=\"hljs-variable language_\">arguments</span>;  <span class=\"hljs-comment\">//取得传入参数</span><br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>()-timeStamp&gt;delay)&#123;<br>        timeStamp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>();<br>        timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>        fn.<span class=\"hljs-title function_\">apply</span>(context,args);<br>      &#125;,delay);<br>    &#125;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<img src=\"/2021/12/07/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/throttle.png\" alt=\"throttle\" style=\"zoom:150%;\">\n","site":{"data":{}},"wordcount":1179,"excerpt":"","more":"<h3 id=\"节流-throttle-与防抖-debounce\"><a href=\"#节流-throttle-与防抖-debounce\" class=\"headerlink\" title=\"节流(throttle)与防抖(debounce)\"></a>节流(throttle)与防抖(debounce)</h3><blockquote>\n<p>一个老生常谈的技巧，为了解决一些类似 搜索框提示，按钮点击等需要频繁触发的函数，这些函数会加重浏览器和服务器的负担，导致用户体验不好</p>\n</blockquote>\n<h4 id=\"防抖-debounce\"><a href=\"#防抖-debounce\" class=\"headerlink\" title=\"防抖 debounce\"></a>防抖 debounce</h4><p><strong>防抖</strong>就是给定一个时间和函数，在这个时间到了之后才会执行函数，但是如果在这个时间内又调用了这个函数，那么就会重新开始计时，直到没有再次调用这个函数，并且到达给定的时间</p>\n<p>实现一个简单的debounce：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> fn 执行函数</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> delay 时间间隔</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> isImmediate 为true，debounce会在delay时间间隔的开始时立即调用这个函数</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@returns</span> &#123;<span class=\"hljs-type\">Function</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">debounce</span>(<span class=\"hljs-params\">fn,delay,isImmediate</span>)&#123;<br>    <span class=\"hljs-keyword\">var</span> timer = <span class=\"hljs-literal\">null</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t\t<span class=\"hljs-keyword\">let</span> ctx = <span class=\"hljs-variable language_\">this</span>;<br>        <span class=\"hljs-keyword\">let</span> args = <span class=\"hljs-variable language_\">arguments</span>; <span class=\"hljs-comment\">//取得参数</span><br>        <span class=\"hljs-built_in\">clearTimeout</span>(timer);<br>        <span class=\"hljs-keyword\">if</span>(isImmediate &amp;&amp; timer === <span class=\"hljs-literal\">null</span>)&#123;<br>            <span class=\"hljs-comment\">//时间间隔外立即执行</span><br>\t\t\tfn.<span class=\"hljs-title function_\">apply</span>(ctx,args);<br>            timer = <span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>      \t\tfn.<span class=\"hljs-title function_\">apply</span>(context,args);<br>      \t\ttimer = <span class=\"hljs-literal\">null</span>;<br>    \t&#125;, delay);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<img src=\"/2021/12/07/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/debounce.png\" alt=\"debounce 防抖\" style=\"zoom:150%;\">\n\n<h4 id=\"节流（throttle）\"><a href=\"#节流（throttle）\" class=\"headerlink\" title=\"节流（throttle）\"></a>节流（throttle）</h4><p><strong>节流</strong>就是像一个止水阀，在规定的时间内，不管你触发了多少次事件，只有最后一个事件才会执行</p>\n<p>简单实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 创建并返回一个像节流阀一样的函数，当重复调用函数的时候，最多每隔delay毫秒调用一次该函数</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> fn 执行函数</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> delay 时间间隔</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@returns</span> &#123;<span class=\"hljs-type\">Function</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">throttle</span>(<span class=\"hljs-params\">fn, delay</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> timer = <span class=\"hljs-literal\">null</span>;<br>  <span class=\"hljs-keyword\">var</span> timeStamp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>();<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> context = <span class=\"hljs-variable language_\">this</span>;  <span class=\"hljs-comment\">//获取函数所在作用域this</span><br>    <span class=\"hljs-keyword\">var</span> args = <span class=\"hljs-variable language_\">arguments</span>;  <span class=\"hljs-comment\">//取得传入参数</span><br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>()-timeStamp&gt;delay)&#123;<br>        timeStamp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>();<br>        timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>        fn.<span class=\"hljs-title function_\">apply</span>(context,args);<br>      &#125;,delay);<br>    &#125;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<img src=\"/2021/12/07/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/throttle.png\" alt=\"throttle\" style=\"zoom:150%;\">\n"},{"title":"返回地区勾选之后的数组","date":"2024-11-08T02:57:31.000Z","index_img":"/img/post/leetcode.jpg","banner_img":null,"_content":"\ntag:`树` `递归`\n\n\n\n> 题目需求， 传入一个 可以勾选的tree，第二个参数是之前勾选的treeData,第三个参数是勾选掉的节点，返回一个更新后的treeData\n\n\n\n```js\nconst treeData = [\n  {\n    name: \"浙江省\",\n    children: [\n      {\n        name: \"杭州市\",\n        children: [\n          {\n            name: \"西湖区\",\n            children: [{ name: \"文三路\" }],\n          },\n          { name: \"上城区\" },\n        ],\n      },\n      { name: \"宁波市\" },\n    ],\n  },\n  {\n    name: \"江苏省\",\n    children: [{ name: \"南京市\" }, { name: \"苏州市\" }],\n  },\n];\n\n\nconst selectedPath = [\n  \"浙江省\",\n  \"杭州市\",\n  \"上城区\",\n  \"西湖区\",\n  \"文三路\",\n  \"江苏省\",\n  \"南京市\",\n];\nconst deselectedNode = \"西湖区\";\n\nconsole.log(updateTreeData(treeData, selectedPath, deselectedNode)); //[ '浙江省', '杭州市', '上城区', '江苏省', '南京市' ]\n```\n\n#### 题解：\n\n```js\nfunction updateTreeData(treeData, selectedPath, deselectedNode) {\n  const updatedPath = []; // 存储更新后的路径\n\n  // 递归函数，用于遍历树\n  function traverse(node, path) {\n    if (node.name === deselectedNode) {\n      return;\n    }\n\n    if (selectedPath.includes(node.name)) {\n      path.push(node.name);\n    }\n\n    if (node.children && node.children.length > 0) {\n      node.children.forEach((child) => traverse(child, path));\n    }\n\n    return false;\n  }\n\n  // 遍历每个根节点\n  treeData.forEach((node) => traverse(node, updatedPath));\n\n  return updatedPath;\n}\n```\n\n#### 思路:\n\n树的题目一般都是遍历，当查询到当前节点的时候，判断是否是取消勾选的节点，如果是就跳出，否则判断该节点是否选中的节点，是就放入结果数组中，同时判断是否有子节点，有的话就递归调用，没有就结束\n","source":"_posts/返回地区勾选之后的数组.md","raw":"---\ntitle: 返回地区勾选之后的数组\ndate: 2024-11-08 10:57:31\ntags: 算法\ncategories: 算法\nindex_img: /img/post/leetcode.jpg\nbanner_img:\n---\n\ntag:`树` `递归`\n\n\n\n> 题目需求， 传入一个 可以勾选的tree，第二个参数是之前勾选的treeData,第三个参数是勾选掉的节点，返回一个更新后的treeData\n\n\n\n```js\nconst treeData = [\n  {\n    name: \"浙江省\",\n    children: [\n      {\n        name: \"杭州市\",\n        children: [\n          {\n            name: \"西湖区\",\n            children: [{ name: \"文三路\" }],\n          },\n          { name: \"上城区\" },\n        ],\n      },\n      { name: \"宁波市\" },\n    ],\n  },\n  {\n    name: \"江苏省\",\n    children: [{ name: \"南京市\" }, { name: \"苏州市\" }],\n  },\n];\n\n\nconst selectedPath = [\n  \"浙江省\",\n  \"杭州市\",\n  \"上城区\",\n  \"西湖区\",\n  \"文三路\",\n  \"江苏省\",\n  \"南京市\",\n];\nconst deselectedNode = \"西湖区\";\n\nconsole.log(updateTreeData(treeData, selectedPath, deselectedNode)); //[ '浙江省', '杭州市', '上城区', '江苏省', '南京市' ]\n```\n\n#### 题解：\n\n```js\nfunction updateTreeData(treeData, selectedPath, deselectedNode) {\n  const updatedPath = []; // 存储更新后的路径\n\n  // 递归函数，用于遍历树\n  function traverse(node, path) {\n    if (node.name === deselectedNode) {\n      return;\n    }\n\n    if (selectedPath.includes(node.name)) {\n      path.push(node.name);\n    }\n\n    if (node.children && node.children.length > 0) {\n      node.children.forEach((child) => traverse(child, path));\n    }\n\n    return false;\n  }\n\n  // 遍历每个根节点\n  treeData.forEach((node) => traverse(node, updatedPath));\n\n  return updatedPath;\n}\n```\n\n#### 思路:\n\n树的题目一般都是遍历，当查询到当前节点的时候，判断是否是取消勾选的节点，如果是就跳出，否则判断该节点是否选中的节点，是就放入结果数组中，同时判断是否有子节点，有的话就递归调用，没有就结束\n","slug":"返回地区勾选之后的数组","published":1,"updated":"2024-11-17T13:58:10.689Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpr003i73t3ckdpg3qj","content":"<p>tag:<code>树</code> <code>递归</code></p>\n<blockquote>\n<p>题目需求， 传入一个 可以勾选的tree，第二个参数是之前勾选的treeData,第三个参数是勾选掉的节点，返回一个更新后的treeData</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> treeData = [<br>  &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;浙江省&quot;</span>,<br>    <span class=\"hljs-attr\">children</span>: [<br>      &#123;<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;杭州市&quot;</span>,<br>        <span class=\"hljs-attr\">children</span>: [<br>          &#123;<br>            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;西湖区&quot;</span>,<br>            <span class=\"hljs-attr\">children</span>: [&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;文三路&quot;</span> &#125;],<br>          &#125;,<br>          &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;上城区&quot;</span> &#125;,<br>        ],<br>      &#125;,<br>      &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;宁波市&quot;</span> &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;江苏省&quot;</span>,<br>    <span class=\"hljs-attr\">children</span>: [&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;南京市&quot;</span> &#125;, &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;苏州市&quot;</span> &#125;],<br>  &#125;,<br>];<br><br><br><span class=\"hljs-keyword\">const</span> selectedPath = [<br>  <span class=\"hljs-string\">&quot;浙江省&quot;</span>,<br>  <span class=\"hljs-string\">&quot;杭州市&quot;</span>,<br>  <span class=\"hljs-string\">&quot;上城区&quot;</span>,<br>  <span class=\"hljs-string\">&quot;西湖区&quot;</span>,<br>  <span class=\"hljs-string\">&quot;文三路&quot;</span>,<br>  <span class=\"hljs-string\">&quot;江苏省&quot;</span>,<br>  <span class=\"hljs-string\">&quot;南京市&quot;</span>,<br>];<br><span class=\"hljs-keyword\">const</span> deselectedNode = <span class=\"hljs-string\">&quot;西湖区&quot;</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">updateTreeData</span>(treeData, selectedPath, deselectedNode)); <span class=\"hljs-comment\">//[ &#x27;浙江省&#x27;, &#x27;杭州市&#x27;, &#x27;上城区&#x27;, &#x27;江苏省&#x27;, &#x27;南京市&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">updateTreeData</span>(<span class=\"hljs-params\">treeData, selectedPath, deselectedNode</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> updatedPath = []; <span class=\"hljs-comment\">// 存储更新后的路径</span><br><br>  <span class=\"hljs-comment\">// 递归函数，用于遍历树</span><br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">traverse</span>(<span class=\"hljs-params\">node, path</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">name</span> === deselectedNode) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (selectedPath.<span class=\"hljs-title function_\">includes</span>(node.<span class=\"hljs-property\">name</span>)) &#123;<br>      path.<span class=\"hljs-title function_\">push</span>(node.<span class=\"hljs-property\">name</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">children</span> &amp;&amp; node.<span class=\"hljs-property\">children</span>.<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span>) &#123;<br>      node.<span class=\"hljs-property\">children</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">child</span>) =&gt;</span> <span class=\"hljs-title function_\">traverse</span>(child, path));<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 遍历每个根节点</span><br>  treeData.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">node</span>) =&gt;</span> <span class=\"hljs-title function_\">traverse</span>(node, updatedPath));<br><br>  <span class=\"hljs-keyword\">return</span> updatedPath;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h4><p>树的题目一般都是遍历，当查询到当前节点的时候，判断是否是取消勾选的节点，如果是就跳出，否则判断该节点是否选中的节点，是就放入结果数组中，同时判断是否有子节点，有的话就递归调用，没有就结束</p>\n","site":{"data":{}},"wordcount":1446,"excerpt":"","more":"<p>tag:<code>树</code> <code>递归</code></p>\n<blockquote>\n<p>题目需求， 传入一个 可以勾选的tree，第二个参数是之前勾选的treeData,第三个参数是勾选掉的节点，返回一个更新后的treeData</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> treeData = [<br>  &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;浙江省&quot;</span>,<br>    <span class=\"hljs-attr\">children</span>: [<br>      &#123;<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;杭州市&quot;</span>,<br>        <span class=\"hljs-attr\">children</span>: [<br>          &#123;<br>            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;西湖区&quot;</span>,<br>            <span class=\"hljs-attr\">children</span>: [&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;文三路&quot;</span> &#125;],<br>          &#125;,<br>          &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;上城区&quot;</span> &#125;,<br>        ],<br>      &#125;,<br>      &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;宁波市&quot;</span> &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;江苏省&quot;</span>,<br>    <span class=\"hljs-attr\">children</span>: [&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;南京市&quot;</span> &#125;, &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;苏州市&quot;</span> &#125;],<br>  &#125;,<br>];<br><br><br><span class=\"hljs-keyword\">const</span> selectedPath = [<br>  <span class=\"hljs-string\">&quot;浙江省&quot;</span>,<br>  <span class=\"hljs-string\">&quot;杭州市&quot;</span>,<br>  <span class=\"hljs-string\">&quot;上城区&quot;</span>,<br>  <span class=\"hljs-string\">&quot;西湖区&quot;</span>,<br>  <span class=\"hljs-string\">&quot;文三路&quot;</span>,<br>  <span class=\"hljs-string\">&quot;江苏省&quot;</span>,<br>  <span class=\"hljs-string\">&quot;南京市&quot;</span>,<br>];<br><span class=\"hljs-keyword\">const</span> deselectedNode = <span class=\"hljs-string\">&quot;西湖区&quot;</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">updateTreeData</span>(treeData, selectedPath, deselectedNode)); <span class=\"hljs-comment\">//[ &#x27;浙江省&#x27;, &#x27;杭州市&#x27;, &#x27;上城区&#x27;, &#x27;江苏省&#x27;, &#x27;南京市&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">updateTreeData</span>(<span class=\"hljs-params\">treeData, selectedPath, deselectedNode</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> updatedPath = []; <span class=\"hljs-comment\">// 存储更新后的路径</span><br><br>  <span class=\"hljs-comment\">// 递归函数，用于遍历树</span><br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">traverse</span>(<span class=\"hljs-params\">node, path</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">name</span> === deselectedNode) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (selectedPath.<span class=\"hljs-title function_\">includes</span>(node.<span class=\"hljs-property\">name</span>)) &#123;<br>      path.<span class=\"hljs-title function_\">push</span>(node.<span class=\"hljs-property\">name</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">children</span> &amp;&amp; node.<span class=\"hljs-property\">children</span>.<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span>) &#123;<br>      node.<span class=\"hljs-property\">children</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">child</span>) =&gt;</span> <span class=\"hljs-title function_\">traverse</span>(child, path));<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 遍历每个根节点</span><br>  treeData.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">node</span>) =&gt;</span> <span class=\"hljs-title function_\">traverse</span>(node, updatedPath));<br><br>  <span class=\"hljs-keyword\">return</span> updatedPath;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h4><p>树的题目一般都是遍历，当查询到当前节点的时候，判断是否是取消勾选的节点，如果是就跳出，否则判断该节点是否选中的节点，是就放入结果数组中，同时判断是否有子节点，有的话就递归调用，没有就结束</p>\n"},{"title":"闭包和作用域的理解","date":"2024-11-13T03:52:47.000Z","_content":"\n> 要完全理解闭包，首先要弄明白Javascript中的作用域的机制\n\n\n\n```js\nlet name = '12312313'\n\nfunction outFun(){\n\tlet name = 'test'\n    let age = 12\n    return function innerFun(){\n\t\tconsole.log(name)\n        console.log(age)\n    }\n}\n\nconst demo = outFun()\n\ndemo()\n```\n\n我们以上面的示例代码来讲解一下js中的作用域机制：\n\n首先js引擎拿到这段js代码的时候，我们从第一行往下看\n\n\n\n变量的赋值有 传值和传址的区别，而函数的传参只有按值传递\n\n\n\n","source":"_posts/闭包和作用域的理解.md","raw":"---\ntitle: 闭包和作用域的理解\ndate: 2024-11-13 11:52:47\ntags: JavaScript基础\ncategories: 前端\n---\n\n> 要完全理解闭包，首先要弄明白Javascript中的作用域的机制\n\n\n\n```js\nlet name = '12312313'\n\nfunction outFun(){\n\tlet name = 'test'\n    let age = 12\n    return function innerFun(){\n\t\tconsole.log(name)\n        console.log(age)\n    }\n}\n\nconst demo = outFun()\n\ndemo()\n```\n\n我们以上面的示例代码来讲解一下js中的作用域机制：\n\n首先js引擎拿到这段js代码的时候，我们从第一行往下看\n\n\n\n变量的赋值有 传值和传址的区别，而函数的传参只有按值传递\n\n\n\n","slug":"闭包和作用域的理解","published":1,"updated":"2024-11-17T13:58:10.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxpr003l73t377qd00vo","content":"<blockquote>\n<p>要完全理解闭包，首先要弄明白Javascript中的作用域的机制</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;12312313&#x27;</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">outFun</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;test&#x27;</span><br>    <span class=\"hljs-keyword\">let</span> age = <span class=\"hljs-number\">12</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">innerFun</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(name)<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(age)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> demo = <span class=\"hljs-title function_\">outFun</span>()<br><br><span class=\"hljs-title function_\">demo</span>()<br></code></pre></td></tr></table></figure>\n\n<p>我们以上面的示例代码来讲解一下js中的作用域机制：</p>\n<p>首先js引擎拿到这段js代码的时候，我们从第一行往下看</p>\n<p>变量的赋值有 传值和传址的区别，而函数的传参只有按值传递</p>\n","site":{"data":{}},"wordcount":312,"excerpt":"","more":"<blockquote>\n<p>要完全理解闭包，首先要弄明白Javascript中的作用域的机制</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;12312313&#x27;</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">outFun</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;test&#x27;</span><br>    <span class=\"hljs-keyword\">let</span> age = <span class=\"hljs-number\">12</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">innerFun</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(name)<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(age)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> demo = <span class=\"hljs-title function_\">outFun</span>()<br><br><span class=\"hljs-title function_\">demo</span>()<br></code></pre></td></tr></table></figure>\n\n<p>我们以上面的示例代码来讲解一下js中的作用域机制：</p>\n<p>首先js引擎拿到这段js代码的时候，我们从第一行往下看</p>\n<p>变量的赋值有 传值和传址的区别，而函数的传参只有按值传递</p>\n"},{"title":"面试题汇总","date":"2023-06-14T06:15:03.000Z","index_img":"/img/mianshi.jpg","banner_img":"/img/sass.jpg","_content":"> 如何区分伪元素和伪类\n\n伪元素和伪类最根本的区别就在于是否创造了新的元素\n\n## 伪类\n\n伪类是用来定义元素特殊状态的，他可以用来设置鼠标悬停样式、元素获取焦点样式、设置链接样式等。如常见的 hover、active、link 等都是伪类。\n\n## 伪元素\n\n伪元素也称为伪对象，它不存在于 DOM 文档中、是一个虚拟的元素。它可以用来代表某个元素的子元素，但是这个子元素并不存在于文档树中。\n\n\n\n## BFC\n\n(Block firmatting context) 块级格式化上下文\n\n能够形成独立的渲染区域，内部元素的渲染不会影响外界\n\n形成BFC 的常见条件\n\n> 浮动元素 \n>\n> 绝对定位\n>\n> 块级元素 overfolw 不是 visible\n>\n> flex元素\n>\n> inline-block元素\n\n应用场景：\n\n1.清除浮动，\n\n2.Margin边距重叠，\n\n3.解决当父级元素没有高度时，子级元素浮动会使父级元素高度塌陷的问题等\n\n\n\nQ: `only` 选择器的作用是？\n\n```js\n@media only screen and (max-width: 1024px) {argin: 0;}\n```\n\nA：停止旧版本浏览器解析选择器的其余部分。\n\n\n\nQ: `screen`关键词是指设备物理屏幕的大小还是指浏览器的视窗？\n\n```\n@media only screen and (max-width: 1024px) {margin: 0;}\n```\n\nA: 浏览器视窗\n\n\n\n## href 和 src的区别\n\n**1.请求资源类型不同**\nhref，超文本引用，用于建立文档与资源的联系，常用的有：link、a。\nsrc，将其所指向的资源下载并应用到当前页面，常见的有script、img。\n**2.作用结果不同**\nhref，用于文档与资源之间确立联系。\nsrc，请求到的资源替换当前内容。\n\n**3.浏览器的解析不同**\nhref，将资源解析成css文件，并行加载请求资源，不会阻塞对当前文档的处理。\nsrc，会暂停其他资源的处理，直到该资源加载、解析和执行完毕，将其所指向资源应用到当前内容。这也是为什么把js文件放在底部而不是头部发热原因\n\n\n\n## 首屏加载白屏怎么优化\n\n1.使用CDN减少代码体积，加快请求速度；\n\n2.SSR通过服务端把所有数据全部渲染完成再返回给客户端\n\n3.路由懒加载\n\n4.使用外链CSS，JS文件\n\n5.开机GZIP压缩\n\n6.使用骨架屏\n\n## 输入url到打开页面，都做了什么\n\n1.输入url，查找缓存，浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容，如果没有则进行下一步\n\n2.DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中域名对应的IP地址\n\n3.TCP握手：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接\n\n4.HTTP请求：浏览器发起读取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给服务器；\n\n5.HTTP响应返回数据结果；\n\n6.通过四次挥手关闭/释放TCP连接；\n\n7.浏览器解析数据并渲染页面\n\n\n\n## TCP的三次握手和四次挥手\n\n三次握手是客户端和服务器之间建立连接，并进行通信的过程。相当于客户端和服务器之间你来我往的三个步骤\n\n- 第一次握手是建立连接，客户端发送连接请求报文，并传送规定的数据包；\n- 第二次握手是服务器端包是接收到连接请求报文，并回传规定的数据包\n- 第三次握手是客户端接收到服务器回传的数据包后，再次给服务器端发送数据包\n\n这样就完成了客户端跟服务器的连接和数据传送；\n\n三次握手的目的：\n\n双方确认自己与对方的发送与接收是正常的。\n\n四次挥手表示当前连接请求已经结束，要断开这次连接。\n\n- 第一次挥手是客户端对服务器发起断开请求\n- 第二次挥手是服务器表示收到这次断开请求\n- 第三次挥手是服务器表示已经断开连接；\n- 第四次挥手是客户端已经断开连接\n\n\n\n## 清除浮动的四种办法\n\n1. clear:both; 在最后面加一个盒子\n2. overflow:hidden;  父盒子\n3. 伪元素:after  父盒子\n4. 双伪元素   父盒子\n\n## Vue的生命周期钩子\n\nbeforCreated\n\nCreated\n\nbeforeMounted\n\nMounted\n\nbeforeUpdated\n\nupdated\n\nbeforeDestory\n\ndestoryed\n\nActived\n\nDeactived\n\n## 什么是闭包，闭包解决了什么问题\n\n闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来.\n\n**我们可以用来保存一些内容，还可以用来保护一些私有的变量。我们总结出闭包有两个作用，分别为保护和保存。**\n\n团队开发时，每个开发者把自己的代码放在一个私有的作用域中，防止相互之间的变量命名冲突；把需要提供给别人的方法，通过 return 或 window.xxx 的方式暴露在全局下。\n\n\n\n## 原型链\n\n 总结：   \n\n1、当一个对象查找属性和方法时会从自身查找,如果查找不到则会通过__proto__指向被实例化的构造函数的prototype      \n\n2、隐式原型也是一个对象,是指向我们构造函数的原型      \n\n3、除了最顶层的Object对象没有`__proto__`，其他所有的对象都有__proto__,这是隐式原型 \n\n4、隐式原型__proto__的作用是让对象通过它来一直往上查找属性或方法，直到找到最顶层的Object的__proto__属性，它的值是null,这个查找的过程就是原型链\n\n## 箭头函数和普通函数的区别\n\n```text\n（1）箭头函数比普通函数更加简洁\n    如果没有参数，就直接写一个空括号即可\n    如果只有一个参数，可以省去参数括号\n    如果有多个参数，用逗号分割\n    如果函数体的返回值只有一句，可以省略大括号\n    如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常用的就是调用一个函数：\n    let fn = () => void doesNotReturn()\n    \n (2) 箭头函数没有自己的this\n 箭头函数不会创建自己的this,所以它没有自己的this,它只会在自己作用域的上一层继承this。所以箭头函数中的this的指向在它在定义时一家确定了，之后不会改变。\n \n（3）箭头函数继承来的this指向永远不会改变\n\n (4) call()、apply()、bind()等方法不能改变箭头函数中的this指向 \n \n (5) 箭头函数不能作为构造函数使用\n \n (6) 箭头函数没有自己的arguments\n \n (7) 箭头函数没有prototype\n \n (8) 箭头函数不能用作Generator函数,不能使用yeild关键字\n```\n\n\n\n## localStorage  sessionStorage  cookies 有什么区别?\n\nlocalStorage:以键值对的方式存储 储存时间没有限制 永久生效 除非自己删除记录\nsessionStorage：当页面关闭后被清理与其他相比不能同源窗口共享 是会话级别的存储方式\ncookies 数据不能超过4k 同时因为每次http请求都会携带cookie 所有cookie只适合保存很小的数据 如会话标识\n\n\n\n## Vuex有哪些基本属性?为什么 Vuex 的 mutation 中不能做异步操作?\n\n有五种，分别是 State、 Getter、Mutation 、Action、 Module\n1、state => 基本数据(数据源存放地)\n2、getters => 从基本数据派生出来的数据\n3、mutations => 提交更改数据的方法，同步\n4、actions => 像一个装饰器，包裹mutations，使之可以异步。\n5、modules => 模块化Vuex\n\n1、Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。\n2、每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。\n\n## 常见的水平居中\n\n1. ```css\n\t.father{\n\t\tdisplay:flex;\n\t\tjustify-content:center;\n\t\talign-items:center;\n\t}\n\t\n\t.son{\n\t....\n\t}\n\t```\n\n2. 绝对定位 \n\n\t```css\n\t.father {\n\t    position: relative;\n\t}\n\t.son {\n\t    position: absolute;\n\t    top: 0;\n\t    left: 0;\n\t    bottom: 0;\n\t    right: 0;\n\t    margin: auto;\n\t}\n\t```\n\n3. 绝对定位配合transform\n\n\t```css\n\t.father {\n\t    position: relative;\n\t}\n\t.son {\n\t    position: absolute;\n\t    top: 50%;\n\t    left: 50%;\n\t    transform: translate(-50%, -50%);\n\t}\n\t```\n\n\t\n\n## Js的基本类型和引用类型\n\n基本类型：undefined , string, number, null ,bigint,boolean,symbol\n\n引用类型: Object,function,array\n\ntypeof/instanceof\n\n## TypeScript的 type和 interface 的区别\n\ninterface可以重复声明，type不行，继承方式不一样，type使用交叉类型方式，interface使用extends实现。在对象扩展的情况下，使用接口继承要比交叉类型的性能更好。建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。\n\n```tsx\ninterface iMan {\n  name: string;\n  age: number;\n}\n// 接口可以进行声明合并\ninterface iMan {\n  hobby: string;\n}\n\ntype tMan = {\n  name: string;\n  age: number;\n};\n// type不能重复定义\n// type tMan = {}\n\n// 继承方式不同,接口继承使用extends\ninterface iManPlus extends iMan {\n  height: string;\n}\n// type继承使用&，又称交叉类型\ntype tManPlus = { height: string } & tMan;\n\nconst aMan: iManPlus = {\n  name: \"aa\",\n  age: 15,\n  height: \"175cm\",\n  hobby: \"eat\",\n};\n\nconst bMan: tManPlus = {\n  name: \"bb\",\n  age: 15,\n  height: \"150cm\",\n};\n```\n\n## 常见的工具类型\n\n```text\nPartial：满足部分属性(一个都没满足也可)即可\nRequired：所有属性都需要\nReadonly: 包装后的所有属性只读\n```\n\n\n\n## computed 和 watch 的区别\n\n使用场景：computed适用于一个数据受多个数据影响使用；watch适合一个数据影响多个数据使用。\n\n区别：computed属性默认会走**缓存**，只有依赖数据发生变化，才会重新计算，不支持异步，有异步导致数据发生变化时，无法做出相应改变；watch不依赖缓存，一旦数据发生变化就直接触发响应操作，支持异步。\n\n\n\n## 浏览器渲染页面的过程\n\n首先输入一个网址，浏览器会向服务器发起DNS请求，得到对应的IP地址（会被缓存一段时间，后续访问就不用再去向服务器查询）。之后会进行TCP三次握手与服务器建立连接，连接建立后，浏览器会代表用户发送一个初始的GET请求，通常是请求一个HTML文件。服务器收到对应请求后 ，会根据相关的响应头和HTML内容进行回复。\n\n一旦浏览器拿到了数据，就会开始解析信息，这个过程中，浏览器会根据HTML文件去构建DOM树，当遇到一些阻塞资源时（如同步加载的script标签）会去加载阻塞资源而停止当前DOM树构建（所以能够异步的或延迟加载的就尽量异步或延迟，同时页面的脚本还是越少越好）。在构建DOM树时，浏览器的主线程被占据着，不过浏览器的预加载扫描器会去请求高优先级的资源（如css、js、字体），预加载扫描器很好的优化了阻塞问题。接下来浏览器会处理CSS生成CSSDOM树，将CSS规则转换为可以理解和使用的样式映射，这个过程非常快（通常小于一次DNS查询所需时间）。有了DOM树和CSSDOM树，浏览器会将其组合生成一个Render树，计算样式或渲染树会从DOM的根节点开始构建，遍历每一个可见节点（将相关样式匹配到每一个可见节点，并根据CSS级联去的每个节点的计算样式）。接下来开始布局，该过程（依旧是从根节点开始）会确定所有节点的宽高和位置，最后通过渲染器将其在页面上绘制。绘制完成了，并不代表交互也都生效了，因为主线程可能还无法抽出时间去处理滚动、触摸等交互，要等到js加载完成，同时主线程空闲了整个页面才是正常可用的状态。\n\n\n\n## webpack中plugin和loader分别做什么？它们之间的执行顺序？\n\n- loader：用于将不同类型的文件转换成webpack可以识别的文件（webpack只认识js和json）。\n- plugin：存在于webpack整个生命周期中，是一种基于事件机制工作的模式，可以在webpck打包过程对某些节点做某些定制化处理。同时plugin可以对loader解析过程中做一些处理，协同处理文件。\n- 执行顺序：两者不存在明显的先后顺序，不过webpack在初始化处理时，会优先识别到plugin中的内容。\n\n## webpack常见的优化方案\n\n- 基于esm的tree shaking\n- 对balel设置缓存，缩小babel-loader的处理范围,及精准指定要处理的目录。\n- 压缩资源（mini-css-extract-plugin，compression-webpack-plugin）\n- 配置资源的按需引入（第三方组件库）\n- 配置splitChunks来进行按需加载（根据）\n- 设置CDN优化\n\n## app.use的原理\n\nvue中使用插件的方法\n\n## 左边固定，右边自适应\n\n1. 浮动\n\n\t左边设置固定宽度,向左浮动，右边设置`margin-left:100px;width:auto`\n\n2. BFC+浮动\n\n​\t左边设置固定宽度，向左浮动，右边设置overflow:hidden 触发BFC\n\n3. flex:1(flex-basic:auto,flex-shrink:1,flex-grow:1)\n4. grid布局\n\n​\tgrid-template-columns:100px 1fr; 这样子的话就是右边自适应\n\n5. 绝对定位\n\n​\t左元素设置为绝对定位，left:0,width:100px\n\n​\t右元素设置为left:100\n\n## scoped的执行原理\n\n当一个style标签拥有scoped属性时，它的CSS样式就只能作用于当前的组件，通过该属性，可以使得组件之间的样式不互相污染。\n\nVue中的scoped属性的效果主要是通过PostCss实现的。给一个组件中的所有dom添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom,这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。\n\n```css\n.home{\n\tcolor:red;\n}\n\n-------------\n.home[data-v-e172323]{\n    color:red;\n}\n```\n\n## 样式穿透的原理\n\n普通的css语法: 在要修改的样式前添加 >>> 符号\n\n```css\n.demo >>> .el-table{\n    border: none;\n}\n```\n\nscss语法: 在要修改的样式前添加 ::v-deep\n\n```css\n::v-deep .el-table{\n    border:none;\n}\n```\n\nsass语法/less语法 : 在要修改的样式前添加 /deep/\n\n```swift\n.demo /deep/ .el-table{\n    border:none;\n}\n```\n\n用了样式穿透后，被穿透的dom不会再加上唯一标识[data-v-xxxxxx]\n\n## 水平垂直居中，垂直居中\n\n水平垂直居中： \n\n```css\ntext-align:center;  //只对inline起作用\n\nmargin:0 auto;  //margin:0 auto;是对元素自身(block)起作用，\n\nposition:absoult;\ntop:50%;\nleft:50%;\ntransform:translate(-50%,-50%)\n\ndisplay:flex;\njustify-content:center;\nalign-item:center;\n\ndisplay:grid;\nalign-items: center;\njustify-content: center;\n```\n\n垂直居中\n\n```css\nline-height === height\n\nvertical-align:middle\n\n\n.father{\n    display:flex;\n}\n.son{\n    align-self:center;\n}\n```\n\n\n\n## flex 和 grid的一些属性\n\n看mdn吧，太多了\n\n\n\n## less 和 scss\n\n## css module\n\n## git的一些操作\n\n>  git stash 怎么恢复回来?\n\n1.使用git status指令查看当前文件状态。\n\n2.然后，使用指令git stash 将文件修改缓存。\n\n3.使用git status指令确认当前分支没有修改内容。\n\n4.使用指令git stash list，查看当前缓存列表。\n\n5.使用指令git stash apply stash@{id}，恢复指令ID的缓存内容，并且保留缓存条目。\n\n6.使用git stash pop 恢复最新的stash，同时删除恢复的缓存条目。\n\n\n\n> git reset 和 git revert的区别\n\n\\- git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；\n\\- git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除\n\n## es6 的新特性以及具体内容\n\n1.新增了块级作用域（let，const），TDZ\n\n2.提供了定义类的语法糖（class）\n\n3.新增了一种基本数据类型（Symbol）\n\n4.新增了变量的解构赋值\n\n5.函数参数允许设置默认值，引入了rest参数，新增了箭头函数。\n\n6.数组新增了一些API，如isArray / from / of 方法；数组实例新增了 entries()，keys() 和 values() 等方法。\n\n7.对象和数组新增了扩展运算符\n\n8.ES6新增了模块化（import / export）\n\n9.ES6新增了Set和Map数据结构。\n\n10.ES6原生提供Proxy构造函数，用来生成Proxy实例\n\n11.ES6新增了生成器（Generator）和遍历器（Iterator）\n\n12.模板字符串\n\n13.promise\n\n## promise.all() 和 promise.race()\n\npromise.all()返回的结果由所有的结果而定，如果返回中有一个失败，那就是失败的，如果全部成功就是成功的\n\npromise.race()返回的结果由最先返回的那个promise来决定，第一个返回的是失败就是失败\n\n## rem 和 em 的区别\n\n- px是固定的单位长度，一旦设置了就无法随页面的大小而适应改变。\n- em是相对长度单位，比px更具灵活性，em的长度是相对于父元素\n- rem的长度是相对于根元素，也就是html的字体大小\n\n## 怎么新建set的集合\n\n直接 new Set() 会直接报错\n\nSet 函数可以接受一个数组（或类似数组的对象）作为参数，用来进行数据初始化。\n\nlet i = new Set([1,2])\n\n操作方法:\nadd(value)　　　　添加数据，并返回新的 Set 结构\ndelete(value)　　　删除数据，返回一个布尔值，表示是否删除成功\nhas(value)　　　　查看是否存在某个数据，返回一个布尔值\nclear()　　　　　　清除所有数据，没有返回值\n\n\n\n**遍历方法:**\n\nSet 提供了三个遍历器生成函数和一个遍历方法。\nkeys()　　　　 返回一个键名的遍历器\nvalues()　　　 返回一个键值的遍历器\nentries()　　　 返回一个键值对的遍历器\nforEach()　　　使用回调函数遍历每个成员\n\n\n\n## js实现栈\n\n```js\n//stack 栈  数组就是一个很完美的栈结构\n//functions: pop,push,peek,length\n\nlet stack = function () {\n    this.count = 0;\n    this.storage = {};\n\n    //给栈中添加一个元素 push\n    this.push = function (value) {\n        this.storage[this.count] = value;\n        this.count++;\n    }\n\n    //给栈中移除一个元素 pop\n    this.pop = function (value) {\n        if (this.count === 0) {\n            return undefined;\n        }\n\n        this.count--;\n        let result = this.storage[this.count]\n        delete this.storage[this.count]\n\n        return result\n    }\n\n    //栈的大小\n    this.length = function () {\n        return this.count;\n    }\n\n    //返回栈顶的元素\n    this.peek = function () {\n        return this.storage[this.count-1]\n    }\n}\n\n\nlet myStack = new stack();\n\nmyStack.push(1)\nmyStack.push(2)\nmyStack.push(3)\n\nconsole.log(myStack);   //  storage: { '0': 1, '1': 2, '2': 3 },\n\nconsole.log(myStack.peek());   //3\nconsole.log(myStack.pop());     //3\nconsole.log(myStack.length());    //2\n```\n\n## for of 和 for in 的区别\n\nfor in  可以用在数组吗？\n\n是可以的，因为for...in（值） 本身是对象的遍历方法，数组也属于对象，但是最好不用，数组的遍历可以用 for..of（索引） , for Each\n\n理由如下：\n\n1. for...in 的属性值是字符串，可以会导致错误\n2. for...in 遍历的是可迭代对象，原型上的属性也可能会被遍历到\n3. for...in  不是按照数组下标顺序来遍历的，是按照对象属性的枚举属性\n\n## 中序遍历二叉树\n\n## 数组去重的几种办法\n\n1. Array.from(new Set(arr))\n2. 双重for循环\n\n```js\nfor(let i = 0; i<len;i++){\n    for(let j = i+1;j<len;j++){\n\t\tif(arr[i] === arr[j]){\n\t\t\tarr.splice(j,1)//删除第二个\n        }\n    }\n}\n```\n\n3.利用indexOf\n\n```js\nfunction methods3(arr) {\n\n    if (!Array.isArray(arr)) {\n\n        return;\n\n    }\n\n    var array = [];\n\n    for (var i = 0; i < arr.length; i++) {\n\n        if (array .indexOf(arr[i]) === -1) {\n\n            array .push(arr[i])\n\n        }\n\n    }\n\n    return array;\n\n}\n```\n\n4.利用sort排序，看看左右两个是否一样\n\n```js\nfunction methods4(arr) {\n\n    if (!Array.isArray(arr)) {\n\n        return;\n\n    }\n\n    arr = arr.sort()\n\n    var arrry= [arr[0]];\n\n    for (var i = 1; i < arr.length; i++) {\n\n        if (arr[i] !== arr[i-1]) {\n\n            arrry.push(arr[i]);\n\n        }\n\n    }\n\n    return arrry;\n\n}\n```\n\n5.利用includes\n\n```js\nfunction methods6(arr) {\n\n    if (!Array.isArray(arr)) {\n\n        return\n\n    }\n\n    var array =[];\n\n    for(var i = 0; i < arr.length; i++) {\n\n            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值\n\n                    array.push(arr[i]);\n\n              }\n\n    }\n\n    return array\n\n}\n```\n\n6.利用Map，递归，filter\n\n```js\nfunction methods10(arr) {\n\n    let map = new Map();\n\n    let array = new Array();// 数组用于返回结果\n\n    for (let i = 0; i < arr.length; i++) {\n\n      if(map .has(arr[i])) {// 如果有该key值\n\n        map .set(arr[i], true); \n\n      } else { \n\n        map .set(arr[i], false);// 如果没有该key值\n\n        array .push(arr[i]);\n\n      }\n\n    } \n\n    return array ;\n\n  }\n```\n\n7.利用reduce\n\n```js\nlet arr = [1, 2, 6, 2, 1];\nlet filterArr = arr.reduce((pre, cur, index, array) => {\n  if (pre.includes(cur) === false) {\n      pre = [...pre, cur];\n  }\n  return pre;\n}, [])\nconsole.log(filterArr); // [1,2,6]\n```\n\n\n\n## forEach 和 Map的区别\n\nmap有返回值，forEach没有，都不可以改变原数组，除非你在callback里面改（giao,为什么要问这种问题）\n\n## 自定义一个v-model\n\nv-model是vue中的一个语法糖，实现数据的双向绑定\n\n```vue\n<input\n    :value=\"parentData\"\n    @input=\"parentData = $event.target.value\"\n>\n```\n\n\n\n## vueRouter传参数的几种办法\n\n#### 一.router-link路由导航方式传参\n\n```js\n//路由配置   {path:'/father/son/:num',name:A,component:A}\n<router-link to=\"/path/num\"></router-link>\n//子组件通过  this.$route.params.num 接受参数\n```\n\n#### 二、调用$router.push实现路由传参\n\n```js\n//路由配置： {path: '/d/:id', name: D, component: D}\nthis.$router.push({\n\tpath:'/d/:id'\n})\n\n//子组件通过  this.$route.params.id  接受参数\n```\n\n#### 三.通过路由属性name匹配路由，再根据params传递参数\n\n```js\n//路由配置： {name:\"B\",path:'/asdsdasd/asdd',component:B} 无所谓path，但是name一定要对应\nthis.$router.push({\n        name: 'B',\n        params: {\n          context: '吴又可吴又可吴又可'\n        }\n      })\n```\n\n#### 四.通过query传参数\n\n```js\n// 路由配置  {path: '/c', name: 'C', component: C}\nthis.$router.push({\n        path: '/c',\n        query: {\n          context: '吴又可吴又可'\n        }\n      })\n```\n\n\n\n## v-router的query和params的区别\n\n## webpack配置\n\n## 数组的一些方法\n\n`join` 连接数组变成字符串,不会改变原数组\n\n```js\nlet arr = [1,2,3,4];\n\nconsole.log(arr.join('-'))  //\"1-2-3-4\"\n```\n\n`split` 将字符串拆分为数组\n\n```js\nconst S = arr.join('-')\narr.split(s)  //['1','2','3','4']\n```\n\n`slice`使用 `slice` 方法从数组中截取部分元素组合成新数组（并不会改变原数组），不传第二个参数时截取到数组的最后元素。\n\n```js\narr.slice(0,3) //[1,2,3]\n```\n\n`splice` 使用`splice` 方法可以添加、删除、替换数组中的元素，会对原数组进行改变，返回值为删除的元素。\n\n删除数组元素第一个参数为从哪开始删除，第二个参数为删除的数量。\n\n```js\nlet arr = [0, 1, 2, 3, 4, 5, 6];\nconsole.log(arr.splice(1, 3)); //返回删除的元素 [1, 2, 3]\nconsole.log(arr); //删除数据后的原数组 [0, 4, 5, 6]\n```\n\n`concat`方法用于连接两个或多个数组，元素是值类型的是复制操作，如果是引用类型还是指向同一对象\n\n```js\narr1 = [1,2]\narr2 = [3,4]\n\nconsole.log(arr.concat(arr1,arr2))\n```\n\n使用 `indexOf` (`lastIndexOf`)从前向后(从后向前)查找元素出现的位置，如果找不到返回 `-1`。\n\n```js\nlet arr = [7, 3, 2, 8, 2, 6];\nconsole.log(arr.indexOf(2)); // 2 从前面查找2出现的位置\n```\n\n使用 `includes` 查找字符串返回值是布尔类型更方便判断\n\n使用`includes`等不能查找引用类型，因为它们的内存地址是不相等的\n\nfind 方法找到后会把值返回出来\n\n- 如果找不到返回值为`undefined`\n\n返回第一次找到的值，不继续查找\n\n### sort\n\n`sort`每次使用两个值进行比较 `Array.sort((a,b)=>a-b`\n\n- 返回负数 a 排在 b 前面，从小到大\n- 返回正数 b 排在 a 前面\n- 返回 0 时不动\n\n原理：\n\n```js\nlet arr = [1, 5, 3, 9, 7];\nfunction sort(array, callback) {\n  for (const n in array) {\n    for (const m in array) {\n      if (callback(array[n], array[m]) < 0) {\n        let temp = array[n];\n        array[n] = array[m];\n        array[m] = temp;\n      }\n    }\n  }\n  return array;\n}\narr = sort(arr, function(a, b) {\n  return a - b;\n});\n```\n\n### 数组遍历\n\nfor循环\n\nforEach\n\n`forEach`使函数作用在每个数组元素上，但是没有返回值。\n\nfor...in...\n\n遍历时的 key 值为数组的索引\n\nfor...of....\n\n遍历时的 key 值为数组的值\n\nmap\n\n**`map()`** 方法**创建一个新数组**，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。\n\n**语法**\n\n```js\nmap(callbackFn)\nmap(callbackFn, thisArg)\t\n```\n\n### [在非数组对象上调用 map()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#在非数组对象上调用_map)\n\n`map()` 方法读取 `this` 的 `length` 属性，然后访问每个整数索引。\n\n```js\nconst arrayLike = {\n  length: 3,\n  0: 2,\n  1: 3,\n  2: 4,\n};\nconsole.log(Array.prototype.map.call(arrayLike, (x) => x ** 2));\n// [ 4, 9, 16 ]\n\n```\n\n[reduce](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n\n`reduce()` 方法是一个[迭代方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#迭代方法)。它按升序对数组中的所有元素运行一个“reducer”回调函数，并将它们累积到一个单一的值中。每次调用时，`callbackFn` 的返回值都作为 `accumulator` 参数传递到下一次调用中。`accumulator` 的最终值（也就是在数组的最后一次迭代中从 `callbackFn` 返回的值）将作为 `reduce()` 的返回值。\n\n```js\n//每一次callbackFn返回的数据都会记录，并用于下次计算\narr = [1,2,3,4]\n\narr.reduce((accumulator,currentValue,currentIndex)=>{\n\tconsole.log(accumulator,currentValue,currentIndex)\n    return accumulator+currentValue\n})\n```\n\n### 展开嵌套数组\n\n```js\nconst flattened = [\n  [0, 1],\n  [2, 3],\n  [4, 5],\n].reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n// flattened 的值是 [0, 1, 2, 3, 4, 5]\n\n```\n\n### 统计对象中值出现的次数\n\n```js\nconst names = [\"Alice\", \"Bob\", \"Tiff\", \"Bruce\", \"Alice\"];\n\nconst countedNames = names.reduce((allNames, name) => {\n  const currCount = allNames[name] ?? 0;\n  return {\n    ...allNames,\n    [name]: currCount + 1,\n  };\n}, {});\n// countedNames 的值是：\n// { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }\n\n```\n\n## VueRouter的钩子函数\n\n1. 全局的beforeEach（前置路由守卫）:进入页面登录判断、管理员权限判断、浏览器判断\n\nbeforeEach(to,from,next)\n\nafterEach（后置路由守卫）\n\n2. 单个组件的 beforeEnter\n3. 组件内的 beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave","source":"_posts/面试题汇总.md","raw":"---\ntitle: 面试题汇总\ndate: 2023-06-14 14:15:03\ntags: 面试\ncategories: 前端\nindex_img: /img/mianshi.jpg\nbanner_img: /img/sass.jpg\n---\n> 如何区分伪元素和伪类\n\n伪元素和伪类最根本的区别就在于是否创造了新的元素\n\n## 伪类\n\n伪类是用来定义元素特殊状态的，他可以用来设置鼠标悬停样式、元素获取焦点样式、设置链接样式等。如常见的 hover、active、link 等都是伪类。\n\n## 伪元素\n\n伪元素也称为伪对象，它不存在于 DOM 文档中、是一个虚拟的元素。它可以用来代表某个元素的子元素，但是这个子元素并不存在于文档树中。\n\n\n\n## BFC\n\n(Block firmatting context) 块级格式化上下文\n\n能够形成独立的渲染区域，内部元素的渲染不会影响外界\n\n形成BFC 的常见条件\n\n> 浮动元素 \n>\n> 绝对定位\n>\n> 块级元素 overfolw 不是 visible\n>\n> flex元素\n>\n> inline-block元素\n\n应用场景：\n\n1.清除浮动，\n\n2.Margin边距重叠，\n\n3.解决当父级元素没有高度时，子级元素浮动会使父级元素高度塌陷的问题等\n\n\n\nQ: `only` 选择器的作用是？\n\n```js\n@media only screen and (max-width: 1024px) {argin: 0;}\n```\n\nA：停止旧版本浏览器解析选择器的其余部分。\n\n\n\nQ: `screen`关键词是指设备物理屏幕的大小还是指浏览器的视窗？\n\n```\n@media only screen and (max-width: 1024px) {margin: 0;}\n```\n\nA: 浏览器视窗\n\n\n\n## href 和 src的区别\n\n**1.请求资源类型不同**\nhref，超文本引用，用于建立文档与资源的联系，常用的有：link、a。\nsrc，将其所指向的资源下载并应用到当前页面，常见的有script、img。\n**2.作用结果不同**\nhref，用于文档与资源之间确立联系。\nsrc，请求到的资源替换当前内容。\n\n**3.浏览器的解析不同**\nhref，将资源解析成css文件，并行加载请求资源，不会阻塞对当前文档的处理。\nsrc，会暂停其他资源的处理，直到该资源加载、解析和执行完毕，将其所指向资源应用到当前内容。这也是为什么把js文件放在底部而不是头部发热原因\n\n\n\n## 首屏加载白屏怎么优化\n\n1.使用CDN减少代码体积，加快请求速度；\n\n2.SSR通过服务端把所有数据全部渲染完成再返回给客户端\n\n3.路由懒加载\n\n4.使用外链CSS，JS文件\n\n5.开机GZIP压缩\n\n6.使用骨架屏\n\n## 输入url到打开页面，都做了什么\n\n1.输入url，查找缓存，浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容，如果没有则进行下一步\n\n2.DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中域名对应的IP地址\n\n3.TCP握手：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接\n\n4.HTTP请求：浏览器发起读取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给服务器；\n\n5.HTTP响应返回数据结果；\n\n6.通过四次挥手关闭/释放TCP连接；\n\n7.浏览器解析数据并渲染页面\n\n\n\n## TCP的三次握手和四次挥手\n\n三次握手是客户端和服务器之间建立连接，并进行通信的过程。相当于客户端和服务器之间你来我往的三个步骤\n\n- 第一次握手是建立连接，客户端发送连接请求报文，并传送规定的数据包；\n- 第二次握手是服务器端包是接收到连接请求报文，并回传规定的数据包\n- 第三次握手是客户端接收到服务器回传的数据包后，再次给服务器端发送数据包\n\n这样就完成了客户端跟服务器的连接和数据传送；\n\n三次握手的目的：\n\n双方确认自己与对方的发送与接收是正常的。\n\n四次挥手表示当前连接请求已经结束，要断开这次连接。\n\n- 第一次挥手是客户端对服务器发起断开请求\n- 第二次挥手是服务器表示收到这次断开请求\n- 第三次挥手是服务器表示已经断开连接；\n- 第四次挥手是客户端已经断开连接\n\n\n\n## 清除浮动的四种办法\n\n1. clear:both; 在最后面加一个盒子\n2. overflow:hidden;  父盒子\n3. 伪元素:after  父盒子\n4. 双伪元素   父盒子\n\n## Vue的生命周期钩子\n\nbeforCreated\n\nCreated\n\nbeforeMounted\n\nMounted\n\nbeforeUpdated\n\nupdated\n\nbeforeDestory\n\ndestoryed\n\nActived\n\nDeactived\n\n## 什么是闭包，闭包解决了什么问题\n\n闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来.\n\n**我们可以用来保存一些内容，还可以用来保护一些私有的变量。我们总结出闭包有两个作用，分别为保护和保存。**\n\n团队开发时，每个开发者把自己的代码放在一个私有的作用域中，防止相互之间的变量命名冲突；把需要提供给别人的方法，通过 return 或 window.xxx 的方式暴露在全局下。\n\n\n\n## 原型链\n\n 总结：   \n\n1、当一个对象查找属性和方法时会从自身查找,如果查找不到则会通过__proto__指向被实例化的构造函数的prototype      \n\n2、隐式原型也是一个对象,是指向我们构造函数的原型      \n\n3、除了最顶层的Object对象没有`__proto__`，其他所有的对象都有__proto__,这是隐式原型 \n\n4、隐式原型__proto__的作用是让对象通过它来一直往上查找属性或方法，直到找到最顶层的Object的__proto__属性，它的值是null,这个查找的过程就是原型链\n\n## 箭头函数和普通函数的区别\n\n```text\n（1）箭头函数比普通函数更加简洁\n    如果没有参数，就直接写一个空括号即可\n    如果只有一个参数，可以省去参数括号\n    如果有多个参数，用逗号分割\n    如果函数体的返回值只有一句，可以省略大括号\n    如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常用的就是调用一个函数：\n    let fn = () => void doesNotReturn()\n    \n (2) 箭头函数没有自己的this\n 箭头函数不会创建自己的this,所以它没有自己的this,它只会在自己作用域的上一层继承this。所以箭头函数中的this的指向在它在定义时一家确定了，之后不会改变。\n \n（3）箭头函数继承来的this指向永远不会改变\n\n (4) call()、apply()、bind()等方法不能改变箭头函数中的this指向 \n \n (5) 箭头函数不能作为构造函数使用\n \n (6) 箭头函数没有自己的arguments\n \n (7) 箭头函数没有prototype\n \n (8) 箭头函数不能用作Generator函数,不能使用yeild关键字\n```\n\n\n\n## localStorage  sessionStorage  cookies 有什么区别?\n\nlocalStorage:以键值对的方式存储 储存时间没有限制 永久生效 除非自己删除记录\nsessionStorage：当页面关闭后被清理与其他相比不能同源窗口共享 是会话级别的存储方式\ncookies 数据不能超过4k 同时因为每次http请求都会携带cookie 所有cookie只适合保存很小的数据 如会话标识\n\n\n\n## Vuex有哪些基本属性?为什么 Vuex 的 mutation 中不能做异步操作?\n\n有五种，分别是 State、 Getter、Mutation 、Action、 Module\n1、state => 基本数据(数据源存放地)\n2、getters => 从基本数据派生出来的数据\n3、mutations => 提交更改数据的方法，同步\n4、actions => 像一个装饰器，包裹mutations，使之可以异步。\n5、modules => 模块化Vuex\n\n1、Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。\n2、每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。\n\n## 常见的水平居中\n\n1. ```css\n\t.father{\n\t\tdisplay:flex;\n\t\tjustify-content:center;\n\t\talign-items:center;\n\t}\n\t\n\t.son{\n\t....\n\t}\n\t```\n\n2. 绝对定位 \n\n\t```css\n\t.father {\n\t    position: relative;\n\t}\n\t.son {\n\t    position: absolute;\n\t    top: 0;\n\t    left: 0;\n\t    bottom: 0;\n\t    right: 0;\n\t    margin: auto;\n\t}\n\t```\n\n3. 绝对定位配合transform\n\n\t```css\n\t.father {\n\t    position: relative;\n\t}\n\t.son {\n\t    position: absolute;\n\t    top: 50%;\n\t    left: 50%;\n\t    transform: translate(-50%, -50%);\n\t}\n\t```\n\n\t\n\n## Js的基本类型和引用类型\n\n基本类型：undefined , string, number, null ,bigint,boolean,symbol\n\n引用类型: Object,function,array\n\ntypeof/instanceof\n\n## TypeScript的 type和 interface 的区别\n\ninterface可以重复声明，type不行，继承方式不一样，type使用交叉类型方式，interface使用extends实现。在对象扩展的情况下，使用接口继承要比交叉类型的性能更好。建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。\n\n```tsx\ninterface iMan {\n  name: string;\n  age: number;\n}\n// 接口可以进行声明合并\ninterface iMan {\n  hobby: string;\n}\n\ntype tMan = {\n  name: string;\n  age: number;\n};\n// type不能重复定义\n// type tMan = {}\n\n// 继承方式不同,接口继承使用extends\ninterface iManPlus extends iMan {\n  height: string;\n}\n// type继承使用&，又称交叉类型\ntype tManPlus = { height: string } & tMan;\n\nconst aMan: iManPlus = {\n  name: \"aa\",\n  age: 15,\n  height: \"175cm\",\n  hobby: \"eat\",\n};\n\nconst bMan: tManPlus = {\n  name: \"bb\",\n  age: 15,\n  height: \"150cm\",\n};\n```\n\n## 常见的工具类型\n\n```text\nPartial：满足部分属性(一个都没满足也可)即可\nRequired：所有属性都需要\nReadonly: 包装后的所有属性只读\n```\n\n\n\n## computed 和 watch 的区别\n\n使用场景：computed适用于一个数据受多个数据影响使用；watch适合一个数据影响多个数据使用。\n\n区别：computed属性默认会走**缓存**，只有依赖数据发生变化，才会重新计算，不支持异步，有异步导致数据发生变化时，无法做出相应改变；watch不依赖缓存，一旦数据发生变化就直接触发响应操作，支持异步。\n\n\n\n## 浏览器渲染页面的过程\n\n首先输入一个网址，浏览器会向服务器发起DNS请求，得到对应的IP地址（会被缓存一段时间，后续访问就不用再去向服务器查询）。之后会进行TCP三次握手与服务器建立连接，连接建立后，浏览器会代表用户发送一个初始的GET请求，通常是请求一个HTML文件。服务器收到对应请求后 ，会根据相关的响应头和HTML内容进行回复。\n\n一旦浏览器拿到了数据，就会开始解析信息，这个过程中，浏览器会根据HTML文件去构建DOM树，当遇到一些阻塞资源时（如同步加载的script标签）会去加载阻塞资源而停止当前DOM树构建（所以能够异步的或延迟加载的就尽量异步或延迟，同时页面的脚本还是越少越好）。在构建DOM树时，浏览器的主线程被占据着，不过浏览器的预加载扫描器会去请求高优先级的资源（如css、js、字体），预加载扫描器很好的优化了阻塞问题。接下来浏览器会处理CSS生成CSSDOM树，将CSS规则转换为可以理解和使用的样式映射，这个过程非常快（通常小于一次DNS查询所需时间）。有了DOM树和CSSDOM树，浏览器会将其组合生成一个Render树，计算样式或渲染树会从DOM的根节点开始构建，遍历每一个可见节点（将相关样式匹配到每一个可见节点，并根据CSS级联去的每个节点的计算样式）。接下来开始布局，该过程（依旧是从根节点开始）会确定所有节点的宽高和位置，最后通过渲染器将其在页面上绘制。绘制完成了，并不代表交互也都生效了，因为主线程可能还无法抽出时间去处理滚动、触摸等交互，要等到js加载完成，同时主线程空闲了整个页面才是正常可用的状态。\n\n\n\n## webpack中plugin和loader分别做什么？它们之间的执行顺序？\n\n- loader：用于将不同类型的文件转换成webpack可以识别的文件（webpack只认识js和json）。\n- plugin：存在于webpack整个生命周期中，是一种基于事件机制工作的模式，可以在webpck打包过程对某些节点做某些定制化处理。同时plugin可以对loader解析过程中做一些处理，协同处理文件。\n- 执行顺序：两者不存在明显的先后顺序，不过webpack在初始化处理时，会优先识别到plugin中的内容。\n\n## webpack常见的优化方案\n\n- 基于esm的tree shaking\n- 对balel设置缓存，缩小babel-loader的处理范围,及精准指定要处理的目录。\n- 压缩资源（mini-css-extract-plugin，compression-webpack-plugin）\n- 配置资源的按需引入（第三方组件库）\n- 配置splitChunks来进行按需加载（根据）\n- 设置CDN优化\n\n## app.use的原理\n\nvue中使用插件的方法\n\n## 左边固定，右边自适应\n\n1. 浮动\n\n\t左边设置固定宽度,向左浮动，右边设置`margin-left:100px;width:auto`\n\n2. BFC+浮动\n\n​\t左边设置固定宽度，向左浮动，右边设置overflow:hidden 触发BFC\n\n3. flex:1(flex-basic:auto,flex-shrink:1,flex-grow:1)\n4. grid布局\n\n​\tgrid-template-columns:100px 1fr; 这样子的话就是右边自适应\n\n5. 绝对定位\n\n​\t左元素设置为绝对定位，left:0,width:100px\n\n​\t右元素设置为left:100\n\n## scoped的执行原理\n\n当一个style标签拥有scoped属性时，它的CSS样式就只能作用于当前的组件，通过该属性，可以使得组件之间的样式不互相污染。\n\nVue中的scoped属性的效果主要是通过PostCss实现的。给一个组件中的所有dom添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom,这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。\n\n```css\n.home{\n\tcolor:red;\n}\n\n-------------\n.home[data-v-e172323]{\n    color:red;\n}\n```\n\n## 样式穿透的原理\n\n普通的css语法: 在要修改的样式前添加 >>> 符号\n\n```css\n.demo >>> .el-table{\n    border: none;\n}\n```\n\nscss语法: 在要修改的样式前添加 ::v-deep\n\n```css\n::v-deep .el-table{\n    border:none;\n}\n```\n\nsass语法/less语法 : 在要修改的样式前添加 /deep/\n\n```swift\n.demo /deep/ .el-table{\n    border:none;\n}\n```\n\n用了样式穿透后，被穿透的dom不会再加上唯一标识[data-v-xxxxxx]\n\n## 水平垂直居中，垂直居中\n\n水平垂直居中： \n\n```css\ntext-align:center;  //只对inline起作用\n\nmargin:0 auto;  //margin:0 auto;是对元素自身(block)起作用，\n\nposition:absoult;\ntop:50%;\nleft:50%;\ntransform:translate(-50%,-50%)\n\ndisplay:flex;\njustify-content:center;\nalign-item:center;\n\ndisplay:grid;\nalign-items: center;\njustify-content: center;\n```\n\n垂直居中\n\n```css\nline-height === height\n\nvertical-align:middle\n\n\n.father{\n    display:flex;\n}\n.son{\n    align-self:center;\n}\n```\n\n\n\n## flex 和 grid的一些属性\n\n看mdn吧，太多了\n\n\n\n## less 和 scss\n\n## css module\n\n## git的一些操作\n\n>  git stash 怎么恢复回来?\n\n1.使用git status指令查看当前文件状态。\n\n2.然后，使用指令git stash 将文件修改缓存。\n\n3.使用git status指令确认当前分支没有修改内容。\n\n4.使用指令git stash list，查看当前缓存列表。\n\n5.使用指令git stash apply stash@{id}，恢复指令ID的缓存内容，并且保留缓存条目。\n\n6.使用git stash pop 恢复最新的stash，同时删除恢复的缓存条目。\n\n\n\n> git reset 和 git revert的区别\n\n\\- git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；\n\\- git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除\n\n## es6 的新特性以及具体内容\n\n1.新增了块级作用域（let，const），TDZ\n\n2.提供了定义类的语法糖（class）\n\n3.新增了一种基本数据类型（Symbol）\n\n4.新增了变量的解构赋值\n\n5.函数参数允许设置默认值，引入了rest参数，新增了箭头函数。\n\n6.数组新增了一些API，如isArray / from / of 方法；数组实例新增了 entries()，keys() 和 values() 等方法。\n\n7.对象和数组新增了扩展运算符\n\n8.ES6新增了模块化（import / export）\n\n9.ES6新增了Set和Map数据结构。\n\n10.ES6原生提供Proxy构造函数，用来生成Proxy实例\n\n11.ES6新增了生成器（Generator）和遍历器（Iterator）\n\n12.模板字符串\n\n13.promise\n\n## promise.all() 和 promise.race()\n\npromise.all()返回的结果由所有的结果而定，如果返回中有一个失败，那就是失败的，如果全部成功就是成功的\n\npromise.race()返回的结果由最先返回的那个promise来决定，第一个返回的是失败就是失败\n\n## rem 和 em 的区别\n\n- px是固定的单位长度，一旦设置了就无法随页面的大小而适应改变。\n- em是相对长度单位，比px更具灵活性，em的长度是相对于父元素\n- rem的长度是相对于根元素，也就是html的字体大小\n\n## 怎么新建set的集合\n\n直接 new Set() 会直接报错\n\nSet 函数可以接受一个数组（或类似数组的对象）作为参数，用来进行数据初始化。\n\nlet i = new Set([1,2])\n\n操作方法:\nadd(value)　　　　添加数据，并返回新的 Set 结构\ndelete(value)　　　删除数据，返回一个布尔值，表示是否删除成功\nhas(value)　　　　查看是否存在某个数据，返回一个布尔值\nclear()　　　　　　清除所有数据，没有返回值\n\n\n\n**遍历方法:**\n\nSet 提供了三个遍历器生成函数和一个遍历方法。\nkeys()　　　　 返回一个键名的遍历器\nvalues()　　　 返回一个键值的遍历器\nentries()　　　 返回一个键值对的遍历器\nforEach()　　　使用回调函数遍历每个成员\n\n\n\n## js实现栈\n\n```js\n//stack 栈  数组就是一个很完美的栈结构\n//functions: pop,push,peek,length\n\nlet stack = function () {\n    this.count = 0;\n    this.storage = {};\n\n    //给栈中添加一个元素 push\n    this.push = function (value) {\n        this.storage[this.count] = value;\n        this.count++;\n    }\n\n    //给栈中移除一个元素 pop\n    this.pop = function (value) {\n        if (this.count === 0) {\n            return undefined;\n        }\n\n        this.count--;\n        let result = this.storage[this.count]\n        delete this.storage[this.count]\n\n        return result\n    }\n\n    //栈的大小\n    this.length = function () {\n        return this.count;\n    }\n\n    //返回栈顶的元素\n    this.peek = function () {\n        return this.storage[this.count-1]\n    }\n}\n\n\nlet myStack = new stack();\n\nmyStack.push(1)\nmyStack.push(2)\nmyStack.push(3)\n\nconsole.log(myStack);   //  storage: { '0': 1, '1': 2, '2': 3 },\n\nconsole.log(myStack.peek());   //3\nconsole.log(myStack.pop());     //3\nconsole.log(myStack.length());    //2\n```\n\n## for of 和 for in 的区别\n\nfor in  可以用在数组吗？\n\n是可以的，因为for...in（值） 本身是对象的遍历方法，数组也属于对象，但是最好不用，数组的遍历可以用 for..of（索引） , for Each\n\n理由如下：\n\n1. for...in 的属性值是字符串，可以会导致错误\n2. for...in 遍历的是可迭代对象，原型上的属性也可能会被遍历到\n3. for...in  不是按照数组下标顺序来遍历的，是按照对象属性的枚举属性\n\n## 中序遍历二叉树\n\n## 数组去重的几种办法\n\n1. Array.from(new Set(arr))\n2. 双重for循环\n\n```js\nfor(let i = 0; i<len;i++){\n    for(let j = i+1;j<len;j++){\n\t\tif(arr[i] === arr[j]){\n\t\t\tarr.splice(j,1)//删除第二个\n        }\n    }\n}\n```\n\n3.利用indexOf\n\n```js\nfunction methods3(arr) {\n\n    if (!Array.isArray(arr)) {\n\n        return;\n\n    }\n\n    var array = [];\n\n    for (var i = 0; i < arr.length; i++) {\n\n        if (array .indexOf(arr[i]) === -1) {\n\n            array .push(arr[i])\n\n        }\n\n    }\n\n    return array;\n\n}\n```\n\n4.利用sort排序，看看左右两个是否一样\n\n```js\nfunction methods4(arr) {\n\n    if (!Array.isArray(arr)) {\n\n        return;\n\n    }\n\n    arr = arr.sort()\n\n    var arrry= [arr[0]];\n\n    for (var i = 1; i < arr.length; i++) {\n\n        if (arr[i] !== arr[i-1]) {\n\n            arrry.push(arr[i]);\n\n        }\n\n    }\n\n    return arrry;\n\n}\n```\n\n5.利用includes\n\n```js\nfunction methods6(arr) {\n\n    if (!Array.isArray(arr)) {\n\n        return\n\n    }\n\n    var array =[];\n\n    for(var i = 0; i < arr.length; i++) {\n\n            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值\n\n                    array.push(arr[i]);\n\n              }\n\n    }\n\n    return array\n\n}\n```\n\n6.利用Map，递归，filter\n\n```js\nfunction methods10(arr) {\n\n    let map = new Map();\n\n    let array = new Array();// 数组用于返回结果\n\n    for (let i = 0; i < arr.length; i++) {\n\n      if(map .has(arr[i])) {// 如果有该key值\n\n        map .set(arr[i], true); \n\n      } else { \n\n        map .set(arr[i], false);// 如果没有该key值\n\n        array .push(arr[i]);\n\n      }\n\n    } \n\n    return array ;\n\n  }\n```\n\n7.利用reduce\n\n```js\nlet arr = [1, 2, 6, 2, 1];\nlet filterArr = arr.reduce((pre, cur, index, array) => {\n  if (pre.includes(cur) === false) {\n      pre = [...pre, cur];\n  }\n  return pre;\n}, [])\nconsole.log(filterArr); // [1,2,6]\n```\n\n\n\n## forEach 和 Map的区别\n\nmap有返回值，forEach没有，都不可以改变原数组，除非你在callback里面改（giao,为什么要问这种问题）\n\n## 自定义一个v-model\n\nv-model是vue中的一个语法糖，实现数据的双向绑定\n\n```vue\n<input\n    :value=\"parentData\"\n    @input=\"parentData = $event.target.value\"\n>\n```\n\n\n\n## vueRouter传参数的几种办法\n\n#### 一.router-link路由导航方式传参\n\n```js\n//路由配置   {path:'/father/son/:num',name:A,component:A}\n<router-link to=\"/path/num\"></router-link>\n//子组件通过  this.$route.params.num 接受参数\n```\n\n#### 二、调用$router.push实现路由传参\n\n```js\n//路由配置： {path: '/d/:id', name: D, component: D}\nthis.$router.push({\n\tpath:'/d/:id'\n})\n\n//子组件通过  this.$route.params.id  接受参数\n```\n\n#### 三.通过路由属性name匹配路由，再根据params传递参数\n\n```js\n//路由配置： {name:\"B\",path:'/asdsdasd/asdd',component:B} 无所谓path，但是name一定要对应\nthis.$router.push({\n        name: 'B',\n        params: {\n          context: '吴又可吴又可吴又可'\n        }\n      })\n```\n\n#### 四.通过query传参数\n\n```js\n// 路由配置  {path: '/c', name: 'C', component: C}\nthis.$router.push({\n        path: '/c',\n        query: {\n          context: '吴又可吴又可'\n        }\n      })\n```\n\n\n\n## v-router的query和params的区别\n\n## webpack配置\n\n## 数组的一些方法\n\n`join` 连接数组变成字符串,不会改变原数组\n\n```js\nlet arr = [1,2,3,4];\n\nconsole.log(arr.join('-'))  //\"1-2-3-4\"\n```\n\n`split` 将字符串拆分为数组\n\n```js\nconst S = arr.join('-')\narr.split(s)  //['1','2','3','4']\n```\n\n`slice`使用 `slice` 方法从数组中截取部分元素组合成新数组（并不会改变原数组），不传第二个参数时截取到数组的最后元素。\n\n```js\narr.slice(0,3) //[1,2,3]\n```\n\n`splice` 使用`splice` 方法可以添加、删除、替换数组中的元素，会对原数组进行改变，返回值为删除的元素。\n\n删除数组元素第一个参数为从哪开始删除，第二个参数为删除的数量。\n\n```js\nlet arr = [0, 1, 2, 3, 4, 5, 6];\nconsole.log(arr.splice(1, 3)); //返回删除的元素 [1, 2, 3]\nconsole.log(arr); //删除数据后的原数组 [0, 4, 5, 6]\n```\n\n`concat`方法用于连接两个或多个数组，元素是值类型的是复制操作，如果是引用类型还是指向同一对象\n\n```js\narr1 = [1,2]\narr2 = [3,4]\n\nconsole.log(arr.concat(arr1,arr2))\n```\n\n使用 `indexOf` (`lastIndexOf`)从前向后(从后向前)查找元素出现的位置，如果找不到返回 `-1`。\n\n```js\nlet arr = [7, 3, 2, 8, 2, 6];\nconsole.log(arr.indexOf(2)); // 2 从前面查找2出现的位置\n```\n\n使用 `includes` 查找字符串返回值是布尔类型更方便判断\n\n使用`includes`等不能查找引用类型，因为它们的内存地址是不相等的\n\nfind 方法找到后会把值返回出来\n\n- 如果找不到返回值为`undefined`\n\n返回第一次找到的值，不继续查找\n\n### sort\n\n`sort`每次使用两个值进行比较 `Array.sort((a,b)=>a-b`\n\n- 返回负数 a 排在 b 前面，从小到大\n- 返回正数 b 排在 a 前面\n- 返回 0 时不动\n\n原理：\n\n```js\nlet arr = [1, 5, 3, 9, 7];\nfunction sort(array, callback) {\n  for (const n in array) {\n    for (const m in array) {\n      if (callback(array[n], array[m]) < 0) {\n        let temp = array[n];\n        array[n] = array[m];\n        array[m] = temp;\n      }\n    }\n  }\n  return array;\n}\narr = sort(arr, function(a, b) {\n  return a - b;\n});\n```\n\n### 数组遍历\n\nfor循环\n\nforEach\n\n`forEach`使函数作用在每个数组元素上，但是没有返回值。\n\nfor...in...\n\n遍历时的 key 值为数组的索引\n\nfor...of....\n\n遍历时的 key 值为数组的值\n\nmap\n\n**`map()`** 方法**创建一个新数组**，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。\n\n**语法**\n\n```js\nmap(callbackFn)\nmap(callbackFn, thisArg)\t\n```\n\n### [在非数组对象上调用 map()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#在非数组对象上调用_map)\n\n`map()` 方法读取 `this` 的 `length` 属性，然后访问每个整数索引。\n\n```js\nconst arrayLike = {\n  length: 3,\n  0: 2,\n  1: 3,\n  2: 4,\n};\nconsole.log(Array.prototype.map.call(arrayLike, (x) => x ** 2));\n// [ 4, 9, 16 ]\n\n```\n\n[reduce](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n\n`reduce()` 方法是一个[迭代方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#迭代方法)。它按升序对数组中的所有元素运行一个“reducer”回调函数，并将它们累积到一个单一的值中。每次调用时，`callbackFn` 的返回值都作为 `accumulator` 参数传递到下一次调用中。`accumulator` 的最终值（也就是在数组的最后一次迭代中从 `callbackFn` 返回的值）将作为 `reduce()` 的返回值。\n\n```js\n//每一次callbackFn返回的数据都会记录，并用于下次计算\narr = [1,2,3,4]\n\narr.reduce((accumulator,currentValue,currentIndex)=>{\n\tconsole.log(accumulator,currentValue,currentIndex)\n    return accumulator+currentValue\n})\n```\n\n### 展开嵌套数组\n\n```js\nconst flattened = [\n  [0, 1],\n  [2, 3],\n  [4, 5],\n].reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n// flattened 的值是 [0, 1, 2, 3, 4, 5]\n\n```\n\n### 统计对象中值出现的次数\n\n```js\nconst names = [\"Alice\", \"Bob\", \"Tiff\", \"Bruce\", \"Alice\"];\n\nconst countedNames = names.reduce((allNames, name) => {\n  const currCount = allNames[name] ?? 0;\n  return {\n    ...allNames,\n    [name]: currCount + 1,\n  };\n}, {});\n// countedNames 的值是：\n// { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }\n\n```\n\n## VueRouter的钩子函数\n\n1. 全局的beforeEach（前置路由守卫）:进入页面登录判断、管理员权限判断、浏览器判断\n\nbeforeEach(to,from,next)\n\nafterEach（后置路由守卫）\n\n2. 单个组件的 beforeEnter\n3. 组件内的 beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave","slug":"面试题汇总","published":1,"updated":"2024-11-17T13:58:10.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxps003o73t32ub1fjfj","content":"<blockquote>\n<p>如何区分伪元素和伪类</p>\n</blockquote>\n<p>伪元素和伪类最根本的区别就在于是否创造了新的元素</p>\n<h2 id=\"伪类\"><a href=\"#伪类\" class=\"headerlink\" title=\"伪类\"></a>伪类</h2><p>伪类是用来定义元素特殊状态的，他可以用来设置鼠标悬停样式、元素获取焦点样式、设置链接样式等。如常见的 hover、active、link 等都是伪类。</p>\n<h2 id=\"伪元素\"><a href=\"#伪元素\" class=\"headerlink\" title=\"伪元素\"></a>伪元素</h2><p>伪元素也称为伪对象，它不存在于 DOM 文档中、是一个虚拟的元素。它可以用来代表某个元素的子元素，但是这个子元素并不存在于文档树中。</p>\n<h2 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h2><p>(Block firmatting context) 块级格式化上下文</p>\n<p>能够形成独立的渲染区域，内部元素的渲染不会影响外界</p>\n<p>形成BFC 的常见条件</p>\n<blockquote>\n<p>浮动元素 </p>\n<p>绝对定位</p>\n<p>块级元素 overfolw 不是 visible</p>\n<p>flex元素</p>\n<p>inline-block元素</p>\n</blockquote>\n<p>应用场景：</p>\n<p>1.清除浮动，</p>\n<p>2.Margin边距重叠，</p>\n<p>3.解决当父级元素没有高度时，子级元素浮动会使父级元素高度塌陷的问题等</p>\n<p>Q: <code>only</code> 选择器的作用是？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">@media only screen <span class=\"hljs-title function_\">and</span> (max-<span class=\"hljs-attr\">width</span>: 1024px) &#123;<span class=\"hljs-attr\">argin</span>: <span class=\"hljs-number\">0</span>;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>A：停止旧版本浏览器解析选择器的其余部分。</p>\n<p>Q: <code>screen</code>关键词是指设备物理屏幕的大小还是指浏览器的视窗？</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> <span class=\"hljs-keyword\">only</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">max-width</span>: <span class=\"hljs-number\">1024px</span>) &#123;<span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>A: 浏览器视窗</p>\n<h2 id=\"href-和-src的区别\"><a href=\"#href-和-src的区别\" class=\"headerlink\" title=\"href 和 src的区别\"></a>href 和 src的区别</h2><p><strong>1.请求资源类型不同</strong><br>href，超文本引用，用于建立文档与资源的联系，常用的有：link、a。<br>src，将其所指向的资源下载并应用到当前页面，常见的有script、img。<br><strong>2.作用结果不同</strong><br>href，用于文档与资源之间确立联系。<br>src，请求到的资源替换当前内容。</p>\n<p><strong>3.浏览器的解析不同</strong><br>href，将资源解析成css文件，并行加载请求资源，不会阻塞对当前文档的处理。<br>src，会暂停其他资源的处理，直到该资源加载、解析和执行完毕，将其所指向资源应用到当前内容。这也是为什么把js文件放在底部而不是头部发热原因</p>\n<h2 id=\"首屏加载白屏怎么优化\"><a href=\"#首屏加载白屏怎么优化\" class=\"headerlink\" title=\"首屏加载白屏怎么优化\"></a>首屏加载白屏怎么优化</h2><p>1.使用CDN减少代码体积，加快请求速度；</p>\n<p>2.SSR通过服务端把所有数据全部渲染完成再返回给客户端</p>\n<p>3.路由懒加载</p>\n<p>4.使用外链CSS，JS文件</p>\n<p>5.开机GZIP压缩</p>\n<p>6.使用骨架屏</p>\n<h2 id=\"输入url到打开页面，都做了什么\"><a href=\"#输入url到打开页面，都做了什么\" class=\"headerlink\" title=\"输入url到打开页面，都做了什么\"></a>输入url到打开页面，都做了什么</h2><p>1.输入url，查找缓存，浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容，如果没有则进行下一步</p>\n<p>2.DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中域名对应的IP地址</p>\n<p>3.TCP握手：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</p>\n<p>4.HTTP请求：浏览器发起读取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给服务器；</p>\n<p>5.HTTP响应返回数据结果；</p>\n<p>6.通过四次挥手关闭/释放TCP连接；</p>\n<p>7.浏览器解析数据并渲染页面</p>\n<h2 id=\"TCP的三次握手和四次挥手\"><a href=\"#TCP的三次握手和四次挥手\" class=\"headerlink\" title=\"TCP的三次握手和四次挥手\"></a>TCP的三次握手和四次挥手</h2><p>三次握手是客户端和服务器之间建立连接，并进行通信的过程。相当于客户端和服务器之间你来我往的三个步骤</p>\n<ul>\n<li>第一次握手是建立连接，客户端发送连接请求报文，并传送规定的数据包；</li>\n<li>第二次握手是服务器端包是接收到连接请求报文，并回传规定的数据包</li>\n<li>第三次握手是客户端接收到服务器回传的数据包后，再次给服务器端发送数据包</li>\n</ul>\n<p>这样就完成了客户端跟服务器的连接和数据传送；</p>\n<p>三次握手的目的：</p>\n<p>双方确认自己与对方的发送与接收是正常的。</p>\n<p>四次挥手表示当前连接请求已经结束，要断开这次连接。</p>\n<ul>\n<li>第一次挥手是客户端对服务器发起断开请求</li>\n<li>第二次挥手是服务器表示收到这次断开请求</li>\n<li>第三次挥手是服务器表示已经断开连接；</li>\n<li>第四次挥手是客户端已经断开连接</li>\n</ul>\n<h2 id=\"清除浮动的四种办法\"><a href=\"#清除浮动的四种办法\" class=\"headerlink\" title=\"清除浮动的四种办法\"></a>清除浮动的四种办法</h2><ol>\n<li>clear:both; 在最后面加一个盒子</li>\n<li>overflow:hidden;  父盒子</li>\n<li>伪元素:after  父盒子</li>\n<li>双伪元素   父盒子</li>\n</ol>\n<h2 id=\"Vue的生命周期钩子\"><a href=\"#Vue的生命周期钩子\" class=\"headerlink\" title=\"Vue的生命周期钩子\"></a>Vue的生命周期钩子</h2><p>beforCreated</p>\n<p>Created</p>\n<p>beforeMounted</p>\n<p>Mounted</p>\n<p>beforeUpdated</p>\n<p>updated</p>\n<p>beforeDestory</p>\n<p>destoryed</p>\n<p>Actived</p>\n<p>Deactived</p>\n<h2 id=\"什么是闭包，闭包解决了什么问题\"><a href=\"#什么是闭包，闭包解决了什么问题\" class=\"headerlink\" title=\"什么是闭包，闭包解决了什么问题\"></a>什么是闭包，闭包解决了什么问题</h2><p>闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来.</p>\n<p><strong>我们可以用来保存一些内容，还可以用来保护一些私有的变量。我们总结出闭包有两个作用，分别为保护和保存。</strong></p>\n<p>团队开发时，每个开发者把自己的代码放在一个私有的作用域中，防止相互之间的变量命名冲突；把需要提供给别人的方法，通过 return 或 window.xxx 的方式暴露在全局下。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p> 总结：   </p>\n<p>1、当一个对象查找属性和方法时会从自身查找,如果查找不到则会通过__proto__指向被实例化的构造函数的prototype      </p>\n<p>2、隐式原型也是一个对象,是指向我们构造函数的原型      </p>\n<p>3、除了最顶层的Object对象没有<code>__proto__</code>，其他所有的对象都有__proto__,这是隐式原型 </p>\n<p>4、隐式原型__proto__的作用是让对象通过它来一直往上查找属性或方法，直到找到最顶层的Object的__proto__属性，它的值是null,这个查找的过程就是原型链</p>\n<h2 id=\"箭头函数和普通函数的区别\"><a href=\"#箭头函数和普通函数的区别\" class=\"headerlink\" title=\"箭头函数和普通函数的区别\"></a>箭头函数和普通函数的区别</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">（1）箭头函数比普通函数更加简洁<br>    如果没有参数，就直接写一个空括号即可<br>    如果只有一个参数，可以省去参数括号<br>    如果有多个参数，用逗号分割<br>    如果函数体的返回值只有一句，可以省略大括号<br>    如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常用的就是调用一个函数：<br>    let fn = () =&gt; void doesNotReturn()<br>    <br> (2) 箭头函数没有自己的this<br> 箭头函数不会创建自己的this,所以它没有自己的this,它只会在自己作用域的上一层继承this。所以箭头函数中的this的指向在它在定义时一家确定了，之后不会改变。<br> <br>（3）箭头函数继承来的this指向永远不会改变<br><br> (4) call()、apply()、bind()等方法不能改变箭头函数中的this指向 <br> <br> (5) 箭头函数不能作为构造函数使用<br> <br> (6) 箭头函数没有自己的arguments<br> <br> (7) 箭头函数没有prototype<br> <br> (8) 箭头函数不能用作Generator函数,不能使用yeild关键字<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"localStorage-sessionStorage-cookies-有什么区别\"><a href=\"#localStorage-sessionStorage-cookies-有什么区别\" class=\"headerlink\" title=\"localStorage  sessionStorage  cookies 有什么区别?\"></a>localStorage  sessionStorage  cookies 有什么区别?</h2><p>localStorage:以键值对的方式存储 储存时间没有限制 永久生效 除非自己删除记录<br>sessionStorage：当页面关闭后被清理与其他相比不能同源窗口共享 是会话级别的存储方式<br>cookies 数据不能超过4k 同时因为每次http请求都会携带cookie 所有cookie只适合保存很小的数据 如会话标识</p>\n<h2 id=\"Vuex有哪些基本属性-为什么-Vuex-的-mutation-中不能做异步操作\"><a href=\"#Vuex有哪些基本属性-为什么-Vuex-的-mutation-中不能做异步操作\" class=\"headerlink\" title=\"Vuex有哪些基本属性?为什么 Vuex 的 mutation 中不能做异步操作?\"></a>Vuex有哪些基本属性?为什么 Vuex 的 mutation 中不能做异步操作?</h2><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module<br>1、state =&gt; 基本数据(数据源存放地)<br>2、getters =&gt; 从基本数据派生出来的数据<br>3、mutations =&gt; 提交更改数据的方法，同步<br>4、actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。<br>5、modules =&gt; 模块化Vuex</p>\n<p>1、Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。<br>2、每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p>\n<h2 id=\"常见的水平居中\"><a href=\"#常见的水平居中\" class=\"headerlink\" title=\"常见的水平居中\"></a>常见的水平居中</h2><ol>\n<li><p>```css<br> .father{</p>\n<pre><code> display:flex;\n justify-content:center;\n align-items:center;\n</code></pre>\n<p> }</p>\n<p> .son{<br> ….<br> }</p>\n <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><br><span class=\"hljs-number\">2</span>. 绝对定位 <br><br>\t```css<br>\t<span class=\"hljs-selector-class\">.father</span> &#123;<br>\t    <span class=\"hljs-attribute\">position</span>: relative;<br>\t&#125;<br>\t<span class=\"hljs-selector-class\">.son</span> &#123;<br>\t    <span class=\"hljs-attribute\">position</span>: absolute;<br>\t    <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>;<br>\t    <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">0</span>;<br>\t    <span class=\"hljs-attribute\">bottom</span>: <span class=\"hljs-number\">0</span>;<br>\t    <span class=\"hljs-attribute\">right</span>: <span class=\"hljs-number\">0</span>;<br>\t    <span class=\"hljs-attribute\">margin</span>: auto;<br>\t&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>绝对定位配合transform</p>\n <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.father</span> &#123;<br>    <span class=\"hljs-attribute\">position</span>: relative;<br>&#125;<br><span class=\"hljs-selector-class\">.son</span> &#123;<br>    <span class=\"hljs-attribute\">position</span>: absolute;<br>    <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">50%</span>;<br>    <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">50%</span>;<br>    <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translate</span>(-<span class=\"hljs-number\">50%</span>, -<span class=\"hljs-number\">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"Js的基本类型和引用类型\"><a href=\"#Js的基本类型和引用类型\" class=\"headerlink\" title=\"Js的基本类型和引用类型\"></a>Js的基本类型和引用类型</h2><p>基本类型：undefined , string, number, null ,bigint,boolean,symbol</p>\n<p>引用类型: Object,function,array</p>\n<p>typeof/instanceof</p>\n<h2 id=\"TypeScript的-type和-interface-的区别\"><a href=\"#TypeScript的-type和-interface-的区别\" class=\"headerlink\" title=\"TypeScript的 type和 interface 的区别\"></a>TypeScript的 type和 interface 的区别</h2><p>interface可以重复声明，type不行，继承方式不一样，type使用交叉类型方式，interface使用extends实现。在对象扩展的情况下，使用接口继承要比交叉类型的性能更好。建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tsx\"><span class=\"hljs-keyword\">interface</span> iMan &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><span class=\"hljs-comment\">// 接口可以进行声明合并</span><br><span class=\"hljs-keyword\">interface</span> iMan &#123;<br>  <span class=\"hljs-attr\">hobby</span>: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> tMan = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;;<br><span class=\"hljs-comment\">// type不能重复定义</span><br><span class=\"hljs-comment\">// type tMan = &#123;&#125;</span><br><br><span class=\"hljs-comment\">// 继承方式不同,接口继承使用extends</span><br><span class=\"hljs-keyword\">interface</span> iManPlus <span class=\"hljs-keyword\">extends</span> iMan &#123;<br>  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><span class=\"hljs-comment\">// type继承使用&amp;，又称交叉类型</span><br><span class=\"hljs-keyword\">type</span> tManPlus = &#123; <span class=\"hljs-attr\">height</span>: <span class=\"hljs-built_in\">string</span> &#125; &amp; tMan;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">aMan</span>: iManPlus = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;aa&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">15</span>,<br>  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-string\">&quot;175cm&quot;</span>,<br>  <span class=\"hljs-attr\">hobby</span>: <span class=\"hljs-string\">&quot;eat&quot;</span>,<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">bMan</span>: tManPlus = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;bb&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">15</span>,<br>  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-string\">&quot;150cm&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"常见的工具类型\"><a href=\"#常见的工具类型\" class=\"headerlink\" title=\"常见的工具类型\"></a>常见的工具类型</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">Partial：满足部分属性(一个都没满足也可)即可<br>Required：所有属性都需要<br>Readonly: 包装后的所有属性只读<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"computed-和-watch-的区别\"><a href=\"#computed-和-watch-的区别\" class=\"headerlink\" title=\"computed 和 watch 的区别\"></a>computed 和 watch 的区别</h2><p>使用场景：computed适用于一个数据受多个数据影响使用；watch适合一个数据影响多个数据使用。</p>\n<p>区别：computed属性默认会走<strong>缓存</strong>，只有依赖数据发生变化，才会重新计算，不支持异步，有异步导致数据发生变化时，无法做出相应改变；watch不依赖缓存，一旦数据发生变化就直接触发响应操作，支持异步。</p>\n<h2 id=\"浏览器渲染页面的过程\"><a href=\"#浏览器渲染页面的过程\" class=\"headerlink\" title=\"浏览器渲染页面的过程\"></a>浏览器渲染页面的过程</h2><p>首先输入一个网址，浏览器会向服务器发起DNS请求，得到对应的IP地址（会被缓存一段时间，后续访问就不用再去向服务器查询）。之后会进行TCP三次握手与服务器建立连接，连接建立后，浏览器会代表用户发送一个初始的GET请求，通常是请求一个HTML文件。服务器收到对应请求后 ，会根据相关的响应头和HTML内容进行回复。</p>\n<p>一旦浏览器拿到了数据，就会开始解析信息，这个过程中，浏览器会根据HTML文件去构建DOM树，当遇到一些阻塞资源时（如同步加载的script标签）会去加载阻塞资源而停止当前DOM树构建（所以能够异步的或延迟加载的就尽量异步或延迟，同时页面的脚本还是越少越好）。在构建DOM树时，浏览器的主线程被占据着，不过浏览器的预加载扫描器会去请求高优先级的资源（如css、js、字体），预加载扫描器很好的优化了阻塞问题。接下来浏览器会处理CSS生成CSSDOM树，将CSS规则转换为可以理解和使用的样式映射，这个过程非常快（通常小于一次DNS查询所需时间）。有了DOM树和CSSDOM树，浏览器会将其组合生成一个Render树，计算样式或渲染树会从DOM的根节点开始构建，遍历每一个可见节点（将相关样式匹配到每一个可见节点，并根据CSS级联去的每个节点的计算样式）。接下来开始布局，该过程（依旧是从根节点开始）会确定所有节点的宽高和位置，最后通过渲染器将其在页面上绘制。绘制完成了，并不代表交互也都生效了，因为主线程可能还无法抽出时间去处理滚动、触摸等交互，要等到js加载完成，同时主线程空闲了整个页面才是正常可用的状态。</p>\n<h2 id=\"webpack中plugin和loader分别做什么？它们之间的执行顺序？\"><a href=\"#webpack中plugin和loader分别做什么？它们之间的执行顺序？\" class=\"headerlink\" title=\"webpack中plugin和loader分别做什么？它们之间的执行顺序？\"></a>webpack中plugin和loader分别做什么？它们之间的执行顺序？</h2><ul>\n<li>loader：用于将不同类型的文件转换成webpack可以识别的文件（webpack只认识js和json）。</li>\n<li>plugin：存在于webpack整个生命周期中，是一种基于事件机制工作的模式，可以在webpck打包过程对某些节点做某些定制化处理。同时plugin可以对loader解析过程中做一些处理，协同处理文件。</li>\n<li>执行顺序：两者不存在明显的先后顺序，不过webpack在初始化处理时，会优先识别到plugin中的内容。</li>\n</ul>\n<h2 id=\"webpack常见的优化方案\"><a href=\"#webpack常见的优化方案\" class=\"headerlink\" title=\"webpack常见的优化方案\"></a>webpack常见的优化方案</h2><ul>\n<li>基于esm的tree shaking</li>\n<li>对balel设置缓存，缩小babel-loader的处理范围,及精准指定要处理的目录。</li>\n<li>压缩资源（mini-css-extract-plugin，compression-webpack-plugin）</li>\n<li>配置资源的按需引入（第三方组件库）</li>\n<li>配置splitChunks来进行按需加载（根据）</li>\n<li>设置CDN优化</li>\n</ul>\n<h2 id=\"app-use的原理\"><a href=\"#app-use的原理\" class=\"headerlink\" title=\"app.use的原理\"></a>app.use的原理</h2><p>vue中使用插件的方法</p>\n<h2 id=\"左边固定，右边自适应\"><a href=\"#左边固定，右边自适应\" class=\"headerlink\" title=\"左边固定，右边自适应\"></a>左边固定，右边自适应</h2><ol>\n<li><p>浮动</p>\n<p> 左边设置固定宽度,向左浮动，右边设置<code>margin-left:100px;width:auto</code></p>\n</li>\n<li><p>BFC+浮动</p>\n</li>\n</ol>\n<p>​    左边设置固定宽度，向左浮动，右边设置overflow:hidden 触发BFC</p>\n<ol start=\"3\">\n<li>flex:1(flex-basic:auto,flex-shrink:1,flex-grow:1)</li>\n<li>grid布局</li>\n</ol>\n<p>​    grid-template-columns:100px 1fr; 这样子的话就是右边自适应</p>\n<ol start=\"5\">\n<li>绝对定位</li>\n</ol>\n<p>​    左元素设置为绝对定位，left:0,width:100px</p>\n<p>​    右元素设置为left:100</p>\n<h2 id=\"scoped的执行原理\"><a href=\"#scoped的执行原理\" class=\"headerlink\" title=\"scoped的执行原理\"></a>scoped的执行原理</h2><p>当一个style标签拥有scoped属性时，它的CSS样式就只能作用于当前的组件，通过该属性，可以使得组件之间的样式不互相污染。</p>\n<p>Vue中的scoped属性的效果主要是通过PostCss实现的。给一个组件中的所有dom添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom,这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.home</span>&#123;<br>\t<span class=\"hljs-attribute\">color</span>:red;<br>&#125;<br><br>-------------<br><span class=\"hljs-selector-class\">.home</span><span class=\"hljs-selector-attr\">[data-v-e172323]</span>&#123;<br>    <span class=\"hljs-attribute\">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"样式穿透的原理\"><a href=\"#样式穿透的原理\" class=\"headerlink\" title=\"样式穿透的原理\"></a>样式穿透的原理</h2><p>普通的css语法: 在要修改的样式前添加 &gt;&gt;&gt; 符号</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.demo</span> &gt;&gt;&gt; <span class=\"hljs-selector-class\">.el-table</span>&#123;<br>    <span class=\"hljs-attribute\">border</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>scss语法: 在要修改的样式前添加 ::v-deep</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">::v-deep .el-table&#123;<br>    <span class=\"hljs-attribute\">border</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>sass语法/less语法 : 在要修改的样式前添加 /deep/</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.demo <span class=\"hljs-regexp\">/deep/</span> .el<span class=\"hljs-operator\">-</span>table&#123;<br>    border:none;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>用了样式穿透后，被穿透的dom不会再加上唯一标识[data-v-xxxxxx]</p>\n<h2 id=\"水平垂直居中，垂直居中\"><a href=\"#水平垂直居中，垂直居中\" class=\"headerlink\" title=\"水平垂直居中，垂直居中\"></a>水平垂直居中，垂直居中</h2><p>水平垂直居中： </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">text-align</span>:center;  //只对inline起作用<br><br><span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-number\">0</span> auto;  //<span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-number\">0</span> auto;是对元素自身(block)起作用，<br><br><span class=\"hljs-attribute\">position</span>:absoult;<br><span class=\"hljs-attribute\">top</span>:<span class=\"hljs-number\">50%</span>;<br><span class=\"hljs-attribute\">left</span>:<span class=\"hljs-number\">50%</span>;<br><span class=\"hljs-attribute\">transform</span>:<span class=\"hljs-built_in\">translate</span>(-<span class=\"hljs-number\">50%</span>,-<span class=\"hljs-number\">50%</span>)<br><br>display:flex;<br><span class=\"hljs-attribute\">justify-content</span>:center;<br>align-item:center;<br><br><span class=\"hljs-attribute\">display</span>:grid;<br><span class=\"hljs-attribute\">align-items</span>: center;<br><span class=\"hljs-attribute\">justify-content</span>: center;<br></code></pre></td></tr></table></figure>\n\n<p>垂直居中</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">line-height</span> === <span class=\"hljs-attribute\">height</span><br><br><span class=\"hljs-attribute\">vertical-align</span>:middle<br><br><br>.father&#123;<br>    <span class=\"hljs-attribute\">display</span>:flex;<br>&#125;<br><span class=\"hljs-selector-class\">.son</span>&#123;<br>    <span class=\"hljs-attribute\">align-self</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"flex-和-grid的一些属性\"><a href=\"#flex-和-grid的一些属性\" class=\"headerlink\" title=\"flex 和 grid的一些属性\"></a>flex 和 grid的一些属性</h2><p>看mdn吧，太多了</p>\n<h2 id=\"less-和-scss\"><a href=\"#less-和-scss\" class=\"headerlink\" title=\"less 和 scss\"></a>less 和 scss</h2><h2 id=\"css-module\"><a href=\"#css-module\" class=\"headerlink\" title=\"css module\"></a>css module</h2><h2 id=\"git的一些操作\"><a href=\"#git的一些操作\" class=\"headerlink\" title=\"git的一些操作\"></a>git的一些操作</h2><blockquote>\n<p> git stash 怎么恢复回来?</p>\n</blockquote>\n<p>1.使用git status指令查看当前文件状态。</p>\n<p>2.然后，使用指令git stash 将文件修改缓存。</p>\n<p>3.使用git status指令确认当前分支没有修改内容。</p>\n<p>4.使用指令git stash list，查看当前缓存列表。</p>\n<p>5.使用指令git stash apply stash@{id}，恢复指令ID的缓存内容，并且保留缓存条目。</p>\n<p>6.使用git stash pop 恢复最新的stash，同时删除恢复的缓存条目。</p>\n<blockquote>\n<p>git reset 和 git revert的区别</p>\n</blockquote>\n<p>- git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；<br>- git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除</p>\n<h2 id=\"es6-的新特性以及具体内容\"><a href=\"#es6-的新特性以及具体内容\" class=\"headerlink\" title=\"es6 的新特性以及具体内容\"></a>es6 的新特性以及具体内容</h2><p>1.新增了块级作用域（let，const），TDZ</p>\n<p>2.提供了定义类的语法糖（class）</p>\n<p>3.新增了一种基本数据类型（Symbol）</p>\n<p>4.新增了变量的解构赋值</p>\n<p>5.函数参数允许设置默认值，引入了rest参数，新增了箭头函数。</p>\n<p>6.数组新增了一些API，如isArray / from / of 方法；数组实例新增了 entries()，keys() 和 values() 等方法。</p>\n<p>7.对象和数组新增了扩展运算符</p>\n<p>8.ES6新增了模块化（import / export）</p>\n<p>9.ES6新增了Set和Map数据结构。</p>\n<p>10.ES6原生提供Proxy构造函数，用来生成Proxy实例</p>\n<p>11.ES6新增了生成器（Generator）和遍历器（Iterator）</p>\n<p>12.模板字符串</p>\n<p>13.promise</p>\n<h2 id=\"promise-all-和-promise-race\"><a href=\"#promise-all-和-promise-race\" class=\"headerlink\" title=\"promise.all() 和 promise.race()\"></a>promise.all() 和 promise.race()</h2><p>promise.all()返回的结果由所有的结果而定，如果返回中有一个失败，那就是失败的，如果全部成功就是成功的</p>\n<p>promise.race()返回的结果由最先返回的那个promise来决定，第一个返回的是失败就是失败</p>\n<h2 id=\"rem-和-em-的区别\"><a href=\"#rem-和-em-的区别\" class=\"headerlink\" title=\"rem 和 em 的区别\"></a>rem 和 em 的区别</h2><ul>\n<li>px是固定的单位长度，一旦设置了就无法随页面的大小而适应改变。</li>\n<li>em是相对长度单位，比px更具灵活性，em的长度是相对于父元素</li>\n<li>rem的长度是相对于根元素，也就是html的字体大小</li>\n</ul>\n<h2 id=\"怎么新建set的集合\"><a href=\"#怎么新建set的集合\" class=\"headerlink\" title=\"怎么新建set的集合\"></a>怎么新建set的集合</h2><p>直接 new Set() 会直接报错</p>\n<p>Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来进行数据初始化。</p>\n<p>let i = new Set([1,2])</p>\n<p>操作方法:<br>add(value)　　　　添加数据，并返回新的 Set 结构<br>delete(value)　　　删除数据，返回一个布尔值，表示是否删除成功<br>has(value)　　　　查看是否存在某个数据，返回一个布尔值<br>clear()　　　　　　清除所有数据，没有返回值</p>\n<p><strong>遍历方法:</strong></p>\n<p>Set 提供了三个遍历器生成函数和一个遍历方法。<br>keys()　　　　 返回一个键名的遍历器<br>values()　　　 返回一个键值的遍历器<br>entries()　　　 返回一个键值对的遍历器<br>forEach()　　　使用回调函数遍历每个成员</p>\n<h2 id=\"js实现栈\"><a href=\"#js实现栈\" class=\"headerlink\" title=\"js实现栈\"></a>js实现栈</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//stack 栈  数组就是一个很完美的栈结构</span><br><span class=\"hljs-comment\">//functions: pop,push,peek,length</span><br><br><span class=\"hljs-keyword\">let</span> stack = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span> = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span> = &#123;&#125;;<br><br>    <span class=\"hljs-comment\">//给栈中添加一个元素 push</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">push</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>[<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>] = value;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//给栈中移除一个元素 pop</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">pop</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span> === <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;<br>        &#125;<br><br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>--;<br>        <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>[<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>]<br>        <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>[<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>]<br><br>        <span class=\"hljs-keyword\">return</span> result<br>    &#125;<br><br>    <span class=\"hljs-comment\">//栈的大小</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">length</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//返回栈顶的元素</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">peek</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>[<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>-<span class=\"hljs-number\">1</span>]<br>    &#125;<br>&#125;<br><br><br><span class=\"hljs-keyword\">let</span> myStack = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">stack</span>();<br><br>myStack.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">1</span>)<br>myStack.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">2</span>)<br>myStack.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">3</span>)<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myStack);   <span class=\"hljs-comment\">//  storage: &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3 &#125;,</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myStack.<span class=\"hljs-title function_\">peek</span>());   <span class=\"hljs-comment\">//3</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myStack.<span class=\"hljs-title function_\">pop</span>());     <span class=\"hljs-comment\">//3</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myStack.<span class=\"hljs-title function_\">length</span>());    <span class=\"hljs-comment\">//2</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"for-of-和-for-in-的区别\"><a href=\"#for-of-和-for-in-的区别\" class=\"headerlink\" title=\"for of 和 for in 的区别\"></a>for of 和 for in 的区别</h2><p>for in  可以用在数组吗？</p>\n<p>是可以的，因为for…in（值） 本身是对象的遍历方法，数组也属于对象，但是最好不用，数组的遍历可以用 for..of（索引） , for Each</p>\n<p>理由如下：</p>\n<ol>\n<li>for…in 的属性值是字符串，可以会导致错误</li>\n<li>for…in 遍历的是可迭代对象，原型上的属性也可能会被遍历到</li>\n<li>for…in  不是按照数组下标顺序来遍历的，是按照对象属性的枚举属性</li>\n</ol>\n<h2 id=\"中序遍历二叉树\"><a href=\"#中序遍历二叉树\" class=\"headerlink\" title=\"中序遍历二叉树\"></a>中序遍历二叉树</h2><h2 id=\"数组去重的几种办法\"><a href=\"#数组去重的几种办法\" class=\"headerlink\" title=\"数组去重的几种办法\"></a>数组去重的几种办法</h2><ol>\n<li>Array.from(new Set(arr))</li>\n<li>双重for循环</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i&lt;len;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j = i+<span class=\"hljs-number\">1</span>;j&lt;len;j++)&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(arr[i] === arr[j])&#123;<br>\t\t\tarr.<span class=\"hljs-title function_\">splice</span>(j,<span class=\"hljs-number\">1</span>)<span class=\"hljs-comment\">//删除第二个</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>3.利用indexOf</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">methods3</span>(<span class=\"hljs-params\">arr</span>) &#123;<br><br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(arr)) &#123;<br><br>        <span class=\"hljs-keyword\">return</span>;<br><br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> array = [];<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-property\">length</span>; i++) &#123;<br><br>        <span class=\"hljs-keyword\">if</span> (array .<span class=\"hljs-title function_\">indexOf</span>(arr[i]) === -<span class=\"hljs-number\">1</span>) &#123;<br><br>            array .<span class=\"hljs-title function_\">push</span>(arr[i])<br><br>        &#125;<br><br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> array;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>4.利用sort排序，看看左右两个是否一样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">methods4</span>(<span class=\"hljs-params\">arr</span>) &#123;<br><br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(arr)) &#123;<br><br>        <span class=\"hljs-keyword\">return</span>;<br><br>    &#125;<br><br>    arr = arr.<span class=\"hljs-title function_\">sort</span>()<br><br>    <span class=\"hljs-keyword\">var</span> arrry= [arr[<span class=\"hljs-number\">0</span>]];<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt; arr.<span class=\"hljs-property\">length</span>; i++) &#123;<br><br>        <span class=\"hljs-keyword\">if</span> (arr[i] !== arr[i-<span class=\"hljs-number\">1</span>]) &#123;<br><br>            arrry.<span class=\"hljs-title function_\">push</span>(arr[i]);<br><br>        &#125;<br><br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> arrry;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>5.利用includes</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">methods6</span>(<span class=\"hljs-params\">arr</span>) &#123;<br><br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(arr)) &#123;<br><br>        <span class=\"hljs-keyword\">return</span><br><br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> array =[];<br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-property\">length</span>; i++) &#123;<br><br>            <span class=\"hljs-keyword\">if</span>( !array.<span class=\"hljs-title function_\">includes</span>( arr[i]) ) &#123;<span class=\"hljs-comment\">//includes 检测数组是否有某个值</span><br><br>                    array.<span class=\"hljs-title function_\">push</span>(arr[i]);<br><br>              &#125;<br><br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> array<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>6.利用Map，递归，filter</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">methods10</span>(<span class=\"hljs-params\">arr</span>) &#123;<br><br>    <span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><br>    <span class=\"hljs-keyword\">let</span> array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>();<span class=\"hljs-comment\">// 数组用于返回结果</span><br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-property\">length</span>; i++) &#123;<br><br>      <span class=\"hljs-keyword\">if</span>(map .<span class=\"hljs-title function_\">has</span>(arr[i])) &#123;<span class=\"hljs-comment\">// 如果有该key值</span><br><br>        map .<span class=\"hljs-title function_\">set</span>(arr[i], <span class=\"hljs-literal\">true</span>); <br><br>      &#125; <span class=\"hljs-keyword\">else</span> &#123; <br><br>        map .<span class=\"hljs-title function_\">set</span>(arr[i], <span class=\"hljs-literal\">false</span>);<span class=\"hljs-comment\">// 如果没有该key值</span><br><br>        array .<span class=\"hljs-title function_\">push</span>(arr[i]);<br><br>      &#125;<br><br>    &#125; <br><br>    <span class=\"hljs-keyword\">return</span> array ;<br><br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>7.利用reduce</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>];<br><span class=\"hljs-keyword\">let</span> filterArr = arr.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">pre, cur, index, array</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (pre.<span class=\"hljs-title function_\">includes</span>(cur) === <span class=\"hljs-literal\">false</span>) &#123;<br>      pre = [...pre, cur];<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> pre;<br>&#125;, [])<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(filterArr); <span class=\"hljs-comment\">// [1,2,6]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"forEach-和-Map的区别\"><a href=\"#forEach-和-Map的区别\" class=\"headerlink\" title=\"forEach 和 Map的区别\"></a>forEach 和 Map的区别</h2><p>map有返回值，forEach没有，都不可以改变原数组，除非你在callback里面改（giao,为什么要问这种问题）</p>\n<h2 id=\"自定义一个v-model\"><a href=\"#自定义一个v-model\" class=\"headerlink\" title=\"自定义一个v-model\"></a>自定义一个v-model</h2><p>v-model是vue中的一个语法糖，实现数据的双向绑定</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;input<br>    :value=&quot;parentData&quot;<br>    @input=&quot;parentData = $event.target.value&quot;<br>&gt;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"vueRouter传参数的几种办法\"><a href=\"#vueRouter传参数的几种办法\" class=\"headerlink\" title=\"vueRouter传参数的几种办法\"></a>vueRouter传参数的几种办法</h2><h4 id=\"一-router-link路由导航方式传参\"><a href=\"#一-router-link路由导航方式传参\" class=\"headerlink\" title=\"一.router-link路由导航方式传参\"></a>一.router-link路由导航方式传参</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//路由配置   &#123;path:&#x27;/father/son/:num&#x27;,name:A,component:A&#125;</span><br>&lt;router-link to=<span class=\"hljs-string\">&quot;/path/num&quot;</span>&gt;&lt;/router-link&gt;<br><span class=\"hljs-comment\">//子组件通过  this.$route.params.num 接受参数</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"二、调用-router-push实现路由传参\"><a href=\"#二、调用-router-push实现路由传参\" class=\"headerlink\" title=\"二、调用$router.push实现路由传参\"></a>二、调用$router.push实现路由传参</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//路由配置： &#123;path: &#x27;/d/:id&#x27;, name: D, component: D&#125;</span><br><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$router</span>.<span class=\"hljs-title function_\">push</span>(&#123;<br>\t<span class=\"hljs-attr\">path</span>:<span class=\"hljs-string\">&#x27;/d/:id&#x27;</span><br>&#125;)<br><br><span class=\"hljs-comment\">//子组件通过  this.$route.params.id  接受参数</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"三-通过路由属性name匹配路由，再根据params传递参数\"><a href=\"#三-通过路由属性name匹配路由，再根据params传递参数\" class=\"headerlink\" title=\"三.通过路由属性name匹配路由，再根据params传递参数\"></a>三.通过路由属性name匹配路由，再根据params传递参数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//路由配置： &#123;name:&quot;B&quot;,path:&#x27;/asdsdasd/asdd&#x27;,component:B&#125; 无所谓path，但是name一定要对应</span><br><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$router</span>.<span class=\"hljs-title function_\">push</span>(&#123;<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;B&#x27;</span>,<br>        <span class=\"hljs-attr\">params</span>: &#123;<br>          <span class=\"hljs-attr\">context</span>: <span class=\"hljs-string\">&#x27;吴又可吴又可吴又可&#x27;</span><br>        &#125;<br>      &#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"四-通过query传参数\"><a href=\"#四-通过query传参数\" class=\"headerlink\" title=\"四.通过query传参数\"></a>四.通过query传参数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 路由配置  &#123;path: &#x27;/c&#x27;, name: &#x27;C&#x27;, component: C&#125;</span><br><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$router</span>.<span class=\"hljs-title function_\">push</span>(&#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/c&#x27;</span>,<br>        <span class=\"hljs-attr\">query</span>: &#123;<br>          <span class=\"hljs-attr\">context</span>: <span class=\"hljs-string\">&#x27;吴又可吴又可&#x27;</span><br>        &#125;<br>      &#125;)<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"v-router的query和params的区别\"><a href=\"#v-router的query和params的区别\" class=\"headerlink\" title=\"v-router的query和params的区别\"></a>v-router的query和params的区别</h2><h2 id=\"webpack配置\"><a href=\"#webpack配置\" class=\"headerlink\" title=\"webpack配置\"></a>webpack配置</h2><h2 id=\"数组的一些方法\"><a href=\"#数组的一些方法\" class=\"headerlink\" title=\"数组的一些方法\"></a>数组的一些方法</h2><p><code>join</code> 连接数组变成字符串,不会改变原数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>];<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;-&#x27;</span>))  <span class=\"hljs-comment\">//&quot;1-2-3-4&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><code>split</code> 将字符串拆分为数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> S = arr.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;-&#x27;</span>)<br>arr.<span class=\"hljs-title function_\">split</span>(s)  <span class=\"hljs-comment\">//[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;]</span><br></code></pre></td></tr></table></figure>\n\n<p><code>slice</code>使用 <code>slice</code> 方法从数组中截取部分元素组合成新数组（并不会改变原数组），不传第二个参数时截取到数组的最后元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">arr.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">//[1,2,3]</span><br></code></pre></td></tr></table></figure>\n\n<p><code>splice</code> 使用<code>splice</code> 方法可以添加、删除、替换数组中的元素，会对原数组进行改变，返回值为删除的元素。</p>\n<p>删除数组元素第一个参数为从哪开始删除，第二个参数为删除的数量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>];<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">//返回删除的元素 [1, 2, 3]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr); <span class=\"hljs-comment\">//删除数据后的原数组 [0, 4, 5, 6]</span><br></code></pre></td></tr></table></figure>\n\n<p><code>concat</code>方法用于连接两个或多个数组，元素是值类型的是复制操作，如果是引用类型还是指向同一对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>]<br>arr2 = [<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>]<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr.<span class=\"hljs-title function_\">concat</span>(arr1,arr2))<br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>indexOf</code> (<code>lastIndexOf</code>)从前向后(从后向前)查找元素出现的位置，如果找不到返回 <code>-1</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">6</span>];<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr.<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// 2 从前面查找2出现的位置</span><br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>includes</code> 查找字符串返回值是布尔类型更方便判断</p>\n<p>使用<code>includes</code>等不能查找引用类型，因为它们的内存地址是不相等的</p>\n<p>find 方法找到后会把值返回出来</p>\n<ul>\n<li>如果找不到返回值为<code>undefined</code></li>\n</ul>\n<p>返回第一次找到的值，不继续查找</p>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h3><p><code>sort</code>每次使用两个值进行比较 <code>Array.sort((a,b)=&gt;a-b</code></p>\n<ul>\n<li>返回负数 a 排在 b 前面，从小到大</li>\n<li>返回正数 b 排在 a 前面</li>\n<li>返回 0 时不动</li>\n</ul>\n<p>原理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">7</span>];<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-params\">array, callback</span>) &#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> n <span class=\"hljs-keyword\">in</span> array) &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> m <span class=\"hljs-keyword\">in</span> array) &#123;<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">callback</span>(array[n], array[m]) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">let</span> temp = array[n];<br>        array[n] = array[m];<br>        array[m] = temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> array;<br>&#125;<br>arr = <span class=\"hljs-title function_\">sort</span>(arr, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a - b;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"数组遍历\"><a href=\"#数组遍历\" class=\"headerlink\" title=\"数组遍历\"></a>数组遍历</h3><p>for循环</p>\n<p>forEach</p>\n<p><code>forEach</code>使函数作用在每个数组元素上，但是没有返回值。</p>\n<p>for…in…</p>\n<p>遍历时的 key 值为数组的索引</p>\n<p>for…of….</p>\n<p>遍历时的 key 值为数组的值</p>\n<p>map</p>\n<p><strong><code>map()</code></strong> 方法<strong>创建一个新数组</strong>，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。</p>\n<p><strong>语法</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">map</span>(callbackFn)<br><span class=\"hljs-title function_\">map</span>(callbackFn, thisArg)\t<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"在非数组对象上调用-map\"><a href=\"#在非数组对象上调用-map\" class=\"headerlink\" title=\"在非数组对象上调用 map()\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#%E5%9C%A8%E9%9D%9E%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8A%E8%B0%83%E7%94%A8_map\">在非数组对象上调用 map()</a></h3><p><code>map()</code> 方法读取 <code>this</code> 的 <code>length</code> 属性，然后访问每个整数索引。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arrayLike = &#123;<br>  <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">3</span>,<br>  <span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">2</span>,<br>  <span class=\"hljs-number\">1</span>: <span class=\"hljs-number\">3</span>,<br>  <span class=\"hljs-number\">2</span>: <span class=\"hljs-number\">4</span>,<br>&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">map</span>.<span class=\"hljs-title function_\">call</span>(arrayLike, <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> x ** <span class=\"hljs-number\">2</span>));<br><span class=\"hljs-comment\">// [ 4, 9, 16 ]</span><br><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\">reduce</a></p>\n<p><code>reduce()</code> 方法是一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95\">迭代方法</a>。它按升序对数组中的所有元素运行一个“reducer”回调函数，并将它们累积到一个单一的值中。每次调用时，<code>callbackFn</code> 的返回值都作为 <code>accumulator</code> 参数传递到下一次调用中。<code>accumulator</code> 的最终值（也就是在数组的最后一次迭代中从 <code>callbackFn</code> 返回的值）将作为 <code>reduce()</code> 的返回值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//每一次callbackFn返回的数据都会记录，并用于下次计算</span><br>arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>]<br><br>arr.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">accumulator,currentValue,currentIndex</span>)=&gt;</span>&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(accumulator,currentValue,currentIndex)<br>    <span class=\"hljs-keyword\">return</span> accumulator+currentValue<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"展开嵌套数组\"><a href=\"#展开嵌套数组\" class=\"headerlink\" title=\"展开嵌套数组\"></a>展开嵌套数组</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> flattened = [<br>  [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],<br>  [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>],<br>  [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>],<br>].<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">accumulator, currentValue</span>) =&gt;</span> accumulator.<span class=\"hljs-title function_\">concat</span>(currentValue), []);<br><span class=\"hljs-comment\">// flattened 的值是 [0, 1, 2, 3, 4, 5]</span><br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"统计对象中值出现的次数\"><a href=\"#统计对象中值出现的次数\" class=\"headerlink\" title=\"统计对象中值出现的次数\"></a>统计对象中值出现的次数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> names = [<span class=\"hljs-string\">&quot;Alice&quot;</span>, <span class=\"hljs-string\">&quot;Bob&quot;</span>, <span class=\"hljs-string\">&quot;Tiff&quot;</span>, <span class=\"hljs-string\">&quot;Bruce&quot;</span>, <span class=\"hljs-string\">&quot;Alice&quot;</span>];<br><br><span class=\"hljs-keyword\">const</span> countedNames = names.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">allNames, name</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> currCount = allNames[name] ?? <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    ...allNames,<br>    [name]: currCount + <span class=\"hljs-number\">1</span>,<br>  &#125;;<br>&#125;, &#123;&#125;);<br><span class=\"hljs-comment\">// countedNames 的值是：</span><br><span class=\"hljs-comment\">// &#123; &#x27;Alice&#x27;: 2, &#x27;Bob&#x27;: 1, &#x27;Tiff&#x27;: 1, &#x27;Bruce&#x27;: 1 &#125;</span><br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"VueRouter的钩子函数\"><a href=\"#VueRouter的钩子函数\" class=\"headerlink\" title=\"VueRouter的钩子函数\"></a>VueRouter的钩子函数</h2><ol>\n<li>全局的beforeEach（前置路由守卫）:进入页面登录判断、管理员权限判断、浏览器判断</li>\n</ol>\n<p>beforeEach(to,from,next)</p>\n<p>afterEach（后置路由守卫）</p>\n<ol start=\"2\">\n<li>单个组件的 beforeEnter</li>\n<li>组件内的 beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li>\n</ol>\n","site":{"data":{}},"wordcount":14535,"excerpt":"","more":"<blockquote>\n<p>如何区分伪元素和伪类</p>\n</blockquote>\n<p>伪元素和伪类最根本的区别就在于是否创造了新的元素</p>\n<h2 id=\"伪类\"><a href=\"#伪类\" class=\"headerlink\" title=\"伪类\"></a>伪类</h2><p>伪类是用来定义元素特殊状态的，他可以用来设置鼠标悬停样式、元素获取焦点样式、设置链接样式等。如常见的 hover、active、link 等都是伪类。</p>\n<h2 id=\"伪元素\"><a href=\"#伪元素\" class=\"headerlink\" title=\"伪元素\"></a>伪元素</h2><p>伪元素也称为伪对象，它不存在于 DOM 文档中、是一个虚拟的元素。它可以用来代表某个元素的子元素，但是这个子元素并不存在于文档树中。</p>\n<h2 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h2><p>(Block firmatting context) 块级格式化上下文</p>\n<p>能够形成独立的渲染区域，内部元素的渲染不会影响外界</p>\n<p>形成BFC 的常见条件</p>\n<blockquote>\n<p>浮动元素 </p>\n<p>绝对定位</p>\n<p>块级元素 overfolw 不是 visible</p>\n<p>flex元素</p>\n<p>inline-block元素</p>\n</blockquote>\n<p>应用场景：</p>\n<p>1.清除浮动，</p>\n<p>2.Margin边距重叠，</p>\n<p>3.解决当父级元素没有高度时，子级元素浮动会使父级元素高度塌陷的问题等</p>\n<p>Q: <code>only</code> 选择器的作用是？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">@media only screen <span class=\"hljs-title function_\">and</span> (max-<span class=\"hljs-attr\">width</span>: 1024px) &#123;<span class=\"hljs-attr\">argin</span>: <span class=\"hljs-number\">0</span>;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>A：停止旧版本浏览器解析选择器的其余部分。</p>\n<p>Q: <code>screen</code>关键词是指设备物理屏幕的大小还是指浏览器的视窗？</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> <span class=\"hljs-keyword\">only</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">max-width</span>: <span class=\"hljs-number\">1024px</span>) &#123;<span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>A: 浏览器视窗</p>\n<h2 id=\"href-和-src的区别\"><a href=\"#href-和-src的区别\" class=\"headerlink\" title=\"href 和 src的区别\"></a>href 和 src的区别</h2><p><strong>1.请求资源类型不同</strong><br>href，超文本引用，用于建立文档与资源的联系，常用的有：link、a。<br>src，将其所指向的资源下载并应用到当前页面，常见的有script、img。<br><strong>2.作用结果不同</strong><br>href，用于文档与资源之间确立联系。<br>src，请求到的资源替换当前内容。</p>\n<p><strong>3.浏览器的解析不同</strong><br>href，将资源解析成css文件，并行加载请求资源，不会阻塞对当前文档的处理。<br>src，会暂停其他资源的处理，直到该资源加载、解析和执行完毕，将其所指向资源应用到当前内容。这也是为什么把js文件放在底部而不是头部发热原因</p>\n<h2 id=\"首屏加载白屏怎么优化\"><a href=\"#首屏加载白屏怎么优化\" class=\"headerlink\" title=\"首屏加载白屏怎么优化\"></a>首屏加载白屏怎么优化</h2><p>1.使用CDN减少代码体积，加快请求速度；</p>\n<p>2.SSR通过服务端把所有数据全部渲染完成再返回给客户端</p>\n<p>3.路由懒加载</p>\n<p>4.使用外链CSS，JS文件</p>\n<p>5.开机GZIP压缩</p>\n<p>6.使用骨架屏</p>\n<h2 id=\"输入url到打开页面，都做了什么\"><a href=\"#输入url到打开页面，都做了什么\" class=\"headerlink\" title=\"输入url到打开页面，都做了什么\"></a>输入url到打开页面，都做了什么</h2><p>1.输入url，查找缓存，浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容，如果没有则进行下一步</p>\n<p>2.DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中域名对应的IP地址</p>\n<p>3.TCP握手：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</p>\n<p>4.HTTP请求：浏览器发起读取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给服务器；</p>\n<p>5.HTTP响应返回数据结果；</p>\n<p>6.通过四次挥手关闭/释放TCP连接；</p>\n<p>7.浏览器解析数据并渲染页面</p>\n<h2 id=\"TCP的三次握手和四次挥手\"><a href=\"#TCP的三次握手和四次挥手\" class=\"headerlink\" title=\"TCP的三次握手和四次挥手\"></a>TCP的三次握手和四次挥手</h2><p>三次握手是客户端和服务器之间建立连接，并进行通信的过程。相当于客户端和服务器之间你来我往的三个步骤</p>\n<ul>\n<li>第一次握手是建立连接，客户端发送连接请求报文，并传送规定的数据包；</li>\n<li>第二次握手是服务器端包是接收到连接请求报文，并回传规定的数据包</li>\n<li>第三次握手是客户端接收到服务器回传的数据包后，再次给服务器端发送数据包</li>\n</ul>\n<p>这样就完成了客户端跟服务器的连接和数据传送；</p>\n<p>三次握手的目的：</p>\n<p>双方确认自己与对方的发送与接收是正常的。</p>\n<p>四次挥手表示当前连接请求已经结束，要断开这次连接。</p>\n<ul>\n<li>第一次挥手是客户端对服务器发起断开请求</li>\n<li>第二次挥手是服务器表示收到这次断开请求</li>\n<li>第三次挥手是服务器表示已经断开连接；</li>\n<li>第四次挥手是客户端已经断开连接</li>\n</ul>\n<h2 id=\"清除浮动的四种办法\"><a href=\"#清除浮动的四种办法\" class=\"headerlink\" title=\"清除浮动的四种办法\"></a>清除浮动的四种办法</h2><ol>\n<li>clear:both; 在最后面加一个盒子</li>\n<li>overflow:hidden;  父盒子</li>\n<li>伪元素:after  父盒子</li>\n<li>双伪元素   父盒子</li>\n</ol>\n<h2 id=\"Vue的生命周期钩子\"><a href=\"#Vue的生命周期钩子\" class=\"headerlink\" title=\"Vue的生命周期钩子\"></a>Vue的生命周期钩子</h2><p>beforCreated</p>\n<p>Created</p>\n<p>beforeMounted</p>\n<p>Mounted</p>\n<p>beforeUpdated</p>\n<p>updated</p>\n<p>beforeDestory</p>\n<p>destoryed</p>\n<p>Actived</p>\n<p>Deactived</p>\n<h2 id=\"什么是闭包，闭包解决了什么问题\"><a href=\"#什么是闭包，闭包解决了什么问题\" class=\"headerlink\" title=\"什么是闭包，闭包解决了什么问题\"></a>什么是闭包，闭包解决了什么问题</h2><p>闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来.</p>\n<p><strong>我们可以用来保存一些内容，还可以用来保护一些私有的变量。我们总结出闭包有两个作用，分别为保护和保存。</strong></p>\n<p>团队开发时，每个开发者把自己的代码放在一个私有的作用域中，防止相互之间的变量命名冲突；把需要提供给别人的方法，通过 return 或 window.xxx 的方式暴露在全局下。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p> 总结：   </p>\n<p>1、当一个对象查找属性和方法时会从自身查找,如果查找不到则会通过__proto__指向被实例化的构造函数的prototype      </p>\n<p>2、隐式原型也是一个对象,是指向我们构造函数的原型      </p>\n<p>3、除了最顶层的Object对象没有<code>__proto__</code>，其他所有的对象都有__proto__,这是隐式原型 </p>\n<p>4、隐式原型__proto__的作用是让对象通过它来一直往上查找属性或方法，直到找到最顶层的Object的__proto__属性，它的值是null,这个查找的过程就是原型链</p>\n<h2 id=\"箭头函数和普通函数的区别\"><a href=\"#箭头函数和普通函数的区别\" class=\"headerlink\" title=\"箭头函数和普通函数的区别\"></a>箭头函数和普通函数的区别</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">（1）箭头函数比普通函数更加简洁<br>    如果没有参数，就直接写一个空括号即可<br>    如果只有一个参数，可以省去参数括号<br>    如果有多个参数，用逗号分割<br>    如果函数体的返回值只有一句，可以省略大括号<br>    如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常用的就是调用一个函数：<br>    let fn = () =&gt; void doesNotReturn()<br>    <br> (2) 箭头函数没有自己的this<br> 箭头函数不会创建自己的this,所以它没有自己的this,它只会在自己作用域的上一层继承this。所以箭头函数中的this的指向在它在定义时一家确定了，之后不会改变。<br> <br>（3）箭头函数继承来的this指向永远不会改变<br><br> (4) call()、apply()、bind()等方法不能改变箭头函数中的this指向 <br> <br> (5) 箭头函数不能作为构造函数使用<br> <br> (6) 箭头函数没有自己的arguments<br> <br> (7) 箭头函数没有prototype<br> <br> (8) 箭头函数不能用作Generator函数,不能使用yeild关键字<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"localStorage-sessionStorage-cookies-有什么区别\"><a href=\"#localStorage-sessionStorage-cookies-有什么区别\" class=\"headerlink\" title=\"localStorage  sessionStorage  cookies 有什么区别?\"></a>localStorage  sessionStorage  cookies 有什么区别?</h2><p>localStorage:以键值对的方式存储 储存时间没有限制 永久生效 除非自己删除记录<br>sessionStorage：当页面关闭后被清理与其他相比不能同源窗口共享 是会话级别的存储方式<br>cookies 数据不能超过4k 同时因为每次http请求都会携带cookie 所有cookie只适合保存很小的数据 如会话标识</p>\n<h2 id=\"Vuex有哪些基本属性-为什么-Vuex-的-mutation-中不能做异步操作\"><a href=\"#Vuex有哪些基本属性-为什么-Vuex-的-mutation-中不能做异步操作\" class=\"headerlink\" title=\"Vuex有哪些基本属性?为什么 Vuex 的 mutation 中不能做异步操作?\"></a>Vuex有哪些基本属性?为什么 Vuex 的 mutation 中不能做异步操作?</h2><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module<br>1、state =&gt; 基本数据(数据源存放地)<br>2、getters =&gt; 从基本数据派生出来的数据<br>3、mutations =&gt; 提交更改数据的方法，同步<br>4、actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。<br>5、modules =&gt; 模块化Vuex</p>\n<p>1、Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。<br>2、每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p>\n<h2 id=\"常见的水平居中\"><a href=\"#常见的水平居中\" class=\"headerlink\" title=\"常见的水平居中\"></a>常见的水平居中</h2><ol>\n<li><p>```css<br> .father{</p>\n<pre><code> display:flex;\n justify-content:center;\n align-items:center;\n</code></pre>\n<p> }</p>\n<p> .son{<br> ….<br> }</p>\n <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><br><span class=\"hljs-number\">2</span>. 绝对定位 <br><br>\t```css<br>\t<span class=\"hljs-selector-class\">.father</span> &#123;<br>\t    <span class=\"hljs-attribute\">position</span>: relative;<br>\t&#125;<br>\t<span class=\"hljs-selector-class\">.son</span> &#123;<br>\t    <span class=\"hljs-attribute\">position</span>: absolute;<br>\t    <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>;<br>\t    <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">0</span>;<br>\t    <span class=\"hljs-attribute\">bottom</span>: <span class=\"hljs-number\">0</span>;<br>\t    <span class=\"hljs-attribute\">right</span>: <span class=\"hljs-number\">0</span>;<br>\t    <span class=\"hljs-attribute\">margin</span>: auto;<br>\t&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>绝对定位配合transform</p>\n <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.father</span> &#123;<br>    <span class=\"hljs-attribute\">position</span>: relative;<br>&#125;<br><span class=\"hljs-selector-class\">.son</span> &#123;<br>    <span class=\"hljs-attribute\">position</span>: absolute;<br>    <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">50%</span>;<br>    <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">50%</span>;<br>    <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translate</span>(-<span class=\"hljs-number\">50%</span>, -<span class=\"hljs-number\">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"Js的基本类型和引用类型\"><a href=\"#Js的基本类型和引用类型\" class=\"headerlink\" title=\"Js的基本类型和引用类型\"></a>Js的基本类型和引用类型</h2><p>基本类型：undefined , string, number, null ,bigint,boolean,symbol</p>\n<p>引用类型: Object,function,array</p>\n<p>typeof/instanceof</p>\n<h2 id=\"TypeScript的-type和-interface-的区别\"><a href=\"#TypeScript的-type和-interface-的区别\" class=\"headerlink\" title=\"TypeScript的 type和 interface 的区别\"></a>TypeScript的 type和 interface 的区别</h2><p>interface可以重复声明，type不行，继承方式不一样，type使用交叉类型方式，interface使用extends实现。在对象扩展的情况下，使用接口继承要比交叉类型的性能更好。建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tsx\"><span class=\"hljs-keyword\">interface</span> iMan &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><span class=\"hljs-comment\">// 接口可以进行声明合并</span><br><span class=\"hljs-keyword\">interface</span> iMan &#123;<br>  <span class=\"hljs-attr\">hobby</span>: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> tMan = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;;<br><span class=\"hljs-comment\">// type不能重复定义</span><br><span class=\"hljs-comment\">// type tMan = &#123;&#125;</span><br><br><span class=\"hljs-comment\">// 继承方式不同,接口继承使用extends</span><br><span class=\"hljs-keyword\">interface</span> iManPlus <span class=\"hljs-keyword\">extends</span> iMan &#123;<br>  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><span class=\"hljs-comment\">// type继承使用&amp;，又称交叉类型</span><br><span class=\"hljs-keyword\">type</span> tManPlus = &#123; <span class=\"hljs-attr\">height</span>: <span class=\"hljs-built_in\">string</span> &#125; &amp; tMan;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">aMan</span>: iManPlus = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;aa&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">15</span>,<br>  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-string\">&quot;175cm&quot;</span>,<br>  <span class=\"hljs-attr\">hobby</span>: <span class=\"hljs-string\">&quot;eat&quot;</span>,<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">bMan</span>: tManPlus = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;bb&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">15</span>,<br>  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-string\">&quot;150cm&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"常见的工具类型\"><a href=\"#常见的工具类型\" class=\"headerlink\" title=\"常见的工具类型\"></a>常见的工具类型</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">Partial：满足部分属性(一个都没满足也可)即可<br>Required：所有属性都需要<br>Readonly: 包装后的所有属性只读<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"computed-和-watch-的区别\"><a href=\"#computed-和-watch-的区别\" class=\"headerlink\" title=\"computed 和 watch 的区别\"></a>computed 和 watch 的区别</h2><p>使用场景：computed适用于一个数据受多个数据影响使用；watch适合一个数据影响多个数据使用。</p>\n<p>区别：computed属性默认会走<strong>缓存</strong>，只有依赖数据发生变化，才会重新计算，不支持异步，有异步导致数据发生变化时，无法做出相应改变；watch不依赖缓存，一旦数据发生变化就直接触发响应操作，支持异步。</p>\n<h2 id=\"浏览器渲染页面的过程\"><a href=\"#浏览器渲染页面的过程\" class=\"headerlink\" title=\"浏览器渲染页面的过程\"></a>浏览器渲染页面的过程</h2><p>首先输入一个网址，浏览器会向服务器发起DNS请求，得到对应的IP地址（会被缓存一段时间，后续访问就不用再去向服务器查询）。之后会进行TCP三次握手与服务器建立连接，连接建立后，浏览器会代表用户发送一个初始的GET请求，通常是请求一个HTML文件。服务器收到对应请求后 ，会根据相关的响应头和HTML内容进行回复。</p>\n<p>一旦浏览器拿到了数据，就会开始解析信息，这个过程中，浏览器会根据HTML文件去构建DOM树，当遇到一些阻塞资源时（如同步加载的script标签）会去加载阻塞资源而停止当前DOM树构建（所以能够异步的或延迟加载的就尽量异步或延迟，同时页面的脚本还是越少越好）。在构建DOM树时，浏览器的主线程被占据着，不过浏览器的预加载扫描器会去请求高优先级的资源（如css、js、字体），预加载扫描器很好的优化了阻塞问题。接下来浏览器会处理CSS生成CSSDOM树，将CSS规则转换为可以理解和使用的样式映射，这个过程非常快（通常小于一次DNS查询所需时间）。有了DOM树和CSSDOM树，浏览器会将其组合生成一个Render树，计算样式或渲染树会从DOM的根节点开始构建，遍历每一个可见节点（将相关样式匹配到每一个可见节点，并根据CSS级联去的每个节点的计算样式）。接下来开始布局，该过程（依旧是从根节点开始）会确定所有节点的宽高和位置，最后通过渲染器将其在页面上绘制。绘制完成了，并不代表交互也都生效了，因为主线程可能还无法抽出时间去处理滚动、触摸等交互，要等到js加载完成，同时主线程空闲了整个页面才是正常可用的状态。</p>\n<h2 id=\"webpack中plugin和loader分别做什么？它们之间的执行顺序？\"><a href=\"#webpack中plugin和loader分别做什么？它们之间的执行顺序？\" class=\"headerlink\" title=\"webpack中plugin和loader分别做什么？它们之间的执行顺序？\"></a>webpack中plugin和loader分别做什么？它们之间的执行顺序？</h2><ul>\n<li>loader：用于将不同类型的文件转换成webpack可以识别的文件（webpack只认识js和json）。</li>\n<li>plugin：存在于webpack整个生命周期中，是一种基于事件机制工作的模式，可以在webpck打包过程对某些节点做某些定制化处理。同时plugin可以对loader解析过程中做一些处理，协同处理文件。</li>\n<li>执行顺序：两者不存在明显的先后顺序，不过webpack在初始化处理时，会优先识别到plugin中的内容。</li>\n</ul>\n<h2 id=\"webpack常见的优化方案\"><a href=\"#webpack常见的优化方案\" class=\"headerlink\" title=\"webpack常见的优化方案\"></a>webpack常见的优化方案</h2><ul>\n<li>基于esm的tree shaking</li>\n<li>对balel设置缓存，缩小babel-loader的处理范围,及精准指定要处理的目录。</li>\n<li>压缩资源（mini-css-extract-plugin，compression-webpack-plugin）</li>\n<li>配置资源的按需引入（第三方组件库）</li>\n<li>配置splitChunks来进行按需加载（根据）</li>\n<li>设置CDN优化</li>\n</ul>\n<h2 id=\"app-use的原理\"><a href=\"#app-use的原理\" class=\"headerlink\" title=\"app.use的原理\"></a>app.use的原理</h2><p>vue中使用插件的方法</p>\n<h2 id=\"左边固定，右边自适应\"><a href=\"#左边固定，右边自适应\" class=\"headerlink\" title=\"左边固定，右边自适应\"></a>左边固定，右边自适应</h2><ol>\n<li><p>浮动</p>\n<p> 左边设置固定宽度,向左浮动，右边设置<code>margin-left:100px;width:auto</code></p>\n</li>\n<li><p>BFC+浮动</p>\n</li>\n</ol>\n<p>​    左边设置固定宽度，向左浮动，右边设置overflow:hidden 触发BFC</p>\n<ol start=\"3\">\n<li>flex:1(flex-basic:auto,flex-shrink:1,flex-grow:1)</li>\n<li>grid布局</li>\n</ol>\n<p>​    grid-template-columns:100px 1fr; 这样子的话就是右边自适应</p>\n<ol start=\"5\">\n<li>绝对定位</li>\n</ol>\n<p>​    左元素设置为绝对定位，left:0,width:100px</p>\n<p>​    右元素设置为left:100</p>\n<h2 id=\"scoped的执行原理\"><a href=\"#scoped的执行原理\" class=\"headerlink\" title=\"scoped的执行原理\"></a>scoped的执行原理</h2><p>当一个style标签拥有scoped属性时，它的CSS样式就只能作用于当前的组件，通过该属性，可以使得组件之间的样式不互相污染。</p>\n<p>Vue中的scoped属性的效果主要是通过PostCss实现的。给一个组件中的所有dom添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom,这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.home</span>&#123;<br>\t<span class=\"hljs-attribute\">color</span>:red;<br>&#125;<br><br>-------------<br><span class=\"hljs-selector-class\">.home</span><span class=\"hljs-selector-attr\">[data-v-e172323]</span>&#123;<br>    <span class=\"hljs-attribute\">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"样式穿透的原理\"><a href=\"#样式穿透的原理\" class=\"headerlink\" title=\"样式穿透的原理\"></a>样式穿透的原理</h2><p>普通的css语法: 在要修改的样式前添加 &gt;&gt;&gt; 符号</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.demo</span> &gt;&gt;&gt; <span class=\"hljs-selector-class\">.el-table</span>&#123;<br>    <span class=\"hljs-attribute\">border</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>scss语法: 在要修改的样式前添加 ::v-deep</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">::v-deep .el-table&#123;<br>    <span class=\"hljs-attribute\">border</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>sass语法/less语法 : 在要修改的样式前添加 /deep/</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\">.demo <span class=\"hljs-regexp\">/deep/</span> .el<span class=\"hljs-operator\">-</span>table&#123;<br>    border:none;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>用了样式穿透后，被穿透的dom不会再加上唯一标识[data-v-xxxxxx]</p>\n<h2 id=\"水平垂直居中，垂直居中\"><a href=\"#水平垂直居中，垂直居中\" class=\"headerlink\" title=\"水平垂直居中，垂直居中\"></a>水平垂直居中，垂直居中</h2><p>水平垂直居中： </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">text-align</span>:center;  //只对inline起作用<br><br><span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-number\">0</span> auto;  //<span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-number\">0</span> auto;是对元素自身(block)起作用，<br><br><span class=\"hljs-attribute\">position</span>:absoult;<br><span class=\"hljs-attribute\">top</span>:<span class=\"hljs-number\">50%</span>;<br><span class=\"hljs-attribute\">left</span>:<span class=\"hljs-number\">50%</span>;<br><span class=\"hljs-attribute\">transform</span>:<span class=\"hljs-built_in\">translate</span>(-<span class=\"hljs-number\">50%</span>,-<span class=\"hljs-number\">50%</span>)<br><br>display:flex;<br><span class=\"hljs-attribute\">justify-content</span>:center;<br>align-item:center;<br><br><span class=\"hljs-attribute\">display</span>:grid;<br><span class=\"hljs-attribute\">align-items</span>: center;<br><span class=\"hljs-attribute\">justify-content</span>: center;<br></code></pre></td></tr></table></figure>\n\n<p>垂直居中</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">line-height</span> === <span class=\"hljs-attribute\">height</span><br><br><span class=\"hljs-attribute\">vertical-align</span>:middle<br><br><br>.father&#123;<br>    <span class=\"hljs-attribute\">display</span>:flex;<br>&#125;<br><span class=\"hljs-selector-class\">.son</span>&#123;<br>    <span class=\"hljs-attribute\">align-self</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"flex-和-grid的一些属性\"><a href=\"#flex-和-grid的一些属性\" class=\"headerlink\" title=\"flex 和 grid的一些属性\"></a>flex 和 grid的一些属性</h2><p>看mdn吧，太多了</p>\n<h2 id=\"less-和-scss\"><a href=\"#less-和-scss\" class=\"headerlink\" title=\"less 和 scss\"></a>less 和 scss</h2><h2 id=\"css-module\"><a href=\"#css-module\" class=\"headerlink\" title=\"css module\"></a>css module</h2><h2 id=\"git的一些操作\"><a href=\"#git的一些操作\" class=\"headerlink\" title=\"git的一些操作\"></a>git的一些操作</h2><blockquote>\n<p> git stash 怎么恢复回来?</p>\n</blockquote>\n<p>1.使用git status指令查看当前文件状态。</p>\n<p>2.然后，使用指令git stash 将文件修改缓存。</p>\n<p>3.使用git status指令确认当前分支没有修改内容。</p>\n<p>4.使用指令git stash list，查看当前缓存列表。</p>\n<p>5.使用指令git stash apply stash@{id}，恢复指令ID的缓存内容，并且保留缓存条目。</p>\n<p>6.使用git stash pop 恢复最新的stash，同时删除恢复的缓存条目。</p>\n<blockquote>\n<p>git reset 和 git revert的区别</p>\n</blockquote>\n<p>- git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；<br>- git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除</p>\n<h2 id=\"es6-的新特性以及具体内容\"><a href=\"#es6-的新特性以及具体内容\" class=\"headerlink\" title=\"es6 的新特性以及具体内容\"></a>es6 的新特性以及具体内容</h2><p>1.新增了块级作用域（let，const），TDZ</p>\n<p>2.提供了定义类的语法糖（class）</p>\n<p>3.新增了一种基本数据类型（Symbol）</p>\n<p>4.新增了变量的解构赋值</p>\n<p>5.函数参数允许设置默认值，引入了rest参数，新增了箭头函数。</p>\n<p>6.数组新增了一些API，如isArray / from / of 方法；数组实例新增了 entries()，keys() 和 values() 等方法。</p>\n<p>7.对象和数组新增了扩展运算符</p>\n<p>8.ES6新增了模块化（import / export）</p>\n<p>9.ES6新增了Set和Map数据结构。</p>\n<p>10.ES6原生提供Proxy构造函数，用来生成Proxy实例</p>\n<p>11.ES6新增了生成器（Generator）和遍历器（Iterator）</p>\n<p>12.模板字符串</p>\n<p>13.promise</p>\n<h2 id=\"promise-all-和-promise-race\"><a href=\"#promise-all-和-promise-race\" class=\"headerlink\" title=\"promise.all() 和 promise.race()\"></a>promise.all() 和 promise.race()</h2><p>promise.all()返回的结果由所有的结果而定，如果返回中有一个失败，那就是失败的，如果全部成功就是成功的</p>\n<p>promise.race()返回的结果由最先返回的那个promise来决定，第一个返回的是失败就是失败</p>\n<h2 id=\"rem-和-em-的区别\"><a href=\"#rem-和-em-的区别\" class=\"headerlink\" title=\"rem 和 em 的区别\"></a>rem 和 em 的区别</h2><ul>\n<li>px是固定的单位长度，一旦设置了就无法随页面的大小而适应改变。</li>\n<li>em是相对长度单位，比px更具灵活性，em的长度是相对于父元素</li>\n<li>rem的长度是相对于根元素，也就是html的字体大小</li>\n</ul>\n<h2 id=\"怎么新建set的集合\"><a href=\"#怎么新建set的集合\" class=\"headerlink\" title=\"怎么新建set的集合\"></a>怎么新建set的集合</h2><p>直接 new Set() 会直接报错</p>\n<p>Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来进行数据初始化。</p>\n<p>let i = new Set([1,2])</p>\n<p>操作方法:<br>add(value)　　　　添加数据，并返回新的 Set 结构<br>delete(value)　　　删除数据，返回一个布尔值，表示是否删除成功<br>has(value)　　　　查看是否存在某个数据，返回一个布尔值<br>clear()　　　　　　清除所有数据，没有返回值</p>\n<p><strong>遍历方法:</strong></p>\n<p>Set 提供了三个遍历器生成函数和一个遍历方法。<br>keys()　　　　 返回一个键名的遍历器<br>values()　　　 返回一个键值的遍历器<br>entries()　　　 返回一个键值对的遍历器<br>forEach()　　　使用回调函数遍历每个成员</p>\n<h2 id=\"js实现栈\"><a href=\"#js实现栈\" class=\"headerlink\" title=\"js实现栈\"></a>js实现栈</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//stack 栈  数组就是一个很完美的栈结构</span><br><span class=\"hljs-comment\">//functions: pop,push,peek,length</span><br><br><span class=\"hljs-keyword\">let</span> stack = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span> = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span> = &#123;&#125;;<br><br>    <span class=\"hljs-comment\">//给栈中添加一个元素 push</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">push</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>[<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>] = value;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//给栈中移除一个元素 pop</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">pop</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span> === <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;<br>        &#125;<br><br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>--;<br>        <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>[<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>]<br>        <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>[<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>]<br><br>        <span class=\"hljs-keyword\">return</span> result<br>    &#125;<br><br>    <span class=\"hljs-comment\">//栈的大小</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">length</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//返回栈顶的元素</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">peek</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>[<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>-<span class=\"hljs-number\">1</span>]<br>    &#125;<br>&#125;<br><br><br><span class=\"hljs-keyword\">let</span> myStack = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">stack</span>();<br><br>myStack.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">1</span>)<br>myStack.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">2</span>)<br>myStack.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">3</span>)<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myStack);   <span class=\"hljs-comment\">//  storage: &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3 &#125;,</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myStack.<span class=\"hljs-title function_\">peek</span>());   <span class=\"hljs-comment\">//3</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myStack.<span class=\"hljs-title function_\">pop</span>());     <span class=\"hljs-comment\">//3</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myStack.<span class=\"hljs-title function_\">length</span>());    <span class=\"hljs-comment\">//2</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"for-of-和-for-in-的区别\"><a href=\"#for-of-和-for-in-的区别\" class=\"headerlink\" title=\"for of 和 for in 的区别\"></a>for of 和 for in 的区别</h2><p>for in  可以用在数组吗？</p>\n<p>是可以的，因为for…in（值） 本身是对象的遍历方法，数组也属于对象，但是最好不用，数组的遍历可以用 for..of（索引） , for Each</p>\n<p>理由如下：</p>\n<ol>\n<li>for…in 的属性值是字符串，可以会导致错误</li>\n<li>for…in 遍历的是可迭代对象，原型上的属性也可能会被遍历到</li>\n<li>for…in  不是按照数组下标顺序来遍历的，是按照对象属性的枚举属性</li>\n</ol>\n<h2 id=\"中序遍历二叉树\"><a href=\"#中序遍历二叉树\" class=\"headerlink\" title=\"中序遍历二叉树\"></a>中序遍历二叉树</h2><h2 id=\"数组去重的几种办法\"><a href=\"#数组去重的几种办法\" class=\"headerlink\" title=\"数组去重的几种办法\"></a>数组去重的几种办法</h2><ol>\n<li>Array.from(new Set(arr))</li>\n<li>双重for循环</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i&lt;len;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> j = i+<span class=\"hljs-number\">1</span>;j&lt;len;j++)&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(arr[i] === arr[j])&#123;<br>\t\t\tarr.<span class=\"hljs-title function_\">splice</span>(j,<span class=\"hljs-number\">1</span>)<span class=\"hljs-comment\">//删除第二个</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>3.利用indexOf</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">methods3</span>(<span class=\"hljs-params\">arr</span>) &#123;<br><br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(arr)) &#123;<br><br>        <span class=\"hljs-keyword\">return</span>;<br><br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> array = [];<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-property\">length</span>; i++) &#123;<br><br>        <span class=\"hljs-keyword\">if</span> (array .<span class=\"hljs-title function_\">indexOf</span>(arr[i]) === -<span class=\"hljs-number\">1</span>) &#123;<br><br>            array .<span class=\"hljs-title function_\">push</span>(arr[i])<br><br>        &#125;<br><br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> array;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>4.利用sort排序，看看左右两个是否一样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">methods4</span>(<span class=\"hljs-params\">arr</span>) &#123;<br><br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(arr)) &#123;<br><br>        <span class=\"hljs-keyword\">return</span>;<br><br>    &#125;<br><br>    arr = arr.<span class=\"hljs-title function_\">sort</span>()<br><br>    <span class=\"hljs-keyword\">var</span> arrry= [arr[<span class=\"hljs-number\">0</span>]];<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt; arr.<span class=\"hljs-property\">length</span>; i++) &#123;<br><br>        <span class=\"hljs-keyword\">if</span> (arr[i] !== arr[i-<span class=\"hljs-number\">1</span>]) &#123;<br><br>            arrry.<span class=\"hljs-title function_\">push</span>(arr[i]);<br><br>        &#125;<br><br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> arrry;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>5.利用includes</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">methods6</span>(<span class=\"hljs-params\">arr</span>) &#123;<br><br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(arr)) &#123;<br><br>        <span class=\"hljs-keyword\">return</span><br><br>    &#125;<br><br>    <span class=\"hljs-keyword\">var</span> array =[];<br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-property\">length</span>; i++) &#123;<br><br>            <span class=\"hljs-keyword\">if</span>( !array.<span class=\"hljs-title function_\">includes</span>( arr[i]) ) &#123;<span class=\"hljs-comment\">//includes 检测数组是否有某个值</span><br><br>                    array.<span class=\"hljs-title function_\">push</span>(arr[i]);<br><br>              &#125;<br><br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> array<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>6.利用Map，递归，filter</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">methods10</span>(<span class=\"hljs-params\">arr</span>) &#123;<br><br>    <span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><br>    <span class=\"hljs-keyword\">let</span> array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>();<span class=\"hljs-comment\">// 数组用于返回结果</span><br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-property\">length</span>; i++) &#123;<br><br>      <span class=\"hljs-keyword\">if</span>(map .<span class=\"hljs-title function_\">has</span>(arr[i])) &#123;<span class=\"hljs-comment\">// 如果有该key值</span><br><br>        map .<span class=\"hljs-title function_\">set</span>(arr[i], <span class=\"hljs-literal\">true</span>); <br><br>      &#125; <span class=\"hljs-keyword\">else</span> &#123; <br><br>        map .<span class=\"hljs-title function_\">set</span>(arr[i], <span class=\"hljs-literal\">false</span>);<span class=\"hljs-comment\">// 如果没有该key值</span><br><br>        array .<span class=\"hljs-title function_\">push</span>(arr[i]);<br><br>      &#125;<br><br>    &#125; <br><br>    <span class=\"hljs-keyword\">return</span> array ;<br><br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>7.利用reduce</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>];<br><span class=\"hljs-keyword\">let</span> filterArr = arr.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">pre, cur, index, array</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (pre.<span class=\"hljs-title function_\">includes</span>(cur) === <span class=\"hljs-literal\">false</span>) &#123;<br>      pre = [...pre, cur];<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> pre;<br>&#125;, [])<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(filterArr); <span class=\"hljs-comment\">// [1,2,6]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"forEach-和-Map的区别\"><a href=\"#forEach-和-Map的区别\" class=\"headerlink\" title=\"forEach 和 Map的区别\"></a>forEach 和 Map的区别</h2><p>map有返回值，forEach没有，都不可以改变原数组，除非你在callback里面改（giao,为什么要问这种问题）</p>\n<h2 id=\"自定义一个v-model\"><a href=\"#自定义一个v-model\" class=\"headerlink\" title=\"自定义一个v-model\"></a>自定义一个v-model</h2><p>v-model是vue中的一个语法糖，实现数据的双向绑定</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;input<br>    :value=&quot;parentData&quot;<br>    @input=&quot;parentData = $event.target.value&quot;<br>&gt;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"vueRouter传参数的几种办法\"><a href=\"#vueRouter传参数的几种办法\" class=\"headerlink\" title=\"vueRouter传参数的几种办法\"></a>vueRouter传参数的几种办法</h2><h4 id=\"一-router-link路由导航方式传参\"><a href=\"#一-router-link路由导航方式传参\" class=\"headerlink\" title=\"一.router-link路由导航方式传参\"></a>一.router-link路由导航方式传参</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//路由配置   &#123;path:&#x27;/father/son/:num&#x27;,name:A,component:A&#125;</span><br>&lt;router-link to=<span class=\"hljs-string\">&quot;/path/num&quot;</span>&gt;&lt;/router-link&gt;<br><span class=\"hljs-comment\">//子组件通过  this.$route.params.num 接受参数</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"二、调用-router-push实现路由传参\"><a href=\"#二、调用-router-push实现路由传参\" class=\"headerlink\" title=\"二、调用$router.push实现路由传参\"></a>二、调用$router.push实现路由传参</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//路由配置： &#123;path: &#x27;/d/:id&#x27;, name: D, component: D&#125;</span><br><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$router</span>.<span class=\"hljs-title function_\">push</span>(&#123;<br>\t<span class=\"hljs-attr\">path</span>:<span class=\"hljs-string\">&#x27;/d/:id&#x27;</span><br>&#125;)<br><br><span class=\"hljs-comment\">//子组件通过  this.$route.params.id  接受参数</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"三-通过路由属性name匹配路由，再根据params传递参数\"><a href=\"#三-通过路由属性name匹配路由，再根据params传递参数\" class=\"headerlink\" title=\"三.通过路由属性name匹配路由，再根据params传递参数\"></a>三.通过路由属性name匹配路由，再根据params传递参数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//路由配置： &#123;name:&quot;B&quot;,path:&#x27;/asdsdasd/asdd&#x27;,component:B&#125; 无所谓path，但是name一定要对应</span><br><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$router</span>.<span class=\"hljs-title function_\">push</span>(&#123;<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;B&#x27;</span>,<br>        <span class=\"hljs-attr\">params</span>: &#123;<br>          <span class=\"hljs-attr\">context</span>: <span class=\"hljs-string\">&#x27;吴又可吴又可吴又可&#x27;</span><br>        &#125;<br>      &#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"四-通过query传参数\"><a href=\"#四-通过query传参数\" class=\"headerlink\" title=\"四.通过query传参数\"></a>四.通过query传参数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 路由配置  &#123;path: &#x27;/c&#x27;, name: &#x27;C&#x27;, component: C&#125;</span><br><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$router</span>.<span class=\"hljs-title function_\">push</span>(&#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/c&#x27;</span>,<br>        <span class=\"hljs-attr\">query</span>: &#123;<br>          <span class=\"hljs-attr\">context</span>: <span class=\"hljs-string\">&#x27;吴又可吴又可&#x27;</span><br>        &#125;<br>      &#125;)<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"v-router的query和params的区别\"><a href=\"#v-router的query和params的区别\" class=\"headerlink\" title=\"v-router的query和params的区别\"></a>v-router的query和params的区别</h2><h2 id=\"webpack配置\"><a href=\"#webpack配置\" class=\"headerlink\" title=\"webpack配置\"></a>webpack配置</h2><h2 id=\"数组的一些方法\"><a href=\"#数组的一些方法\" class=\"headerlink\" title=\"数组的一些方法\"></a>数组的一些方法</h2><p><code>join</code> 连接数组变成字符串,不会改变原数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>];<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;-&#x27;</span>))  <span class=\"hljs-comment\">//&quot;1-2-3-4&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><code>split</code> 将字符串拆分为数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> S = arr.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;-&#x27;</span>)<br>arr.<span class=\"hljs-title function_\">split</span>(s)  <span class=\"hljs-comment\">//[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;]</span><br></code></pre></td></tr></table></figure>\n\n<p><code>slice</code>使用 <code>slice</code> 方法从数组中截取部分元素组合成新数组（并不会改变原数组），不传第二个参数时截取到数组的最后元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">arr.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">//[1,2,3]</span><br></code></pre></td></tr></table></figure>\n\n<p><code>splice</code> 使用<code>splice</code> 方法可以添加、删除、替换数组中的元素，会对原数组进行改变，返回值为删除的元素。</p>\n<p>删除数组元素第一个参数为从哪开始删除，第二个参数为删除的数量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>];<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">//返回删除的元素 [1, 2, 3]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr); <span class=\"hljs-comment\">//删除数据后的原数组 [0, 4, 5, 6]</span><br></code></pre></td></tr></table></figure>\n\n<p><code>concat</code>方法用于连接两个或多个数组，元素是值类型的是复制操作，如果是引用类型还是指向同一对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>]<br>arr2 = [<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>]<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr.<span class=\"hljs-title function_\">concat</span>(arr1,arr2))<br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>indexOf</code> (<code>lastIndexOf</code>)从前向后(从后向前)查找元素出现的位置，如果找不到返回 <code>-1</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">6</span>];<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr.<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// 2 从前面查找2出现的位置</span><br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>includes</code> 查找字符串返回值是布尔类型更方便判断</p>\n<p>使用<code>includes</code>等不能查找引用类型，因为它们的内存地址是不相等的</p>\n<p>find 方法找到后会把值返回出来</p>\n<ul>\n<li>如果找不到返回值为<code>undefined</code></li>\n</ul>\n<p>返回第一次找到的值，不继续查找</p>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h3><p><code>sort</code>每次使用两个值进行比较 <code>Array.sort((a,b)=&gt;a-b</code></p>\n<ul>\n<li>返回负数 a 排在 b 前面，从小到大</li>\n<li>返回正数 b 排在 a 前面</li>\n<li>返回 0 时不动</li>\n</ul>\n<p>原理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">7</span>];<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-params\">array, callback</span>) &#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> n <span class=\"hljs-keyword\">in</span> array) &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> m <span class=\"hljs-keyword\">in</span> array) &#123;<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">callback</span>(array[n], array[m]) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">let</span> temp = array[n];<br>        array[n] = array[m];<br>        array[m] = temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> array;<br>&#125;<br>arr = <span class=\"hljs-title function_\">sort</span>(arr, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a - b;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"数组遍历\"><a href=\"#数组遍历\" class=\"headerlink\" title=\"数组遍历\"></a>数组遍历</h3><p>for循环</p>\n<p>forEach</p>\n<p><code>forEach</code>使函数作用在每个数组元素上，但是没有返回值。</p>\n<p>for…in…</p>\n<p>遍历时的 key 值为数组的索引</p>\n<p>for…of….</p>\n<p>遍历时的 key 值为数组的值</p>\n<p>map</p>\n<p><strong><code>map()</code></strong> 方法<strong>创建一个新数组</strong>，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。</p>\n<p><strong>语法</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">map</span>(callbackFn)<br><span class=\"hljs-title function_\">map</span>(callbackFn, thisArg)\t<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"在非数组对象上调用-map\"><a href=\"#在非数组对象上调用-map\" class=\"headerlink\" title=\"在非数组对象上调用 map()\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#%E5%9C%A8%E9%9D%9E%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8A%E8%B0%83%E7%94%A8_map\">在非数组对象上调用 map()</a></h3><p><code>map()</code> 方法读取 <code>this</code> 的 <code>length</code> 属性，然后访问每个整数索引。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arrayLike = &#123;<br>  <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">3</span>,<br>  <span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">2</span>,<br>  <span class=\"hljs-number\">1</span>: <span class=\"hljs-number\">3</span>,<br>  <span class=\"hljs-number\">2</span>: <span class=\"hljs-number\">4</span>,<br>&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">map</span>.<span class=\"hljs-title function_\">call</span>(arrayLike, <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> x ** <span class=\"hljs-number\">2</span>));<br><span class=\"hljs-comment\">// [ 4, 9, 16 ]</span><br><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\">reduce</a></p>\n<p><code>reduce()</code> 方法是一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95\">迭代方法</a>。它按升序对数组中的所有元素运行一个“reducer”回调函数，并将它们累积到一个单一的值中。每次调用时，<code>callbackFn</code> 的返回值都作为 <code>accumulator</code> 参数传递到下一次调用中。<code>accumulator</code> 的最终值（也就是在数组的最后一次迭代中从 <code>callbackFn</code> 返回的值）将作为 <code>reduce()</code> 的返回值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//每一次callbackFn返回的数据都会记录，并用于下次计算</span><br>arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>]<br><br>arr.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">accumulator,currentValue,currentIndex</span>)=&gt;</span>&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(accumulator,currentValue,currentIndex)<br>    <span class=\"hljs-keyword\">return</span> accumulator+currentValue<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"展开嵌套数组\"><a href=\"#展开嵌套数组\" class=\"headerlink\" title=\"展开嵌套数组\"></a>展开嵌套数组</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> flattened = [<br>  [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],<br>  [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>],<br>  [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>],<br>].<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">accumulator, currentValue</span>) =&gt;</span> accumulator.<span class=\"hljs-title function_\">concat</span>(currentValue), []);<br><span class=\"hljs-comment\">// flattened 的值是 [0, 1, 2, 3, 4, 5]</span><br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"统计对象中值出现的次数\"><a href=\"#统计对象中值出现的次数\" class=\"headerlink\" title=\"统计对象中值出现的次数\"></a>统计对象中值出现的次数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> names = [<span class=\"hljs-string\">&quot;Alice&quot;</span>, <span class=\"hljs-string\">&quot;Bob&quot;</span>, <span class=\"hljs-string\">&quot;Tiff&quot;</span>, <span class=\"hljs-string\">&quot;Bruce&quot;</span>, <span class=\"hljs-string\">&quot;Alice&quot;</span>];<br><br><span class=\"hljs-keyword\">const</span> countedNames = names.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">allNames, name</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> currCount = allNames[name] ?? <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    ...allNames,<br>    [name]: currCount + <span class=\"hljs-number\">1</span>,<br>  &#125;;<br>&#125;, &#123;&#125;);<br><span class=\"hljs-comment\">// countedNames 的值是：</span><br><span class=\"hljs-comment\">// &#123; &#x27;Alice&#x27;: 2, &#x27;Bob&#x27;: 1, &#x27;Tiff&#x27;: 1, &#x27;Bruce&#x27;: 1 &#125;</span><br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"VueRouter的钩子函数\"><a href=\"#VueRouter的钩子函数\" class=\"headerlink\" title=\"VueRouter的钩子函数\"></a>VueRouter的钩子函数</h2><ol>\n<li>全局的beforeEach（前置路由守卫）:进入页面登录判断、管理员权限判断、浏览器判断</li>\n</ol>\n<p>beforeEach(to,from,next)</p>\n<p>afterEach（后置路由守卫）</p>\n<ol start=\"2\">\n<li>单个组件的 beforeEnter</li>\n<li>组件内的 beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li>\n</ol>\n"},{"title":"【每日算法】长度为k的子数组的能量","date":"2024-11-06T01:47:01.000Z","index_img":"/img/post/leetcode.jpg","banner_img":null,"_content":"\n\n\n[长度为k的子数组的能量I](https://leetcode.cn/problems/find-the-power-of-k-size-subarrays-i/description/?envType=daily-question&envId=2024-11-06)\n\ntag:`数组` `滑动窗口`\n\n给你一个长度为 `n` 的整数数组 `nums` 和一个正整数 `k` 。\n\n一个数组的 **能量值** 定义为：\n\n- 如果 **所有** 元素都是依次 **连续** 且 **上升** 的，那么能量值为 **最大** 的元素。\n- 否则为 -1 。\n\n你需要求出 `nums` 中所有长度为 `k` 的 \n\n子数组\n\n 的能量值。\n\n\n\n请你返回一个长度为 `n - k + 1` 的整数数组 `results` ，其中 `results[i]` 是子数组 `nums[i..(i + k - 1)]` 的能量值。\n\n\n\n#### 示例一\n\n**输入：**nums = [1,2,3,4,3,2,5], k = 3\n\n**输出：**[3,4,-1,-1,-1]\n\n**解释：**\n\n`nums` 中总共有 5 个长度为 3 的子数组：\n\n- `[1, 2, 3]` 中最大元素为 3 。\n- `[2, 3, 4]` 中最大元素为 4 。\n- `[3, 4, 3]` 中元素 **不是** 连续的。\n- `[4, 3, 2]` 中元素 **不是** 上升的。\n- `[3, 2, 5]` 中元素 **不是** 连续的。\n\n\n\n#### 题解：\n\n```js\nconst ans = Array(nums.length - k + 1).fill(-1);\n    let cnt = 0;\n    for (let i = 0; i < nums.length; i++) {\n        cnt = i === 0 || nums[i] === nums[i - 1] + 1 ? cnt + 1 : 1;\n        if (cnt >= k) {\n            ans[i - k + 1] = nums[i];\n        }\n    }\n\treturn ans;\n}\n```\n\n#### 思路：\n\n要特别注意是**连续的**这个意思，就是一定是 num[i] === num[i] +1 ，这个才叫连续\n\n其实就是判断一个定长的窗口中是否是连续的，如果是就返回最大值\n\n要找连续上升的段。如果段长至少是 *k*，那么这段中的所有长为 *k* 的子数组都是符合要求的，子数组的最后一个元素是最大的。\n\n#### 最开始的写法\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar resultsArray = function (nums, k) {\n    let p1 = 0, p2 = k - 1\n    let n = nums.length\n    const result = []\n    while (p2 <= n - 1) {\n        let tempArr = nums.slice(p1, p2 + 1)\n        const res = getMax(tempArr)\n        result.push(res)\n        p1++\n        p2++\n    }\n\n    return result\n};\n\nconst getMax = function (arr) {\n    let isSort = true\n    for (let i = 0; i < arr.length - 1; i++) {\n        if (arr[i] != arr[i + 1]-1) {\n            isSort = false\n            break\n        }\n    }\n\n    if (isSort) return arr[arr.length-1]\n    return -1\n}\n```\n\n这样子写的话过不了第二种[长度为k的子数组的能量||](https://leetcode.cn/problems/find-the-power-of-k-size-subarrays-ii/description/)的最后几个测试\n\n#### 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","source":"_posts/长度为K的子数组的能量.md","raw":"---\ntitle: 【每日算法】长度为k的子数组的能量\ndate: 2024-11-06 9:47:01\ntags: 每日一题\ncategories: 算法\nindex_img: /img/post/leetcode.jpg\nbanner_img: \n---\n\n\n\n[长度为k的子数组的能量I](https://leetcode.cn/problems/find-the-power-of-k-size-subarrays-i/description/?envType=daily-question&envId=2024-11-06)\n\ntag:`数组` `滑动窗口`\n\n给你一个长度为 `n` 的整数数组 `nums` 和一个正整数 `k` 。\n\n一个数组的 **能量值** 定义为：\n\n- 如果 **所有** 元素都是依次 **连续** 且 **上升** 的，那么能量值为 **最大** 的元素。\n- 否则为 -1 。\n\n你需要求出 `nums` 中所有长度为 `k` 的 \n\n子数组\n\n 的能量值。\n\n\n\n请你返回一个长度为 `n - k + 1` 的整数数组 `results` ，其中 `results[i]` 是子数组 `nums[i..(i + k - 1)]` 的能量值。\n\n\n\n#### 示例一\n\n**输入：**nums = [1,2,3,4,3,2,5], k = 3\n\n**输出：**[3,4,-1,-1,-1]\n\n**解释：**\n\n`nums` 中总共有 5 个长度为 3 的子数组：\n\n- `[1, 2, 3]` 中最大元素为 3 。\n- `[2, 3, 4]` 中最大元素为 4 。\n- `[3, 4, 3]` 中元素 **不是** 连续的。\n- `[4, 3, 2]` 中元素 **不是** 上升的。\n- `[3, 2, 5]` 中元素 **不是** 连续的。\n\n\n\n#### 题解：\n\n```js\nconst ans = Array(nums.length - k + 1).fill(-1);\n    let cnt = 0;\n    for (let i = 0; i < nums.length; i++) {\n        cnt = i === 0 || nums[i] === nums[i - 1] + 1 ? cnt + 1 : 1;\n        if (cnt >= k) {\n            ans[i - k + 1] = nums[i];\n        }\n    }\n\treturn ans;\n}\n```\n\n#### 思路：\n\n要特别注意是**连续的**这个意思，就是一定是 num[i] === num[i] +1 ，这个才叫连续\n\n其实就是判断一个定长的窗口中是否是连续的，如果是就返回最大值\n\n要找连续上升的段。如果段长至少是 *k*，那么这段中的所有长为 *k* 的子数组都是符合要求的，子数组的最后一个元素是最大的。\n\n#### 最开始的写法\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar resultsArray = function (nums, k) {\n    let p1 = 0, p2 = k - 1\n    let n = nums.length\n    const result = []\n    while (p2 <= n - 1) {\n        let tempArr = nums.slice(p1, p2 + 1)\n        const res = getMax(tempArr)\n        result.push(res)\n        p1++\n        p2++\n    }\n\n    return result\n};\n\nconst getMax = function (arr) {\n    let isSort = true\n    for (let i = 0; i < arr.length - 1; i++) {\n        if (arr[i] != arr[i + 1]-1) {\n            isSort = false\n            break\n        }\n    }\n\n    if (isSort) return arr[arr.length-1]\n    return -1\n}\n```\n\n这样子写的话过不了第二种[长度为k的子数组的能量||](https://leetcode.cn/problems/find-the-power-of-k-size-subarrays-ii/description/)的最后几个测试\n\n#### 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","slug":"长度为K的子数组的能量","published":1,"updated":"2024-11-17T13:58:10.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm3tylxps003r73t33so73iyo","content":"<p><a href=\"https://leetcode.cn/problems/find-the-power-of-k-size-subarrays-i/description/?envType=daily-question&envId=2024-11-06\">长度为k的子数组的能量I</a></p>\n<p>tag:<code>数组</code> <code>滑动窗口</code></p>\n<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p>\n<p>一个数组的 <strong>能量值</strong> 定义为：</p>\n<ul>\n<li>如果 <strong>所有</strong> 元素都是依次 <strong>连续</strong> 且 <strong>上升</strong> 的，那么能量值为 <strong>最大</strong> 的元素。</li>\n<li>否则为 -1 。</li>\n</ul>\n<p>你需要求出 <code>nums</code> 中所有长度为 <code>k</code> 的 </p>\n<p>子数组</p>\n<p> 的能量值。</p>\n<p>请你返回一个长度为 <code>n - k + 1</code> 的整数数组 <code>results</code> ，其中 <code>results[i]</code> 是子数组 <code>nums[i..(i + k - 1)]</code> 的能量值。</p>\n<h4 id=\"示例一\"><a href=\"#示例一\" class=\"headerlink\" title=\"示例一\"></a>示例一</h4><p><strong>输入：</strong>nums = [1,2,3,4,3,2,5], k = 3</p>\n<p><strong>输出：</strong>[3,4,-1,-1,-1]</p>\n<p><strong>解释：</strong></p>\n<p><code>nums</code> 中总共有 5 个长度为 3 的子数组：</p>\n<ul>\n<li><code>[1, 2, 3]</code> 中最大元素为 3 。</li>\n<li><code>[2, 3, 4]</code> 中最大元素为 4 。</li>\n<li><code>[3, 4, 3]</code> 中元素 <strong>不是</strong> 连续的。</li>\n<li><code>[4, 3, 2]</code> 中元素 <strong>不是</strong> 上升的。</li>\n<li><code>[3, 2, 5]</code> 中元素 <strong>不是</strong> 连续的。</li>\n</ul>\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> ans = <span class=\"hljs-title class_\">Array</span>(nums.<span class=\"hljs-property\">length</span> - k + <span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">fill</span>(-<span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-keyword\">let</span> cnt = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.<span class=\"hljs-property\">length</span>; i++) &#123;<br>        cnt = i === <span class=\"hljs-number\">0</span> || nums[i] === nums[i - <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span> ? cnt + <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">if</span> (cnt &gt;= k) &#123;<br>            ans[i - k + <span class=\"hljs-number\">1</span>] = nums[i];<br>        &#125;<br>    &#125;<br>\t<span class=\"hljs-keyword\">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>要特别注意是<strong>连续的</strong>这个意思，就是一定是 num[i] === num[i] +1 ，这个才叫连续</p>\n<p>其实就是判断一个定长的窗口中是否是连续的，如果是就返回最大值</p>\n<p>要找连续上升的段。如果段长至少是 <em>k</em>，那么这段中的所有长为 <em>k</em> 的子数组都是符合要求的，子数组的最后一个元素是最大的。</p>\n<h4 id=\"最开始的写法\"><a href=\"#最开始的写法\" class=\"headerlink\" title=\"最开始的写法\"></a>最开始的写法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number[]</span>&#125; <span class=\"hljs-variable\">nums</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number</span>&#125; <span class=\"hljs-variable\">k</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-type\">number[]</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number[]</span>&#125; <span class=\"hljs-variable\">nums</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number</span>&#125; <span class=\"hljs-variable\">k</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-type\">number[]</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">var</span> resultsArray = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums, k</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> p1 = <span class=\"hljs-number\">0</span>, p2 = k - <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">let</span> n = nums.<span class=\"hljs-property\">length</span><br>    <span class=\"hljs-keyword\">const</span> result = []<br>    <span class=\"hljs-keyword\">while</span> (p2 &lt;= n - <span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-keyword\">let</span> tempArr = nums.<span class=\"hljs-title function_\">slice</span>(p1, p2 + <span class=\"hljs-number\">1</span>)<br>        <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-title function_\">getMax</span>(tempArr)<br>        result.<span class=\"hljs-title function_\">push</span>(res)<br>        p1++<br>        p2++<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> getMax = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> isSort = <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>; i++) &#123;<br>        <span class=\"hljs-keyword\">if</span> (arr[i] != arr[i + <span class=\"hljs-number\">1</span>]-<span class=\"hljs-number\">1</span>) &#123;<br>            isSort = <span class=\"hljs-literal\">false</span><br>            <span class=\"hljs-keyword\">break</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (isSort) <span class=\"hljs-keyword\">return</span> arr[arr.<span class=\"hljs-property\">length</span>-<span class=\"hljs-number\">1</span>]<br>    <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样子写的话过不了第二种<a href=\"https://leetcode.cn/problems/find-the-power-of-k-size-subarrays-ii/description/\">长度为k的子数组的能量||</a>的最后几个测试</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(1)</p>\n","site":{"data":{}},"wordcount":1373,"excerpt":"","more":"<p><a href=\"https://leetcode.cn/problems/find-the-power-of-k-size-subarrays-i/description/?envType=daily-question&envId=2024-11-06\">长度为k的子数组的能量I</a></p>\n<p>tag:<code>数组</code> <code>滑动窗口</code></p>\n<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p>\n<p>一个数组的 <strong>能量值</strong> 定义为：</p>\n<ul>\n<li>如果 <strong>所有</strong> 元素都是依次 <strong>连续</strong> 且 <strong>上升</strong> 的，那么能量值为 <strong>最大</strong> 的元素。</li>\n<li>否则为 -1 。</li>\n</ul>\n<p>你需要求出 <code>nums</code> 中所有长度为 <code>k</code> 的 </p>\n<p>子数组</p>\n<p> 的能量值。</p>\n<p>请你返回一个长度为 <code>n - k + 1</code> 的整数数组 <code>results</code> ，其中 <code>results[i]</code> 是子数组 <code>nums[i..(i + k - 1)]</code> 的能量值。</p>\n<h4 id=\"示例一\"><a href=\"#示例一\" class=\"headerlink\" title=\"示例一\"></a>示例一</h4><p><strong>输入：</strong>nums = [1,2,3,4,3,2,5], k = 3</p>\n<p><strong>输出：</strong>[3,4,-1,-1,-1]</p>\n<p><strong>解释：</strong></p>\n<p><code>nums</code> 中总共有 5 个长度为 3 的子数组：</p>\n<ul>\n<li><code>[1, 2, 3]</code> 中最大元素为 3 。</li>\n<li><code>[2, 3, 4]</code> 中最大元素为 4 。</li>\n<li><code>[3, 4, 3]</code> 中元素 <strong>不是</strong> 连续的。</li>\n<li><code>[4, 3, 2]</code> 中元素 <strong>不是</strong> 上升的。</li>\n<li><code>[3, 2, 5]</code> 中元素 <strong>不是</strong> 连续的。</li>\n</ul>\n<h4 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> ans = <span class=\"hljs-title class_\">Array</span>(nums.<span class=\"hljs-property\">length</span> - k + <span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">fill</span>(-<span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-keyword\">let</span> cnt = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.<span class=\"hljs-property\">length</span>; i++) &#123;<br>        cnt = i === <span class=\"hljs-number\">0</span> || nums[i] === nums[i - <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span> ? cnt + <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">if</span> (cnt &gt;= k) &#123;<br>            ans[i - k + <span class=\"hljs-number\">1</span>] = nums[i];<br>        &#125;<br>    &#125;<br>\t<span class=\"hljs-keyword\">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>要特别注意是<strong>连续的</strong>这个意思，就是一定是 num[i] === num[i] +1 ，这个才叫连续</p>\n<p>其实就是判断一个定长的窗口中是否是连续的，如果是就返回最大值</p>\n<p>要找连续上升的段。如果段长至少是 <em>k</em>，那么这段中的所有长为 <em>k</em> 的子数组都是符合要求的，子数组的最后一个元素是最大的。</p>\n<h4 id=\"最开始的写法\"><a href=\"#最开始的写法\" class=\"headerlink\" title=\"最开始的写法\"></a>最开始的写法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number[]</span>&#125; <span class=\"hljs-variable\">nums</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number</span>&#125; <span class=\"hljs-variable\">k</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-type\">number[]</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number[]</span>&#125; <span class=\"hljs-variable\">nums</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param</span> &#123;<span class=\"hljs-type\">number</span>&#125; <span class=\"hljs-variable\">k</span></span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-type\">number[]</span>&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">var</span> resultsArray = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums, k</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> p1 = <span class=\"hljs-number\">0</span>, p2 = k - <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">let</span> n = nums.<span class=\"hljs-property\">length</span><br>    <span class=\"hljs-keyword\">const</span> result = []<br>    <span class=\"hljs-keyword\">while</span> (p2 &lt;= n - <span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-keyword\">let</span> tempArr = nums.<span class=\"hljs-title function_\">slice</span>(p1, p2 + <span class=\"hljs-number\">1</span>)<br>        <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-title function_\">getMax</span>(tempArr)<br>        result.<span class=\"hljs-title function_\">push</span>(res)<br>        p1++<br>        p2++<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> getMax = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> isSort = <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>; i++) &#123;<br>        <span class=\"hljs-keyword\">if</span> (arr[i] != arr[i + <span class=\"hljs-number\">1</span>]-<span class=\"hljs-number\">1</span>) &#123;<br>            isSort = <span class=\"hljs-literal\">false</span><br>            <span class=\"hljs-keyword\">break</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (isSort) <span class=\"hljs-keyword\">return</span> arr[arr.<span class=\"hljs-property\">length</span>-<span class=\"hljs-number\">1</span>]<br>    <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样子写的话过不了第二种<a href=\"https://leetcode.cn/problems/find-the-power-of-k-size-subarrays-ii/description/\">长度为k的子数组的能量||</a>的最后几个测试</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(1)</p>\n"}],"PostAsset":[{"_id":"source/_posts/Git/CSSOM.png","post":"cm3tylxpc000373t34e5te62z","slug":"CSSOM.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue-路由/vueRouter.jpg","post":"cm3tylxpf000d73t3elqo33et","slug":"vueRouter.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Vue的虚拟DOM/render-DOM.png","post":"cm3tylxph000h73t3gaaub20j","slug":"render-DOM.png","modified":1,"renderable":1},{"_id":"source/_posts/前后端交互模式/1.png","post":"cm3tylxpn001y73t3c5e7grst","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/前后端交互模式/2.png","post":"cm3tylxpn001y73t3c5e7grst","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/前后端交互模式/3.png","post":"cm3tylxpn001y73t3c5e7grst","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/原型链/原型链.png","post":"cm3tylxpo002773t3e4g67kzk","slug":"原型链.png","modified":1,"renderable":1},{"_id":"source/_posts/变量的本质和垃圾回收/heap.png","post":"cm3tylxpo002d73t38ys68845","slug":"heap.png","modified":1,"renderable":1},{"_id":"source/_posts/变量的本质和垃圾回收/任务队列.png","post":"cm3tylxpo002d73t38ys68845","slug":"任务队列.png","modified":1,"renderable":1},{"_id":"source/_posts/变量的本质和垃圾回收/同步和异步栈.png","post":"cm3tylxpo002d73t38ys68845","slug":"同步和异步栈.png","modified":1,"renderable":1},{"_id":"source/_posts/变量的本质和垃圾回收/垃圾回收.png","post":"cm3tylxpo002d73t38ys68845","slug":"垃圾回收.png","modified":1,"renderable":1},{"_id":"source/_posts/变量的本质和垃圾回收/栈.png","post":"cm3tylxpo002d73t38ys68845","slug":"栈.png","modified":1,"renderable":1},{"_id":"source/_posts/变量的本质和垃圾回收/浅拷贝.png","post":"cm3tylxpo002d73t38ys68845","slug":"浅拷贝.png","modified":1,"renderable":1},{"_id":"source/_posts/变量的本质和垃圾回收/浏览器的进程.png","post":"cm3tylxpo002d73t38ys68845","slug":"浏览器的进程.png","modified":1,"renderable":1},{"_id":"source/_posts/服务器端/server01.png","post":"cm3tylxpp002r73t39z9jgyv5","slug":"server01.png","modified":1,"renderable":1},{"_id":"source/_posts/服务器端/server02.png","post":"cm3tylxpp002r73t39z9jgyv5","slug":"server02.png","modified":1,"renderable":1},{"_id":"source/_posts/服务器端/server03.png","post":"cm3tylxpp002r73t39z9jgyv5","slug":"server03.png","modified":1,"renderable":1},{"_id":"source/_posts/服务器端/server04.png","post":"cm3tylxpp002r73t39z9jgyv5","slug":"server04.png","modified":1,"renderable":1},{"_id":"source/_posts/深浅拷贝/对象赋值.png","post":"cm3tylxpq003373t3b65e2oi8","slug":"对象赋值.png","modified":1,"renderable":1},{"_id":"source/_posts/深浅拷贝/浅拷贝.png","post":"cm3tylxpq003373t3b65e2oi8","slug":"浅拷贝.png","modified":1,"renderable":1},{"_id":"source/_posts/深浅拷贝/深拷贝.png","post":"cm3tylxpq003373t3b65e2oi8","slug":"深拷贝.png","modified":1,"renderable":1},{"_id":"source/_posts/回流和重绘/回流.jpg","post":"cm3tylxpp002i73t3a9zrcnu6","slug":"回流.jpg","modified":1,"renderable":1},{"_id":"source/_posts/回流和重绘/重绘.jpg","post":"cm3tylxpp002i73t3a9zrcnu6","slug":"重绘.jpg","modified":1,"renderable":1},{"_id":"source/_posts/渲染引擎的执行原理/CSSOM.png","post":"cm3tylxpq003573t3arizf01d","slug":"CSSOM.png","modified":1,"renderable":1},{"_id":"source/_posts/渲染引擎的执行原理/DOM树.png","post":"cm3tylxpq003573t3arizf01d","slug":"DOM树.png","modified":1,"renderable":1},{"_id":"source/_posts/渲染引擎的执行原理/DRAW QUAD.png","post":"cm3tylxpq003573t3arizf01d","slug":"DRAW QUAD.png","modified":1,"renderable":1},{"_id":"source/_posts/渲染引擎的执行原理/Tree.png","post":"cm3tylxpq003573t3arizf01d","slug":"Tree.png","modified":1,"renderable":1},{"_id":"source/_posts/渲染引擎的执行原理/光栅化.png","post":"cm3tylxpq003573t3arizf01d","slug":"光栅化.png","modified":1,"renderable":1},{"_id":"source/_posts/渲染引擎的执行原理/分块.png","post":"cm3tylxpq003573t3arizf01d","slug":"分块.png","modified":1,"renderable":1},{"_id":"source/_posts/渲染引擎的执行原理/布局.png","post":"cm3tylxpq003573t3arizf01d","slug":"布局.png","modified":1,"renderable":1},{"_id":"source/_posts/渲染引擎的执行原理/浏览器解析原理.png","post":"cm3tylxpq003573t3arizf01d","slug":"浏览器解析原理.png","modified":1,"renderable":1},{"_id":"source/_posts/渲染引擎的执行原理/重绘.png","post":"cm3tylxpq003573t3arizf01d","slug":"重绘.png","modified":1,"renderable":1},{"_id":"source/_posts/节流与防抖/debounce.png","post":"cm3tylxpr003f73t3ciknbzsn","slug":"debounce.png","modified":1,"renderable":1},{"_id":"source/_posts/节流与防抖/throttle.png","post":"cm3tylxpr003f73t3ciknbzsn","slug":"throttle.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cm3tylxpa000173t3cdqtfgxu","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpg000e73t3e06vcry7"},{"post_id":"cm3tylxpe000873t35kixghny","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxph000i73t30vnz2a5t"},{"post_id":"cm3tylxpf000c73t38x5yf6h5","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpi000l73t33bgggb57"},{"post_id":"cm3tylxpc000373t34e5te62z","category_id":"cm3tylxpf000973t3avgm3fbk","_id":"cm3tylxpi000o73t3bqo72mar"},{"post_id":"cm3tylxpf000d73t3elqo33et","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpj000r73t38k8if5lv"},{"post_id":"cm3tylxph000h73t3gaaub20j","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpj000v73t394t1bl68"},{"post_id":"cm3tylxpe000773t35toe97tb","category_id":"cm3tylxpf000973t3avgm3fbk","_id":"cm3tylxpj000y73t37jl98vsr"},{"post_id":"cm3tylxph000k73t30gdjgd0u","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpk001073t31ce70t6y"},{"post_id":"cm3tylxpi000q73t3fpqc24b0","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpk001473t3f77b4lkv"},{"post_id":"cm3tylxpj000u73t3f5hzan5i","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpk001673t3gct64d52"},{"post_id":"cm3tylxpj000x73t33wt88a86","category_id":"cm3tylxpj000s73t3e066hgmd","_id":"cm3tylxpl001a73t3bi6l2il3"},{"post_id":"cm3tylxpi000n73t3gocw4fi5","category_id":"cm3tylxpj000s73t3e066hgmd","_id":"cm3tylxpl001d73t393nghj48"},{"post_id":"cm3tylxpk000z73t3aj7v38ha","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpl001h73t3fq9bg8n1"},{"post_id":"cm3tylxpk001973t33zke8fu1","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpm001k73t3b1g9edhs"},{"post_id":"cm3tylxpl001c73t3g3g1gksj","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpm001o73t31sco8wyy"},{"post_id":"cm3tylxpk001373t375js8tes","category_id":"cm3tylxpk001873t34326f5q4","_id":"cm3tylxpm001r73t378742zwn"},{"post_id":"cm3tylxpl001j73t3b35z5lg8","category_id":"cm3tylxpf000973t3avgm3fbk","_id":"cm3tylxpn001v73t3cwrn2ar7"},{"post_id":"cm3tylxpk001573t3a89v8zi5","category_id":"cm3tylxpk001873t34326f5q4","_id":"cm3tylxpn001z73t38e9k1boo"},{"post_id":"cm3tylxpl001f73t36l0s6nln","category_id":"cm3tylxpm001n73t3dse30yc3","_id":"cm3tylxpn002273t3gczihwne"},{"post_id":"cm3tylxpn001u73t378x494ca","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpo002573t3534e0ne6"},{"post_id":"cm3tylxpn001y73t3c5e7grst","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpo002873t3d61mcmju"},{"post_id":"cm3tylxpn002173t3dyd9aper","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpo002b73t3fr3gc5au"},{"post_id":"cm3tylxpm001q73t34nnc9mij","category_id":"cm3tylxpn001w73t3464rc432","_id":"cm3tylxpo002f73t3fl5m2xws"},{"post_id":"cm3tylxpo002773t3e4g67kzk","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpp002j73t38fvaafhc"},{"post_id":"cm3tylxpo002d73t38ys68845","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpp002p73t3dpvb30lb"},{"post_id":"cm3tylxpp002i73t3a9zrcnu6","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpp002s73t30hdd3rpp"},{"post_id":"cm3tylxpp002l73t3ekieg99g","category_id":"cm3tylxpn001w73t3464rc432","_id":"cm3tylxpq002v73t37knpgbm1"},{"post_id":"cm3tylxpo002a73t3e0sic4k1","category_id":"cm3tylxpo002g73t36ald492y","_id":"cm3tylxpq002y73t3a1kdg8bo"},{"post_id":"cm3tylxpp002o73t33cwuey2n","category_id":"cm3tylxpn001w73t3464rc432","_id":"cm3tylxpq003173t32cmk3qxn"},{"post_id":"cm3tylxpp002r73t39z9jgyv5","category_id":"cm3tylxpf000973t3avgm3fbk","_id":"cm3tylxpq003473t3gtchcx5f"},{"post_id":"cm3tylxpp002u73t38gkuffzc","category_id":"cm3tylxpn001w73t3464rc432","_id":"cm3tylxpq003673t361bw419s"},{"post_id":"cm3tylxpq002x73t30nrh53ee","category_id":"cm3tylxpf000973t3avgm3fbk","_id":"cm3tylxpr003a73t35c88h6z4"},{"post_id":"cm3tylxpq003073t398ny9wpz","category_id":"cm3tylxpn001w73t3464rc432","_id":"cm3tylxpr003d73t38fik7a4o"},{"post_id":"cm3tylxpq003573t3arizf01d","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxpr003g73t3463w6xon"},{"post_id":"cm3tylxpq003973t3fe0bewng","category_id":"cm3tylxpn001w73t3464rc432","_id":"cm3tylxpr003j73t34uz56b5z"},{"post_id":"cm3tylxpr003c73t3hwcjehvi","category_id":"cm3tylxpn001w73t3464rc432","_id":"cm3tylxpr003m73t3d9lh99lw"},{"post_id":"cm3tylxpr003f73t3ciknbzsn","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxps003p73t3ebaq9cjw"},{"post_id":"cm3tylxpr003i73t3ckdpg3qj","category_id":"cm3tylxpn001w73t3464rc432","_id":"cm3tylxps003s73t3c75jhnsh"},{"post_id":"cm3tylxpr003l73t377qd00vo","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxps003u73t3gvgt13a9"},{"post_id":"cm3tylxps003o73t32ub1fjfj","category_id":"cm3tylxpd000473t36ezb8qv2","_id":"cm3tylxps003v73t3gsyf9m3w"},{"post_id":"cm3tylxps003r73t33so73iyo","category_id":"cm3tylxpn001w73t3464rc432","_id":"cm3tylxps003y73t36lsm6edz"}],"PostTag":[{"post_id":"cm3tylxpa000173t3cdqtfgxu","tag_id":"cm3tylxpd000573t3flzebsck","_id":"cm3tylxpf000b73t392wp649e"},{"post_id":"cm3tylxpc000373t34e5te62z","tag_id":"cm3tylxpf000a73t3hkqk7c2a","_id":"cm3tylxph000j73t32g5xa8db"},{"post_id":"cm3tylxpe000673t3goo10pmd","tag_id":"cm3tylxpg000g73t31zvh7irx","_id":"cm3tylxpi000p73t35yhw60w4"},{"post_id":"cm3tylxpe000773t35toe97tb","tag_id":"cm3tylxpi000m73t32eu801km","_id":"cm3tylxpj000w73t3bgdi2y9b"},{"post_id":"cm3tylxpe000873t35kixghny","tag_id":"cm3tylxpj000t73t36p9o481a","_id":"cm3tylxpk001273t3g6uz00e3"},{"post_id":"cm3tylxpf000c73t38x5yf6h5","tag_id":"cm3tylxpk001173t3hn32e9xq","_id":"cm3tylxpl001b73t399ro3se9"},{"post_id":"cm3tylxpf000d73t3elqo33et","tag_id":"cm3tylxpk001773t39o72bw40","_id":"cm3tylxpl001i73t3h45jccj2"},{"post_id":"cm3tylxph000h73t3gaaub20j","tag_id":"cm3tylxpk001773t39o72bw40","_id":"cm3tylxpm001p73t33y9xfakp"},{"post_id":"cm3tylxpm001m73t32smfb9h2","tag_id":"cm3tylxpg000g73t31zvh7irx","_id":"cm3tylxpn001t73t3cd6s6hzu"},{"post_id":"cm3tylxph000k73t30gdjgd0u","tag_id":"cm3tylxpk001773t39o72bw40","_id":"cm3tylxpn001x73t3fb10bzha"},{"post_id":"cm3tylxpi000n73t3gocw4fi5","tag_id":"cm3tylxpn001s73t3allt33yb","_id":"cm3tylxpn002373t3ays5djin"},{"post_id":"cm3tylxpi000q73t3fpqc24b0","tag_id":"cm3tylxpk001173t3hn32e9xq","_id":"cm3tylxpo002973t338u447kk"},{"post_id":"cm3tylxpo002773t3e4g67kzk","tag_id":"cm3tylxpj000t73t36p9o481a","_id":"cm3tylxpo002c73t32eadfgum"},{"post_id":"cm3tylxpj000u73t3f5hzan5i","tag_id":"cm3tylxpo002673t32u3efdyc","_id":"cm3tylxpo002h73t37tf1epur"},{"post_id":"cm3tylxpo002d73t38ys68845","tag_id":"cm3tylxpj000t73t36p9o481a","_id":"cm3tylxpp002k73t316yn6b8y"},{"post_id":"cm3tylxpp002i73t3a9zrcnu6","tag_id":"cm3tylxpj000t73t36p9o481a","_id":"cm3tylxpp002n73t36m26e7g3"},{"post_id":"cm3tylxpj000x73t33wt88a86","tag_id":"cm3tylxpo002e73t39uki9onv","_id":"cm3tylxpp002q73t3c0odbuf6"},{"post_id":"cm3tylxpk000z73t3aj7v38ha","tag_id":"cm3tylxpp002m73t3d65j1vk8","_id":"cm3tylxpq002w73t3c6d89bmw"},{"post_id":"cm3tylxpk001373t375js8tes","tag_id":"cm3tylxpp002t73t3hnqy74de","_id":"cm3tylxpq003273t39yy8c1za"},{"post_id":"cm3tylxpk001573t3a89v8zi5","tag_id":"cm3tylxpq002z73t39azb3jux","_id":"cm3tylxpq003873t37udvgdz9"},{"post_id":"cm3tylxpq003573t3arizf01d","tag_id":"cm3tylxpj000t73t36p9o481a","_id":"cm3tylxpr003b73t35mkce4db"},{"post_id":"cm3tylxpk001973t33zke8fu1","tag_id":"cm3tylxpq003773t3broofen0","_id":"cm3tylxpr003h73t3ddegfo1r"},{"post_id":"cm3tylxpl001c73t3g3g1gksj","tag_id":"cm3tylxpr003e73t31n060zaj","_id":"cm3tylxpr003n73t39ps00suw"},{"post_id":"cm3tylxpl001f73t36l0s6nln","tag_id":"cm3tylxpr003k73t37hkahs8p","_id":"cm3tylxps003t73t3f9e2b3iw"},{"post_id":"cm3tylxpl001j73t3b35z5lg8","tag_id":"cm3tylxps003q73t3cwum61y8","_id":"cm3tylxps003x73t3gta9gwlz"},{"post_id":"cm3tylxpm001q73t34nnc9mij","tag_id":"cm3tylxps003w73t31pbfd7gk","_id":"cm3tylxps004073t34om9e5l7"},{"post_id":"cm3tylxpn001u73t378x494ca","tag_id":"cm3tylxpq003773t3broofen0","_id":"cm3tylxps004273t354750ghy"},{"post_id":"cm3tylxpn001y73t3c5e7grst","tag_id":"cm3tylxps004173t3cseicnj4","_id":"cm3tylxps004473t3600jgvg9"},{"post_id":"cm3tylxpn002173t3dyd9aper","tag_id":"cm3tylxps004373t3cehb0pku","_id":"cm3tylxps004673t36hxd6gf1"},{"post_id":"cm3tylxpn002473t308ri4s2x","tag_id":"cm3tylxps004173t3cseicnj4","_id":"cm3tylxps004873t3gxjda1oc"},{"post_id":"cm3tylxpo002a73t3e0sic4k1","tag_id":"cm3tylxps004773t37ajw3y1g","_id":"cm3tylxpt004a73t3hr314hpa"},{"post_id":"cm3tylxpp002l73t3ekieg99g","tag_id":"cm3tylxps004973t353dp9q8t","_id":"cm3tylxpt004c73t300yfc8s4"},{"post_id":"cm3tylxpp002o73t33cwuey2n","tag_id":"cm3tylxps004973t353dp9q8t","_id":"cm3tylxpt004e73t30io68486"},{"post_id":"cm3tylxpp002r73t39z9jgyv5","tag_id":"cm3tylxpt004d73t38ur6eyg8","_id":"cm3tylxpt004g73t31i6qdfje"},{"post_id":"cm3tylxpp002u73t38gkuffzc","tag_id":"cm3tylxpt004f73t31nulbm1i","_id":"cm3tylxpt004i73t3d2jb2q1f"},{"post_id":"cm3tylxpq002x73t30nrh53ee","tag_id":"cm3tylxpt004h73t3balw6xk4","_id":"cm3tylxpt004k73t316seb22o"},{"post_id":"cm3tylxpq003073t398ny9wpz","tag_id":"cm3tylxps004973t353dp9q8t","_id":"cm3tylxpt004m73t39bih361y"},{"post_id":"cm3tylxpq003373t3b65e2oi8","tag_id":"cm3tylxps004173t3cseicnj4","_id":"cm3tylxpt004o73t3gy2679hr"},{"post_id":"cm3tylxpq003973t3fe0bewng","tag_id":"cm3tylxps004973t353dp9q8t","_id":"cm3tylxpt004q73t3gqgj33kd"},{"post_id":"cm3tylxpr003c73t3hwcjehvi","tag_id":"cm3tylxps004973t353dp9q8t","_id":"cm3tylxpt004s73t35seu0hn6"},{"post_id":"cm3tylxpr003f73t3ciknbzsn","tag_id":"cm3tylxps004373t3cehb0pku","_id":"cm3tylxpu004u73t3aa4rfrfq"},{"post_id":"cm3tylxpr003i73t3ckdpg3qj","tag_id":"cm3tylxpt004f73t31nulbm1i","_id":"cm3tylxpu004w73t32amd8z9o"},{"post_id":"cm3tylxpr003l73t377qd00vo","tag_id":"cm3tylxpu004v73t302tyf1pv","_id":"cm3tylxpu004y73t332ytb7mu"},{"post_id":"cm3tylxps003o73t32ub1fjfj","tag_id":"cm3tylxpu004x73t3bisyca67","_id":"cm3tylxpu005073t35u2y62y8"},{"post_id":"cm3tylxps003r73t33so73iyo","tag_id":"cm3tylxps004973t353dp9q8t","_id":"cm3tylxpu005173t31byr1dnh"}],"Tag":[{"name":"Electron","_id":"cm3tylxpd000573t3flzebsck"},{"name":"Git","_id":"cm3tylxpf000a73t3hkqk7c2a"},{"name":"后端","_id":"cm3tylxpg000g73t31zvh7irx"},{"name":"Gulp","_id":"cm3tylxpi000m73t32eu801km"},{"name":"基础知识点","_id":"cm3tylxpj000t73t36p9o481a"},{"name":"css","_id":"cm3tylxpk001173t3hn32e9xq"},{"name":"Vue","_id":"cm3tylxpk001773t39o72bw40"},{"name":"c语言","_id":"cm3tylxpn001s73t3allt33yb"},{"name":"css3","_id":"cm3tylxpo002673t32u3efdyc"},{"name":"数据库","_id":"cm3tylxpo002e73t39uki9onv"},{"name":"总结","_id":"cm3tylxpp002m73t3d65j1vk8"},{"name":"hello world","_id":"cm3tylxpp002t73t3hnqy74de"},{"name":"hexo","_id":"cm3tylxpq002z73t39azb3jux"},{"name":"HTML","_id":"cm3tylxpq003773t3broofen0"},{"name":"mongoDB","_id":"cm3tylxpr003e73t31n060zaj"},{"name":"aplyer","_id":"cm3tylxpr003k73t37hkahs8p"},{"name":"Node","_id":"cm3tylxps003q73t3cwum61y8"},{"name":"哈希算法","_id":"cm3tylxps003w73t31pbfd7gk"},{"name":"前端","_id":"cm3tylxps004173t3cseicnj4"},{"name":"tips","_id":"cm3tylxps004373t3cehb0pku"},{"name":"变量提升","_id":"cm3tylxps004773t37ajw3y1g"},{"name":"每日一题","_id":"cm3tylxps004973t353dp9q8t"},{"name":"服务器端","_id":"cm3tylxpt004d73t38ur6eyg8"},{"name":"算法","_id":"cm3tylxpt004f73t31nulbm1i"},{"name":"正则表达式","_id":"cm3tylxpt004h73t3balw6xk4"},{"name":"JavaScript基础","_id":"cm3tylxpu004v73t302tyf1pv"},{"name":"面试","_id":"cm3tylxpu004x73t3bisyca67"}]}}